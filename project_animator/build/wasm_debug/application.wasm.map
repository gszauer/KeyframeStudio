{"version":3,"names":[],"sources":["animator.cpp","../platform/assert.h","../platform/memory.cpp","../platform/window.cpp","../framework/sort.cpp","../framework/draw2d.cpp","../platform/graphics.h","../framework/vector.h","../framework/vec4.h","../debt/stb_truetype.h","../debt/stb_rect_pack.h","../platform/math.h","../debt/stb_image.h","../framework/draw2d.h","../framework/vec2.h","../framework/vec2.cpp","../framework/vec3.cpp","../framework/vec3.h","../framework/Transform.cpp","../framework/Transform.h","../framework/quat.cpp","../framework/quat.h","../debt/stb_sprintf.h","AnimLoader.cpp","AnimLoader.h","imgui.cpp","imgui.h","../platform/window.h","color.h","Node2D.cpp","Document.cpp","Document.h","Node2D.h"],"sourcesContent":["#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n#if MEM_PLATFORM_WASM\n// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    __wasm_call_ctors();\n}\n\nextern \"C\" void _cxa_pure_virtual() {\n    PlatformAssert(false, __LOCATION__);\n}\n\nextern \"C\" void __cxa_pure_virtual() {\n    PlatformAssert(false, __LOCATION__);\n}\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\" \n#else\n#define export extern \"C\"\n#endif\n\n#include \"../platform/platform.h\"\n#include \"../platform/memory.h\"\n#include \"../debt/stb_vorbis.h\"\n#include \"../debt/stb_image.h\"\n#include \"../debt/stb_truetype.h\"\n#include \"../framework/vec2.h\"\n#include \"../framework/vec3.h\"\n#include \"../framework/vec2.h\"\n#include \"../debt/fast_obj.h\"\n#include \"../framework/vector.h\"\n#include \"../framework/draw2d.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"imgui.h\"\n#include \"Node2D.h\"\n#include \"Document.h\"\n#include \"../framework/mat4.h\"\n#include \"inter_ttf.inc\"\n#include \"pixel_ttf.inc\"\n#include \"material_ttf.inc\"\n#include \"AnimLoader.h\"\n\n#if MEM_PLATFORM_WASM\n#include \"../platform/memory.cpp\"\n#include \"../platform/window.cpp\"\n#include \"../framework/sort.cpp\"\n#include \"../framework/draw2d.cpp\"\n#include \"../framework/vec2.cpp\"\n#include \"../framework/vec3.cpp\"\n#include \"../framework/Transform.cpp\"\n#include \"../framework/quat.cpp\"\n#include \"../framework/mat4.cpp\"\n#include \"../debt/stb_vorbis.cpp\"\n#include \"../debt/stb_image.cpp\"\n#include \"../debt/stb_truetype.cpp\"\n#include \"../debt/stb_rect_pack.cpp\"\n#include \"../debt/stb_sprintf.cpp\"\n#include \"AnimLoader.cpp\"\n#include \"imgui.cpp\"\n#include \"Node2D.cpp\"\n#include \"Document.cpp\"\n\nWASM_LOADER_ENABLE_CALLBACKS\n#endif\n\n#define FONT_LOAD_ARENA_BYTES (1024 * 1024)\n#define IMAGE_PREVIEW_SIZE 88.0f\n\n#if _WIN32 & _DEBUG\n#define DOCUMENT_NUM_UNDO_STEPS 100\n#else\n#define DOCUMENT_NUM_UNDO_STEPS 1000\n#endif\n\nenum class ActiveTool {\n    None = 0,\n    Move,\n    Rotate,\n    Scale,\n    Pivot,\n    Pan,\n    Zoom,\n    Grid\n};\n\nstruct Application {\n    Document* document;\n    StyleSheet style;\n\n    vec3 view; // x & y are viewport offsets, z is scale\n    bool zoomIn;\n\n    bool showSide;\n    bool showBottom;\n\n    u32 gridShader;\n    u32 gridPositionAttrib;\n    u32 gridOffsetUniform;\n    u32 gridColor1Uniform;\n    u32 gridColor2Uniform;\n    u32 gridVbo;\n    u32 gridVao;\n    u32 gridIbo;\n\n    u32 kbdHot;\n    u32 kbdActive;\n    u32 kbdGen;\n    bool kbdHandled;\n    bool ctrlLock;\n    bool altLock;\n\n    Imgui::HoldAreaDetails zoomDetails;\n    i32 selectedMenu;\n\n    bool moveWorld;\n    bool moveSnap;\n    f32 moveSnapVal;\n    bool moveSelect;\n\n    bool rotateSnap;\n    f32 rotateSnapVal;\n    bool rotateSelect;\n\n    bool scaleSnap;\n    f32 scaleSnapVal;\n    bool scaleSelect;\n\n    bool pivotWorld;\n    bool pivotSnap;\n    f32 pivotSnapVal;\n    bool pivotSelect;\n\n    bool gridShow;\n    bool gridHighlight;\n    f32 gridSize;\n\n    u32 iconFont;\n    u32 labelFont;\n    u32 interfaceFont;\n\n    u32 numFilesLoading;\n    f32 msPerFrame[60];\n    u32 msIter;\n\n    float inspectorWidth;\n    float inspectorSplit;\n    float timelineSplit;\n    float animationSplit;\n    float drawerHeight;\n\n    float hierarchyScroll;\n    u32 hierarchyTab;\n    u32 transformTab;\n    u32 sceneTab;\n\n    bool synchAnimView;\n    float frameSideScroll;\n    float frameUpScroll;\n\n    float memoryScroll;\n    bool memVisible;\n    u32 fpsDisplay;\n\n    bool playSelectedAnimation;\n    i32  playingAnimationFrame;\n    f32 playingAnimationTimer;\n\n    i32 timelineTab;\n    //vec3 camera;\n\n    bool autoKey;\n\n    ActiveTool activeTool;\n    ActiveTool effector;\n    vec2 effectorMousePos;\n    Transform effectorTransform;\n    Node2D* effectorNode;\n    vec2 effectorAxis;\n\n    inline void NewDocument() {\n\n        effectorNode = 0;\n        playSelectedAnimation = false;\n        playingAnimationFrame = 0;\n        playingAnimationTimer = 0;\n\n        document->NewDocument();\n    }\n\n    inline void SelectTool(ActiveTool tool) {\n        if (activeTool == tool) {\n            activeTool = ActiveTool::None;\n        }\n        else {\n            activeTool = tool;\n        }\n    }\n};\n\nstruct FontUserData {\n    Application* app;\n    u32* target;\n    const char* path;\n    void* data;\n};\n\nvoid LoadFont(Application* app, u32* target, const char* path) {\n    app->numFilesLoading += 1;\n\n    void* loadArena = MemAlloc(FONT_LOAD_ARENA_BYTES + sizeof(FontUserData));\n    FontUserData* fontData = (FontUserData*)((u8*)loadArena + FONT_LOAD_ARENA_BYTES);\n    fontData->app = app;\n    fontData->target = target;\n    fontData->path = path;\n    fontData->data = fontData + 1;\n\n    LoadFileAsynch(path, loadArena, FONT_LOAD_ARENA_BYTES, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        FontUserData* fontData = (FontUserData*)((u8*)data + FONT_LOAD_ARENA_BYTES);\n        Application* app = (Application*)userData;\n        u32* target = fontData->target;\n\n        PlatformAssert(data != 0, __LOCATION__);\n        PlatformAssert(bytes != 0, __LOCATION__);\n\n        *target = Draw2D::LoadFont(data, bytes, true);\n        app->numFilesLoading -= 1;\n        }, app);\n}\n\nvoid OpenFile(Application* app, void* data, u32 bytes);\n\nexport void* Initialize() {\n    WindowUpdateTitle(\"Keyframe Studio\");\n    Draw2D::Initialize();\n    GfxEnableStats(true);\n\n    Application* app = (Application*)MemAlloc(sizeof(Application));\n    MemClear(app, sizeof(Application));\n    app->document = (Document*)MemAlloc(sizeof(Document));\n    MemClear(app->document, sizeof(Document));\n    new (app->document) Document(DOCUMENT_NUM_UNDO_STEPS);\n\n    {\n        app->gridShader = GfxCreateShader(\n            \"#version 300 es\\n\\\n            precision highp float;                                   \\n\\\n            in vec2 position;                                        \\n\\\n            out vec2 fragCoord;                                      \\n\\\n            void main() {                                            \\n\\\n                vec2 ndc = vec2(position.x, 1.0 - position.y);       \\n\\\n                ndc = ndc * 2.0 - 1.0;                               \\n\\\n                gl_Position = vec4(ndc, 0.0, 1.0);                   \\n\\\n                fragCoord = (sign(ndc) + vec2(1.0)) / vec2(2.0);     \\n\\\n                fragCoord = vec2(fragCoord.x, 1.0 - fragCoord.y);    \\n\\\n            }\",\n            \"#version 300 es\\n\\\n            precision highp float;                                                   \\n\\\n            uniform vec4 offset; // xy(position), z(zoom), w(size)                   \\n\\\n            uniform vec4 color1; // w is screen width (ie 1920)                      \\n\\\n            uniform vec4 color2; // w is screen height (ie 1080)                     \\n\\\n            out vec4 fragColor;                                                      \\n\\\n            in vec2 fragCoord;                                                       \\n\\\n            void main() {                                                            \\n\\\n                vec2 uv = floor((vec2(fragCoord.x, fragCoord.y) * vec2(color1.w, color2.w) + offset.xy) / offset.w * (1.0f - offset.z + 0.1f));                 \\n\\\n                float mask = mod(uv.x + mod(uv.y, 2.0), 2.0);                        \\n\\\n                fragColor = vec4(mix(color1.rgb, color2.rgb, mask), 1.0);            \\n\\\n            }\"\n        );\n\n        app->gridPositionAttrib = GfxGetAttributeSlot(app->gridShader, \"position\");\n        app->gridOffsetUniform = GfxGetUniformSlot(app->gridShader, \"offset\");\n        app->gridColor1Uniform = GfxGetUniformSlot(app->gridShader, \"color1\");\n        app->gridColor2Uniform = GfxGetUniformSlot(app->gridShader, \"color2\");;\n    \n        app->gridVbo = GfxCreateBuffer();\n        app->gridIbo =  GfxCreateBuffer();\n        app->gridVao = GfxCreateVertexLayout(app->gridShader);\n\n        f32 vertices[8] = {\n            /*0*/0.0f, 0.0f,         /*1*/1.0f, 0.0f,\n            /*2*/0.0f, 1.0f,         /*3*/1.0f, 1.0f\n        };\n\n        u16 indices[6] = {\n            0, 2, 1,\n            3, 1, 2\n        };\n\n        GfxFillArrayBuffer(app->gridVbo, vertices, sizeof(f32) * 8, true);\n        GfxFillIndexBuffer(app->gridIbo, indices, sizeof(u16) * 6, GfxIndexTypeShort, true);\n        \n        GfxAddBufferToLayout(app->gridVao, app->gridPositionAttrib, app->gridVbo, 2, 0, GfxBufferTypeFloat32, 0);\n        GfxAddIndexBufferToLayout(app->gridVao, app->gridIbo);\n    }\n\n    app->memVisible = true;\n    app->gridSize = 30;\n    app->moveSnapVal = 10;\n    app->scaleSnapVal = 10;\n    app->rotateSnapVal = 10;\n\n    app->showSide = true;\n    app->showBottom = true;\n\n    app->synchAnimView = false;\n    app->zoomIn = true;\n\n    for (i32 i = 0; i < 60; ++i) {\n        app->msPerFrame[i] = 16.6f / 1000.0f;\n    }\n    app->fpsDisplay = 60;\n\n    app->style.animationFrameWidth = 10;\n    app->style.animationFrameHeight = 16;\n    app->style.frameEven = ColorRGB8(80);\n    app->style.frameOdd = ColorRGB8(90);\n\n    app->style.gizmoR = ColorRGB8(150, 20, 20);\n    app->style.gizmoG = ColorRGB8(20, 150, 20);\n    app->style.gizmoB = ColorRGB8(20, 20, 150);\n    app->style.gizmoY = ColorRGB8(150, 150, 20);\n\n    app->style.gridA = ColorRGB8(60);\n    app->style.gridB = ColorRGB8(70);\n\n    app->style.gizmoR_Hover = ColorRGB8(230, 20, 20);\n    app->style.gizmoG_Hover = ColorRGB8(20, 230, 20);\n    app->style.gizmoB_Hover = ColorRGB8(20, 20, 230);\n    app->style.gizmoY_Hover = ColorRGB8(220, 230, 20);\n\n    app->style.menuBarHeight = 30.0f;\n    app->style.footerHeight = 25.0f;\n    app->style.toolbarWidth = 36.0f;\n    app->style.inspectorMinWidth = 300;\n    app->style.animatorMinHeight = 300;\n    app->style.timelineMinWidth = 200.0f;\n    app->style.menuTextLineHeight = 16;\n    app->style.headerHeight = 27;\n    app->style.headerFontSize = 14;\n    app->style.listBoxItemHeight = 20;\n    app->style.hierarchyLabelFontSize = 14;\n\n    app->style.menuBarBg = ColorRGB8(60);\n    app->style.footerBg = ColorRGB8(60);\n\n    app->style.toolBarBg = ColorRGB8(66);\n    app->style.tooltipIconBGColor = ColorRGB8(10, 10, 10);\n    app->style.tooltipIconFGColor = ColorRGB8(240, 240, 240);\n\n    app->style.tooltipTextColor = ColorRGB8(40);\n    app->style.tooltipTextBGColor = ColorRGB8(180);\n\n    app->style.keyframeDiamond = ColorRGB8(30);\n    app->style.documentBGColor = ColorRGB8(40, 40, 40); // Checker board can be 50, or 45\n    app->style.panelBgColor = ColorRGB8(70);\n    app->style.dividerAColor = ColorRGB8(55);\n    app->style.dividerBColor = ColorRGB8(85);\n    app->style.dividerHotTint = 1.1f;\n    app->style.dividerActiveTint = 0.8f;\n\n    app->style.headerBgColor = ColorRGB8(50);\n    app->style.hierarchyFooterBg = ColorRGB8(60);\n\n    app->style.HeaderBGHotColor = ColorRGB8(55);\n    app->style.HeaderBGActiveColor = ColorRGB8(60);\n\n    app->style.hierarchyToggleHot = ColorRGB8(210);\n    app->style.hierarchyToggleNormal = ColorRGB8(150);\n\n    app->style.headerFontColor = ColorRGB8(190);\n    app->style.hierarchyFooterButtonBG_Hot = ColorRGB8(60, 60, 60);\n    app->style.hierarchyFooterButtonBorder_Hot = ColorRGB8(50, 50, 50);\n    app->style.hierarchyFooterButtonBG_Active = ColorRGB8(70, 70, 70);\n    app->style.hierarchyFooterButtonBorder_Active = ColorRGB8(40, 40, 40);\n    app->style.hierarchyFooterButtonIcon = ColorRGB8(200, 200, 200);\n    app->style.hierarchyFooterRemoveIcon = ColorRGB8(240, 180, 180);\n    app->style.hierarchyFooterDisabledIconColor = ColorRGB8(40, 40, 40);\n    app->style.scrollBarTrackBG = ColorRGB8(55);\n    app->style.scrollBarHotButtonBg = ColorRGB8(150, 150, 150);\n    app->style.scrollBarIconNormal = ColorRGB8(200, 200, 200);\n    app->style.scrollBarIconHot = ColorRGB8(50, 50, 50);\n    app->style.scrollGrabberNormal = ColorRGB8(120);\n    app->style.scrollGrabberHot = ColorRGB8(180);\n    app->style.karratColor = ColorRGB8(200);\n\n    app->style.textAreaBg_AnimatedTint.r =\n        app->style.textAreaOutline_AnimatedTint.r =\n        app->style.textAreaFont_AnimatedTint.r = 0.05f;\n    app->style.textAreaBg_AnimatedTint.g =\n        app->style.textAreaBg_AnimatedTint.b =\n        app->style.textAreaOutline_AnimatedTint.g =\n        app->style.textAreaOutline_AnimatedTint.b =\n        app->style.textAreaFont_AnimatedTint.g =\n        app->style.textAreaFont_AnimatedTint.b = -0.05f;\n\n    app->style.textAreaBg_InterpolatedTint.g =\n        app->style.textAreaOutline_InterpolatedTint.g =\n        app->style.textAreaFont_InterpolatedTint.g = 0.05f;\n    app->style.textAreaBg_InterpolatedTint.r =\n        app->style.textAreaBg_InterpolatedTint.b =\n        app->style.textAreaOutline_InterpolatedTint.r =\n        app->style.textAreaOutline_InterpolatedTint.b =\n        app->style.textAreaFont_InterpolatedTint.r =\n        app->style.textAreaFont_InterpolatedTint.b = -0.05f;\n\n    app->style.textAreaBg_DirtyTint.b =\n        app->style.textAreaOutline_DirtyTint.b =\n        app->style.textAreaFont_DirtyTint.b = 0.05f;\n    app->style.textAreaBg_DirtyTint.r =\n        app->style.textAreaBg_DirtyTint.g =\n        app->style.textAreaOutline_DirtyTint.r =\n        app->style.textAreaOutline_DirtyTint.g =\n        app->style.textAreaFont_DirtyTint.r =\n        app->style.textAreaFont_DirtyTint.g = -0.05f;\n\n    app->style.hierarchyLabel = ColorRGB8(200, 200, 200);\n    app->style.hierarchyItemBG_A = ColorRGB8(70);\n    app->style.hierarchyItemBG_B = ColorRGB8(65);\n    app->style.hierarchyItemBG_Selected = ColorRGB8(10, 90, 130);\n    app->style.hierarchyItemBG_Movable = ColorRGB8(130, 90, 10);\n\n    app->style.fps1 = ColorRGB8(30, 180, 30);\n    app->style.fps2 = ColorRGB8(180, 80, 30);\n    app->style.fps3 = ColorRGB8(180, 30, 30);\n\n    app->style.hierarchyLabelDisabled = ColorRGB8(70);\n    app->style.hierarchyItemBGDisabled = ColorRGB8(100);\n\n    app->style.textAreaBg_Normal = ColorRGB8(65);\n    app->style.textAreaBg_Hot = ColorRGB8(75);\n    app->style.textAreaBg_Active = ColorRGB8(60);\n    app->style.textAreaBg_Disabled = app->style.panelBgColor;\n\n    app->style.textAreaFont_Normal = ColorRGB8(190);\n    app->style.textAreaFont_Hot = ColorRGB8(210);\n    app->style.textAreaFont_Active = ColorRGB8(170);\n    app->style.textAreaFont_Disabled = ColorRGB8(120);\n\n    app->style.textAreaOutline_Normal = ColorRGB8(40);\n    app->style.textAreaOutline_Hot = ColorRGB8(40);\n    app->style.textAreaOutline_Active = ColorRGB8(20);\n    app->style.textAreaOutline_Disabled = ColorRGB8(110);\n\n    app->style.textAreaLabel_Normal = ColorRGB8(170);\n    app->style.textAreaLabel_Hot = ColorRGB8(190);\n    app->style.textAreaLabel_Active = ColorRGB8(30);\n    app->style.textAreaLabel_Disabled = ColorRGB8(120);\n\n    app->style.memoryFreePage = ColorRGB8(30, 150, 30);\n    app->style.memoryPageInUse = ColorRGB8(150, 30, 30);\n\n    app->style.toggleButtonBorder = app->style.textAreaOutline_Normal;\n    app->style.toggleButtonDisabledBorder = app->style.textAreaOutline_Disabled;\n\n    app->style.toggleButtonNormal = app->style.textAreaBg_Normal;\n    app->style.toggleButtonHot = app->style.textAreaBg_Hot;\n    app->style.toggleButtonActive = app->style.textAreaBg_Active;\n    app->style.toggleButtonDisabled = app->style.textAreaBg_Disabled;\n\n    app->style.textAreaSelectionColor = ColorRGB8(10, 90, 130);\n    app->style.labelFontColorNormal = app->style.textAreaLabel_Normal;\n    app->style.labelFontColorDisabled = app->style.textAreaLabel_Disabled;\n\n    app->style.imageBlockOutlineColor = app->style.textAreaOutline_Normal;\n    app->style.imageBlockBackgroundColor = app->style.textAreaBg_Normal;\n    app->style.imageBlockLabelColor = app->style.textAreaLabel_Normal;\n\n    app->inspectorWidth = app->style.inspectorMinWidth;\n    app->inspectorSplit = 0.9f; // Making these big is an easy way to make sure they have enough space.\n    app->animationSplit = 0.9f;\n    app->timelineSplit = 0.1f; // Make these small\n    app->drawerHeight = app->style.animatorMinHeight;\n    app->style.hierarchyFooterHeight = app->style.headerHeight;\n    app->style.hierarchyFooterButtonSize = 20;\n    app->style.scrollBarSize = 20;\n    app->style.scrollIconSize = 18;\n    app->style.scrollBarHandleSize = 30;\n\n    app->style.txtAreaHeight = 20;\n    app->style.textAreaFontSize = 14;\n    app->style.textAreaLabelSize = 9;\n\n    app->numFilesLoading += 1; // Increase so none of the load functions end\n    app->interfaceFont = Draw2D::LoadFont(inter_ttf, inter_ttf_len, false);\n    app->iconFont = Draw2D::LoadFont(material_ttf, material_ttf_len, false);\n    app->labelFont = Draw2D::LoadFont(pixel_ttf, pixel_ttf_len, false);\n\n#if MEM_PLATFORM_WASM || _DEBUG\n    app->numFilesLoading += 1; // Increase so none of the load functions end\n    void* loadArena = MemAlloc(1024 * 1024);\n    LoadFileAsynch(\"assets/sample.kfs\", loadArena, 1024 * 1024, [](const char* path, void* data, unsigned int bytes, void* userData) {\n        Application* app = (Application*)userData;\n        OpenFile(app, data, bytes); // Calls MEmRelease(data)\n        app->numFilesLoading -= 1; // Increase so none of the load functions end\n    }, app);\n#endif\n    \n    return app;\n}\n\nexport void Update(float dt, void* userData) {\n    Application* app = (Application*)userData;\n\n    app->msPerFrame[app->msIter] = dt;\n    if (++app->msIter >= 60) {\n        app->msIter = 0;\n    }\n\n    if (app->numFilesLoading == 1) {\n        Imgui::Initialize(app->interfaceFont, app->iconFont, app->labelFont);\n        app->numFilesLoading -= 1; // Artificial file i added in init.\n    }\n    if (app->numFilesLoading != 0) {\n        return;\n    }\n\n    Imgui::TickFrame(dt);\n\n    if (app->playSelectedAnimation) {\n        Animation* timelineAnim = app->document->GetTimelineAnimation();\n        f32 duration = timelineAnim->GetDuration();\n        if (timelineAnim != 0 && duration > 0.0f) {\n            app->playingAnimationTimer += dt;\n            if (app->playingAnimationTimer >= duration) {\n                if (timelineAnim->loop == AnimationLoopMode::Looping) {\n                    while (app->playingAnimationTimer >= duration) {\n                        app->playingAnimationTimer -= duration;\n                    }\n                    PlatformAssert(app->playingAnimationTimer > 0, __LOCATION__);\n                }\n                else {\n                    app->playingAnimationTimer = duration;\n                }\n            }\n\n            float t = app->playingAnimationTimer / duration;\n            float frame = t * (float)timelineAnim->frameCount;\n            if (frame != app->playingAnimationFrame) {\n                app->document->SetSelectedFrame(frame);\n            }\n            app->playingAnimationFrame = frame;\n        }\n    }\n}\n\nfloat FigureOutScrollBarHeight(float contentHeight, float scrollAreaHeight) {\n    float scrollerHeight = 0.0f;\n    if (contentHeight > scrollAreaHeight) {\n        float ratio = MathFloor(contentHeight / scrollAreaHeight);\n\n        if (ratio >= 5.0f) {\n            scrollerHeight = scrollAreaHeight * 0.1f;\n        }\n        else if (ratio >= 4.0f) {\n            scrollerHeight = scrollAreaHeight * 0.2f;\n        }\n        else if (ratio >= 3.0f) {\n            scrollerHeight = scrollAreaHeight * 0.35f;\n        }\n        else if (ratio >= 2.0f) {\n            scrollerHeight = scrollAreaHeight * 0.5f;\n        }\n        else if (ratio >= 1.0f) {\n            scrollerHeight = scrollAreaHeight * 0.75f;\n        }\n        else if (ratio < 0.0f) {\n            scrollerHeight = 0.0f;\n        }\n        else {\n            PlatformAssert(false, __LOCATION__);\n        }\n        if (scrollerHeight < 30.0f) {\n            scrollerHeight = 30.0f;\n        }\n    }\n    return scrollerHeight;\n}\n\nstatic void ImguiResources(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw footer\n    StyleSheet* s = &a->style;\n\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n    {\n        listItemKarrat.y -= (a->document->GetNumResources() * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n        int i = 0;\n        for (Resource* iter = a->document->ResourceIterator(0); iter != 0; iter = a->document->ResourceIterator(iter)) {\n            const char* name = \"[NULL]\";\n            if (iter->name != 0) {\n                name = iter->name;\n            }\n\n            if (Imgui::UndoListItem(listItemKarrat, scrollArea, name, (i++) % 2, false, a->document->GetSelectedResource() == iter)) {\n                a->document->SelectResource(iter);\n            }\n\n            listItemKarrat.y += s->listBoxItemHeight;\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        if (Imgui::ClickArea(fillMissing)) {\n            a->document->SelectResource(0);\n        }\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = a->document->GetNumResources() * s->listBoxItemHeight;\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    {\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        {\n            if (a->document->GetSelectedResource() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Delete Resource\", s->hierarchyFooterButtonIcon)) {\n                    if (a->document->GetSelectedResource() != 0) {\n                        a->document->DestroyResource(a->document->GetSelectedResource());\n                    }\n                }\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_ADD_FILE, \"Import Resource\", s->hierarchyFooterButtonIcon)) {\n                a->document->RequestResource([](const char* path, const Resource& resource, void* userData) {\n                    // Nothing to really do here. If the function suceeds, then the resource\n                    // is already registered. If the function fails, then nothing.\n                    }, a);\n            }\n\n            { // Label\n                char printString[36] = { 0 };\n                stbsp_snprintf(printString, 36, \"Num Resources: %d\", a->document->GetNumResources());\n                Draw2D::DrawString(a->interfaceFont, 12, hierarchyFooter.x + 5, hierarchyFooter.y + 20, printString,\n                    s->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n            }\n        }\n    }\n}\n\nstatic void ImguiSynchAnimViewIcon(Imgui::Rect footerKarrat, Application* a, StyleSheet* s, bool selectTimeline) {\n    bool activated = false;\n    if (a->synchAnimView) {\n        StyleColor c = s->hierarchyFooterButtonIcon;\n        c.r *= 0.25f;\n        c.g *= 0.55f;\n        c.b *= 0.25f;\n        if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_SYNC_ENABLED, \"Sync Enabled (click to disbale)\", c)) {\n            a->synchAnimView = false;\n            activated = true;\n        }\n    }\n    else {\n        StyleColor c = s->hierarchyFooterRemoveIcon;\n        if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_SYNC_DISABLED, \"Sync Disabled (click to enable)\", c)) {\n            a->synchAnimView = true;\n            activated = true;\n        }\n    }\n\n    if (a->synchAnimView) {\n        if (selectTimeline) {\n            // This happens all the time, has no bearing on selected frame\n            if (a->document->GetTimelineAnimation() != a->document->GetSelectedAnimation()) {\n                a->playSelectedAnimation = false;\n                a->autoKey = false;\n            }\n            a->document->SelectTimeline(a->document->GetSelectedAnimation());\n        }\n        else {\n            // This changes the selected frame.\n            if (activated) {\n                a->document->SelectAnimation(a->document->GetTimelineAnimation());\n                a->playSelectedAnimation = false;\n                a->autoKey = false;\n            }\n        }\n    }\n}\n\nstatic void ImguiAnimations(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw footer\n    StyleSheet* s = &a->style;\n\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n    {\n        listItemKarrat.y -= (a->document->GetNumAnimations() * s->listBoxItemHeight - scrollArea.h) * a->frameUpScroll;\n\n        int i = 0;\n        for (Animation* iter = a->document->AnimationIterator(0); iter != 0; iter = a->document->AnimationIterator(iter)) {\n            const char* name = \"[NULL]\";\n            if (iter->name != 0) {\n                name = iter->name;\n            }\n\n            if (Imgui::UndoListItem(listItemKarrat, scrollArea, name, (i++) % 2, false, a->document->GetSelectedAnimation() == iter)) {\n                a->document->SelectAnimation(iter);\n            }\n\n            listItemKarrat.y += s->listBoxItemHeight;\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        if (Imgui::ClickArea(fillMissing)) {\n            a->document->SelectAnimation(0);\n        }\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = a->document->GetNumAnimations() * s->listBoxItemHeight;\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    {\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        {\n            if (a->document->GetSelectedAnimation() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Delete animation\", s->hierarchyFooterButtonIcon)) {\n                    if (a->document->GetSelectedAnimation() != 0) {\n                        Animation* oldSelected = a->document->GetSelectedAnimation();\n                        if (a->document->GetTimelineAnimation() == oldSelected) {\n                            a->document->SelectTimeline(0);\n                        }\n                        a->document->SelectAnimation(0);\n                        a->autoKey = false;\n                        a->document->DeleteAnimation(oldSelected);\n                    }\n                }\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_ADDTRACK, \"Create animation\", s->hierarchyFooterButtonIcon)) {\n                a->document->CreateAnimation();\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (a->document->GetSelectedAnimation() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_DESELECT, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_DESELECT, \"Deselect animation\", s->hierarchyFooterButtonIcon)) {\n                    a->document->SelectAnimation(0);\n                    a->autoKey = false;\n\n                }\n            }\n\n            // Seperator\n            footerKarrat.x -= 5;\n            Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n            Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            ImguiSynchAnimViewIcon(footerKarrat, a, s, true);\n        }\n    }\n}\n\nstatic void ImguiKeyButton(Imgui::Rect& footerKarrat, Application* a, StyleSheet* s) {\n    if (a->document->GetSelectedNode() == 0 || a->document->GetTimelineAnimation() == 0) {\n        Imgui::Rect iconRect = footerKarrat;\n        iconRect.x += 2; // Footer specific\n        iconRect.y += 3;\n        Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_KEY, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n    }\n    else {\n        u32 numPopupItems = 14;\n\n        f32 popupMenuWidth = 200.0f;\n        Imgui::Rect popupArea(footerKarrat.x + footerKarrat.w - popupMenuWidth / 2.0f,\n            footerKarrat.y - (numPopupItems * s->listBoxItemHeight) * 2,\n            popupMenuWidth, numPopupItems * s->listBoxItemHeight);\n\n        i32 modal = Imgui::BeginModalPopup(popupArea, footerKarrat, numPopupItems);\n        Imgui::PushModalPopupItem(\"Transform.Position.X\");\n        Imgui::PushModalPopupItem(\"Transform.Position.Y\");\n        Imgui::PushModalPopupItem(\"Transform.Rotation\");\n        Imgui::PushModalPopupItem(\"Transform.Scale.X\");\n        Imgui::PushModalPopupItem(\"Transform.Scale.Y\");\n        Imgui::PushModalPopupItem(\"Sprite.Tint.R\");\n        Imgui::PushModalPopupItem(\"Sprite.Tint.G\");\n        Imgui::PushModalPopupItem(\"Sprite.Tint.B\");\n        Imgui::PushModalPopupItem(\"Sprite.Visible\");\n        Imgui::PushModalPopupItem(\"Sprite.Source.X\");\n        Imgui::PushModalPopupItem(\"Sprite.Source.Y\");\n        Imgui::PushModalPopupItem(\"Sprite.Source.W\");\n        Imgui::PushModalPopupItem(\"Sprite.Source.H\");\n        Imgui::PushModalPopupItem(\"SortIndex\");\n        Imgui::EndModalPopup();\n\n        if (modal != -1) {\n            TrackType trackType = TrackType::TransformPositionX;\n            if (modal == 0) {\n                trackType = TrackType::TransformPositionX;\n            }\n            else if (modal == 1) {\n                trackType = TrackType::TransformPositionY;\n            }\n            else if (modal == 2) {\n                trackType = TrackType::TransformRotation;\n            }\n            else if (modal == 3) {\n                trackType = TrackType::TransformScaleX;\n            }\n            else if (modal == 4) {\n                trackType = TrackType::TransformScaleY;\n            }\n            else if (modal == 5) {\n                trackType = TrackType::SpriteTintR;\n            }\n            else if (modal == 6) {\n                trackType = TrackType::SpriteTintG;\n            }\n            else if (modal == 7) {\n                trackType = TrackType::SpriteTintB;\n            }\n            else if (modal == 8) {\n                trackType = TrackType::SpriteVisibility;\n            }\n            else if (modal == 9) {\n                trackType = TrackType::SpriteSourceX;\n            }\n            else if (modal == 10) {\n                trackType = TrackType::SpriteSourceY;\n            }\n            else if (modal == 11) {\n                trackType = TrackType::SpriteSourceW;\n            }\n            else if (modal == 12) {\n                trackType = TrackType::SpriteSourceH;\n            }\n            else if (modal == 13) {\n                trackType = TrackType::SortIndex;\n            }\n\n            a->document->AddTrack(a->document->GetTimelineAnimation(), a->document->GetSelectedNode(), trackType);\n        }\n\n        if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_KEY, \"Animate node property\", s->hierarchyFooterButtonIcon)) {\n            // Nothing to do, modal self-activates\n        }\n    }\n}\n\nstatic void ImguiHierarchy(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw scroll list\n    StyleSheet* s = &a->style;\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n\n    Node2D* hierarchyRearrangeDragging = 0;\n    Imgui::Rect hierarchyInsertIndicator;\n\n    u32 visibleNodeCount = a->document->GetVisibleNodeCount();\n    Imgui::Point mousePos = Imgui::GetPointer();\n\n    listItemKarrat.y -= (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n    Node2D* itr = a->document->DepthFirstExpandedOnly(0); // Root is guaranteed to exist\n    itr = a->document->DepthFirstExpandedOnly(itr); // First one to draw\n\n    bool even = true;\n    while (itr != 0) {\n        Imgui::HierarchyListItemResult listItem = Imgui::HierarchyListItem(listItemKarrat, scrollArea, itr->name,\n            (itr->depth - 1) * 18, even, a->document->GetSelectedNode() == itr, itr->uiExpanded, itr->firstChild == 0);\n\n        itr->uiExpanded = listItem.expanded;\n\n        if (listItem.dragging) {\n            hierarchyRearrangeDragging = itr;\n        }\n\n        if (listItem.activated) {\n            a->document->SelectNode(itr);\n        }\n\n        even = !even;\n        listItemKarrat.y += s->listBoxItemHeight;\n        itr = a->document->DepthFirstExpandedOnly(itr);\n    }\n\n    if (hierarchyRearrangeDragging != 0) {\n        float mouseInScrollSpace = (mousePos.y - scrollArea.y);\n        if (mouseInScrollSpace < 0.0f) {\n            mouseInScrollSpace = 0.0f;\n        }\n        else if (mouseInScrollSpace > scrollArea.h) {\n            mouseInScrollSpace = scrollArea.h;\n        }\n        // Content goes up, so mouse goes down\n        mouseInScrollSpace += (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n        i32 index = mouseInScrollSpace / s->listBoxItemHeight;\n        PlatformAssert(index >= 0, __LOCATION__);\n\n        if (index >= visibleNodeCount && visibleNodeCount >= 1) {\n            index = visibleNodeCount - 1;\n        }\n\n        if (visibleNodeCount > 0) {\n            PlatformAssert(index < visibleNodeCount, __LOCATION__);\n        }\n\n        Node2D* dropTarget = a->document->DepthFirstExpandedOnly(0);\n        dropTarget = a->document->DepthFirstExpandedOnly(dropTarget);\n        for (i32 i = 0; i < index; ++i) {\n            dropTarget = a->document->DepthFirstExpandedOnly(dropTarget);\n        }\n        PlatformAssert(dropTarget != 0, __LOCATION__);\n\n        bool above = false;\n        bool below = false;\n\n        float firstThird = ((float)index * s->listBoxItemHeight + s->listBoxItemHeight / 3.0f);\n        float secondThird = firstThird + s->listBoxItemHeight / 3.0f;\n        if (mouseInScrollSpace < firstThird) {\n            above = true;\n        }\n\n        if (mouseInScrollSpace > secondThird) {\n            below = true;\n        }\n\n        float midPoint = ((float)index * s->listBoxItemHeight + s->listBoxItemHeight / 2.0f);\n        hierarchyInsertIndicator = Imgui::Rect(\n            scrollArea.x, scrollArea.y + midPoint,\n            scrollArea.w, 2\n        );\n\n        if (above) {\n            hierarchyInsertIndicator.y -= s->listBoxItemHeight / 2.0f;\n\n            if (dropTarget->depth >= 1) {\n                hierarchyInsertIndicator.x += (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n                hierarchyInsertIndicator.w -= (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n            }\n        }\n        else if (below) {\n            hierarchyInsertIndicator.y += s->listBoxItemHeight / 2.0f;\n\n            if (dropTarget->depth >= 1) {\n                hierarchyInsertIndicator.x += (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n                hierarchyInsertIndicator.w -= (dropTarget->depth - 1) * 18 + s->hierarchyLabelFontSize + 3;\n            }\n        }\n        else {\n            hierarchyInsertIndicator.y += s->listBoxItemHeight / 2.0f;\n            hierarchyInsertIndicator.x += (dropTarget->depth) * 18 + s->hierarchyLabelFontSize + 3;\n            hierarchyInsertIndicator.w -= (dropTarget->depth) * 18 + s->hierarchyLabelFontSize + 3;\n        }\n        hierarchyInsertIndicator.y -= (visibleNodeCount * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n        if (Imgui::PointerReleased() && Imgui::Contains(scrollArea, mousePos)) {\n            if (dropTarget != hierarchyRearrangeDragging) {\n                if (above) {\n                    Node2D* parent = dropTarget->parent;\n                    Node2D* prev = 0;\n                    Node2D* iter = parent->firstChild;\n                    while (iter != 0) {\n                        if (iter == dropTarget) {\n                            break;\n                        }\n                        prev = iter;\n                        iter = iter->next;\n                    }\n                    a->document->RearrangeNode(*hierarchyRearrangeDragging, *parent, prev);\n                }\n                else if (below) {\n                    Node2D* parent = dropTarget->parent;\n                    Node2D* prev = dropTarget;\n                    a->document->RearrangeNode(*hierarchyRearrangeDragging, *parent, prev);\n                }\n                else {\n                    a->document->RearrangeNode(*hierarchyRearrangeDragging, *dropTarget, 0);\n                }\n            }\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        if (Imgui::ClickArea(fillMissing)) {\n            a->document->SelectNode(0);\n        }\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = visibleNodeCount * s->listBoxItemHeight;\n\n    // Move scroll bar if re-arranging hierarchy\n    if (hierarchyRearrangeDragging != 0) {\n        Imgui::Rect scrollUp = scrollArea;\n        scrollUp.h = s->scrollBarSize;\n        Imgui::Rect scrollDown = scrollUp;\n        scrollDown.y += scrollArea.h - scrollUp.h;\n\n        if (Imgui::GetPulse()) {\n            if (Imgui::Contains(scrollUp, mousePos)) {\n                a->hierarchyScroll -= 0.05f;\n            }\n            if (Imgui::Contains(scrollDown, mousePos)) {\n                a->hierarchyScroll += 0.05f;\n            }\n\n            if (a->hierarchyScroll < 0.0f) {\n                a->hierarchyScroll = 0.0f;\n            }\n            if (a->hierarchyScroll > 1.0f) {\n                a->hierarchyScroll = 1.0f;\n            }\n        }\n    }\n\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    {\n        // Footer BG\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        // Footer divider\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        { // New / delete node\n            if (a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Delete selected node\", s->hierarchyFooterButtonIcon)) {\n                    a->document->DeleteNode(a->document->GetSelectedNode());\n                }\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_NEWLAYER, \"Create new node\", s->hierarchyFooterButtonIcon)) {\n                a->document->CreateNode(a->document->GetSelectedNode());\n            }\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (a->document->GetSelectedNode() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_DESELECT, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_DESELECT, \"Deselect node\", s->hierarchyFooterButtonIcon)) {\n                    a->document->SelectNode(0);\n                }\n            }\n        }\n\n        footerKarrat.x -= 5;\n        Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        { // Key / unkey\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            ImguiKeyButton(footerKarrat, a, s);\n        }\n\n        { // Node Count Label\n            char printString[12] = { 0 };\n            stbsp_snprintf(printString, 12, \"Count: %d\", a->document->GetNodeCount());\n            Draw2D::DrawString(a->interfaceFont, 12, hierarchyFooter.x + 5, hierarchyFooter.y + 20, printString,\n                s->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n        }\n    }\n\n    // Draw re-arrange indicator\n    if (a->hierarchyTab == 0) { // Hierarchy re-arrange indicator (needs to draw above footer)\n        if (hierarchyRearrangeDragging != 0) {\n            Draw2D::DrawRect(hierarchyInsertIndicator.x, hierarchyInsertIndicator.y, hierarchyInsertIndicator.w, hierarchyInsertIndicator.h, s->hierarchyItemBG_Movable.r, s->hierarchyItemBG_Movable.g, s->hierarchyItemBG_Movable.b);\n        }\n    }\n}\n\nstatic void ImguiUndoStack(const Imgui::Rect& scrollArea, Application* a) {\n    // Draw scroll list\n    StyleSheet* s = &a->style;\n    Imgui::Rect listItemKarrat = scrollArea;\n    listItemKarrat.h = s->listBoxItemHeight;\n\n    listItemKarrat.y -= (a->document->GetNumUndoSteps() * s->listBoxItemHeight - scrollArea.h) * a->hierarchyScroll;\n\n    bool do_undo = false;\n    u32 undoIndex = 0;\n\n    u32 currentUndoStep = a->document->GetUndoStackCurrent();\n    u32 currentUndoIndex = currentUndoStep;\n    if (currentUndoIndex != 0) {\n        currentUndoIndex -= 1;\n    }\n\n    for (u32 i = 0, numUndoSteps = a->document->GetNumUndoSteps(); i < numUndoSteps; ++i) {\n        const char* name = a->document->GetUndoStepName(i);\n\n        if (Imgui::UndoListItem(listItemKarrat, scrollArea, name, i % 2, currentUndoStep < i + 1, i + 1 == currentUndoStep)) {\n            if (!do_undo) {\n                do_undo = true;\n                undoIndex = i;\n            }\n        }\n\n        listItemKarrat.y += s->listBoxItemHeight;\n    }\n\n    if (do_undo) {\n        if (undoIndex < currentUndoIndex) { // Undo x times\n            u32 numUndoSteps = currentUndoIndex - undoIndex;\n            for (u32 i = 0; i < numUndoSteps; ++i) {\n                if (a->document->CanUndo()) {\n                    a->document->Undo();\n                }\n            }\n        }\n        else if (undoIndex > currentUndoIndex) { // Redo x times\n            u32 numRedoSteps = undoIndex - currentUndoIndex;\n            for (u32 i = 0; i < numRedoSteps; ++i) {\n                if (a->document->CanRedo()) {\n                    a->document->Redo();\n                }\n            }\n        }\n    }\n\n    // Fill any missing space\n    float bottom = scrollArea.y + scrollArea.h;\n    float delta = bottom - (listItemKarrat.y);\n    if (delta > 0.0f) {\n        Imgui::Rect fillMissing = listItemKarrat;\n        fillMissing.h = delta;\n\n        Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n    }\n\n    // Draw scroll bar\n    Imgui::Rect hierarchyScrollBar = scrollArea;\n    hierarchyScrollBar.x = scrollArea.x + scrollArea.w;\n    hierarchyScrollBar.w = s->scrollBarSize;\n    float contentHeight = a->document->GetNumUndoSteps() * s->listBoxItemHeight;\n    float scrollerHeight = FigureOutScrollBarHeight(contentHeight, scrollArea.h);\n\n    a->hierarchyScroll = Imgui::VScroll(hierarchyScrollBar, a->hierarchyScroll, scrollerHeight, Imgui::HandleScroll(scrollArea));\n\n    // Draw footer\n    Imgui::Rect hierarchyFooter = scrollArea;\n    hierarchyFooter.y = scrollArea.y + scrollArea.h;\n    hierarchyFooter.h = s->hierarchyFooterHeight;\n    hierarchyFooter.w = scrollArea.w + s->scrollBarSize;\n\n    // Draw footer\n    {\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, hierarchyFooter.h,\n            s->hierarchyFooterBg.r, s->hierarchyFooterBg.g, s->hierarchyFooterBg.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y + 1, hierarchyFooter.w, 1,\n            s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(hierarchyFooter.x, hierarchyFooter.y, hierarchyFooter.w, 1,\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n        Imgui::Rect footerKarrat = hierarchyFooter;\n        footerKarrat.x = hierarchyFooter.x + hierarchyFooter.w - s->hierarchyFooterButtonSize - 3;\n        footerKarrat.y = hierarchyFooter.y + 5;\n        footerKarrat.w = s->hierarchyFooterButtonSize;\n        footerKarrat.h = s->hierarchyFooterButtonSize;\n\n        { // Clear Stack / Debug View\n            if (a->document->GetNumUndoSteps() == 0) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific offset\n                iconRect.y += 3; // Footer specific offset\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_TRASHCAN, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_TRASHCAN, \"Clear undo history\", s->hierarchyFooterButtonIcon)) {\n                    a->document->ClearUndoHistory();\n                }\n            }\n\n            footerKarrat.x -= 5;\n            Draw2D::DrawRect((footerKarrat.x), hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n            Draw2D::DrawRect((footerKarrat.x) + 1, hierarchyFooter.y + 2, 1, hierarchyFooter.h - 2,\n                s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (!a->document->CanRedo()) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_REDO, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_REDO, \"Redo\", s->hierarchyFooterButtonIcon)) {\n                    a->document->Redo();\n                }\n            }\n            footerKarrat.x = footerKarrat.x - s->hierarchyFooterButtonSize - 3;\n            if (!a->document->CanUndo()) {\n                Imgui::Rect iconRect = footerKarrat;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_UNDO, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (Imgui::FooterButton(footerKarrat, IMGUI_ICON_CODEPOINT_UNDO, \"Undo\", s->hierarchyFooterButtonIcon)) {\n                    a->document->Undo();\n                }\n            }\n\n            { // History Label\n                char printString[36] = { 0 };\n                stbsp_snprintf(printString, 36, \"History: %d, Max: %d\", a->document->GetUndoStackCurrent(), a->document->GetMaxUndoSteps());\n                Draw2D::DrawString(a->interfaceFont, 12, hierarchyFooter.x + 5, hierarchyFooter.y + 20, printString,\n                    s->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n            }\n        }\n    }\n}\n\nstatic void ImguiAnimationEditor(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n    Draw2D::DrawRect(area.x, area.y, area.w, area.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);\n\n    // Draw text boxes\n    Imgui::Rect karrat(area.x + 10, area.y + 13, area.w - 20, 0);\n    Imgui::Rect textArea = karrat;\n    textArea.h = s->txtAreaHeight;\n\n    const char* oldName = \"\";\n    Animation* selectedAnim = a->document->GetSelectedAnimation();\n    if (selectedAnim != 0) {\n        oldName = selectedAnim->name;\n    }\n\n    const char* newName = Imgui::TextArea(textArea, oldName, \"Name\", selectedAnim == 0, false, false, false, false, false);\n    if (selectedAnim != 0 && newName != oldName) {\n        a->document->RenameAnimation(selectedAnim, newName);\n    }\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    float trippleWidth = (textArea.w - 20) / 3.0f;\n    textArea.w = trippleWidth;\n\n    char num_buffer[64] = { 0 };\n    {\n        if (selectedAnim != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.d\", selectedAnim->frameRate);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Frame Rate\", selectedAnim == 0, false, true, false, false, false);\n        if (selectedAnim != 0 && newNumber != num_buffer) {\n            i32 frameRate = MathAToI(newNumber);\n            if (frameRate < 0) {\n                frameRate = 0;\n            }\n            a->document->UpdateAnimation(selectedAnim, selectedAnim->frameCount, frameRate, selectedAnim->loop);\n        }\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        if (selectedAnim != 0) {\n            stbsp_snprintf(num_buffer, 64, \"%.d\", selectedAnim->frameCount);\n        }\n        else {\n            num_buffer[0] = '\\0';\n        }\n        const char* newNumber = Imgui::TextArea(textArea, num_buffer, \"Frame Count\", selectedAnim == 0, false, true, false, false, false);\n        if (selectedAnim != 0 && newNumber != num_buffer) {\n            i32 frameCount = MathAToI(newNumber);\n            if (frameCount < 0) {\n                frameCount = 0;\n            }\n            a->document->UpdateAnimation(selectedAnim, frameCount, selectedAnim->frameRate, selectedAnim->loop);\n        }\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    {\n        const char* name = \"None\";\n        i32 selected = -1;\n        if (selectedAnim != 0) {\n            selected = 0;\n            if (selectedAnim->loop == AnimationLoopMode::Looping) {\n                selected = 1;\n                name = \"Looping\";\n            }\n        }\n\n        i32 selection = Imgui::BeginComboBox(textArea, name, selectedAnim == 0 ? 0 : 2, selected, \"Repeat\", false, selectedAnim == 0);\n        if (selectedAnim != 0) {\n            Imgui::PushComboBoxItem(\"None\");\n            Imgui::PushComboBoxItem(\"Looping\");\n        }\n        Imgui::EndComboBox();\n\n        if (selected != selection && selectedAnim != 0) {\n            a->document->UpdateAnimation(selectedAnim, selectedAnim->frameCount, selectedAnim->frameRate, selection == 1 ? AnimationLoopMode::Looping : AnimationLoopMode::None);\n        }\n    }\n\n}\n\ninline Track* ContainsTrack(Animation* anim, Node2D* node, TrackType type) {\n    if (anim == 0 || node == 0) {\n        return 0;\n    }\n\n    return anim->Contains(node, type);\n}\n\nstatic void ImguiAnimatedFloatTextField(Application* a, const Imgui::Rect& area, const char* label, TrackType trackType, char* displayBuffer, u32 displayBufferLen) {\n    Document* doc = a->document;\n\n    Animation* timelineAnimation = doc->GetTimelineAnimation();\n    Node2D* selectedNode = doc->GetSelectedNode();\n    i32 selectedFrame = doc->GetSelectedFrame();\n    Track* animatedTrack = ContainsTrack(timelineAnimation, selectedNode, trackType);\n\n    bool contained = animatedTrack != 0 && animatedTrack->numKeyFrames > 0;\n    bool interpolated = false;\n    bool tempChanged = false;\n\n    if (selectedNode != 0) {\n        if (contained) {\n            PlatformAssert(timelineAnimation != 0, __LOCATION__); // Safe if contained\n\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolated = false;\n                tempChanged = true;\n                stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", selectedNode->GetPropertyBuffer<f32>(trackType));\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrack->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", animatedTrack->frames[0].fValue);\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolated = true;\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", selectedNode->GetProperty<f32>(trackType));\n                    }\n                }\n                else {\n                    PlatformAssert(selectedFrame < animatedTrack->frameCount, __LOCATION__);\n\n                    if (animatedTrack->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", animatedTrack->frames[selectedFrame].fValue);\n                    }\n                    else {\n                        interpolated = true;\n\n                        float interpolated_value = animatedTrack->InterpolateF(selectedFrame, selectedNode->GetProperty<f32>(trackType), timelineAnimation->loop);\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", interpolated_value);\n                    }\n                }\n            }\n        }\n        else {\n            stbsp_snprintf(displayBuffer, displayBufferLen, \"%.2f\", selectedNode->GetProperty<f32>(trackType));\n        }\n    }\n    else {\n        displayBuffer[0] = '\\0';\n    }\n\n    bool disabled = selectedNode == 0;\n\n\n    const char* newNumber = Imgui::TextArea(area, displayBuffer, label, disabled, true, false, contained, interpolated, tempChanged);\n    if (selectedNode != 0 && newNumber != displayBuffer) {\n        float new_val = MathAToF(newNumber);\n        if (contained) {\n            if (a->document->GetSelectedFrame() == a->document->GetLastSelectedFrame() && a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                Frame dummy = { 0 };\n                dummy.fValue = new_val;\n                doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n            }\n            else {\n                selectedNode->SetBuffered<f32>(trackType, new_val);\n            }\n        }\n        else {\n            if (doc->UpdateNodeTransformSingleF(selectedNode, new_val, trackType)) {\n                if (a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = new_val;\n                    doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n        }\n    }\n}\n\nstatic void ImguiAnimatedToggle(Application* a, const Imgui::Rect& toggleArea, TrackType trackType) {\n    Document* doc = a->document;\n    StyleSheet* s = &a->style;\n\n    Animation* timelineAnimation = doc->GetTimelineAnimation();\n    Node2D* selectedNode = doc->GetSelectedNode();\n    i32 selectedFrame = doc->GetSelectedFrame();\n    Track* animatedTrack = ContainsTrack(timelineAnimation, selectedNode, trackType);\n\n    bool contained = animatedTrack != 0 && animatedTrack->numKeyFrames > 0;\n    bool interpolated = false;\n    bool tempChanged = false;\n\n    bool displayBool = false;\n\n    if (selectedNode != 0) {\n        if (contained) {\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolated = false;\n                tempChanged = true;\n                displayBool = selectedNode->GetPropertyBuffer<bool>(trackType);\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrack->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        displayBool = animatedTrack->frames[0].bValue;\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolated = true;\n                        displayBool = selectedNode->GetProperty<bool>(trackType);\n                    }\n                }\n                else {\n                    if (animatedTrack->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        displayBool = animatedTrack->frames[selectedFrame].bValue;\n                    }\n                    else {\n                        interpolated = true;\n                        bool interpolated_value = animatedTrack->InterpolateB(selectedFrame, selectedNode->GetProperty<bool>(trackType), timelineAnimation->loop);\n                        displayBool = interpolated_value;\n                    }\n                }\n            }\n        }\n        else {\n            displayBool = selectedNode->GetProperty<bool>(trackType);\n        }\n    }\n\n    StyleColor tint = { 0 };\n    if (tempChanged) {\n        tint.r = s->textAreaBg_DirtyTint.r;\n        tint.g = s->textAreaBg_DirtyTint.g;\n        tint.b = s->textAreaBg_DirtyTint.b;\n    }\n    else if (interpolated) {\n        tint.r = s->textAreaBg_InterpolatedTint.r;\n        tint.g = s->textAreaBg_InterpolatedTint.g;\n        tint.b = s->textAreaBg_InterpolatedTint.b;\n    }\n    else if (contained) {\n        tint.r = s->textAreaBg_AnimatedTint.r;\n        tint.g = s->textAreaBg_AnimatedTint.g;\n        tint.b = s->textAreaBg_AnimatedTint.b;\n    }\n\n\n    bool visible = Imgui::ToggleButton(toggleArea, IMGUI_ICON_CODEPOINT_VISIBLE, IMGUI_ICON_CODEPOINT_INVISIBLE,\n        displayBool, selectedNode == 0, 0, tint);\n\n    if (selectedNode != 0 && visible != displayBool) {\n        if (contained) {\n            if (a->document->GetSelectedFrame() == a->document->GetLastSelectedFrame() && a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                Frame dummy = { 0 };\n                dummy.bValue = visible;\n                doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n            }\n            else {\n                selectedNode->SetBuffered<bool>(trackType, visible);\n            }\n        }\n        else {\n            if (doc->UpdateSpriteVisibility(selectedNode, visible, selectedNode->sortIndex)) {\n                if (a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.bValue = visible;\n                    doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n        }\n\n    }\n}\n\nstatic void ImguiAnimatedColorPicker(Application* a, StyleSheet* s, const Imgui::Rect& toggleArea) {\n    Document* doc = a->document;\n\n    Animation* timelineAnimation = doc->GetTimelineAnimation();\n    Node2D* selectedNode = doc->GetSelectedNode();\n    i32 selectedFrame = doc->GetSelectedFrame();\n    Track* animatedTrackR = ContainsTrack(timelineAnimation, selectedNode, TrackType::SpriteTintR);\n    Track* animatedTrackG = ContainsTrack(timelineAnimation, selectedNode, TrackType::SpriteTintG);\n    Track* animatedTrackB = ContainsTrack(timelineAnimation, selectedNode, TrackType::SpriteTintB);\n\n\n    rgb color = { 0 };\n\n    bool containedR = animatedTrackR != 0 && animatedTrackR->numKeyFrames > 0;\n    bool containedG = animatedTrackG != 0 && animatedTrackG->numKeyFrames > 0;\n    bool containedB = animatedTrackB != 0 && animatedTrackB->numKeyFrames > 0;\n    bool interpolatedR = false;\n    bool interpolatedG = false;\n    bool interpolatedB = false;\n    bool tempChangedR = false;\n    bool tempChangedG = false;\n    bool tempChangedB = false;\n\n    if (selectedNode != 0) {\n        TrackType trackType = TrackType::SpriteTintR;\n        if (containedR) {\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolatedR = false;\n                tempChangedR = true;\n                color.r = selectedNode->GetPropertyBuffer<f32>(trackType);\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrackR != 0 && animatedTrackR->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolatedR = false;\n                        color.r = animatedTrackR->frames[0].fValue;\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolatedR = true;\n                        color.r = selectedNode->GetProperty<f32>(trackType);\n                    }\n                }\n                else {\n                    if (animatedTrackR->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolatedR = false;\n                        color.r = animatedTrackR->frames[selectedFrame].fValue;\n                    }\n                    else {\n                        interpolatedR = true;\n                        f32 interpolated_value = animatedTrackR->InterpolateF(selectedFrame, selectedNode->GetProperty<f32>(trackType), timelineAnimation->loop);\n                        color.r = interpolated_value;\n                    }\n                }\n            }\n        }\n        else {\n            color.r = selectedNode->GetProperty<f32>(trackType);\n        }\n\n        trackType = TrackType::SpriteTintG;\n        if (containedG) {\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolatedG = false;\n                tempChangedG = true;\n                color.g = selectedNode->GetPropertyBuffer<f32>(trackType);\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrackG->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolatedG = false;\n                        color.g = animatedTrackG->frames[0].fValue;\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolatedG = true;\n                        color.g = selectedNode->GetProperty<f32>(trackType);\n                    }\n                }\n                else {\n                    if (animatedTrackG->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolatedG = false;\n                        color.g = animatedTrackG->frames[selectedFrame].fValue;\n                    }\n                    else {\n                        interpolatedG = true;\n                        f32 interpolated_value = animatedTrackG->InterpolateF(selectedFrame, selectedNode->GetProperty<f32>(trackType), timelineAnimation->loop);\n                        color.g = interpolated_value;\n                    }\n                }\n            }\n        }\n        else {\n            color.g = selectedNode->GetProperty<f32>(trackType);\n        }\n\n        trackType = TrackType::SpriteTintB;\n        if (containedB) {\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolatedB = false;\n                tempChangedB = true;\n                color.b = selectedNode->GetPropertyBuffer<f32>(trackType);\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrackB->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolatedB = false;\n                        color.b = animatedTrackB->frames[0].fValue;\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolatedB = true;\n                        color.b = selectedNode->GetProperty<f32>(trackType);\n                    }\n                }\n                else {\n                    if (animatedTrackB->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolatedB = false;\n                        color.b = animatedTrackB->frames[selectedFrame].fValue;\n                    }\n                    else {\n                        interpolatedB = true;\n                        f32 interpolated_value = animatedTrackB->InterpolateF(selectedFrame, selectedNode->GetProperty<f32>(trackType), timelineAnimation->loop);\n                        color.b = interpolated_value;\n                    }\n                }\n            }\n        }\n        else {\n            color.b = selectedNode->GetProperty<f32>(trackType);\n        }\n    }\n\n    StyleColor tint = { 0 };\n    if (tempChangedR || tempChangedG || tempChangedB) {\n        tint.r = s->textAreaBg_DirtyTint.r;\n        tint.g = s->textAreaBg_DirtyTint.g;\n        tint.b = s->textAreaBg_DirtyTint.b;\n    }\n    else if (containedR || containedG || containedB) {\n        tint.r = s->textAreaBg_AnimatedTint.r;\n        tint.g = s->textAreaBg_AnimatedTint.g;\n        tint.b = s->textAreaBg_AnimatedTint.b;\n    }\n    else if (interpolatedR || interpolatedG || interpolatedB) {\n        tint.r = s->textAreaBg_InterpolatedTint.r;\n        tint.g = s->textAreaBg_InterpolatedTint.g;\n        tint.b = s->textAreaBg_InterpolatedTint.b;\n    }\n\n\n    rgb newColor = hsv2rgb(Imgui::ColorPickerButton(toggleArea, rgb2hsv(color), selectedNode == 0, tint));\n\n    if (selectedNode != 0 && !compare(color, newColor)) {\n        if (containedR || containedG || containedB) {\n            bool validTrack = animatedTrackR != 0 || animatedTrackG != 0 || animatedTrackB != 0;\n            if (a->document->GetSelectedFrame() == a->document->GetLastSelectedFrame() && a->autoKey && validTrack && selectedFrame >= 0) {\n                if (a->autoKey && animatedTrackR != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.r;\n                    doc->AutoKeyFrameValue(animatedTrackR, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n                if (a->autoKey && animatedTrackG != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.g;\n                    doc->AutoKeyFrameValue(animatedTrackG, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n                if (a->autoKey && animatedTrackB != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.b;\n                    doc->AutoKeyFrameValue(animatedTrackB, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n            else {\n                selectedNode->SetBuffered<float>(TrackType::SpriteTintR, newColor.r);\n                selectedNode->SetBuffered<float>(TrackType::SpriteTintG, newColor.g);\n                selectedNode->SetBuffered<float>(TrackType::SpriteTintB, newColor.b);\n            }\n        }\n        else {\n            if (doc->UpdateSpriteTint(selectedNode, newColor.r, newColor.g, newColor.b, selectedNode->sprite.tintA)) {\n                if (a->autoKey && animatedTrackR != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.r;\n                    doc->AutoKeyFrameValue(animatedTrackR, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n                if (a->autoKey && animatedTrackG != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.g;\n                    doc->AutoKeyFrameValue(animatedTrackG, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n                if (a->autoKey && animatedTrackB != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = newColor.b;\n                    doc->AutoKeyFrameValue(animatedTrackB, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n        }\n    }\n}\n\nstatic void ImguiAnimatedIntTextField(Application* a, const Imgui::Rect& area, const char* label, TrackType trackType, char* displayBuffer, u32 displayBufferLen, bool allowNegative) {\n    Document* doc = a->document;\n\n    Animation* timelineAnimation = doc->GetTimelineAnimation();\n    Node2D* selectedNode = doc->GetSelectedNode();\n    i32 selectedFrame = doc->GetSelectedFrame();\n    Track* animatedTrack = ContainsTrack(timelineAnimation, selectedNode, trackType);\n\n    bool contained = animatedTrack != 0 && animatedTrack->numKeyFrames > 0;\n    bool interpolated = false;\n    bool tempChanged = false;\n\n    if (selectedNode != 0) {\n        if (contained) {\n            PlatformAssert(timelineAnimation != 0, __LOCATION__); // Safe if contained\n\n            if (selectedNode->IsPropertyDirty(trackType)) {\n                interpolated = false;\n                tempChanged = true;\n                i32 print_val = selectedNode->GetPropertyBuffer<i32>(trackType);\n                stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", print_val);\n            }\n            else {\n                if (selectedFrame == -1) { // No frame selected, show frame 0\n                    if (animatedTrack->frames[0].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", animatedTrack->frames[0].iValue);\n                    }\n                    else { // Nothing is keyed for frame 0, show hierarchy value\n                        interpolated = true;\n                        i32 print_val = selectedNode->GetProperty<i32>(trackType);\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", print_val);\n                    }\n                }\n                else {\n                    PlatformAssert(selectedFrame < animatedTrack->frameCount, __LOCATION__);\n\n                    if (animatedTrack->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                        interpolated = false;\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", animatedTrack->frames[selectedFrame].iValue);\n                    }\n                    else {\n                        interpolated = true;\n\n                        int interpolated_value = animatedTrack->InterpolateI(selectedFrame, selectedNode->GetProperty<i32>(trackType), timelineAnimation->loop);\n                        stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", interpolated_value);\n                    }\n                }\n            }\n        }\n        else {\n            i32 print_val = selectedNode->GetProperty<i32>(trackType);\n            stbsp_snprintf(displayBuffer, displayBufferLen, \"%d\", print_val);\n        }\n    }\n    else {\n        displayBuffer[0] = '\\0';\n    }\n\n    bool disabled = selectedNode == 0;\n\n    const char* newNumber = Imgui::TextArea(area, displayBuffer, label, disabled, false, true, contained, interpolated, tempChanged);\n    if (selectedNode != 0 && newNumber != displayBuffer) {\n        i32 new_val = MathAToI(newNumber);\n        if (!allowNegative) {\n            new_val = MathAbsI(new_val);\n        }\n        if (contained) {\n            if (a->document->GetSelectedFrame() == a->document->GetLastSelectedFrame() && a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                Frame dummy = { 0 };\n                dummy.iValue = new_val;\n                doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n            }\n            else {\n                selectedNode->SetBuffered<i32>(trackType, new_val);\n            }\n        }\n        else {\n            if (doc->UpdateNodeTransformSingleI(selectedNode, new_val, trackType)) {\n                if (a->autoKey && animatedTrack != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.iValue = new_val;\n                    doc->AutoKeyFrameValue(animatedTrack, selectedFrame, doc->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n        }\n    }\n}\n\nstatic void ImguiSpriteEditor(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n    Draw2D::DrawRect(area.x, area.y, area.w, area.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);\n    f32 areaSize = 22;\n\n    Imgui::Rect karrat(area.x + 10, area.y + 13, area.w - 20, 0);\n    Imgui::Rect textArea = karrat;\n    textArea.h = s->txtAreaHeight;\n    textArea.w = karrat.w - (75 + 55 + 20);\n    //float trippleWidth = (textArea.w - 20) / 3.0f;\n\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    //const char* oldName = (selectedNode != 0) ? selectedNode->name : \"\";\n    //const char* newName = Imgui::TextArea(textArea, oldName, \"Resource\", selectedNode == 0, false);\n\n    const char* selected = \"None\";\n    Resource* selectedResource = 0;\n    if (selectedNode != 0) {\n        selectedResource = a->document->FindResourceById(selectedNode->sprite.resourceUID);\n    }\n\n    i32 selectionIndex = -1;\n    if (selectedResource != 0) {\n        selected = selectedResource->name;\n        selectionIndex = 0;\n\n        for (Resource* iter = a->document->ResourceIterator(0); iter != 0; iter = a->document->ResourceIterator(iter), selectionIndex++) {\n            if (iter == selectedResource) {\n                break;\n            }\n        }\n    }\n\n    i32 selectedIndex = Imgui::BeginComboBox(textArea, selected, a->document->GetNumResources(), selectionIndex, \"Image\", false, selectedNode == 0);\n\n    Resource* iter = a->document->ResourceIterator(0);\n    int resourceCounter = 0;\n    while (iter != 0) {\n        const char* option = iter->name;\n        if (option == 0) {\n            option = \"[NULL]\";\n        }\n        Imgui::PushComboBoxItem(option);\n\n        if (selectionIndex != selectedIndex) {\n            if (resourceCounter == selectedIndex) {\n                selectedResource = iter;\n                a->document->UpdateSprite(selectedNode, selectedResource);\n            }\n        }\n\n        resourceCounter += 1;\n        iter = a->document->ResourceIterator(iter);\n    }\n\n    Imgui::EndComboBox();\n\n    textArea.x = karrat.x + textArea.w + 10;\n    textArea.w = 55;\n    Imgui::Rect labelRect(textArea.x, textArea.y, textArea.w, 16);\n    Imgui::Label(labelRect, \"Tint\", selectedNode == 0);\n    Imgui::Rect toggleArea(textArea.x + 32, textArea.y - 1, areaSize, areaSize);\n\n\n    ImguiAnimatedColorPicker(a, &a->style, toggleArea);\n    /*rgb color = { 0 };\n    if (selectedNode != 0) {\n        color.r = selectedNode->sprite.tintR;\n        color.g = selectedNode->sprite.tintG;\n        color.b = selectedNode->sprite.tintB;\n    }\n\n\n    rgb newColor = hsv2rgb(Imgui::ColorPickerButton(toggleArea, rgb2hsv(color), selectedNode == 0));\n\n    if (selectedNode != 0 && !compare(color, newColor)) {\n        a->document->UpdateSpriteTint(selectedNode, newColor.r, newColor.g, newColor.b, selectedNode->sprite.tintA);\n    }*/\n\n    textArea.x += textArea.w + 10;\n    textArea.w = 75;\n\n    labelRect = Imgui::Rect(textArea.x, textArea.y, textArea.w, 16);\n    Imgui::Label(labelRect, \"Visible\", selectedNode == 0);\n    toggleArea = Imgui::Rect(textArea.x + 52, textArea.y - 1, areaSize, areaSize);\n\n    ImguiAnimatedToggle(a, toggleArea, TrackType::SpriteVisibility);\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x;\n#if 1\n    float trippleWidth = ((karrat.w - 20.0f) - IMAGE_PREVIEW_SIZE) / 2.0f;\n\n    textArea.w = textArea.h = IMAGE_PREVIEW_SIZE;\n\n    Imgui::Rect sourceRect;\n    if (selectedResource != 0 && selectedNode != 0) {\n        sourceRect.x = selectedNode->sprite.sourceX;\n        sourceRect.y = selectedNode->sprite.sourceY;\n        sourceRect.w = selectedNode->sprite.sourceW;\n        sourceRect.h = selectedNode->sprite.sourceH;\n        vec3 xForm = Imgui::ImageBlock(textArea, \"Preview\", selectedResource->image, sourceRect, selectedNode == 0);\n        vec2 scaledPivot(selectedNode->sprite.pivotX * xForm.z + xForm.x, selectedNode->sprite.pivotY * xForm.z + xForm.y);\n\n        if (selectedNode->sprite.pivotX > 0.0f && selectedNode->sprite.pivotY > 0.0f) {\n            if (selectedNode->sprite.pivotX < selectedNode->sprite.sourceW && selectedNode->sprite.pivotY < selectedNode->sprite.sourceW) {\n                Draw2D::DrawRect(textArea.x + scaledPivot.x - 2, textArea.y + scaledPivot.y - 2, 5, 5, 0.0f, 0.0f, 0.0f);\n                //Draw2D::DrawRect(textArea.x + scaledPivot.x - 2, textArea.y + scaledPivot.y - 1, 5, 3, 0.0f, 0.0f, 0.0f);\n\n                Draw2D::DrawRect(textArea.x + scaledPivot.x, textArea.y + scaledPivot.y - 1, 1, 3, 1.0f, 1.0f, 1.0f);\n                Draw2D::DrawRect(textArea.x + scaledPivot.x - 1, textArea.y + scaledPivot.y, 3, 1, 1.0f, 1.0f, 1.0f);\n            }\n        }\n    }\n    else {\n        Imgui::ImageBlock(textArea, \"Preview\", 0, sourceRect, selectedNode == 0);\n    }\n\n    textArea.w = trippleWidth;\n    textArea.h = s->txtAreaHeight;\n    textArea.x = karrat.x + IMAGE_PREVIEW_SIZE + 10;\n\n    char num_buffer[64] = { 0 };\n\n\n    ImguiAnimatedIntTextField(a, textArea, \"Source.x\", TrackType::SpriteSourceX, num_buffer, 64, false);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedIntTextField(a, textArea, \"Source.y\", TrackType::SpriteSourceY, num_buffer, 64, false);\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x + IMAGE_PREVIEW_SIZE + 10;\n\n    ImguiAnimatedIntTextField(a, textArea, \"Source.w\", TrackType::SpriteSourceW, num_buffer, 64, false);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedIntTextField(a, textArea, \"Source.h\", TrackType::SpriteSourceH, num_buffer, 64, false);\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x + IMAGE_PREVIEW_SIZE + 10;\n\n    vec2 pivot;\n    if (selectedNode != 0) {\n        pivot.x = selectedNode->sprite.pivotX;\n        pivot.y = selectedNode->sprite.pivotY;\n    }\n    bool updatePivot = false;\n    \n    stbsp_snprintf(num_buffer, 64, \"%.2f\", selectedNode == 0? 0.0 : selectedNode->sprite.pivotX);\n    const char* text = Imgui::TextArea(textArea, num_buffer, \"Pivot.X\", selectedNode == 0, true, false, false, false, false);\n    if (text != num_buffer) {\n        pivot.x = MathAToF(text);\n        updatePivot = true;\n    }\n\n    textArea.x += trippleWidth + 10;\n\n    stbsp_snprintf(num_buffer, 64, \"%.2f\", selectedNode == 0 ? 0.0 : selectedNode->sprite.pivotY);\n    text = Imgui::TextArea(textArea, num_buffer, \"Pivot.Y\", selectedNode == 0, true, false, false, false, false);\n    if (text != num_buffer) {\n        pivot.y = MathAToF(text);\n        updatePivot = true;\n    }\n\n    if (selectedNode != 0 && updatePivot) {\n        a->document->UpdateSprite(selectedNode, selectedNode->sprite.sourceX, selectedNode->sprite.sourceY,\n            selectedNode->sprite.sourceW, selectedNode->sprite.sourceH, pivot.x, pivot.y);\n    }\n\n    textArea.x += trippleWidth + 10;\n#endif\n}\n\nstatic void ImguiTransformEditor(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n    char num_buffer[64] = { 0 };\n    // Draw BG\n    Draw2D::DrawRect(area.x, area.y, area.w, area.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);\n\n    // Draw text boxes\n    Imgui::Rect karrat(area.x + 10, area.y + 13, area.w - 20, 0);\n    Imgui::Rect textArea = karrat;\n    textArea.h = s->txtAreaHeight;\n\n    const char* oldName = \"\";\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    if (selectedNode != 0) {\n        oldName = selectedNode->name;\n    }\n\n    Animation* timelineAnimation = a->document->GetTimelineAnimation();\n\n    float trippleWidth = (textArea.w - 20) / 3.0f;\n    //textArea.w -= trippleWidth;\n    //textArea.w -= 10.0f;\n\n    const char* newName = Imgui::TextArea(textArea, oldName, \"Name\", selectedNode == 0, false, false, false, false, false);\n    if (selectedNode != 0 && newName != oldName) {\n        a->document->RenameNode(selectedNode, newName);\n    }\n\n    textArea.w = trippleWidth;\n    textArea.x += (trippleWidth + 10.0f) * 2.0f;\n\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n    textArea.x = karrat.x;\n\n    ImguiAnimatedFloatTextField(a, textArea, \"Rotation\", TrackType::TransformRotation, num_buffer, 64);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedFloatTextField(a, textArea, \"Position.x\", TrackType::TransformPositionX, num_buffer, 64);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedFloatTextField(a, textArea, \"Position.y\", TrackType::TransformPositionY, num_buffer, 64);\n    textArea.x = karrat.x;\n    textArea.y += textArea.h + 5 + s->textAreaLabelSize;\n\n    ImguiAnimatedIntTextField(a, textArea, \"Sort Index\", TrackType::SortIndex, num_buffer, 64, true);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedFloatTextField(a, textArea, \"Scale.x\", TrackType::TransformScaleX, num_buffer, 64);\n    textArea.x += trippleWidth + 10;\n\n    ImguiAnimatedFloatTextField(a, textArea, \"Scale.y\", TrackType::TransformScaleY, num_buffer, 64);\n    textArea.x += trippleWidth + 10;\n}\n\nstatic void ImguiMemoryViewer(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n\n#define MEMORY_UI_HEADER_HEIGHT 55.0f\n#define MEM_BLOCK_W 4.0f\n#define MEM_BLOCK_H 7.0f\n\n    Imgui::Rect headerArea(area.x + 1, area.y + 1, area.w - 2, MEMORY_UI_HEADER_HEIGHT);\n    float chartAreaY = area.y + 1 + MEMORY_UI_HEADER_HEIGHT + 1;\n    Imgui::Rect chartArea(area.x + 1, chartAreaY, area.w - s->scrollBarSize, area.h - (chartAreaY - area.y));\n\n    char line[64] = { 0 };\n\n    i32 pageSize = MemGetPageSize();\n    i32 totalPageCount = MemGetHeapSize() / MemGetPageSize();\n    i32 overheadCount = MemGetNumOverheadPages();\n    i32 numPagesUsed = MemGetCurrentNumPages();\n    i32 mostMemPages = MemGetMostPagesUsedAtOne();\n    i32 freeCount = totalPageCount - overheadCount - numPagesUsed;\n    f32 halfW = chartArea.w / 2.0f;\n\n    StyleColor fontColor = s->textAreaFont_Normal;\n\n    { // Header\n        Imgui::Point karrat(headerArea.x + 5, headerArea.y + 5);\n\n        Draw2D::DrawRect(headerArea.x + 1, headerArea.y + 1, headerArea.w - 2, headerArea.h - 2,\n            s->textAreaBg_Normal.r, s->textAreaBg_Normal.g, s->textAreaBg_Normal.b);\n\n        stbsp_snprintf(line, 64, \"Page size: %d bytes\", pageSize);\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n        karrat.x += halfW;\n\n        stbsp_snprintf(line, 64, \"Total page count: %d\", totalPageCount);\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n        karrat.x -= halfW;\n        karrat.y += 16;\n\n        stbsp_snprintf(line, 64, \"Overhead page count: %d\", overheadCount);\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n        karrat.x += halfW;\n\n        stbsp_snprintf(line, 64, \"Used page count: %d\", numPagesUsed);\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n        karrat.x -= halfW;\n        karrat.y += 16;\n\n        float most_used_precent = (float)mostMemPages / (float)totalPageCount + 0.005;;\n        i32 most_used_int = Math01(most_used_precent) * 100.0f;\n        stbsp_snprintf(line, 64, \"Most pages used: %d (~%d%c)\", mostMemPages, most_used_int, '%');\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n        karrat.x += halfW;\n\n        float free_precent = (float)freeCount / (float)totalPageCount + 0.005;\n        i32 free_int = Math01(free_precent) * 100.0f;\n        stbsp_snprintf(line, 64, \"Free page count: %d (~%d%c)\", freeCount, free_int, '%');\n        Draw2D::DrawString(a->interfaceFont, 12, karrat.x, karrat.y + 12, line, fontColor.r, fontColor.g, fontColor.b);\n    }\n\n    { // Body\n        Imgui::Point karrat(chartArea.x + 2, chartArea.y + 2);\n\n        u32 numColumns = (chartArea.w - 2) / MEM_BLOCK_W;\n        u32 numRows = totalPageCount / numColumns + (totalPageCount % numColumns == 0 ? 0 : 1);\n\n\n        f32 contentHeight = (f32)numRows * MEM_BLOCK_H;\n        float scrollerHeight = FigureOutScrollBarHeight(contentHeight, chartArea.h - 4);\n\n        Imgui::Rect scrollableArea(chartArea.x + chartArea.w, chartArea.y, s->scrollBarSize, chartArea.h);\n        a->memoryScroll = Imgui::VScroll(scrollableArea, a->memoryScroll, scrollerHeight, Imgui::HandleScroll(chartArea));\n\n        f32 scroll_adj = (contentHeight - (chartArea.h - 4)) * a->memoryScroll;\n\n        Draw2D::PushClip(chartArea.x, chartArea.y, chartArea.w, chartArea.h);\n        for (i32 y = 0; y < numRows; ++y) {\n            for (i32 x = 0; x < numColumns; ++x) {\n                i32 index = y * numColumns + x;\n                if (index >= totalPageCount) {\n                    continue;\n                }\n                if (MemIsPageUsed(index)) {\n                    Draw2D::DrawRect(karrat.x + x * MEM_BLOCK_W, karrat.y + y * MEM_BLOCK_H - scroll_adj, MEM_BLOCK_W - 1, MEM_BLOCK_H - 1,\n                        s->memoryPageInUse.r, s->memoryPageInUse.g, s->memoryPageInUse.b);\n                }\n                else {\n                    Draw2D::DrawRect(karrat.x + x * MEM_BLOCK_W, karrat.y + y * MEM_BLOCK_H - scroll_adj, MEM_BLOCK_W - 1, MEM_BLOCK_H - 1,\n                        s->memoryFreePage.r, s->memoryFreePage.g, s->memoryFreePage.b);\n                }\n\n\n            }\n        }\n        Draw2D::PopClip();\n    }\n\n    //Draw2D::DrawRect(chartArea.x, chartArea.y, chartArea.w, chartArea.h);\n}\n\n\nbool KeyboardButton(u32 font, const Imgui::Rect& screenPos, const char* label, Application* a) {\n    u32 widgetId = ++a->kbdGen;\n\n    StyleSheet* s = &a->style;\n    Imgui::Point mouse = Imgui::GetPointer();\n    bool pressed = Imgui::PointerPressed();\n    bool released = Imgui::PointerReleased();\n\n    // Make hot\n    if (Imgui::Contains(screenPos, mouse)) {\n        if (a->kbdActive == widgetId || a->kbdActive == 0) {\n            a->kbdHot = widgetId;\n        }\n    }\n\n    // Make active\n    if (a->kbdHot == widgetId && a->kbdActive == 0) {\n        if (pressed) {\n            a->kbdActive = widgetId;\n        }\n    }\n\n    if (a->kbdActive == widgetId) {\n        Imgui::VirtualKeyWasPressed();\n    }\n\n    // Render\n    StyleColor outline = s->textAreaOutline_Normal;\n    StyleColor fill = s->textAreaBg_Normal;\n\n    if (a->kbdActive == widgetId) {\n        outline = s->textAreaOutline_Active;\n        fill = s->textAreaBg_Active;\n    }\n    else if (a->kbdHot == widgetId) {\n        outline = s->textAreaOutline_Hot;\n        fill = s->textAreaBg_Hot;\n    }\n\n    Draw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outline.r, outline.g, outline.b);\n    Draw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, fill.r, fill.g, fill.b);\n    if (label != 0) {\n        Draw2D::DrawString(font, 28,\n            screenPos.x + screenPos.w / 2 - Draw2D::MeasureString(a->interfaceFont, 28, label).w / 2,\n            //screenPos.x + 20,\n            screenPos.y + 33, label);\n    }\n\n    // Activate return\n    if (a->kbdActive == widgetId && a->kbdHot == widgetId) {\n        if (released) {\n            a->kbdHandled = true;\n            if (Imgui::GetFakeShiftToggle() && !(label[0] == 'S' && (label[1] == 'h' || label[1] == 'H'))) {\n                Imgui::SetFakeShiftToggle(false);\n            }\n            if (Imgui::GetFakeControlToggle() && !(label[0] == 'C' && (label[1] == 't' || label[1] == 'T'))) {\n                if (!(label[0] == 'c' || label[0] == 'C' || label[0] == 'v' || label[0] == 'V' || label[0] == 'x' || label[0] == 'X' || label[0] == 'a' || label[0] == 'A'))\n                Imgui::SetFakeControlToggle(false);\n                a->ctrlLock = false;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nbool KeyboardButton(const Imgui::Rect& screenPos, const char* label, Application* a) {\n    return KeyboardButton(a->interfaceFont, screenPos, label, a);\n}\n\nbool KeyboardButtonIcon(const Imgui::Rect& screenPos, const char* label, Application* a) {\n    return KeyboardButton(a->iconFont, screenPos, label, a);\n}\n\nstatic void ImguiKeyboard(const Imgui::Rect& area, Application* a) {\n    float buttonSize = 30.0f;\n    float sp = 5.0f;\n    bool shift = KeyboardDown(KeyboardCodeShift);\n    if (Imgui::GetFakeShiftToggle() || Imgui::GetFakeCapsToggle()) {\n        shift = true;\n    }\n\n    float keyboard_width = (buttonSize * 1.5f + sp) + (buttonSize * 2.0f + sp) + ((buttonSize + sp) * 12.0f) + 5.0f;\n    float keyboard_height = ((buttonSize + sp) * 5.0f) + 5.0f;\n\n    float w_ratio = area.w / keyboard_width;\n    buttonSize *= w_ratio;\n    sp *= w_ratio;\n    keyboard_height *= w_ratio;\n    keyboard_width *= w_ratio;\n\n    if (keyboard_height > area.h) {\n        float h_ratio = area.h / keyboard_height;\n        buttonSize *= h_ratio;\n        sp *= h_ratio;\n        keyboard_height *= h_ratio;\n        keyboard_width *= h_ratio;\n    }\n\n    float x_offset = MathAbsF(keyboard_width - area.w) * 0.5f;;\n    vec2 karrat(x_offset + area.x + 5, area.y + 5);\n\n#define VirtualButton(widthMul, lowerString, upperString, daKeyCode) \\\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (widthMul), buttonSize), shift ? (upperString) : (lowerString), a)) { \\\n            PushKey(daKeyCode); \\\n        } \\\n        karrat.x += buttonSize * (widthMul) + sp;\n\n#define VirtualButtonIcn(widthMul, lowerString, upperString, daKeyCode) \\\n        if (KeyboardButtonIcon(Imgui::Rect(karrat.x, karrat.y, buttonSize * (widthMul), buttonSize), shift ? (upperString) : (lowerString), a)) { \\\n            PushKey(daKeyCode); \\\n        } \\\n        karrat.x += buttonSize * (widthMul) + sp;\n\n\n    { // Num row\n        \n\n        VirtualButton(1.5f, \"`\", \"~\", KeyboardCodeTilde);\n        VirtualButton(1.0f, \"1\", \"!\", KeyboardCode1);\n        VirtualButton(1.0f, \"2\", \"@\", KeyboardCode2);\n        VirtualButton(1.0f, \"3\", \"#\", KeyboardCode3);\n        VirtualButton(1.0f, \"4\", \"$\", KeyboardCode4);\n        VirtualButton(1.0f, \"5\", \"%\", KeyboardCode5);\n        VirtualButton(1.0f, \"6\", \"^\", KeyboardCode6);\n        VirtualButton(1.0f, \"7\", \"&\", KeyboardCode7);\n        VirtualButton(1.0f, \"8\", \"*\", KeyboardCode8);\n        VirtualButton(1.0f, \"9\", \"(\", KeyboardCode9);\n        VirtualButton(1.0f, \"0\", \")\", KeyboardCode0);\n        VirtualButton(1.0f, \"-\", \"_\", KeyboardCodeMinus);\n        VirtualButton(1.0f, \"=\", \"+\", KeyboardCodeEquals);\n        VirtualButton(2.0f, \"Back\", \"Back\", KeyboardCodeBackspace);\n    }\n\n    karrat.y += buttonSize + sp;\n    karrat.x = x_offset + area.x + 5;\n\n    { // qwerty\n        VirtualButton(2.0f, \"Tab\", \"Tab\", KeyboardCodeTab);\n        VirtualButton(1.0f, \"q\", \"Q\", KeyboardCodeQ);\n        VirtualButton(1.0f, \"w\", \"W\", KeyboardCodeW);\n        VirtualButton(1.0f, \"e\", \"E\", KeyboardCodeE);\n        VirtualButton(1.0f, \"r\", \"R\", KeyboardCodeR);\n        VirtualButton(1.0f, \"t\", \"T\", KeyboardCodeT);\n        VirtualButton(1.0f, \"y\", \"Y\", KeyboardCodeY);\n        VirtualButton(1.0f, \"u\", \"U\", KeyboardCodeU);\n        VirtualButton(1.0f, \"i\", \"I\", KeyboardCodeI);\n        VirtualButton(1.0f, \"o\", \"O\", KeyboardCodeO);\n        VirtualButton(1.0f, \"p\", \"P\", KeyboardCodeP);\n        VirtualButton(1.0f, \"[\", \"{\", KeyboardCodeLBracket);\n        VirtualButton(1.0f, \"]\", \"}\", KeyboardCodeRbracket);\n        VirtualButton(1.5f, \"\\\\\", \"|\", KeyboardCodeBackslash);\n    }\n\n    karrat.y += buttonSize + sp;\n    karrat.x = x_offset + area.x + 5;\n\n    { // asdf\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (2.5f), buttonSize), Imgui::GetFakeCapsToggle()? \"CAP\" : \"Cap\", a)) {\n            Imgui::SetFakeCapsToggle(!Imgui::GetFakeCapsToggle());\n        }\n        karrat.x += buttonSize * (2.5) + sp;\n\n        VirtualButton(1.0f, \"a\", \"A\", KeyboardCodeA);\n        VirtualButton(1.0f, \"s\", \"S\", KeyboardCodeS);\n        VirtualButton(1.0f, \"d\", \"D\", KeyboardCodeD);\n        VirtualButton(1.0f, \"f\", \"F\", KeyboardCodeF);\n        VirtualButton(1.0f, \"g\", \"G\", KeyboardCodeG);\n        VirtualButton(1.0f, \"h\", \"H\", KeyboardCodeH);\n        VirtualButton(1.0f, \"j\", \"J\", KeyboardCodeJ);\n        VirtualButton(1.0f, \"k\", \"K\", KeyboardCodeK);\n        VirtualButton(1.0f, \"l\", \"L\", KeyboardCodeL);\n        VirtualButton(1.0f, \";\", \":\", KeyboardCodeColon);\n        VirtualButton(1.0f, \"'\", \"\\\"\", KeyboardCodeQoute);\n        VirtualButton(2.2f, \"Enter\", \"Enter\", KeyboardCodeReturn);\n    }\n\n    karrat.y += buttonSize + sp;\n    karrat.x = x_offset + area.x + 5;\n\n    { // zxcv\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (3.0f), buttonSize), Imgui::GetFakeShiftToggle() ? (\"SHIFT\") : (\"Shift\"), a)) {\n            Imgui::SetFakeShiftToggle(!Imgui::GetFakeShiftToggle());\n        }\n        karrat.x += buttonSize * (3.0f)+sp;\n\n        VirtualButton(1.0f, \"z\", \"Z\", KeyboardCodeZ);\n        VirtualButton(1.0f, \"x\", \"X\", KeyboardCodeX);\n        VirtualButton(1.0f, \"c\", \"C\", KeyboardCodeC);\n        VirtualButton(1.0f, \"v\", \"V\", KeyboardCodeV);\n        VirtualButton(1.0f, \"b\", \"B\", KeyboardCodeB);\n        VirtualButton(1.0f, \"n\", \"N\", KeyboardCodeN);\n        VirtualButton(1.0f, \"m\", \"M\", KeyboardCodeM);\n        VirtualButton(1.0f, \",\", \"<\", KeyboardCodeComma);\n        VirtualButton(1.0f, \".\", \">\", KeyboardCodePeriod);\n        VirtualButton(1.0f, \"/\", \"?\", KeyboardCodeSlash);\n        VirtualButtonIcn(1.0f, \"#\", \"#\", KeyboardCodeSlash);\n        \n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.7f), buttonSize), Imgui::GetFakeShiftToggle() ? (\"SHIFT\") : (\"Shift\"), a)) {\n            Imgui::SetFakeShiftToggle(!Imgui::GetFakeShiftToggle());\n        }\n        karrat.x += buttonSize * (1.7f) + sp;\n    }\n\n    karrat.y += buttonSize + sp;\n    karrat.x = x_offset + area.x + 5;\n\n    { // Spacebar\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.5f), buttonSize), a->ctrlLock ? \"CTRL\" : \"Ctrl\", a)) {\n            a->ctrlLock = !a->ctrlLock;\n            Imgui::SetFakeControlToggle(a->ctrlLock);\n        }\n        karrat.x += buttonSize * (1.5f) + sp;\n\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.5f), buttonSize), a->altLock ? \"ALT\" : \"Alt\", a)) {\n            a->altLock = !a->altLock;\n        }\n        karrat.x += buttonSize * (1.5f) + sp;\n\n        VirtualButtonIcn(6.5, (const char*)0, (const char*)0, KeyboardCodeSpace);\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.5f), buttonSize), a->ctrlLock ? \"CTRL\" : \"Ctrl\", a)) {\n            a->ctrlLock = !a->ctrlLock;\n            Imgui::SetFakeControlToggle(a->ctrlLock);\n        }\n        karrat.x += buttonSize * (1.5f) + sp;\n        if (KeyboardButton(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.5f), buttonSize), a->altLock ? \"ALT\" : \"Alt\", a)) {\n            a->altLock = !a->altLock;\n        }\n        karrat.x += buttonSize * (1.5f) + sp;\n        //VirtualButtonIcn(1.35f, \"!\", \"!\", KeyboardCodeLeft);\n        if (KeyboardButtonIcon(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.35f), buttonSize), \"!\", a)) {\n            Imgui::SetFakeLeftPressed(true);\n        }\n        karrat.x += buttonSize * (1.35f) + sp;\n\n        VirtualButtonIcn(1.0f, \"$\", \"$\", KeyboardCodeDown);\n        //VirtualButtonIcn(1.7f, \"\\\"\", \"\\\"\", KeyboardCodeRight);\n        if (KeyboardButtonIcon(Imgui::Rect(karrat.x, karrat.y, buttonSize * (1.7f), buttonSize), \"\\\"\", a)) {\n            Imgui::SetFakeRightPressed(true);\n        }\n        karrat.x += buttonSize * (1.7f) + sp;\n    }\n}\n\nstatic void ImguiAnimationInspector(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n\n    Animation* timelineAnimation = a->document->GetTimelineAnimation();\n\n    Imgui::Rect header = area;\n    Imgui::Rect body = area;\n    Imgui::Rect footer = area;\n\n    header.h = s->headerHeight;\n    footer.h = s->scrollBarSize;\n\n    body.h -= header.h;\n    body.h -= footer.h;\n    body.y += s->headerHeight;\n\n    footer.y = body.y + body.h;\n\n    // Draw header bg\n    Draw2D::DrawRect(header.x, header.y, header.w, header.h,\n        s->toolBarBg.r, s->toolBarBg.g, s->toolBarBg.b);\n\n    Draw2D::DrawRect(header.x, header.y + header.h - 2, header.w, 1,\n        s->headerBgColor.r, s->headerBgColor.g, s->headerBgColor.b);\n\n    // Draw splitter\n    a->timelineSplit = Imgui::VSplit(area, s->timelineMinWidth, a->timelineSplit);\n    Imgui::Rect timelineLeft = Imgui::VSplitFirstArea(area, a->timelineSplit);\n    Imgui::Rect timelineRight = Imgui::VSplitSecondArea(area, a->timelineSplit);\n\n    float scrollableHeight = 0.0f;\n    u32 numTracks = 0;\n    if (timelineAnimation != 0) {\n        numTracks = timelineAnimation->numTracks;\n        Track* tmp = timelineAnimation->tracks;\n        for (u32 i = 0; i < timelineAnimation->numTracks; ++i) {\n            if (!tmp->avtive) {\n                numTracks -= 1;\n            }\n            tmp = tmp->next;\n        }\n        scrollableHeight = numTracks * s->listBoxItemHeight;\n    }\n\n    Imgui::Rect nodesScrollARea;\n    float tracksScrollOffset = 0.0f;\n    if (timelineAnimation != 0) { // Draw the list of tracks\n        nodesScrollARea.x = timelineLeft.x;\n        nodesScrollARea.w = timelineLeft.w - s->scrollBarSize;\n        nodesScrollARea.y = timelineLeft.y + header.h;\n        nodesScrollARea.h = timelineLeft.h - header.h - footer.h;\n\n        Imgui::Rect listItemKarrat = nodesScrollARea;\n        listItemKarrat.h = s->listBoxItemHeight;\n\n        {\n            tracksScrollOffset = (scrollableHeight - nodesScrollARea.h) * a->frameUpScroll;\n            listItemKarrat.y -= tracksScrollOffset;\n\n            char uiName[128] = { 0 };\n            int i = 0;\n            Track* activeTrack = a->document->GetSelectedTrack();\n            for (Track* iter = timelineAnimation->tracks; iter != 0; iter = iter->next) {\n                if (!iter->avtive) {\n                    if (iter == activeTrack) {\n                        a->document->SelectTrack(0);\n                    }\n                    continue;\n                }\n\n#if _DEBUG\n                u32 numKeys = 0;\n                for (int i = 0; i < iter->frameCount; ++i) {\n                    if (iter->frames[i].key) {\n                        numKeys += 1;\n                    }\n                }\n                PlatformAssert(numKeys == iter->numKeyFrames, __LOCATION__);\n#endif\n\n                Node2D* targetNode = a->document->FindNodeById(iter->targetNode);\n                if (targetNode == 0) {\n                    iter->avtive = false;\n                    continue;\n                }\n                PlatformAssert(targetNode != 0, __LOCATION__);\n\n                stbsp_snprintf(uiName, 128, \"%s%s\", targetNode->name, TrackTypeToString(iter->targetProp));\n                Imgui::DeletableListItemResult actionResult = Imgui::DeletableListItem(listItemKarrat, nodesScrollARea, uiName, (i++) % 2, false, activeTrack == iter);\n                //if (Imgui::UndoListItem(listItemKarrat, nodesScrollARea, uiName, (i++) % 2, false, activeTrack == iter)) {\n\n                if (actionResult.activated) {\n                    a->document->SelectTrack(iter);\n                }\n                else if (actionResult.deleted) {\n                    a->document->RemoveTrack(iter);\n                }\n\n                listItemKarrat.y += s->listBoxItemHeight;\n            }\n        }\n\n        // Fill any missing space\n        float bottom = nodesScrollARea.y + nodesScrollARea.h;\n        float delta = bottom - (listItemKarrat.y);\n        if (delta > 0.0f) {\n            Imgui::Rect fillMissing = listItemKarrat;\n            fillMissing.h = delta;\n\n            Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n            if (Imgui::ClickArea(fillMissing)) {\n                a->document->SelectTrack(0);\n            }\n        }\n    }\n\n    {\n        Imgui::Rect leftHeader = timelineLeft;\n        leftHeader.h = header.h;\n\n        Imgui::Rect control = leftHeader;\n        control.h = s->hierarchyFooterButtonSize + 1;// s->scrollBarSize;\n        control.w = s->hierarchyFooterButtonSize + 1;// s->scrollBarSize;\n        control.y += 2;\n        control.w -= 2;\n        control.x += 2;\n        StyleColor tint = { 0 };\n        bool now_playing = Imgui::ToggleButton(control, IMGUI_ICON_STOP, IMGUI_ICON_PLAY,\n            a->playSelectedAnimation, timelineAnimation == 0, a->playSelectedAnimation ? \"Stop\" : \"Play\", tint);\n\n        if (now_playing != a->playSelectedAnimation) {\n            a->playSelectedAnimation = now_playing;\n            a->playingAnimationFrame = 0;\n            a->playingAnimationTimer = 0;\n\n            if (now_playing) {\n                a->document->SelectTrack(0);\n            }\n        }\n\n        control.x += control.w;\n        control.x += 2;\n        StyleColor tint2 = { 0 };\n\n        if (a->autoKey) {\n            tint.r = 0.07f;\n            tint2.r = 0.5f;\n        }\n        bool new_autokey = Imgui::ToggleButton(control, IMGUI_ICON_PAUSE, IMGUI_ICON_RECORD, a->autoKey, timelineAnimation == 0, \"Autokey\", tint, &tint2);\n        tint.r = 0.0f;\n\n        if (new_autokey != a->autoKey) {\n            a->autoKey = new_autokey;\n        }\n\n        float x_pos_for_dropdown = control.x + control.w + 2;\n\n        control = leftHeader;\n        control.h = s->hierarchyFooterButtonSize + 1;\n        control.w = s->hierarchyFooterButtonSize + 1;\n        control.y += 2;\n        control.x = leftHeader.x + leftHeader.w - control.w;\n        control.w -= 2;\n        control.x += 1;\n        // Imgui::IconToggle(control, IMGUI_ICON_RECORD, IMGUI_ICON_RECORD, true, timelineAnimation == 0, \"Autokey\");\n\n        if (timelineAnimation == 0) {\n            Imgui::Rect iconRect = control;\n            iconRect.x += 2; // Footer specific\n            iconRect.y += 3;\n            Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CODEPOINT_DESELECT, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n        }\n        else {\n            if (Imgui::FooterButton(control, IMGUI_ICON_CODEPOINT_DESELECT, \"Deselect track\", s->hierarchyFooterButtonIcon)) {\n                a->document->SelectTrack(0);\n                a->document->SetSelectedFrame(-1);\n                a->playSelectedAnimation = false;\n            }\n        }\n\n        control.x -= control.w;\n        control.x -= 2;\n\n        { // tmp scope for selectedTrak and selectedFrame\n            Track* selectedTrack = a->document->GetSelectedTrack();\n            i32 selectedFrame = a->document->GetSelectedFrame();\n            bool disable_delete = timelineAnimation == 0 || selectedTrack == 0 || selectedFrame < 0;\n            if (!disable_delete) {\n                PlatformAssert(selectedFrame < selectedTrack->frameCount, __LOCATION__);\n                disable_delete = !selectedTrack->frames[selectedFrame].key;\n            }\n\n            if (timelineAnimation != 0 && selectedTrack == 0 && selectedFrame >= 0) {\n                for (Track* t = a->document->TrackIterator(timelineAnimation); t != 0; t = a->document->TrackIterator(t)) {\n                    if (t->frames[selectedFrame].key) {\n                        disable_delete = false;\n                        break;\n                    }\n                }\n            }\n\n            if (disable_delete) {\n                Imgui::Rect iconRect = control;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_CLEARKEY, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n            else {\n                if (timelineAnimation != 0 && selectedTrack == 0 && selectedFrame >= 0) {\n                    if (Imgui::FooterButton(control, IMGUI_ICON_CLEARKEY, \"Remove all keys for frame\", s->hierarchyFooterButtonIcon)) {\n                        for (Track* t = a->document->TrackIterator(timelineAnimation); t != 0; t = a->document->TrackIterator(t)) {\n                            if (t->avtive && t->frames[selectedFrame].key) {\n                                a->document->ClearFrame(t, selectedFrame);\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (Imgui::FooterButton(control, IMGUI_ICON_CLEARKEY, \"Remove keyframe\", s->hierarchyFooterButtonIcon)) {\n                        a->document->ClearFrame(selectedTrack, selectedFrame);\n                    }\n                }\n            }\n\n            control.x -= control.w;\n            control.x -= 2;\n            //ImguiKeyButton(control, a, s);\n\n            if (timelineAnimation != 0 && selectedTrack != 0 && selectedFrame >= 0) {\n                const char* label = \"Update keyframe\";\n                if (!selectedTrack->frames[selectedFrame].key) {\n                    label = \"Insert keyframe\";\n                }\n                if (Imgui::FooterButton(control, IMGUI_ICON_TIMELINEKEY, label, s->hierarchyFooterButtonIcon)) {\n                    a->document->SetFrame(selectedTrack, selectedFrame, a->document->GetSelectedInterpolationType());\n                }\n            }\n            else if (timelineAnimation != 0 && selectedFrame >= 0 && selectedTrack == 0) {\n                if (Imgui::FooterButton(control, IMGUI_ICON_TIMELINEKEY, \"Keyframe all tracks\", s->hierarchyFooterButtonIcon)) {\n                    for (Track* t = a->document->TrackIterator(timelineAnimation); t != 0; t = a->document->TrackIterator(t)) {\n                        if (t->avtive) {\n                            a->document->SetFrame(t, selectedFrame, a->document->GetSelectedInterpolationType());\n                        }\n                    }\n                }\n            }\n            else {\n                Imgui::Rect iconRect = control;\n                iconRect.x += 2; // Footer specific\n                iconRect.y += 3;\n                Imgui::Icon(iconRect, s->hierarchyFooterButtonSize - 4, IMGUI_ICON_TIMELINEKEY, s->hierarchyFooterDisabledIconColor.r, s->hierarchyFooterDisabledIconColor.g, s->hierarchyFooterDisabledIconColor.b);\n            }\n\n            control.x -= control.w * 4.5;\n            control.w *= 4.5;\n            control.x -= 2;\n\n            const char* labels[5] = {\n                \"Linear\", \"Step\", \"Ease In\", \"Ease Out\", \"Ease In Out\"\n            };\n\n            float right_side_of_dropdown = control.x + control.w;\n            float control_width = right_side_of_dropdown - x_pos_for_dropdown;\n            if (control_width >= control.w) {\n                control.w = control_width;\n                control.x = x_pos_for_dropdown;\n            }\n\n            i32 interpolationSelectionIndex = a->document->GetInterpolationIndex();\n            i32 newINdex = Imgui::BeginComboBox(control, labels[interpolationSelectionIndex], 5, interpolationSelectionIndex, 0, false, timelineAnimation == 0);\n            if (timelineAnimation != 0) {\n                for (int xxy = 0; xxy < 5; ++xxy) {\n                    Imgui::PushComboBoxItem(labels[xxy]);\n                }\n            }\n            if (newINdex != interpolationSelectionIndex) {\n                a->document->SetInterpolationIndex(newINdex);\n            }\n            Imgui::EndComboBox();\n        }\n\n        // Scroll bar\n        Imgui::Rect sideScrollBar = timelineLeft;\n        sideScrollBar.x = timelineLeft.x + timelineLeft.w - s->scrollBarSize;\n        sideScrollBar.y = body.y;\n        sideScrollBar.h = body.h;\n        sideScrollBar.w = s->scrollBarSize;\n\n        float sideScrollContentHeight = 0.0f;\n        if (timelineAnimation != 0) {\n            sideScrollContentHeight = numTracks * s->listBoxItemHeight;\n        }\n        a->frameUpScroll = Imgui::VScroll(sideScrollBar, a->frameUpScroll, FigureOutScrollBarHeight(sideScrollContentHeight, sideScrollBar.h), Imgui::HandleScroll(nodesScrollARea));\n\n        // Footer\n        {\n            Imgui::Rect selectedTimelineArea = footer;\n            selectedTimelineArea.x = timelineLeft.x;\n            selectedTimelineArea.w = timelineLeft.w;\n\n            selectedTimelineArea.w -= s->scrollBarSize;\n            selectedTimelineArea.w -= 2;\n            //Imgui::HScroll(bottomScrollBar, 0.0f, 15.0f, false);\n\n            Imgui::Rect synchButton = selectedTimelineArea;\n            synchButton.x = selectedTimelineArea.x + selectedTimelineArea.w + 2;\n            synchButton.y += 1;\n            synchButton.h -= 2;\n            synchButton.w = s->scrollBarSize;\n            synchButton.w -= 1;\n\n            // Draw synch button\n            ImguiSynchAnimViewIcon(synchButton, a, s, false);\n\n            // Draw dropdown box\n            u32 numAnims = a->document->GetNumAnimations() + 1;\n            i32 animIndex = -1;\n            const char* displayString = \"None\";\n            if (timelineAnimation != 0) {\n                int counter = 1;\n                for (Animation* iter = a->document->AnimationIterator(0); iter != 0; iter = a->document->AnimationIterator(iter), ++counter) {\n                    if (iter == timelineAnimation) {\n                        animIndex = counter;\n                        displayString = iter->name;\n                        break;\n                    }\n                }\n            }\n\n            bool disabled = numAnims == 1;\n            if (a->synchAnimView) {\n                disabled = true;\n            }\n\n            i32 selection = Imgui::BeginComboBox(selectedTimelineArea, displayString, disabled ? 0 : numAnims, animIndex, 0, true, disabled);\n            if (a->synchAnimView) {\n                selection = animIndex;\n            }\n\n            Animation* selectionPtr = 0;\n            if (numAnims > 1) {\n                Imgui::PushComboBoxItem(\"None\");\n                if (selection == 0) {\n                    selectionPtr = 0;\n                }\n                i32 counter = 1;\n                for (Animation* iter = a->document->AnimationIterator(0); iter != 0; iter = a->document->AnimationIterator(iter), ++counter) {\n                    if (counter == selection) {\n                        selectionPtr = iter;\n                    }\n                    Imgui::PushComboBoxItem(iter->name);\n                }\n            }\n            Imgui::EndComboBox();\n\n            if (selection != animIndex) {\n                a->document->SelectTimeline(selectionPtr);\n                a->playSelectedAnimation = false;\n                a->autoKey = false;\n            }\n        }\n    }\n\n    u32 numFrames = 0;\n    if (timelineAnimation != 0) {\n        numFrames = timelineAnimation->frameCount;\n    }\n\n    float scrollableWidth = numFrames * s->animationFrameWidth;\n\n    { // Frame area\n        Imgui::Rect control = timelineRight;\n        control.h = header.h;\n\n        Imgui::Rect bottomScrollBar = footer;\n        bottomScrollBar.x = timelineRight.x;\n        bottomScrollBar.w = timelineRight.w;\n\n        u32 timelineSelectedFrame = a->document->GetSelectedFrame();\n\n        a->frameSideScroll = Imgui::HScroll(bottomScrollBar, a->frameSideScroll, FigureOutScrollBarHeight(scrollableWidth, bottomScrollBar.w), false);\n        u32 timelineFrame = timelineSelectedFrame;\n\n        Imgui::Rect timelineRect(control.x, control.y, bottomScrollBar.w, control.h - 2);\n        Imgui::Rect clipRect(timelineRect.x, timelineRect.y, timelineRect.w, timelineRight.h - timelineRect.h);\n        if (timelineAnimation != 0) {\n            Draw2D::PushClip(clipRect.x, clipRect.y, clipRect.w, clipRect.h);\n\n            Imgui::Rect row = clipRect;\n            row.y += timelineRect.h;\n            row.h = s->listBoxItemHeight;\n\n            float highlight_w = row.w;\n            if (scrollableWidth < highlight_w) {\n                highlight_w = scrollableWidth;\n            }\n\n            float x_offset = 0.0f;\n            if (timelineRect.w < scrollableWidth) {\n                float delta = scrollableWidth - timelineRect.w;\n                x_offset = Math01(a->frameSideScroll) * delta;\n            }\n\n            // Draw BG pattern\n            int i = 0;\n            int k = 0;\n            Track* selectedTrack = a->document->GetSelectedTrack();\n            for (Track* t = a->document->TrackIterator(timelineAnimation); t != 0; t = a->document->TrackIterator(t), ++i) {\n                if (!t->avtive) {\n                    continue;\n                }\n\n                StyleColor bg = a->style.hierarchyItemBG_A;\n                if ((k++) % 2 != 0) {\n                    bg = a->style.hierarchyItemBG_B;\n                }\n\n\n                Draw2D::DrawRect(row.x, row.y - tracksScrollOffset, row.w, row.h, bg.r, bg.g, bg.b);\n                if (t == selectedTrack) {\n                    bg.r *= 1.2f;//a->style.hierarchyItemBG_Selected.r;\n                    bg.g *= 1.2f;//a->style.hierarchyItemBG_Selected.g;\n                    bg.b *= 1.5f;// a->style.hierarchyItemBG_Selected.b;\n                    Draw2D::DrawRect(row.x, row.y - tracksScrollOffset, highlight_w, row.h, bg.r, bg.g, bg.b);\n                }\n\n\n                for (int f = 0; f < t->frameCount; ++f) {\n                    Imgui::Rect frame = row;\n\n                    frame.x = row.x + (float)f * s->animationFrameWidth;\n                    frame.w = s->animationFrameWidth;\n                    frame.y -= tracksScrollOffset;\n                    frame.x -= x_offset;\n\n                    if (f == timelineFrame) {\n                        if (t != selectedTrack) {\n                            bg.r *= 1.2f;//a->style.hierarchyItemBG_Selected.r;\n                            bg.g *= 1.2f;//a->style.hierarchyItemBG_Selected.g;\n                            bg.b *= 1.5f;// a->style.hierarchyItemBG_Selected.b;\n                        }\n                        else {\n                            bg = s->hierarchyItemBG_Selected;\n                            bg.r *= 0.8f;//a->style.hierarchyItemBG_Selected.r;\n                            bg.g *= 0.8f;//a->style.hierarchyItemBG_Selected.g;\n                            bg.b *= 0.9f;// a->style.hierarchyItemBG_Selected.b;\n                        }\n                        Draw2D::DrawRect(frame.x, frame.y, frame.w, frame.h, bg.r, bg.g, bg.b);\n                    }\n\n                    if (t->frames[f].key) {\n                        frame.y += 11;\n                        frame.x += 1;\n                        Imgui::Icon(frame, 8, IMGUI_ICON_DIAMOND,\n                            s->keyframeDiamond.r, s->keyframeDiamond.g, s->keyframeDiamond.b);\n                        frame.y -= 11;\n\n                        Imgui::Rect label_rect = frame;\n                        label_rect.h = 8;\n                        label_rect.y += 1;\n                        label_rect.x += 2;\n                        if (t->frames[f].interp == InterpolationType::Linear) {\n                            Imgui::Label(label_rect, \"L\", false, false, true, &s->keyframeDiamond);\n                        }\n                        else if (t->frames[f].interp == InterpolationType::Step) {\n                            Imgui::Label(label_rect, \"S\", false, false, true, &s->keyframeDiamond);\n                        }\n                        else if (t->frames[f].interp == InterpolationType::EaseIn) {\n                            Imgui::Label(label_rect, \"I\", false, false, true, &s->keyframeDiamond);\n                        }\n                        else if (t->frames[f].interp == InterpolationType::EaseOut) {\n                            Imgui::Label(label_rect, \"O\", false, false, true, &s->keyframeDiamond);\n                        }\n                        else if (t->frames[f].interp == InterpolationType::EaseInOut) {\n                            Imgui::Label(label_rect, \"E\", false, false, true, &s->keyframeDiamond);\n                        }\n                    }\n                }\n\n                row.y += row.h;\n            }\n\n            // Draw timeline\n            i32 selectedFrame = Imgui::Timeline(timelineRect, timelineAnimation->frameCount, timelineSelectedFrame, Math01(a->frameSideScroll));\n            if (selectedFrame != timelineSelectedFrame) {\n                a->document->SetSelectedFrame(selectedFrame);\n                a->playSelectedAnimation = false;\n            }\n\n            Draw2D::PopClip();\n\n            Imgui::Rect clickArea = clipRect;\n            clickArea.y += timelineRect.h;\n\n            float areaHeight = clickArea.h - timelineRect.h;\n            float rowsHeight = s->listBoxItemHeight * (float)(numTracks);\n\n            if (areaHeight < rowsHeight) {\n                clickArea.h = areaHeight;\n            }\n            else {\n                clickArea.h = rowsHeight;\n            }\n\n\n\n            //Draw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h);\n            if (Imgui::HoldArea(clickArea) && timelineAnimation != 0) {\n                Imgui::Point mousePos = Imgui::GetPointer();\n                if (mousePos.x >= clickArea.x && mousePos.x <= clickArea.x + clickArea.w) {\n                    if (mousePos.y >= clickArea.y && mousePos.y <= clickArea.y + clickArea.h) {\n                        Imgui::Point adjustedMouse(\n                            mousePos.x - clickArea.x + x_offset,\n                            mousePos.y - clickArea.y + tracksScrollOffset\n                        );\n\n                        float t_x = adjustedMouse.x / scrollableWidth;\n                        float t_y = adjustedMouse.y / scrollableHeight;\n                        if (t_x >= 0.0f && t_x < 1.0f) {\n                            if (t_y >= 0.0f && t_y < 1.0f) {\n                                i32 x_index = t_x * (float)(numFrames);\n                                i32 y_index = t_y * (float)(numTracks);\n                                PlatformAssert(x_index >= 0, __LOCATION__);\n                                PlatformAssert(y_index >= 0, __LOCATION__);\n                                PlatformAssert(x_index < numFrames, __LOCATION__);\n                                PlatformAssert(y_index < numTracks, __LOCATION__);\n\n                                int xxx = 0;\n                                Track* iter = timelineAnimation->tracks;\n                                for (int y = 0; y < timelineAnimation->numTracks; ++y) {\n                                    if (!iter->avtive) {\n                                        iter = iter->next;\n                                        continue;\n                                    }\n                                    \n                                    PlatformAssert(iter != 0, __LOCATION__);\n                                    \n                                    \n                                    if (xxx == y_index) {\n                                        break;\n                                    }\n                                    iter = iter->next;\n\n                                    xxx += 1;\n\n                                    if (iter == 0) {\n                                        break;\n                                    }\n                                }\n                                if (iter != 0) {\n                                    a->document->SelectTrack(iter);\n                                }\n\n                                a->document->SetSelectedFrame(x_index);\n                                a->playSelectedAnimation = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (rowsHeight < areaHeight) {\n                float delta = areaHeight - rowsHeight;\n                if (delta > 0.0f) {\n                    Imgui::Rect fillMissing = clickArea;\n                    fillMissing.y += clickArea.h;\n                    fillMissing.h = delta;\n\n                    //Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                    //Draw2D::DrawRect(fillMissing.x, fillMissing.y, fillMissing.w, fillMissing.h);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                    if (Imgui::ClickArea(fillMissing)) {\n                        a->document->SetSelectedFrame(-1);\n                        a->playSelectedAnimation = false;\n                    }\n                }\n            }\n\n        }\n    }\n}\n\n// Used as a helper for AdjustNodeTransformForGizmoPerTrack\nstatic void UpdateSingleValueByTrackType(Application* a, float* target, TrackType trackType) {\n    Animation* timelineAnim = a->document->GetTimelineAnimation();\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    i32 selectedFrame = a->document->GetSelectedFrame();\n\n    Track* track = 0;\n    if (timelineAnim != 0) {\n        track = ContainsTrack(timelineAnim, selectedNode, trackType);\n    }\n    if (track != 0) {\n        if (selectedNode->IsPropertyDirty(trackType)) {\n            *target = selectedNode->GetPropertyBuffer<f32>(trackType);\n        }\n        else {\n            if (selectedFrame == -1) { // No frame selected, show frame 0\n                if (track != 0 && track->frames[0].key) { // Frame 0 was a key, show it's value\n                    *target = track->frames[0].fValue;\n                } // else use default\n            }\n            else {\n                if (track != 0 && track->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                    *target = track->frames[selectedFrame].fValue;\n                }\n                else {\n                    f32 interpolated_value = track->InterpolateF(selectedFrame, selectedNode->GetProperty<f32>(trackType), timelineAnim->loop);\n                    *target = interpolated_value;\n                }\n            }\n        }\n    } // Else use default\n}\n\n// Used to get the actual node transform (since it can be effected by application state) for ImguiSceneView\nstatic Transform AdjustNodeTransformForGizmoPerTrack(Application* a, Transform result) {\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    i32 selectedFrame = a->document->GetSelectedFrame();\n    Animation* timelineAnim = a->document->GetTimelineAnimation();\n\n    UpdateSingleValueByTrackType(a, &result.position.x, TrackType::TransformPositionX);\n    UpdateSingleValueByTrackType(a, &result.position.y, TrackType::TransformPositionY);\n    UpdateSingleValueByTrackType(a, &result.scale.x, TrackType::TransformScaleX);\n    UpdateSingleValueByTrackType(a, &result.scale.y, TrackType::TransformScaleY);\n\n    f32 rotationInDegrees = getAngle(result.rotation) * MATH_RAD2DEG;\n    if (result.rotation.z < 0.0f) {\n        rotationInDegrees *= -1.0f;\n    }\n    UpdateSingleValueByTrackType(a, &rotationInDegrees, TrackType::TransformRotation);\n    result.rotation = angleAxis(rotationInDegrees * MATH_DEG2RAD, vec3(0, 0, 1));\n\n    return result;\n}\n\nvoid SetGizmoPropInNode(Application* a, Node2D* targetNode, TrackType trackType, float new_val) {\n    Animation* timelineAnim = a->document->GetTimelineAnimation();\n    i32 selectedFrame = a->document->GetSelectedFrame();\n\n    if (targetNode != 0) {\n        Track* track = 0;\n        if (timelineAnim != 0) {\n            track = ContainsTrack(timelineAnim, targetNode, trackType);\n        }\n\n        if (track != 0) {\n            if (selectedFrame == a->document->GetLastSelectedFrame() && a->autoKey && track != 0 && selectedFrame >= 0) {\n                Frame dummy = { 0 };\n                dummy.fValue = new_val;\n                targetNode->SetBuffered<f32>(trackType, new_val);\n                a->document->AutoKeyFrameValue(track, selectedFrame, a->document->GetSelectedInterpolationType(), dummy.uValue);\n            }\n            else if (track != 0 && track->numKeyFrames > 0) {\n                targetNode->SetBuffered<f32>(trackType, new_val);\n            }\n            else {\n                if (a->document->UpdateNodeTransformSingleF(targetNode, new_val, trackType)) {\n                    if (a->autoKey && track != 0 && selectedFrame >= 0) {\n                        Frame dummy = { 0 };\n                        dummy.fValue = new_val;\n                        a->document->AutoKeyFrameValue(track, selectedFrame, a->document->GetSelectedInterpolationType(), dummy.uValue);\n                    }\n                }\n            }\n        }\n        else {\n            if (a->document->UpdateNodeTransformSingleF(targetNode, new_val, trackType)) {\n                if (a->autoKey && track != 0 && selectedFrame >= 0) {\n                    Frame dummy = { 0 };\n                    dummy.fValue = new_val;\n                    a->document->AutoKeyFrameValue(track, selectedFrame, a->document->GetSelectedInterpolationType(), dummy.uValue);\n                }\n            }\n        }\n    }\n}\n\nstatic void ImguiSceneView(const Imgui::Rect& area, Application* a) {\n    StyleSheet* s = &a->style;\n\n    Imgui::Rect toolBar = area;\n    toolBar.w = s->toolbarWidth;\n\n    Imgui::Rect header = area;\n    header.h = s->headerHeight;\n    //header.w -= toolBar.w;\n    //header.x += toolBar.w;\n\n    Imgui::Rect content = area;\n    content.w -= toolBar.w;\n    content.x += toolBar.w;\n    content.h -= header.h;\n    content.y += header.h;\n\n    Imgui::Point _mouse = Imgui::GetPointer();\n    Imgui::Point _prevMouse = Imgui::GetPrevPointer();\n    Imgui::Point _mouseDelta = Imgui::GetPointerDelta();\n    vec2 mouse(_mouse.x, _mouse.y);\n    vec2 prevMouse(_prevMouse.x, _prevMouse.y);\n    vec2 mouseDelta(_mouseDelta.x, _mouseDelta.y);\n    vec2 offset(content.x, content.y);\n\n    Document* d = a->document;\n\n    bool zoom_to_point = false;\n    bool pan_delta_mouse = false;\n\n    float ZOOM_TOOL_STEP = 15.0f;\n    bool zoomIn = a->zoomIn;\n\n    if (a->activeTool == ActiveTool::Pan && content.Contains(_mouse)) {\n        Imgui::SetTooltipIcon(IMGUI_ICON_MOVETOOL);\n        if (Imgui::HoldArea(content)) {\n            pan_delta_mouse = true;\n        }\n    }\n    else if (a->activeTool == ActiveTool::Zoom && content.Contains(_mouse)) {\n        Imgui::SetTooltipIcon(a->zoomIn ? IMGUI_ICON_ZOOM_IN : IMGUI_ICON_ZOOM_OUT);\n\n        vec2 viewPos(a->view.x, a->view.y);\n        Imgui::HoldArea(content, &a->zoomDetails, &a->view.z, &viewPos);\n\n        if (a->zoomDetails.activated) {\n            vec2 delta = mouse - a->zoomDetails.mouseDown;\n            if (lenSq(delta) <= 3.0f * 3.0f) {\n                zoom_to_point = true;\n            }\n        }\n        else if (a->zoomDetails.active) {\n            vec2 delta = mouse - a->zoomDetails.mouseDown;\n            float sqLen = lenSq(delta);\n\n            if (sqLen >= 3.0f * 3.0f) {\n                float old_t = (a->zoomDetails.rememberF32OnClick + 500.0f) / 1000.0f;\n\n                float tt = sqLen / (400.0f * 400.0f);\n                float inv_t = 1.0f - old_t;\n                float step_t = inv_t * tt;\n                if (!a->zoomIn) {\n                    step_t *= -1.0f;\n                }\n                float new_t = old_t + step_t;\n                float new_tt = old_t + step_t;\n\n                old_t *= 2.0f;\n                old_t += 0.1f;\n                new_t *= 2.0f;\n                new_t += 0.1f;\n\n                float oldMouseX = old_t * (mouse.x);\n                float newMouseX = new_t * (mouse.x);\n                float oldMouseY = old_t * (mouse.y);\n                float newMouseY = new_t * (mouse.y);\n\n                a->view.z = (new_tt * 1000.0f) - 500.0f;\n\n\n                if (a->view.z < -500.0f) {\n                    a->view.z = -500.0f;\n                }\n                else if (a->view.z > 500.0f) {\n                    a->view.z = 500.0f;\n                }\n                else {\n                    if (!a->zoomIn) {\n                        a->view.x = a->zoomDetails.rememberVec2OnClick.x + (newMouseX - oldMouseX);\n                        a->view.y = a->zoomDetails.rememberVec2OnClick.y + (newMouseY - oldMouseY);\n                    }\n                    else {\n                        a->view.x = a->zoomDetails.rememberVec2OnClick.x + (newMouseX - oldMouseX);\n                        a->view.y = a->zoomDetails.rememberVec2OnClick.y + (newMouseY - oldMouseY);\n                    }\n                }\n            }\n            else {\n                a->view.z = a->zoomDetails.rememberF32OnClick;\n                a->view.x = a->zoomDetails.rememberVec2OnClick.x;\n                a->view.y = a->zoomDetails.rememberVec2OnClick.y;\n            }\n\n            if (a->view.z < -500.0f) {\n                a->view.z = -500.0f;\n            }\n            if (a->view.z > 500.0f) {\n                a->view.z = 500.0f;\n            }\n        }\n    }\n    else {\n        Imgui::Dummy();\n    }\n\n    // No matter the tool, zoom on mouse wheel\n    if (content.Contains(_mouse)) {\n        i32 scroll = MouseGetScroll();\n        if (scroll < 0.0f) {\n            zoom_to_point = true;\n            zoomIn = false;\n        }\n        else if (scroll > 0.0f) {\n            zoom_to_point = true;\n        }\n\n        if (MouseDown(MouseButtonMiddle) ||\n            MouseDown(MouseButtonRight)) {\n            pan_delta_mouse = true;\n        }\n    }\n\n    if (pan_delta_mouse) {\n        a->view.x -= _mouseDelta.x;\n        a->view.y -= _mouseDelta.y;\n    }\n\n    if (zoom_to_point) {\n        float old_t = (a->view.z + 500.0f) / 1000.0f;\n        old_t *= 2.0f;\n        old_t += 0.1f;\n\n        a->view.z += ZOOM_TOOL_STEP * (zoomIn ? 1.0f : -1.0f);\n        if (a->view.z > 500.0f) {\n            a->view.z = 500.0f;\n        }\n        if (a->view.z < -500.0f) {\n            a->view.z = -500.0f;\n        }\n\n        float new_t = (a->view.z + 500.0f) / 1000.0f;\n        new_t *= 2.0f;\n        new_t += 0.1f;\n\n        float oldMouseX = old_t * (mouse.x);\n        float newMouseX = new_t * (mouse.x);\n        float oldMouseY = old_t * (mouse.y);\n        float newMouseY = new_t * (mouse.y);\n\n        a->view.x += (newMouseX - oldMouseX);\n        a->view.y += (newMouseY - oldMouseY);\n    }\n\n    bool autoSelect = false;\n    bool autoSelectFound = false;\n    Draw2D::OBB autoSelectOBB = { 0 };\n    Transform autoSelectTransform;\n    Node2D* autoHighlightedNode = 0;\n\n    Node2D* selectedNode = a->document->GetSelectedNode();\n    Draw2D::OBB selectedNodeObb = { 0 };\n    Transform selectedNodeTransform;\n\n    if (a->activeTool == ActiveTool::Move && a->moveSelect) {\n        autoSelect = true;\n    }\n    else if (a->activeTool == ActiveTool::Rotate && a->rotateSelect) {\n        autoSelect = true;\n    }\n    else if (a->activeTool == ActiveTool::Scale && a->scaleSelect) {\n        autoSelect = true;\n    }\n    else if (a->activeTool == ActiveTool::Pivot && a->pivotSelect) {\n        autoSelect = true;\n    }\n\n    Draw2D::PushClip(content.x, content.y, content.w, content.h);\n\n    float val = (a->view.z + 500.0f) / 1000.0f;\n    val *= 2.0f;\n    val += 0.1f;\n    Transform view(vec3(-a->view.x, -a->view.y, 0), quat(), vec3(val, val, 1));\n    vec2 motion = (mouse - a->effectorMousePos) * vec2(1.0f / view.scale.x, 1.0f / view.scale.y);\n    f32 invScaleUnitSize = 1.0f / 60.0f;\n\n    vec2 backup_position(0, 0);\n    float backup_rotation = 0.0f;\n    vec2 backup_scale(1, 1);\n    // If there is an effecting tool active, temp replace the nodes local transform.\n    if (a->effectorNode != 0) {\n        backup_position = a->effectorNode->position;\n        backup_rotation = a->effectorNode->rotationAngles;\n        backup_scale = a->effectorNode->scale;\n\n        a->effectorNode->position = a->effectorTransform.position.asVec2;\n        a->effectorNode->rotationAngles = getAngle(a->effectorTransform.rotation) * MATH_RAD2DEG;\n        if (a->effectorTransform.rotation.z < 0.0f) {\n            a->effectorNode->rotationAngles *= -1.0f;\n        }\n        a->effectorNode->scale = a->effectorTransform.scale.asVec2;\n\n        \n\n        if (a->effector == ActiveTool::Move) {\n            if (a->moveSnap) {\n                motion.x = motion.x - MathFmod(motion.x, a->moveSnapVal);\n                motion.y = motion.y - MathFmod(motion.y, a->moveSnapVal);\n            }\n\n            vec2 axis = a->effectorAxis;\n\n            if (a->moveWorld) {\n                quat rot = quat();\n                if (a->effectorNode->parent != 0) {\n                    rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                }\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n                if (lenSq(axis) > 0.0f) {\n                    axis = rotate(axis, -rotationAngles);\n                }\n            }\n            vec2 new_pos = a->effectorNode->position + motion;\n\n            if (lenSq(axis) > 0) {\n                if (lenSq(motion) > 0) {\n                    new_pos = a->effectorNode->position + (axis * dot(motion, axis));\n                }\n            }\n            else if (lenSq(motion) > 0) {\n                quat rot = quat();\n                    rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n                \n                new_pos = a->effectorNode->position + rotate(motion, -rotationAngles);\n            }\n\n            a->effectorNode->position = new_pos;\n            a->effectorNode->transformToolActive = true;\n        }\n        else if (a->effector == ActiveTool::Scale) {\n            if (a->scaleSnap) {\n                motion.x = motion.x - MathFmod(motion.x, a->scaleSnapVal);\n                motion.y = motion.y - MathFmod(motion.y, a->scaleSnapVal);\n            }\n\n            vec2 axis = normalized(a->effectorAxis);\n\n            vec2 new_scale = (a->effectorTransform.scale.asVec2) + rotate(motion * invScaleUnitSize * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation));\n            \n            if (lenSq(axis) > 0) {\n                if (lenSq(motion) > 0) {\n                    new_scale = a->effectorTransform.scale.asVec2 + (axis * dot(rotate(motion * invScaleUnitSize * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation)), axis));\n                }\n            }\n            else if (lenSq(motion) > 0) {\n                quat rot = quat();\n                rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n\n                new_scale = (a->effectorTransform.scale.asVec2) + rotate((motion * invScaleUnitSize) * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation));\n            }\n\n            a->effectorNode->scale = new_scale;\n            a->effectorNode->transformToolActive = true;\n        }\n        else if (a->effector == ActiveTool::Rotate) {\n            float angle = getAngle(a->effectorTransform.rotation); \n            if (a->effectorTransform.rotation.z < 0.0f) {\n                angle *= -1.0f;\n            }\n            angle = angle + a->effectorAxis.y;\n\n            a->effectorNode->rotationAngles = angle * MATH_RAD2DEG;;\n            a->effectorNode->transformToolActive = true;\n        }\n    }\n\n    for (Node2D* iter = d->Sorted(0); iter != 0; iter = d->Sorted(iter)) {\n        Transform worldTransform = d->GetWorldTransform(iter);\n        Transform nodeXForm = combine(view, worldTransform);\n\n        vec3 origin(0, 0, 0);\n        origin = transformPoint(nodeXForm, origin);\n        float rotAngle = getAngle(nodeXForm.rotation);\n\n        if (nodeXForm.rotation.z < 0.0f) {\n            rotAngle *= -1.0f;\n        }\n        Draw2D::OBB boundingBox = { 0 };\n        if (iter->sprite.visible && iter->sprite.resourceUID != 0) {\n            boundingBox = Draw2D::DrawImage(iter->sprite.resourceUID,\n                offset.x + origin.x, offset.y + origin.y,\n                iter->sprite.sourceW, iter->sprite.sourceH,\n                iter->sprite.sourceX, iter->sprite.sourceY,\n                iter->sprite.sourceW, iter->sprite.sourceH,\n                nodeXForm.scale.x, nodeXForm.scale.y,\n                iter->sprite.pivotX, iter->sprite.pivotY,\n                rotAngle,\n                iter->sprite.tintR, iter->sprite.tintG, iter->sprite.tintB);\n        }\n        else {\n            boundingBox = Draw2D::ImageTransform(\n                offset.x + origin.x, offset.y + origin.y,\n                0, 0,\n                nodeXForm.scale.x, nodeXForm.scale.y,\n                iter->sprite.pivotX, iter->sprite.pivotY,\n                rotAngle);\n        }\n\n        if (selectedNode == iter) {\n            selectedNodeObb = boundingBox;\n            selectedNodeTransform = nodeXForm;\n        }\n\n        if (autoSelect) {\n            if (boundingBox.Contains(mouse)) {\n                autoSelectFound = true;\n                autoSelectOBB = boundingBox;\n                autoSelectTransform = nodeXForm;\n                if (Imgui::PointerPressed()) {\n                    a->document->SelectNode(iter);\n                }\n            }\n        }\n    }\n\n    if ((a->effector == ActiveTool::Move && a->effectorNode != 0) ||\n        (a->effector == ActiveTool::Scale && a->effectorNode != 0) ||\n        (a->effector == ActiveTool::Rotate && a->effectorNode != 0)) {\n        a->effectorNode->transformToolActive = false;\n        a->effectorNode->position = backup_position;\n        a->effectorNode->rotationAngles = backup_rotation;\n        a->effectorNode->scale = backup_scale;\n    }\n\n    if (selectedNode != 0 && selectedNode->sprite.visible && selectedNode->sprite.resourceUID != 0 && a->gridHighlight) {\n        float rotAngleRadians = getAngle(selectedNodeTransform.rotation);\n        if (selectedNodeTransform.rotation.z < 0.0f) {\n            rotAngleRadians *= -1.0f;\n        }\n\n        StyleColor highlight = s->hierarchyItemBG_Selected;\n\n        vec2 rotated = rotate(selectedNodeObb.extents, rotAngleRadians);\n        vec2 topLeft = selectedNodeObb.center - rotated;\n        Draw2D::DrawRect(topLeft.x, topLeft.y, selectedNodeObb.extents.x * 2.0f, 2,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngleRadians);\n\n        Draw2D::DrawRect(topLeft.x, topLeft.y, 2, selectedNodeObb.extents.y * 2.0f,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngleRadians);\n\n        rotated = rotate(vec2(selectedNodeObb.extents.x, selectedNodeObb.extents.y * -1.0f), rotAngleRadians);\n        vec2 topRight = selectedNodeObb.center + rotated;\n        Draw2D::DrawRect(topRight.x, topRight.y, 2, selectedNodeObb.extents.y * 2.0f,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngleRadians);\n\n        rotated = rotate(vec2(selectedNodeObb.extents.x, selectedNodeObb.extents.y * -1.0f), rotAngleRadians);\n        vec2 bottomLeft = selectedNodeObb.center - rotated;\n        Draw2D::DrawRect(bottomLeft.x, bottomLeft.y, selectedNodeObb.extents.x * 2.0f + 2, 2,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngleRadians);\n\n        float min_size = 2.0f;\n        float max_size = 25.0f;\n        float tsize = (a->view.z + 500.0f) / 1000.0f;\n        float quarter = min_size + (max_size - min_size) * tsize;\n\n        vec3 origin(0, -quarter / selectedNodeTransform.scale.y, 0);\n        origin = transformPoint(selectedNodeTransform, origin);\n\n        Draw2D::DrawRect(origin.x + offset.x,\n            origin.y + offset.y,\n            2, quarter * 2.0f,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1.0f,\n            0, 0.0f,\n            rotAngleRadians);\n\n        origin = vec3(-quarter / selectedNodeTransform.scale.x, 0, 0);\n        origin = transformPoint(selectedNodeTransform, origin);\n\n        Draw2D::DrawRect(origin.x + offset.x,\n            origin.y + offset.y,\n            quarter * 2.0f, 2,\n            highlight.r, highlight.g, highlight.b, 1,\n            1.0f, 1,\n            0.0f, 0,\n            rotAngleRadians);\n    }\n\n    if (autoSelectFound) {\n        StyleColor highlight = s->hierarchyItemBG_Movable;\n\n        float rotAngle = getAngle(autoSelectTransform.rotation);\n        if (selectedNodeTransform.rotation.z < 0.0f) {\n            rotAngle *= -1.0f;\n        }\n\n        vec2 rotated = rotate(autoSelectOBB.extents, rotAngle);\n        vec2 topLeft = autoSelectOBB.center - rotated;\n        Draw2D::DrawRect(topLeft.x, topLeft.y, autoSelectOBB.extents.x * 2.0f, 4,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngle);\n\n        Draw2D::DrawRect(topLeft.x, topLeft.y, 4, autoSelectOBB.extents.y * 2.0f,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngle);\n\n        rotated = rotate(vec2(autoSelectOBB.extents.x, autoSelectOBB.extents.y * -1.0f), rotAngle);\n        vec2 topRight = autoSelectOBB.center + rotated;\n        Draw2D::DrawRect(topRight.x, topRight.y, 4, autoSelectOBB.extents.y * 2.0f,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngle);\n\n        rotated = rotate(vec2(autoSelectOBB.extents.x, autoSelectOBB.extents.y * -1.0f), rotAngle);\n        vec2 bottomLeft = autoSelectOBB.center - rotated;\n        Draw2D::DrawRect(bottomLeft.x, bottomLeft.y, autoSelectOBB.extents.x * 2.0f + 4, 4,\n            highlight.r, highlight.g, highlight.b, 1,\n            1, 1, 0, 0, rotAngle);\n    }\n\n    Animation* timelineAnim = a->document->GetTimelineAnimation();\n    i32 selectedFrame = a->document->GetSelectedFrame();\n    // Draw active Gizmo\n    {\n        float gizmoSize = 60.0f;\n        float qSize = gizmoSize / 3.0f;\n        vec3 gizmoOrigin = transformPoint(selectedNodeTransform, vec3(0.0f, 0.0f, 0.0f));\n\n        float rotAngle = getAngle(selectedNodeTransform.rotation);\n        if (selectedNodeTransform.rotation.z < 0.0f) {\n            rotAngle *= -1.0f;\n        }\n        if (a->activeTool == ActiveTool::Move && a->moveWorld) {\n            rotAngle = 0.0f;\n        }\n\n        if ((a->activeTool == ActiveTool::Move || a->activeTool == ActiveTool::Scale || a->activeTool == ActiveTool::Pivot) && selectedNode != 0) {\n            bool multi_active = false;\n            bool y_active = false;\n            bool x_active = false;\n            StyleColor handleColor = a->style.gizmoY;\n\n            // X Y Handle\n            {\n                Draw2D::OBB gizmoObb = { 0 };\n                gizmoObb.rotation = rotAngle;\n                gizmoObb.extents = vec2(qSize * 0.5f, qSize * 0.5f);\n                gizmoObb.center = vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y) + rotate(vec2(qSize * 0.5f + 6, qSize * -0.5f - 6), rotAngle);\n\n                bool handleActive = false;\n                if (gizmoObb.Contains(mouse)) {\n                    handleActive = true;\n                    handleColor = a->style.gizmoY_Hover;\n                    multi_active = true;\n\n                    if (Imgui::PointerPressed()) {\n                        a->effector = a->activeTool;\n                        a->effectorAxis = vec2(0, 0); // Unlocked\n                        a->effectorMousePos = mouse;\n                        a->effectorNode = selectedNode;\n\n                        a->effectorTransform = a->document->GetLocalTransform(selectedNode);\n                        a->effectorTransform = AdjustNodeTransformForGizmoPerTrack(a, a->effectorTransform);\n                    }\n                }\n\n                vec2 rotationRectTopLeft = vec2(gizmoOrigin.x, gizmoOrigin.y) + rotate(vec2(qSize * 0.5f, qSize * -0.5f), rotAngle);\n                Draw2D::DrawRect(\n                    rotationRectTopLeft.x + offset.x, rotationRectTopLeft.y + offset.y,\n                    qSize, qSize,\n                    handleColor.r, handleColor.g, handleColor.b, 1,\n                    1, 1,\n                    qSize * 0.5f - 6, qSize * 0.5f + 6,\n                    rotAngle);\n            }\n\n            // Y handle\n            {\n                Draw2D::OBB gizmoObb = { 0 };\n                gizmoObb.rotation = rotAngle;\n                gizmoObb.extents = vec2(4, gizmoSize / 2.0f);\n\n                vec2 gizmoAxis(0, -1);\n                vec2 gizmoPerp(1, 0);\n\n                gizmoObb.center = vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y) + (gizmoAxis * gizmoSize * 0.5f);\n                vec2 p0 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) - (gizmoPerp * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                vec2 p1 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (gizmoPerp * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                vec2 p2 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (gizmoAxis * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                vec2 _o = vec2(gizmoOrigin.x, gizmoOrigin.y) + offset + (normalized(gizmoAxis) * gizmoSize);\n\n                if ((a->activeTool == ActiveTool::Move && !a->moveWorld) ||\n                    (a->activeTool == ActiveTool::Scale)) {\n                   \n                    float rotAngle = getAngle(selectedNodeTransform.rotation);\n                    if (selectedNodeTransform.rotation.z < 0.0f) {\n                        rotAngle *= -1.0f;\n                    }\n                    if (a->activeTool == ActiveTool::Move && a->moveWorld) {\n                        rotAngle = 0.0f;\n                    }\n                    vec2 _gizmoAxis = rotate(gizmoAxis, rotAngle);\n                    vec2 _gizmoPerp = rotate(gizmoPerp, rotAngle);\n\n                    p0 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) - (_gizmoPerp * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    p1 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (_gizmoPerp * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    p2 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (_gizmoAxis * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    gizmoObb.center = vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y) + (_gizmoAxis * gizmoSize * 0.5f);\n                    _o = vec2(gizmoOrigin.x, gizmoOrigin.y) + offset + (_gizmoAxis * gizmoSize);\n\n                    rotAngle = selectedNode->rotationAngles * MATH_DEG2RAD;\n                    gizmoAxis = rotate(gizmoAxis, rotAngle);\n                    gizmoPerp = rotate(gizmoPerp, rotAngle);\n                }\n\n\n                handleColor = a->style.gizmoG;\n\n                bool handleActive = false;\n                if (gizmoObb.Contains(mouse)) {\n                    if (!multi_active) {\n                        handleActive = true;\n                        handleColor = a->style.gizmoG_Hover;\n                        y_active = true;\n                    }\n                }\n                else {\n                    gizmoObb.center = gizmoObb.center + gizmoAxis * gizmoSize * 0.5f;\n                    gizmoObb.extents = vec2(qSize * 0.5f, qSize * 0.5f);\n                    if (gizmoObb.Contains(mouse)) {\n                        if (!multi_active) {\n                            handleActive = true;\n                            handleColor = a->style.gizmoG_Hover;\n                            y_active = true;\n                        }\n                    }\n                }\n\n                if (handleActive) {\n                    if (Imgui::PointerPressed()) {\n                        a->effector = a->activeTool;\n                        a->effectorMousePos = mouse;\n                        a->effectorAxis = normalized(gizmoAxis);\n                        a->effectorNode = selectedNode;\n\n                        a->effectorTransform = a->document->GetLocalTransform(selectedNode);\n                        a->effectorTransform = AdjustNodeTransformForGizmoPerTrack(a, a->effectorTransform);\n                    }\n                }\n\n                if (a->activeTool == ActiveTool::Move) {\n                    Draw2D::DrawTriangle(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, handleColor.r, handleColor.g, handleColor.b);\n                }\n                else {\n\n                    Draw2D::DrawRect(_o.x, _o.y,\n                        qSize, qSize, handleColor.r, handleColor.g, handleColor.b, 1,\n                        1, 1, qSize * 0.5f, qSize * 0.5f, rotAngle);\n                }\n\n\n                Draw2D::DrawRect(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y,\n                    4, gizmoSize,\n                    handleColor.r, handleColor.g, handleColor.b, 1,\n                    1, 1,\n                    2, gizmoSize,\n                    rotAngle);\n            }\n\n            // X handle\n            {\n                handleColor = a->style.gizmoR;\n\n                Draw2D::OBB gizmoObb = { 0 };\n                gizmoObb.rotation = rotAngle;\n                gizmoObb.extents = vec2(gizmoSize / 2.0f, 4);\n\n                vec2 gizmoAxis = vec2(1, 0);\n                vec2 gizmoPerp = vec2(0, -1);\n\n                vec2 p0 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) - (gizmoPerp * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                vec2 p1 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (gizmoPerp * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                vec2 p2 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (gizmoAxis * qSize * 0.5f) + (gizmoAxis * gizmoSize);\n                gizmoObb.center = vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y) + (gizmoAxis * gizmoSize * 0.5f);\n                vec2 _o = vec2(gizmoOrigin.x, gizmoOrigin.y) + offset + (gizmoAxis * gizmoSize);\n\n                if ((a->activeTool == ActiveTool::Move && !a->moveWorld) ||\n                    (a->activeTool == ActiveTool::Scale)) {\n\n                    float rotAngle = getAngle(selectedNodeTransform.rotation);\n                    if (selectedNodeTransform.rotation.z < 0.0f) {\n                        rotAngle *= -1.0f;\n                    }\n                    if (a->activeTool == ActiveTool::Move && a->moveWorld) {\n                        rotAngle = 0.0f;\n                    }\n                    vec2 _gizmoAxis = rotate(gizmoAxis, rotAngle);\n                    vec2 _gizmoPerp = rotate(gizmoPerp, rotAngle);\n\n                    p0 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) - (_gizmoPerp * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    p1 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (_gizmoPerp * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    p2 = (vec2(gizmoOrigin.x, gizmoOrigin.y) + offset) + (_gizmoAxis * qSize * 0.5f) + (_gizmoAxis * gizmoSize);\n                    gizmoObb.center = vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y) + (_gizmoAxis * gizmoSize * 0.5f);\n                    _o = vec2(gizmoOrigin.x, gizmoOrigin.y) + offset + (_gizmoAxis * gizmoSize);\n\n                    rotAngle = selectedNode->rotationAngles * MATH_DEG2RAD;\n                    gizmoAxis = rotate(gizmoAxis, rotAngle);\n                    gizmoPerp = rotate(gizmoPerp, rotAngle);\n                }\n\n                bool handleActive = false;\n                if (gizmoObb.Contains(mouse)) {\n                    if (!(y_active || multi_active)) {\n                        handleActive = true;\n                        handleColor = a->style.gizmoR_Hover;\n                        x_active = true;\n                    }\n                }\n                else {\n                    gizmoObb.center = gizmoObb.center + gizmoAxis * gizmoSize * 0.5f;\n                    gizmoObb.extents = vec2(qSize * 0.5f, qSize * 0.5f);\n                    if (gizmoObb.Contains(mouse)) {\n                        if (!(y_active || multi_active)) {\n                            handleActive = true;\n                            handleColor = a->style.gizmoR_Hover;\n                            x_active = true;\n                        }\n                    }\n                }\n\n                if (handleActive) {\n                    if (Imgui::PointerPressed()) {\n                        a->effector = a->activeTool;\n                        a->effectorMousePos = mouse;\n                        a->effectorAxis = normalized(gizmoAxis);\n                        a->effectorNode = selectedNode;\n\n                        a->effectorTransform = a->document->GetLocalTransform(selectedNode);\n                        a->effectorTransform = AdjustNodeTransformForGizmoPerTrack(a, a->effectorTransform);\n                    }\n                }\n\n                if (a->activeTool == ActiveTool::Move || a->activeTool == ActiveTool::Pivot) {\n                    Draw2D::DrawTriangle(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, handleColor.r, handleColor.g, handleColor.b);\n                }\n                else {\n                    Draw2D::DrawRect(_o.x, _o.y,\n                        qSize, qSize, handleColor.r, handleColor.g, handleColor.b, 1,\n                        1, 1, qSize * 0.5f, qSize * 0.5f, rotAngle);\n                }\n\n                Draw2D::DrawRect(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y, gizmoSize, 4, handleColor.r, handleColor.g, handleColor.b, 1, 1, 1, 0, 2, rotAngle);\n            }\n        }\n        else if (a->activeTool == ActiveTool::Rotate && selectedNode != 0) {\n            float innerR = gizmoSize;\n            float outerR = gizmoSize + gizmoSize * 0.1f;\n\n            StyleColor handleColor = a->style.gizmoB;\n            vec2 delta = mouse - vec2(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y);\n            float lSq = lenSq(delta);\n\n            innerR -= 1.0f;\n            outerR += 1.0f;\n            if (lSq >= innerR * innerR && lSq <= outerR * outerR) {\n                handleColor = a->style.gizmoB_Hover;\n                if (Imgui::PointerPressed()) {\n                    a->effector = a->activeTool;\n                    a->effectorMousePos = mouse;\n                    a->effectorAxis = vec2(0,0); // effectorAxis.x will be the angle accumulator\n                    a->effectorNode = selectedNode;\n\n                    a->effectorTransform = a->document->GetLocalTransform(selectedNode);\n                    a->effectorTransform = AdjustNodeTransformForGizmoPerTrack(a, a->effectorTransform);\n                }\n            }\n            innerR += 1.0f;\n            outerR -= 1.0f;\n\n            if (a->effector == a->activeTool) {\n                vec2 center(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y);\n\n                vec2 prevMouseOnCircle = normalized(prevMouse - center);// *(outerR - 1.0f);\n                vec2 thisMouseOnCircle = normalized(mouse - center);// *(outerR - 1.0f);\n                vec2 clickedOnCircle = normalized(a->effectorMousePos - center);// *(outerR - 1.0f);\n\n                float angl = angle(prevMouseOnCircle, thisMouseOnCircle);\n                if (angl > 0.00001f) {\n                    if (dot(thisMouseOnCircle, perp(prevMouseOnCircle)) >= 0.0f) {\n                        angl *= -1.0f;\n                    }\n                    a->effectorAxis.x += angl;\n                    a->effectorAxis.y = a->effectorAxis.x;\n                    if (a->rotateSnap) {\n                        float snapInRadians = a->rotateSnapVal * MATH_DEG2RAD;\n                        a->effectorAxis.y = a->effectorAxis.x - MathFmod(a->effectorAxis.x, snapInRadians);\n                    }\n                }\n               \n                float startAngle = MathAtan2(clickedOnCircle.y, clickedOnCircle.x);\n                float endAngle = startAngle + a->effectorAxis.y;\n\n                if (MathAbsF(startAngle - endAngle) > 2.0f * MATH_PI) {\n                    endAngle = startAngle + 2.0f * MATH_PI - 0.001f;\n                }\n                else if (endAngle < startAngle) {\n                    startAngle = MathFmod(startAngle, 2.0f * MATH_PI);\n                    endAngle = MathFmod(endAngle, 2.0f * MATH_PI);\n                    if (endAngle < startAngle) {\n                        endAngle += 2.0f * MATH_PI;\n                    }\n\n                    float tmp = endAngle;\n                    endAngle = startAngle;\n                    startAngle = tmp;\n                }\n\n                Draw2D::DrawCircleSlice(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y,\n                    innerR * 0.3f, startAngle, endAngle,\n                    s->gizmoY_Hover.r, s->gizmoY_Hover.g, s->gizmoY_Hover.b\n                );\n\n                if (a->rotateSnap) {\n                    thisMouseOnCircle = rotate(clickedOnCircle, a->effectorAxis.y);\n                }\n\n                clickedOnCircle = clickedOnCircle * (outerR - 1.0f);\n                thisMouseOnCircle = thisMouseOnCircle * (outerR - 1.0f);\n                float points[4] = { center.x, center.y,\n                    center.x + clickedOnCircle.x, center.y + clickedOnCircle.y\n                };\n                Draw2D::DrawLine(points, 2, 2.0f, s->gizmoY_Hover.r, s->gizmoY_Hover.g, s->gizmoY_Hover.b);\n                points[2] = center.x + thisMouseOnCircle.x;\n                points[3] = center.y + thisMouseOnCircle.y;\n                Draw2D::DrawLine(points, 2, 2.0f, s->gizmoY_Hover.r, s->gizmoY_Hover.g, s->gizmoY_Hover.b);\n            }\n\n            Draw2D::DrawHollowCircle(gizmoOrigin.x + offset.x, gizmoOrigin.y + offset.y,\n                innerR, outerR,\n                handleColor.r, handleColor.g, handleColor.b);\n        }\n    }\n\n    // Apply actual move logic\n    if (a->effector == ActiveTool::Move) {\n        if (a->effectorNode != 0 && Imgui::PointerReleased()) {\n            Node2D* effector = a->effectorNode;\n            \n            // Copy\n            if (a->moveSnap) {\n                motion.x = motion.x - MathFmod(motion.x, a->moveSnapVal);\n                motion.y = motion.y - MathFmod(motion.y, a->moveSnapVal);\n            }\n\n            vec2 axis = a->effectorAxis;\n\n            if (a->moveWorld) {\n                quat rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n                if (lenSq(axis) > 0.0f) {\n                    axis = rotate(axis, -rotationAngles);\n                }\n            }\n            vec2 new_pos = a->effectorNode->position + motion;\n\n            if (lenSq(axis) > 0) {\n                if (lenSq(motion) > 0) {\n                    new_pos = a->effectorNode->position + (axis * dot(motion, axis));\n                }\n            }\n            else if (lenSq(motion) > 0) {\n                quat rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n\n                new_pos = a->effectorNode->position + rotate(motion, -rotationAngles);\n            }\n            // End copy\n\n            SetGizmoPropInNode(a, effector, TrackType::TransformPositionX, new_pos.x);\n            SetGizmoPropInNode(a, effector, TrackType::TransformPositionY, new_pos.y);\n        }\n    }\n    else if (a->effector == ActiveTool::Scale) {\n        if (a->effectorNode != 0 && Imgui::PointerReleased()) {\n            Node2D* effector = a->effectorNode;\n            vec2 scale = a->effectorTransform.scale.asVec2;\n\n            /*vec2 new_motion = motion;\n            if (lenSq(a->effectorAxis) > 0.0f) {\n                new_motion = (a->effectorAxis * dot(new_motion, a->effectorAxis));\n            }\n            vec2 new_scale = (a->effectorTransform.scale.asVec2) + rotate((new_motion * invScaleUnitSize) * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation));\n            */\n\n            vec2 axis = normalized(a->effectorAxis);\n\n            vec2 new_scale = (a->effectorTransform.scale.asVec2) + rotate(motion * invScaleUnitSize * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation));\n\n            if (lenSq(axis) > 0) {\n                if (lenSq(motion) > 0) {\n                    new_scale = a->effectorTransform.scale.asVec2 + (axis * dot(rotate(motion * invScaleUnitSize * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation)), axis));\n                }\n            }\n            else if (lenSq(motion) > 0) {\n                quat rot = quat();\n                rot = a->document->GetWorldTransform(a->effectorNode->parent).rotation;\n                f32 rotationAngles = getAngle(rot);\n                if (rot.z < 0.0f) {\n                    rotationAngles *= -1.0f;\n                }\n\n                new_scale = (a->effectorTransform.scale.asVec2) + rotate((motion * invScaleUnitSize) * vec2(1.0f, -1.0f), getAngle(a->effectorTransform.rotation));\n            }\n\n            SetGizmoPropInNode(a, effector, TrackType::TransformScaleX, new_scale.x);\n            SetGizmoPropInNode(a, effector, TrackType::TransformScaleY, new_scale.y);\n        }\n    }\n    else if (a->effector == ActiveTool::Rotate) {\n        if (a->effectorNode != 0 && Imgui::PointerReleased()) {\n            Node2D* effector = a->effectorNode;\n\n            float angle = getAngle(a->effectorTransform.rotation);\n            if (a->effectorTransform.rotation.z < 0.0f) {\n                angle *= -1.0f;\n            }\n            angle = angle + a->effectorAxis.y;\n\n            SetGizmoPropInNode(a, effector, TrackType::TransformRotation, angle* MATH_RAD2DEG);\n        }\n    }\n\n    // Release pos & rot & scl\n    if (Imgui::PointerReleased()) {\n        a->effector = ActiveTool::None;\n        a->effectorNode = 0;\n    }\n\n    Draw2D::PopClip();\n\n    // Draw side toolbar\n    Draw2D::DrawRect(toolBar.x, toolBar.y, toolBar.w, toolBar.h, s->toolBarBg.r, s->toolBarBg.g, s->toolBarBg.b, 1.0f);\n    Draw2D::DrawRect(toolBar.x + toolBar.w - 1, toolBar.y, 1, toolBar.h, s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b, 1.0f);\n\n    {\n        Imgui::Rect toolbarButton = toolBar;\n#define TOOLBAR_BTN_PADDING 12.0f\n        toolbarButton.w = toolBar.w - TOOLBAR_BTN_PADDING;\n        toolbarButton.x += TOOLBAR_BTN_PADDING / 2.0f;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n        toolbarButton.h = toolbarButton.w;\n\n        toolbarButton.y += TOOLBAR_BTN_PADDING * 2.0f + 1;\n\n        if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_MOVE, \"Translate\", a->activeTool == ActiveTool::Move)) {\n            a->SelectTool(ActiveTool::Move);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_ROTATE, \"Rotate\", a->activeTool == ActiveTool::Rotate)) {\n            a->SelectTool(ActiveTool::Rotate);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_SCALE, \"Scale\", a->activeTool == ActiveTool::Scale)) {\n            a->SelectTool(ActiveTool::Scale);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        /*if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_PIVOT, \"Pivot\", a->activeTool == ActiveTool::Pivot)) {\n            a->SelectTool(ActiveTool::Pivot);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;*/\n\n        Draw2D::DrawRect(toolbarButton.x - 2, toolbarButton.y, toolbarButton.w + 4, 2, s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b);\n        Draw2D::DrawRect(toolbarButton.x - 2, toolbarButton.y, toolbarButton.w + 4, 1, s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_MOVETOOL, \"Pan\", a->activeTool == ActiveTool::Pan)) {\n            a->SelectTool(ActiveTool::Pan);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        if (Imgui::SidebarButton(toolbarButton, a->zoomIn ? IMGUI_ICON_ZOOM_IN : IMGUI_ICON_ZOOM_OUT, \"Zoom\", a->activeTool == ActiveTool::Zoom)) {\n            a->SelectTool(ActiveTool::Zoom);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n\n        if (Imgui::SidebarButton(toolbarButton, IMGUI_ICON_GRID, \"Display options\", a->activeTool == ActiveTool::Grid)) {\n            a->SelectTool(ActiveTool::Grid);\n        }\n        toolbarButton.y += toolbarButton.h;\n        toolbarButton.y += TOOLBAR_BTN_PADDING / 2.0f;\n    }\n\n    // Draw header toolbar\n    Draw2D::DrawRect(header.x, header.y, header.w, header.h, s->toolBarBg.r, s->toolBarBg.g, s->toolBarBg.b);\n    Draw2D::DrawRect(header.x, header.y + header.h - 1, header.w, 1, s->headerBgColor.r, s->headerBgColor.g, s->headerBgColor.b);\n\n    {\n        Imgui::Rect _toolbarButton(header.x + 3, header.y + 3, 30, header.h - 6);\n        vec3 icon(3, 2, header.h - 10);\n        if (Imgui::SidebarButton(_toolbarButton, IMGUI_ICON_APPICON, \"Keyframe Studio Github\", false, &icon)) {\n            WindowOpenURL(\"https://github.com/gszauer/KeyframeStudio\");\n        }\n\n        header.x += 38; // Just some padding\n\n        Draw2D::DrawRect(toolBar.w - 2, header.y, 2, header.h, s->toolBarBg.r, s->toolBarBg.g, s->toolBarBg.b, 1.0f);\n        Draw2D::DrawRect(toolBar.w - 1, header.y, 1, header.h, s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b, 1.0f);\n\n        char textBuffer[32] = { 0 };\n        if (a->activeTool == ActiveTool::Move || a->activeTool == ActiveTool::Rotate || a->activeTool == ActiveTool::Scale || a->activeTool == ActiveTool::Pivot) {\n            Imgui::Rect control(header.x, header.y, header.w, header.h);\n            control.y += 5;\n            control.h -= 14;\n            control.x += 5;\n            control.w = 67;\n\n            if (a->activeTool == ActiveTool::Move || a->activeTool == ActiveTool::Pivot) {\n                Imgui::Label(control, \"Tool space\", false, false);\n                control.x += 69;\n                control.x += 5;\n            }\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            if (a->activeTool == ActiveTool::Move) {\n                i32 selected = a->moveWorld ? 1 : 0;\n                a->moveWorld = Imgui::BeginComboBox(control, a->moveWorld ? \"World\" : \"Local\", 2, selected, 0, false, false);\n            }\n            if (a->activeTool == ActiveTool::Pivot) {\n                i32 selected = a->pivotWorld ? 1 : 0;\n                a->pivotWorld = Imgui::BeginComboBox(control, a->pivotWorld ? \"World\" : \"Local\", 2, selected, 0, false, false);\n            }\n\n\n            if (a->activeTool == ActiveTool::Move || a->activeTool == ActiveTool::Pivot) {\n                Imgui::PushComboBoxItem(\"Local\");\n                Imgui::PushComboBoxItem(\"World\");\n                Imgui::EndComboBox();\n\n                control.x += control.w;\n                control.x += 15;\n            }\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n\n            Imgui::Label(control, \"Snap\", false, false);\n            control.x += 31;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            control.w = control.h;\n\n            control.y += 1;\n            if (a->activeTool == ActiveTool::Move) {\n                a->moveSnap = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->moveSnap, \"Snap\");\n            }\n            else if (a->activeTool == ActiveTool::Rotate) {\n                a->rotateSnap = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->rotateSnap, \"Snap\");\n            }\n            else if (a->activeTool == ActiveTool::Scale) {\n                a->scaleSnap = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->scaleSnap, \"Snap\");\n            }\n            else if (a->activeTool == ActiveTool::Pivot) {\n                a->pivotSnap = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->pivotSnap, \"Snap\");\n            }\n            control.y -= 1;\n\n            control.w = 65;\n\n            control.x += 25;\n\n            if (a->activeTool == ActiveTool::Move) {\n                stbsp_snprintf(textBuffer, 32, \"%.2f\", a->moveSnapVal);\n\n                const char* text = Imgui::TextArea(control, textBuffer, 0, !a->moveSnap, true, false, false, false, false);\n                if (text != textBuffer) {\n                    f32 val = MathAToF(text);\n                    a->moveSnapVal = MathAbsF(val);\n                }\n            }\n            else if (a->activeTool == ActiveTool::Rotate) {\n                stbsp_snprintf(textBuffer, 32, \"%.2f\", a->rotateSnapVal);\n\n                const char* text = Imgui::TextArea(control, textBuffer, 0, !a->rotateSnap, true, false, false, false, false);\n                if (text != textBuffer) {\n                    f32 val = MathAToF(text);\n                    a->rotateSnapVal = MathAbsF(val);\n                }\n            }\n            else if (a->activeTool == ActiveTool::Scale) {\n                stbsp_snprintf(textBuffer, 32, \"%.2f\", a->scaleSnapVal);\n\n                const char* text = Imgui::TextArea(control, textBuffer, 0, !a->scaleSnap, true, false, false, false, false);\n                if (text != textBuffer) {\n                    f32 val = MathAToF(text);\n                    a->scaleSnapVal = MathAbsF(val);\n                }\n            }\n            else if (a->activeTool == ActiveTool::Pivot) {\n                stbsp_snprintf(textBuffer, 32, \"%.2f\", a->pivotSnapVal);\n\n                const char* text = Imgui::TextArea(control, textBuffer, 0, !a->pivotSnap, true, false, false, false, false);\n                if (text != textBuffer) {\n                    f32 val = MathAToF(text);\n                    a->pivotSnapVal = MathAbsF(val);\n                }\n            }\n            control.x += control.w;\n            control.x += 15;\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n\n            Imgui::Label(control, \"Auto select layer\", false, false);\n            control.x += 105;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            control.w = control.h;\n\n            control.y += 1;\n            if (a->activeTool == ActiveTool::Move) {\n                a->moveSelect = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->moveSelect, \"Auto Select\");\n            }\n            else if (a->activeTool == ActiveTool::Rotate) {\n                a->rotateSelect = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->rotateSelect, \"Auto Select\");\n            }\n            else if (a->activeTool == ActiveTool::Scale) {\n                a->scaleSelect = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->scaleSelect, \"Auto Select\");\n            }\n            else if (a->activeTool == ActiveTool::Pivot) {\n                a->pivotSelect = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->pivotSelect, \"Auto Select\");\n            }\n            control.y -= 1;\n        }\n        else if (a->activeTool == ActiveTool::Pan) {\n            Imgui::Rect control(header.x, header.y, header.w, header.h);\n            control.y += 5;\n            control.h -= 14;\n            control.x += 5;\n            control.w = 67;\n\n            Imgui::Label(control, \"Viewport x\", false);\n\n            control.x += 72;\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            stbsp_snprintf(textBuffer, 32, \"%.2f\", a->view.x);\n            const char* text = Imgui::TextArea(control, textBuffer, 0, false, true, false, false, false, false);\n            if (text != textBuffer) {\n                float val = MathAToF(text);\n                a->view.x = val;\n            }\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n\n            control.x += control.w;\n            control.x += 5;\n\n            Imgui::Label(control, \"y\", false, true);\n\n            control.x += 6;\n            control.x += 5;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            stbsp_snprintf(textBuffer, 32, \"%.2f\", a->view.y);\n            text = Imgui::TextArea(control, textBuffer, 0, false, true, false, false, false, false);\n            if (text != textBuffer) {\n                float val = MathAToF(text);\n                a->view.y = val;\n            }\n\n            control.x += control.w;\n            control.x += 15;\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n\n            Imgui::Label(control, \"Zoom\", false, false);\n            control.x += 36;\n            control.x += 5;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            stbsp_snprintf(textBuffer, 32, \"%.2f\", a->view.z);\n            text = Imgui::TextArea(control, textBuffer, 0, false, true, false, false, false, false);\n            if (text != textBuffer) {\n                a->view.z = MathAToF(text);\n            }\n            control.x += control.w;\n            control.x += 5;\n\n            control.w = 200.0f;\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            float val = (a->view.z + 500.0f) / 1000.0f;\n            val = Imgui::FloatSlider(control, val);\n            a->view.z = (val * 1000.0f) - 500.0f;\n\n            if (a->view.z < -500.0f) {\n                a->view.z = -500.0f;\n            }\n            if (a->view.z > 500.0f) {\n                a->view.z = 500.0f;\n            }\n        }\n        else if (a->activeTool == ActiveTool::Zoom) {\n            Imgui::Rect control(header.x, header.y, header.w, header.h);\n            control.y += 5;\n            control.h -= 14;\n            control.x += 5;\n            control.w = 67;\n\n            Imgui::Label(control, \"Tool mode\", false, false);\n            control.x += 67;\n            control.x += 5;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            control.w = 85;\n\n            a->zoomIn = Imgui::BeginComboBox(control, a->zoomIn ? \"Zoom in\" : \"Zoom out\", 2, a->zoomIn ? 0 : 1, 0, false, false) ? false : true;\n            Imgui::PushComboBoxItem(\"Zoom in\");\n            Imgui::PushComboBoxItem(\"Zoom out\");\n            Imgui::EndComboBox();\n\n            control.x += control.w;\n            control.x += 15;\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n\n            Imgui::Label(control, \"Zoom\", false, false);\n            control.x += 36;\n            control.x += 5;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            stbsp_snprintf(textBuffer, 32, \"%.2f\", a->view.z);\n            const char* text = Imgui::TextArea(control, textBuffer, 0, false, true, false, false, false, false);\n            if (text != textBuffer) {\n                a->view.z = MathAToF(text);\n            }\n            control.x += control.w;\n            control.x += 5;\n\n            control.w = 200.0f;\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n\n            float val = (a->view.z + 500.0f) / 1000.0f;\n            val = Imgui::FloatSlider(control, val);\n            a->view.z = (val * 1000.0f) - 500.0f;\n\n            if (a->view.z < -500.0f) {\n                a->view.z = -500.0f;\n            }\n            if (a->view.z > 500.0f) {\n                a->view.z = 500.0f;\n            }\n        }\n        else if (a->activeTool == ActiveTool::Grid) {\n            Imgui::Rect control(header.x, header.y, header.w, header.h);\n            control.y += 5;\n            control.h -= 14;\n            control.x += 5;\n            control.w = 67;\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n            Imgui::Label(control, \"Show Grid\", false, false);\n            control.x += 65;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            control.w = control.h;\n            control.y += 1;\n            a->gridShow = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->gridShow, \"Show Grid\");\n            control.y -= 1;\n            control.x += control.h + 10;\n\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n            Imgui::Label(control, \"Grid Size\", false, false);\n            control.x += 60;\n\n            control.y -= 2;\n            control.w = 65;\n            control.h = header.h - 6.0f;\n            stbsp_snprintf(textBuffer, 32, \"%.2f\", a->gridSize);\n            const char* text = Imgui::TextArea(control, textBuffer, 0, !a->gridShow, true, false, false, false, false);\n            if (text != textBuffer) {\n                f32 val = MathAToF(text);\n                a->gridSize = MathAbsF(val);\n            }\n            control.y += 2;\n            control.x += 65 + 10;\n\n\n            control.y = header.y + 5;\n            control.h = header.h - 14;\n            Imgui::Label(control, \"Outline Selected Node\", false, false);\n            control.x += 140;\n\n            control.y = header.y + 3.0f;\n            control.h = header.h - 6.0f;\n            control.w = control.h;\n            control.y += 1;\n            a->gridHighlight = Imgui::ToggleIcon(control, IMGUI_ICON_CHECKED, IMGUI_ICON_UNCHECKED, a->gridHighlight, \"Outline Selected Node\");\n            control.y -= 1;\n        }\n    }\n}\n\nNode2D* ConvertNode(AnimLoader::Node* source) {\n    Node2D* result = (Node2D*)MemAlloc(sizeof(Node2D));\n    MemSet(result, 0, sizeof(Node2D));\n\n    result->uid = source->nodeUid;\n\n    char* src = (char*)source->name;\n    char* iter = (char*)source->name;\n    while (iter != 0 && *iter != 0) {\n        ++iter;\n    }\n    if (result->uid != 0) {\n        result->nameLength = iter - src;\n        result->name = (char*)MemAlloc(result->nameLength + 1);\n        for (u32 i = 0; i < result->nameLength; ++i) {\n            result->name[i] = src[i];\n        }\n        result->name[result->nameLength] = 0;\n        result->nameCapacity = result->nameLength;\n    }\n    else {\n        result->nameLength = result->nameCapacity = 0;\n        result->name = 0;\n    }\n\n    result->parent = (Node2D*)source->parentUid;\n    result->firstChild = (Node2D*)source->firstChildUid;\n    result->next = (Node2D*)source->nextSiblingUid;\n    result->depth = 0;\n\n    result->refCount = 1; // Document will hold onto it\n\n    result->sortIndex = source->sortIndex;\n    result->sortedPrev = 0;\n    result->sortedNext = 0;\n\n    result->position = vec2(source->positionX, source->positionY);\n    result->rotationAngles = source->rotationAngles;\n    result->scale = vec2(source->scaleX, source->scaleY);\n\n    result->sprite.sourceX = source->sourceX;\n    result->sprite.sourceY = source->sourceY;\n    result->sprite.sourceW = source->sourceW;\n    result->sprite.sourceH = source->sourceH;\n    result->sprite.pivotX = source->pivotX;\n    result->sprite.pivotY = source->pivotY;\n    result->sprite.tintR = source->tintR;\n    result->sprite.tintG = source->tintG;\n    result->sprite.tintB = source->tintB;\n    result->sprite.tintA = source->tintA;\n    result->sprite.visible = source->visible;\n    result->sprite.resourceUID = source->resourceUid;\n\n    result->uiVisible = source->visible;\n    result->uiExpanded = true;\n\n    return result;\n}\n\nvoid OpenFile(Application* app, void* data, u32 bytes) {\n    if (data != 0 && bytes != 0) {\n        AnimLoader::Header* kfs = AnimLoader::Parse(data, bytes);\n\n        app->document->nodeUidGenerator = kfs->nodeUidGenerator;\n        app->document->animationUidGenerator = kfs->animationUidGenerator;\n        app->document->resourceUidGenerator = kfs->resourceUidGenerator;\n\n        app->document->nodeUidGenerator = kfs->nodeUidGenerator;\n        app->document->animationUidGenerator = kfs->animationUidGenerator;\n        app->document->resourceUidGenerator = kfs->resourceUidGenerator;\n        app->document->numNodes = kfs->nodeCount - 1;\n\n        { // Create all nodes\n            AnimLoader::Node* loadedRoot = kfs->FirstNode();\n            PlatformAssert(app->document->rootNode != 0, __LOCATION__);\n            PlatformAssert(app->document->rootNode->firstChild == 0, __LOCATION__);\n            PlatformAssert(app->document->rootNode->next == 0, __LOCATION__);\n            PlatformAssert(app->document->rootNode->name == 0, __LOCATION__);\n\n            MemRelease(app->document->rootNode);\n            Node2D* newRootNode = ConvertNode(loadedRoot);\n            app->document->rootNode = newRootNode;\n\n            loadedRoot = loadedRoot->Next();\n            for (int i = 1; i < kfs->nodeCount; ++i) {\n                Node2D* newNode = ConvertNode(loadedRoot);\n                newRootNode->sortedNext = newNode;\n                newRootNode = newNode;\n                loadedRoot = loadedRoot->Next();\n            }\n        }\n\n        { // Re-link all nodes\n            Node2D* iter = app->document->rootNode;\n            for (int i = 0; i < kfs->nodeCount; ++i) {\n                // Parent\n                if (iter->uid != 0) {\n                    u32 parentUid = (u32)iter->parent;\n                    iter->parent = 0;\n\n                    Node2D* search = app->document->rootNode;\n                    for (int j = 0; j < kfs->nodeCount; ++j) {\n                        if (search->uid == parentUid) {\n                            iter->parent = search;\n                            break;\n                        }\n                        search = search->sortedNext;\n                    }\n\n                }\n                else {\n                    iter->parent = 0; // Root never has a parent\n                }\n\n                // First child\n                u32 firstChildUid = (u32)iter->firstChild;\n                if (firstChildUid != 0) {\n                    Node2D* search = app->document->rootNode;\n                    for (int j = 0; j < kfs->nodeCount; ++j) {\n                        if (search->uid == firstChildUid) {\n                            iter->firstChild = search;\n                            break;\n                        }\n                        search = search->sortedNext;\n                    }\n                }\n\n                // Next sibling\n                u32 nextSiblingUid = (u32)iter->next;\n                if (nextSiblingUid != 0) {\n                    Node2D* search = app->document->rootNode;\n                    for (int j = 0; j < kfs->nodeCount; ++j) {\n                        if (search->uid == nextSiblingUid) {\n                            iter->next = search;\n                            break;\n                        }\n                        search = search->sortedNext;\n                    }\n                }\n\n                iter = iter->sortedNext;\n            }\n\n            // Clear all sorted next\n            Node2D* clearIter = app->document->rootNode;\n            for (int i = 0; i < kfs->nodeCount; ++i) {\n                Node2D* thisIter = clearIter;\n                clearIter = clearIter->sortedNext;\n                thisIter->sortedNext = 0;\n\n                thisIter->depth = 0;\n                Node2D* parentIter = thisIter;\n                while (parentIter != 0) {\n                    thisIter->depth += 1;\n                    parentIter = parentIter->parent;\n                }\n            }\n        }\n        app->document->selectedNode = 0;\n\n        app->document->numResources = kfs->resourceCount;\n        { // Populate resources\n            AnimLoader::Resource* loadedResource = kfs->FirstResource();\n            for (u32 i = 0; i < kfs->resourceCount; ++i) {\n                Resource* newResource = (Resource*)MemAlloc(sizeof(Resource));\n                MemSet(newResource, 0, sizeof(Resource));\n\n                newResource->nameLen = 0;\n                for (char* iter = (char*)loadedResource->name; *iter != 0; ++iter, newResource->nameLen++) {}\n                if (newResource->nameLen != 0) {\n                    newResource->name = (char*)MemAlloc(newResource->nameLen + 1);\n                    char* oldName = (char*)loadedResource->name;\n                    for (u32 i = 0; i < newResource->nameLen; ++i) {\n                        newResource->name[i] = oldName[i];\n                    }\n                    newResource->name[newResource->nameLen] = 0;\n                }\n                else {\n                    newResource->name = 0;\n                }\n\n                newResource->uid = loadedResource->resourceUid;\n                newResource->size = loadedResource->bytes;\n                newResource->data = MemAlloc(newResource->size);\n                void* src = loadedResource->Data();\n\n                MemCopy(newResource->data, src, newResource->size);\n                newResource->filter = Draw2D::Interpolation::Linear;\n                newResource->width = loadedResource->width;\n                newResource->height = loadedResource->height;\n                newResource->image = Draw2D::LoadImage(newResource->data, newResource->size, newResource->filter);\n\n                if (app->document->resources == 0) {\n                    app->document->resources = newResource;\n                }\n                else {\n                    Resource* insert = app->document->resources;\n                    while (insert->next != 0) {\n                        insert = insert->next;\n                    }\n                    newResource->prev = insert;\n                    insert->next = newResource;\n                }\n                loadedResource = loadedResource->Next();\n            }\n        }\n        app->document->selectedResource = 0;\n\n        app->document->numAnimations = kfs->animationCount;\n        PlatformAssert(app->document->allAnimations == 0, __LOCATION__);\n        Animation* lastAnim = 0;\n        AnimLoader::Animation* loadedAnim = kfs->FirstAnimation();\n        for (u32 i = 0; i < kfs->animationCount; ++i) {\n            Animation* anim = (Animation*)MemAlloc(sizeof(Animation));\n            MemClear(anim, sizeof(Animation));\n\n            anim->uid = loadedAnim->animUid;\n            anim->refCount = 1;\n            anim->frameCount = loadedAnim->frameCount;\n            anim->frameRate = loadedAnim->frameRate;\n            anim->loop = loadedAnim->looping ? AnimationLoopMode::Looping : AnimationLoopMode::None;\n\n            anim->name = 0;\n            if (loadedAnim->name != 0) {\n                char* start = (char*)loadedAnim->name;\n                char* end = (char*)loadedAnim->name;\n                while (*end != 0) {\n                    ++end;\n                }\n                u32 len = end - start;\n                anim->name = (char*)MemAlloc(len + 1);\n\n                for (u32 j = 0; j < len; ++j) {\n                    anim->name[j] = start[j];\n                }\n\n                anim->name[len] = 0;\n            }\n\n            anim->tracks = 0;\n            anim->numTracks = loadedAnim->numTracks;\n            AnimLoader::Track* loadedTrack = loadedAnim->FirstTrack();\n            Track* lastTrack = 0;\n            for (u32 j = 0; j < loadedAnim->numTracks; ++j) {\n                Track* newTrack = (Track*)MemAlloc(sizeof(Track));\n                MemClear(newTrack, sizeof(Track));\n\n                newTrack->avtive = true;\n                newTrack->targetNode = loadedTrack->targetNodeUid;\n                newTrack->targetProp = (TrackType)loadedTrack->targetProp;\n\n                newTrack->frameCount = loadedAnim->frameCount;\n                newTrack->frameCapacity = loadedAnim->frameCount;\n                newTrack->numKeyFrames = loadedTrack->numFrames;\n\n                newTrack->frames = (Frame*)MemAlloc(sizeof(Frame) * newTrack->frameCount);\n                MemClear(newTrack->frames, sizeof(Frame) * newTrack->frameCount);\n\n                AnimLoader::Frame* loadedFrame = loadedTrack->FirstFrame();\n                for (u32 k = 0; k < loadedTrack->numFrames; ++k) {\n                    Frame* thisFrame = &newTrack->frames[loadedFrame->index];\n                    thisFrame->key = true;\n                    thisFrame->interp = (InterpolationType)loadedFrame->interp;\n                    thisFrame->uValue = loadedFrame->uValue;\n\n                    loadedFrame = loadedFrame->Next();\n                }\n\n                if (anim->tracks == 0) {\n                    anim->tracks = newTrack;\n                }\n\n                if (lastTrack == 0) {\n                    lastTrack = newTrack;\n                }\n                else {\n                    newTrack->prev = lastTrack;\n                    lastTrack->next = newTrack;\n                    lastTrack = newTrack;\n                }\n                loadedTrack = loadedTrack->NextInAnimation();\n            }\n\n            if (app->document->allAnimations == 0) {\n                app->document->allAnimations = anim;\n            }\n            if (lastAnim == 0) {\n                lastAnim = anim;\n            }\n            else {\n                lastAnim->next = anim;\n                anim->prev = lastAnim;\n                lastAnim = anim;\n            }\n            loadedAnim = loadedAnim->Next();\n        }\n        app->document->selectedAnimation = 0;\n\n        app->document->timelineAnimation = 0;\n        app->document->selectedTrack = 0;\n        app->document->timelineSelectedFrame = -1;\n        app->document->timelineLastSelectedFrame = -1;\n\n        if (app->document->allAnimations != 0) {\n            app->document->SelectAnimation(app->document->allAnimations);\n            app->document->SelectTimeline(app->document->allAnimations);\n        }\n\n        MemRelease(data);\n    }\n}\n\nexport void Render(unsigned int x, unsigned int y, unsigned int __w, unsigned int __h, float dpi, void* userData) {\n    Application* app = (Application*)userData;\n#if _DEBUG\n    GfxClearColor(0, 0, 0.5f, 0.6, 0.7f);\n#else\n    GfxClearColor(0, 0, 0.0f, 0.0, 0.0f);\n#endif\n\n    float w = (float)__w / dpi;\n    float h = (float)__h / dpi;\n    StyleSheet* s = &app->style;\n\n    if (app->numFilesLoading != 0) {\n        Draw2D::Begin(1920, 1080, dpi, __w, __h);\n\n        Draw2D::EnableAlphaBlending();\n        Draw2D::DrawRect(w / 2 - 200, h / 2 - 100, 400, 100, s->menuBarBg.r, s->menuBarBg.g, s->menuBarBg.b, 1.0f);\n        Draw2D::DrawString(app->interfaceFont, 35, w / 2 - 200 + 25, h / 2 - 50 + 10, \"Loading, please wait\");\n        Draw2D::DisableAlphaBlending();\n\n        Draw2D::End();\n        return;\n    }\n\n    if (app->gridShow) {\n        vec4 offset(app->view.x, app->view.y, (app->view.z + 500.0f) / 1000.0f, MathMaxF(app->gridSize, 0.1f));\n        vec4 color1(s->gridA.r, s->gridA.g, s->gridA.b, w);\n        vec4 color2(s->gridB.r, s->gridB.g, s->gridB.b, h);\n        GfxSetUniform(app->gridShader, app->gridOffsetUniform, &offset.x, GfxUniformTypeFloat4, 1);\n        GfxSetUniform(app->gridShader, app->gridColor1Uniform, &color1.x, GfxUniformTypeFloat4, 1);\n        GfxSetUniform(app->gridShader, app->gridColor2Uniform, &color2.x, GfxUniformTypeFloat4, 1);\n        GfxDraw(0, 0, app->gridVao, GfxDrawModeTriangles, 0, 6, 1);\n    }\n\n    Draw2D::Begin(1920, 1080, dpi, __w, __h);\n    Imgui::BeginFrame(dpi, app->style);\n    Draw2D::EnableAlphaBlending();\n\n    Imgui::Rect inspectorArea; // The entire inspector (game + hierarchy + anim + inspector)\n    Imgui::Rect inspectorLeft; // Left side only (game / anim)\n    Imgui::Rect inspectorRight; // Right side only (inspector / hierarchy)\n    Imgui::Rect animationArea; // Split up / down. Game view & anim view\n    Imgui::Rect animationTop; // Game view only (top)\n    Imgui::Rect animationBottom; // Anim view only (bottom)\n    Imgui::Rect menuBar;\n    Imgui::Rect hierarchySchrollArea;\n    Imgui::Rect hierarchyScrollBar;\n    Imgui::Rect hierarchyFooter;\n\n    u32 visibleNodeCount = app->document->GetVisibleNodeCount();\n    Imgui::Point mousePos = Imgui::GetPointer();\n    const char* title[4] = { 0 };\n\n    { // Menu bar\n        menuBar.w = w;\n        menuBar.h = s->menuBarHeight;\n        //Draw2D::DrawRect(menuBar.x, menuBar.y, menuBar.w, menuBar.h, s->menuBarBg.r, s->menuBarBg.g, s->menuBarBg.b, 1.0f);\n        const char* fileMenu[] = {\n            \"File\",\n            \"Edit\",\n            \"Animation\",\n            \"View\",\n            \"Help\"\n        };\n        Imgui::Rect activator[5] = { \n            Imgui::Rect(10, 5, 28.5, 20),\n            Imgui::Rect(48.5, 5, 31, 20),\n            Imgui::Rect(89.5, 5, 72, 20),\n            Imgui::Rect(171.5, 5, 38, 20),\n            Imgui::Rect(219.5, 5, 36, 20),\n         };\n\n       // At the end?\n\n        const char* fileOptions[] = {\n            \"New\",\n            \"Open\",\n            \"Save As\",\n            \"Import Asset\",\n            \"Open Sample Project\",\n        };\n\n        //if (app->fileMenuOpen) {\n            Imgui::Rect popupArea(activator[0].x, menuBar.y, 150, menuBar.h);\n            i32 modal = Imgui::BeginModalPopup(popupArea, activator[0], 5);\n            for (u32 i = 0; i < 5; ++i) {\n                Imgui::PushModalPopupItem(fileOptions[i]);\n            }\n            if (!Imgui::EndModalPopup()) {\n            }\n\n            if (modal == 0) {\n                app->NewDocument();\n            }\n            else if (modal == 1) {\n                app->NewDocument();\n\n                RequestFileAsynch([](const char* path, void* data, unsigned int bytes, void* userData) {\n                    Application* app = (Application*)userData;\n                    OpenFile(app, data, bytes);\n                }, app);\n            }\n            else if (modal == 2) {\n                u32 saveBytes = app->document->GetSaveSizeBytes();\n                void* saveData = MemAlloc(saveBytes);\n                MemSet(saveData, 0, saveBytes);\n                saveBytes = app->document->SaveInto(saveData);\n                PresentFile(saveData, saveBytes);\n                MemRelease(saveData);\n            }\n            else if (modal == 3) {\n                app->document->RequestResource([](const char* path, const Resource& resource, void* userData) {\n                    // Nothing to really do here. If the function suceeds, then the resource\n                    // is already registered. If the function fails, then nothing.\n                    }, app);\n            }\n            else if (modal == 4) {\n                app->numFilesLoading += 1; // Increase so none of the load functions end\n                void* loadArena = MemAlloc(1024 * 1024);\n                LoadFileAsynch(\"assets/sample.kfs\", loadArena, 1024 * 1024, [](const char* path, void* data, unsigned int bytes, void* userData) {\n                    Application* app = (Application*)userData;\n                    app->document->NewDocument();\n                    OpenFile(app, data, bytes); // Calls MEmRelease(data)\n                    app->numFilesLoading -= 1; // Increase so none of the load functions end\n                }, app);\n            }\n        //}\n\n        const char* editOptions[] = {\n            \"Undo\",\n            \"Redo\",\n            \"Clear Undo History\",\n            \"Create New Node\",\n            \"Delete Selected Node\",\n        };\n\n        popupArea = Imgui::Rect(activator[1].x, menuBar.y, 160, menuBar.h);\n        modal = Imgui::BeginModalPopup(popupArea, activator[1], 5);\n        for (u32 i = 0; i < 5; ++i) {\n            Imgui::PushModalPopupItem(editOptions[i]);\n        }\n        if (!Imgui::EndModalPopup()) {\n        }\n\n        if (modal == 0) {\n            app->document->Undo();\n        }\n        else if (modal == 1) {\n            app->document->Redo();\n        }\n        else if (modal == 2) {\n            app->document->ClearUndoHistory();\n        }\n        else if (modal == 3) {\n            app->document->CreateNode(app->document->rootNode);\n        }\n        else if (modal == 4) {\n            Node2D* n = app->document->GetSelectedNode();\n            if (n != 0) {\n                app->document->DeleteNode(n);\n            }\n        }\n\n        const char* animationOptions[] = {\n            \"Create New Animation\",\n            \"Delete Selected Animation\",\n            \"Set Keyframe\",\n            \"Clear Keyframe\",\n            \"Auto Key\",\n        };\n\n        //if (app->editMenuOpen) {\n        popupArea = Imgui::Rect(activator[2].x, menuBar.y, 190, menuBar.h);\n        modal = Imgui::BeginModalPopup(popupArea, activator[2], 5);\n        for (u32 i = 0; i < 5; ++i) {\n            Imgui::PushModalPopupItem(animationOptions[i]);\n        }\n        if (!Imgui::EndModalPopup()) {\n        }\n        //}\n\n        if (modal == 0) {\n            app->document->CreateAnimation();\n        }\n        else if (modal == 1) {\n            if (app->document->GetSelectedAnimation() != 0) {\n                Animation* oldSelected = app ->document->GetSelectedAnimation();\n                if (app->document->GetTimelineAnimation() == oldSelected) {\n                    app->document->SelectTimeline(0);\n                }\n                app->document->SelectAnimation(0);\n                app->autoKey = false;\n                app->document->DeleteAnimation(oldSelected);\n            }\n        }\n        else if (modal == 2) {\n            Track* selectedTrack = app->document->GetSelectedTrack();\n            i32 selectedFrame = app->document->GetSelectedFrame();\n            if (selectedTrack != 0 && selectedFrame >= 0) {\n                app->document->SetFrame(selectedTrack, selectedFrame, app->document->GetSelectedInterpolationType());\n            }\n        }\n        else if (modal == 3) {\n            Track* selectedTrack = app->document->GetSelectedTrack();\n            i32 selectedFrame = app->document->GetSelectedFrame();\n            if (selectedTrack != 0 && selectedFrame >= 0) {\n                app->document->ClearFrame(selectedTrack, selectedFrame);\n            }\n        }\n        else if (modal == 4) {\n            app->autoKey = !app->autoKey;\n        }\n\n        const char* viewOptions[] = {\n            \"Show Sidebar\",\n            \"Show Footer\",\n        };\n\n        popupArea = Imgui::Rect(activator[3].x, menuBar.y, 105, menuBar.h);\n        modal = Imgui::BeginModalPopup(popupArea, activator[3], 2);\n        for (u32 i = 0; i < 2; ++i) {\n            Imgui::PushModalPopupItem(viewOptions[i]);\n        }\n        if (!Imgui::EndModalPopup()) {\n        }\n\n        if (modal == 0) {\n            app->showSide = !app->showSide;\n        }\n        else if (modal == 1) {\n            app->showBottom = !app->showBottom;\n        }\n\n        const char* helpOptions[] = {\n            \"Github\"\n        };\n\n        popupArea = Imgui::Rect(activator[4].x, menuBar.y, 100, menuBar.h);\n        modal = Imgui::BeginModalPopup(popupArea, activator[4], 1);\n        for (u32 i = 0; i < 1; ++i) {\n            Imgui::PushModalPopupItem(helpOptions[i]);\n        }\n        if (!Imgui::EndModalPopup()) {\n        }\n\n        if (modal == 0) {\n            WindowOpenURL(\"https://github.com/gszauer/KeyframeStudio\");\n        }\n\n        app->selectedMenu = Imgui::FileMenu(menuBar, fileMenu, 5, app->selectedMenu, activator);\n\n    }\n\n    { // Inspector Splitter (Game / anim on left, inspector / hierarchy right)\n        inspectorArea.x = 0;\n        inspectorArea.y = s->menuBarHeight;\n        inspectorArea.w = w;\n        inspectorArea.h = h - s->menuBarHeight - s->footerHeight;\n        \n        if (app->showSide) {\n            app->inspectorSplit = Imgui::VSplit(inspectorArea, s->inspectorMinWidth, app->inspectorSplit);\n            inspectorLeft = Imgui::VSplitFirstArea(inspectorArea, app->inspectorSplit);\n            inspectorRight = Imgui::VSplitSecondArea(inspectorArea, app->inspectorSplit);\n        }\n        else {\n            app->inspectorSplit = 1.0f;\n            inspectorLeft = inspectorArea;\n        }\n        //Draw2D::DrawRect(inspectorArea.x, inspectorArea.y, inspectorArea.w, inspectorArea.h, 0, 0, 1);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        //Draw2D::DrawRect(inspectorLeft.x, inspectorLeft.y, inspectorLeft.w, inspectorLeft.h, 1, 0, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n        //Draw2D::DrawRect(inspectorRight.x, inspectorRight.y, inspectorRight.w, inspectorRight.h, 0, 1, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n\n        {\n            { // Animation Splitter\n                animationArea = inspectorLeft;\n                //Draw2D::DrawRect(animationArea.x, animationArea.y + 30, animationArea.w, animationArea.h, 0, 1, 0);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                if (app->showBottom) {\n                    app->animationSplit = Imgui::HSplit(animationArea, s->animatorMinHeight, app->animationSplit);\n                    animationTop = Imgui::HSplitFirstArea(animationArea, app->animationSplit);\n                    animationBottom = Imgui::HSplitSecondArea(animationArea, app->animationSplit);\n                }\n                else {\n                    app->animationSplit = 1.0f;\n                    animationTop = animationArea;\n                }\n\n                //Draw2D::DrawRect(animationArea.x, animationArea.y, animationArea.w, animationArea.h, 0, 0, 1);// s->documentBGColor.r, s->documentBGColor.g, s->documentBGColor.b, 1.0f);\n                if (app->sceneTab != 0 || !app->gridShow) {\n                    Draw2D::DrawRect(animationTop.x, animationTop.y, animationTop.w, animationTop.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b, 1.0f);\n                }\n                if (app->showBottom) {\n                    Draw2D::DrawRect(animationBottom.x, animationBottom.y, animationBottom.w, animationBottom.h, s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b, 1.0f);\n                }\n\n                {\n                    Imgui::Rect gameHeader = animationTop;\n                    gameHeader.h = s->headerHeight;\n                    Imgui::Rect gameArea = animationTop;\n                    gameArea.y += gameHeader.h;\n                    gameArea.h -= gameHeader.h;\n\n                    // Draw header\n                    title[0] = \"Scene\";\n                    title[1] = 0;// \"Exporter\";\n                    title[2] = \"Memory\";\n\n                    if (!app->memVisible) {\n                        title[2] = 0;\n                    }\n\n                    u32 oldTab = app->sceneTab;\n                    u32 newTab = app->sceneTab = Imgui::Header(gameHeader, title, 3, oldTab);\n\n                    if (newTab == 2 && !app->memVisible) {\n                        newTab = app->sceneTab = 0;\n                    }\n\n                    if (oldTab != newTab) {\n                        if (newTab == 2) {\n                            app->memoryScroll = 0.0f;\n                        }\n                    }\n\n                    if (newTab == 0) {\n                        ImguiSceneView(gameArea, app);\n                    }\n                    else if (newTab == 2) {\n                        ImguiMemoryViewer(gameArea, app);\n                    }\n                }\n\n                if (app->showBottom) { // Animation\n                    Imgui::Rect animationHeader = animationBottom;\n                    animationHeader.h = s->headerHeight;\n\n                    Imgui::Rect animRect = animationBottom;\n                    animRect.y += s->headerHeight;\n                    animRect.h -= s->headerHeight;\n\n                    if (app->timelineTab == 0) {\n                        ImguiAnimationInspector(animRect, app);\n                    }\n                    else {\n                        ImguiKeyboard(animRect, app);\n                    }\n\n                    // Draw header\n                    title[0] = \"Timeline\";\n                    title[1] = \"Keyboard\";\n\n                    app->timelineTab = Imgui::Header(animationHeader, title, 2, app->timelineTab);\n                }\n            }\n        }\n\n        if (app->showSide) { // InspectorPanel\n            f32 inspectorStack = inspectorArea.y;\n\n            Imgui::Rect detailHeader = inspectorRight;\n            detailHeader.h = s->headerHeight;\n            detailHeader.y = inspectorStack;\n\n            if (app->hierarchyTab == 0) { // Transform\n                inspectorStack += detailHeader.h;\n\n                Imgui::Rect transformEditor = detailHeader;\n                transformEditor.y = detailHeader.y + detailHeader.h;\n\n                if (app->transformTab == 0) {\n                    transformEditor.h = IMGUI_TRANSFORM_HEIGHT;\n                    inspectorStack += IMGUI_TRANSFORM_HEIGHT;\n                    ImguiTransformEditor(transformEditor, app);\n                }\n                else {\n                    transformEditor.h = IMGUI_SPRITE_HEIGHT;\n                    inspectorStack += IMGUI_SPRITE_HEIGHT;\n                    ImguiSpriteEditor(transformEditor, app);\n                }\n\n                Node2D* selectedNode = app->document->GetSelectedNode();\n                title[0] = \"Transform\"; // Header\n                title[1] = \"Sprite\"; // Header\n\n                app->transformTab = Imgui::Header(detailHeader, title, 2, app->transformTab);\n            }\n            else if (app->hierarchyTab == 1) { // Assets\n                inspectorStack += detailHeader.h;\n\n                Imgui::Rect animEditor = detailHeader;\n                animEditor.y = animEditor.y + animEditor.h;\n\n                animEditor.h = IMGUI_PREVIEW_HEIGHT;\n                inspectorStack += IMGUI_PREVIEW_HEIGHT;\n\n                StyleSheet* s = &app->style;\n                Draw2D::DrawRect(animEditor.x, animEditor.y, animEditor.w, animEditor.h,\n                    s->panelBgColor.r, s->panelBgColor.g, s->panelBgColor.b);\n\n                animEditor.w = IMGUI_PREVIEW_HEIGHT;\n                Resource* r = app->document->GetSelectedResource();\n\n                Imgui::Rect imageArea(animEditor.x + 5, animEditor.y + 5, animEditor.w - 10, animEditor.h - 10);\n                Imgui::Rect sourceRect;\n                if (r != 0) {\n                    sourceRect.w = r->width;\n                    sourceRect.h = r->height;\n                    Imgui::ImageBlock(imageArea, 0, r->image, sourceRect, r == 0);\n                }\n                else {\n                    Imgui::ImageBlock(imageArea, 0, 0, sourceRect, r == 0);\n                }\n\n                animEditor.x += IMGUI_PREVIEW_HEIGHT;\n                animEditor.x += 2;\n                animEditor.y += 7;\n                animEditor.h = 14;\n\n                if (r != 0) {\n                    char printBuff[64] = { 0 };\n                    stbsp_snprintf(printBuff, 64, \"Name: %s\", r->name);\n                    Imgui::Label(animEditor, printBuff, false);\n                    animEditor.y += 20;\n                    stbsp_snprintf(printBuff, 64, \"Width: %d\", r->width);\n                    Imgui::Label(animEditor, printBuff, false);\n                    animEditor.y += 20;\n                    stbsp_snprintf(printBuff, 64, \"Height: %d\", r->height);\n                    Imgui::Label(animEditor, printBuff, false);\n                    animEditor.y += 20;\n                    stbsp_snprintf(printBuff, 64, \"Bytes: %d\", r->size);\n                    Imgui::Label(animEditor, printBuff, false);\n                    animEditor.y += 20;\n                    stbsp_snprintf(printBuff, 64, \"References: %d\", app->document->GetReferenceCount(r));\n                    Imgui::Label(animEditor, printBuff, false);\n                }\n                else {\n                    Imgui::Label(animEditor, \"Select image\\nto preview\", false);\n                }\n\n                title[0] = \"Preview\";\n                Imgui::Header(detailHeader, title, 1, 0);\n            }\n            else if (app->hierarchyTab == 2) { // Anims\n                inspectorStack += detailHeader.h;\n\n                Imgui::Rect animEditor = detailHeader;\n                animEditor.y = animEditor.y + animEditor.h;\n\n                animEditor.h = IMGUI_ANIMDETAIL_HEIGHT;\n                inspectorStack += IMGUI_ANIMDETAIL_HEIGHT;\n\n                ImguiAnimationEditor(animEditor, app);\n                title[0] = \"Animation\";\n                Imgui::Header(detailHeader, title, 1, 0);\n            }\n\n            { // Hierarchy and undo stack\n                Imgui::Rect hierarchyHeader = inspectorRight;\n                hierarchyHeader.h = s->headerHeight;\n                hierarchyHeader.y = inspectorStack;\n\n                f32 hiearchyHeight = inspectorRight.h - s->footerHeight - s->headerHeight - (inspectorStack - inspectorArea.y) - 2;\n                if (hiearchyHeight < 0.0f) {\n                    hiearchyHeight = 0.0f;\n                }\n\n                hierarchySchrollArea = hierarchyHeader;\n                hierarchySchrollArea.y = hierarchyHeader.y + hierarchyHeader.h;\n                hierarchySchrollArea.w = inspectorRight.w - s->scrollBarSize;\n                hierarchySchrollArea.h = hiearchyHeight;\n\n                if (hierarchySchrollArea.w < 0.0f) {\n                    hierarchySchrollArea = 0.0f;\n                }\n\n                if (app->hierarchyTab == 0) {\n                    ImguiHierarchy(hierarchySchrollArea, app);\n                }\n                else if (app->hierarchyTab == 1) {\n                    ImguiResources(hierarchySchrollArea, app);\n                }\n                else if (app->hierarchyTab == 2) {\n                    ImguiAnimations(hierarchySchrollArea, app);\n                }\n                else if (app->hierarchyTab == 3) {\n                    ImguiUndoStack(hierarchySchrollArea, app);\n                }\n\n                // Draw header\n                title[0] = \"Nodes\";\n                title[1] = \"Images\";\n                title[2] = \"Animations\";\n                title[3] = \"Undo\";\n\n                u32 oldTab = app->hierarchyTab;\n                app->hierarchyTab = Imgui::Header(hierarchyHeader, title, 4, app->hierarchyTab);\n                if (app->hierarchyTab != oldTab) {\n                    app->hierarchyScroll = 0.0f;\n                    Imgui::ClearActiveTextAreas();\n                }\n            }\n        }\n    }\n\n\n    { // Draw the footer\n        Draw2D::DrawRect(0, h - s->footerHeight, w, s->footerHeight, s->footerBg.r, s->footerBg.g, s->footerBg.b, 1.0f);\n\n        float colorA[3] = {\n                s->dividerAColor.r, s->dividerAColor.g, s->dividerAColor.b\n        };\n        float colorB[3] = {\n            s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b\n        };\n\n        Draw2D::DrawRect(0, h - s->footerHeight, w, 2, colorA[0], colorA[1], colorA[2], 1.0f);\n        Draw2D::DrawRect(0, h - s->footerHeight, w, 1, colorB[0], colorB[1], colorB[2], 1.0f);\n\n\n#define FPS_LABEL_WIDTH 45.0f\n#define MEM_LABEL_WIDTH_2 61.0f\n#define MEM_LABEL_WIDTH_1 54.0f\n#define FOOTERBAR_PADDING 5.0f\n#define FPS_GRAPH_WIDTH 31.0f\n#define MEM_BTN_WIDTH 50.0f\n\n\n        vec2 footerKarrat(w, h - s->footerHeight + 1);\n        footerKarrat.x -= FOOTERBAR_PADDING / 2;\n\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= s->footerHeight - 6;\n        Imgui::Rect mem_rect(footerKarrat.x, footerKarrat.y + 3, s->footerHeight - 6, s->footerHeight - 6);\n\n        u32 activgePages = MemGetCurrentNumPages();\n        u32 numPages = MemGetHeapSize() / MemGetPageSize();\n        float t = (float)activgePages / (float)numPages + 0.005f;\n        u32 p = 100.0f * t;\n#define ANIMATOR_MEM_BUFFER_SIZE 32\n        char mem_buffer[ANIMATOR_MEM_BUFFER_SIZE] = { 0 };\n\n        u32 activeBytes = activgePages * 4049;\n        int written = 0;\n        if (activeBytes > 1024 * 1024 * 1024) {\n            float gib = (float)activeBytes / 1024.0f / 1024.0f / 1024.0f;\n            written = stbsp_snprintf(mem_buffer, ANIMATOR_MEM_BUFFER_SIZE, \"%.1fGB / \", gib);\n        }\n        else if (activeBytes > 1024 * 1024) {\n            float mib = (float)activeBytes / 1024.0f / 1024.0f;\n            written = stbsp_snprintf(mem_buffer, ANIMATOR_MEM_BUFFER_SIZE, \"%.1fMB / \", mib);\n        }\n        else if (activeBytes > 1024) {\n            float kib = (float)activeBytes / 1024.0f;\n            written = stbsp_snprintf(mem_buffer, ANIMATOR_MEM_BUFFER_SIZE, \"%.1fKB / \", kib);\n        }\n        else {\n            written = stbsp_snprintf(mem_buffer, ANIMATOR_MEM_BUFFER_SIZE, \"%dB / \", activeBytes);\n        }\n\n        char* iter = mem_buffer + written;\n\n        u32 totalBytes = MemGetHeapSize();\n        if (totalBytes > 1024 * 1024 * 1024) {\n            float gib = (float)totalBytes / 1024.0f / 1024.0f / 1024.0f;\n            stbsp_snprintf(iter, ANIMATOR_MEM_BUFFER_SIZE - written, \"%.1fGB\", gib);\n        }\n        else if (totalBytes > 1024 * 1024) {\n            float mib = (float)totalBytes / 1024.0f / 1024.0f;\n            stbsp_snprintf(iter, ANIMATOR_MEM_BUFFER_SIZE - written, \"%.1fMB\", mib);\n        }\n        else if (totalBytes > 1024) {\n            float kib = (float)totalBytes / 1024.0f;\n            stbsp_snprintf(iter, ANIMATOR_MEM_BUFFER_SIZE - written, \"%.1fKB\", kib);\n        }\n        else {\n            stbsp_snprintf(iter, ANIMATOR_MEM_BUFFER_SIZE - written, \"%dB\", totalBytes);\n        }\n\n        StyleColor tint = { 0 };\n        app->memVisible = Imgui::ToggleButton(mem_rect, '0' + (p / 10), '0' + (p / 10), app->memVisible, false, mem_buffer, tint);\n\n        footerKarrat.x -= FOOTERBAR_PADDING / 3;\n        if (p < 10) {\n            footerKarrat.x -= MEM_LABEL_WIDTH_1;\n        }\n        else {\n            footerKarrat.x -= MEM_LABEL_WIDTH_2;\n        }\n\n#define ANIMATOR_MEM_BUFFER2_SIZE 32\n        char memBuffer[ANIMATOR_MEM_BUFFER2_SIZE] = { 0 };\n        stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER2_SIZE, \"MEM: %d%c\", p, '%');\n\n        Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n            s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= FPS_GRAPH_WIDTH;\n        float graph_height = s->footerHeight - 10;\n        Draw2D::DrawRect(footerKarrat.x, footerKarrat.y + 5, FPS_GRAPH_WIDTH, graph_height,\n            s->textAreaOutline_Normal.r, s->textAreaOutline_Normal.g, s->textAreaOutline_Normal.b);\n        Draw2D::DrawRect(footerKarrat.x + 1, footerKarrat.y + 5 + 1, FPS_GRAPH_WIDTH - 2, graph_height - 2,\n            s->textAreaBg_Normal.r, s->textAreaBg_Normal.g, s->textAreaBg_Normal.b);\n\n        double avgDt = 0.0;\n        for (i32 i = 0; i < 60; ++i) {\n            avgDt += app->msPerFrame[i];\n        }\n        if (avgDt > 0.0) {\n            avgDt /= 60.0;\n        }\n\n        if (app->msIter == 0) {\n            app->fpsDisplay = (i32)(1000.0 / (avgDt * 1000.0));\n        }\n\n        float lastSample = 1000.0f / (app->msPerFrame[0] * 1000.0f);\n        float lastSampleNormalized = Math01(lastSample / 60.0f);\n\n        StyleColor color = s->fps1;\n        if (app->fpsDisplay < 28) {\n            color = s->fps2;\n        }\n        else if (app->fpsDisplay < 18) {\n            color = s->fps3;\n        }\n\n        f32 points[30 * 2] = { 0 };\n        for (int i = 0; i < 30; ++i) {\n            float thisSample = 1000.0f / (app->msPerFrame[i * 2] * 1000.0f);\n            float thisNormalized = Math01(thisSample / 60.0f);\n            points[i * 2 + 0] = footerKarrat.x + 1 + i;\n            points[i * 2 + 1] = footerKarrat.y + 1 + 5 + 4 + (1.0f - thisNormalized) * (graph_height - 8);\n        }\n        Draw2D::DrawLine(points, 30, 1, color.r, color.g, color.b);\n\n\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= FPS_LABEL_WIDTH;\n\n        stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER2_SIZE, \"FPS: %d\", app->fpsDisplay);\n        Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n            s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\n\n        stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER2_SIZE, \"Index count: %d\", GfxStatsIndexCount());\n        Draw2D::Size size = Draw2D::MeasureString(app->interfaceFont, 12, memBuffer);\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= size.w + 2;\n        Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n            s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\n        stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER2_SIZE, \"Draw calls: %d\", GfxStatsDrawCount());\n        size = Draw2D::MeasureString(app->interfaceFont, 12, memBuffer);\n        footerKarrat.x -= FOOTERBAR_PADDING;\n        footerKarrat.x -= size.w + 2;\n        Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n            s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\n        footerKarrat.x = FOOTERBAR_PADDING;\n\n        Animation* timelineAnimation = app->document->GetTimelineAnimation();\n        if (timelineAnimation == 0) {\n            stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER_SIZE, \"Duration: 0\");\n            Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n                s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n            Draw2D::Size screenSize = Draw2D::MeasureString(app->interfaceFont, 12, memBuffer);\n            footerKarrat.x += screenSize.w;\n            footerKarrat.x += FOOTERBAR_PADDING;\n            footerKarrat.x += FOOTERBAR_PADDING;\n\n            stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER_SIZE, \"Frame: 0/0\");\n            Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n                s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n        }\n        else {\n            float seconds = (float)timelineAnimation->frameCount / (float)timelineAnimation->frameRate;\n            stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER_SIZE, \"Duration: %.1fs\", seconds);\n            Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n                s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n            Draw2D::Size screenSize = Draw2D::MeasureString(app->interfaceFont, 12, memBuffer);\n            footerKarrat.x += screenSize.w;\n\n            footerKarrat.x += FOOTERBAR_PADDING;\n            footerKarrat.x += FOOTERBAR_PADDING;\n            {\n                stbsp_snprintf(memBuffer, ANIMATOR_MEM_BUFFER_SIZE, \"Frame: %d/%d\", (app->document->GetSelectedFrame() + 1), (timelineAnimation->frameCount));\n\n            }\n            Draw2D::DrawString(app->interfaceFont, 12, footerKarrat.x, footerKarrat.y + 12 + 6, memBuffer,\n                s->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n        }\n    }\n\n    app->kbdGen = 0;\n    if (Imgui::PointerReleased()) {\n        app->kbdActive = 0;\n    }\n    app->kbdHot = 0;\n    app->kbdHandled = false;\n\n    bool processedKbd = Imgui::EndFrame(__w, __h);\n    Draw2D::DisableAlphaBlending();\n    Draw2D::End();\n\n    if (!processedKbd) {\n        if (KeyboardPressed(KeyboardCodeQ)) {\n            app->activeTool = ActiveTool::None;\n        }\n        else if (KeyboardPressed(KeyboardCodeW)) {\n            app->activeTool = ActiveTool::Move;\n        }\n        else if (KeyboardPressed(KeyboardCodeE)) {\n            app->activeTool = ActiveTool::Rotate;\n        }\n        else if (KeyboardPressed(KeyboardCodeR)) {\n            app->activeTool = ActiveTool::Scale;\n        }\n        else if (KeyboardPressed(KeyboardCodeS)) {\n            if (KeyboardDown(KeyboardCodeControl)) {\n                u32 saveBytes = app->document->GetSaveSizeBytes();\n                void* saveData = MemAlloc(saveBytes);\n                MemSet(saveData, 0, saveBytes);\n                saveBytes = app->document->SaveInto(saveData);\n                PresentFile(saveData, saveBytes);\n                MemRelease(saveData);\n            }\n            else {\n                Animation* timeline = app->document->GetTimelineAnimation();\n                if (timeline != 0) {\n                    Track* track = app->document->GetSelectedTrack();\n                    if (track != 0) {\n                        i32 frame = app->document->GetSelectedFrame();\n                        if (frame > 0) {\n                            app->document->SetFrame(track, frame, app->document->GetSelectedInterpolationType());\n                        }\n                    }\n                }\n            }\n        }\n        else if (KeyboardPressed(KeyboardCodeZ)) {\n            if (KeyboardDown(KeyboardCodeControl)) {\n                app->document->Undo();\n            }\n        }\n        else if (KeyboardPressed(KeyboardCodeY)) {\n            if (KeyboardDown(KeyboardCodeControl)) {\n                app->document->Redo();\n            }\n        }\n        else if (KeyboardPressed(KeyboardCodeSpace)) {\n            app->playSelectedAnimation = !app->playSelectedAnimation;\n            // a->playingAnimationFrame\n            //a->playingAnimationTimer\n        }    \n    }        \n    app->document->EndOfFrame(app->autoKey); // Updates node animations\n}\n\nexport void Shutdown(void* userData) {\n    Application* app = (Application*)userData;\n    app->document->~Document();\n\n    GfxDestroyShaderVertexLayout(app->gridVao);\n    GfxDestroyBuffer(app->gridVbo);\n    GfxDestroyBuffer(app->gridIbo);\n    GfxDestroyShader(app->gridShader);\n\n    Imgui::Shutdown();\n    Draw2D::Shutdown();\n\n    MemRelease(app->document);\n    MemRelease(app);\n}","#ifndef _H_PLATFORMASSERT_\n#define _H_PLATFORMASSERT_\n\n// Mirrored from memory.h\n#if defined(__APPLE__) && defined(__MACH__)\n#define MEM_PLATFORM_APPLE 1\n#define platform_t unsigned long long\n#elif defined(WIN64) || defined(_WIN64) || defined(__WIN64) || defined(__WIN64__)\n#define MEM_PLATFORM_WINDOWS 1\n#define platform_t unsigned long long\n#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)\n#define MEM_PLATFORM_WINDOWS 1\n#define platform_t unsigned long\n#elif defined(__linux__)\n#define MEM_PLATFORM_LINUX 1\n#define platform_t unsigned long long\n#else\n#define MEM_PLATFORM_WASM 1\n#define platform_t unsigned long\n#endif\n\n#if _DEBUG\n#ifndef PLATFORM_DEBUG\n#define PLATFORM_DEBUG 1\n#endif\n#else\n#ifndef PLATFORM_DEBUG\n#define PLATFORM_DEBUG 0\n#endif\n#endif\n\n#if _DEBUG\ninline int PlatformAssert(bool cond, const char* msg) { // Always returns 0\n#if MEM_PLATFORM_WASM\n\tif (!cond) {\n\t\t\tPrintDebugString(msg);\n            __builtin_trap();\n\t\t}\n#else\n\tif (!cond) {\n\t\tunsigned char* ptr = (unsigned char*)0;\n\t\t*ptr = 0;\n\t}\n#endif\n\treturn 0;\n}\n\n#else\n#define PlatformAssert(x, m)\n#endif\n\n#ifndef __LOCATION__\n#define mem_xstr(a) mem_str(a)\n#define mem_str(a) #a\n#if _DEBUG\n#define __LOCATION__ (\"On line \" mem_xstr(__LINE__) \", in \" __FILE__)\n#else\n#define __LOCATION__ ((const char*)0)\n#endif\n#endif // !__LOCATION__\n\n#endif // !_H_ASSERT_\n","#include \"memory.h\"\n#include \"assert.h\"\n\n#if defined(MEM_PLATFORM_WINDOWS)\n    #include <windows.h>\n    mem_cfunc void PrintDebugString(const char* str) {\n        OutputDebugStringA(str);\n    }\n#elif defined(MEM_PLATFORM_WASM)\n    extern unsigned char __heap_base;\n    extern unsigned char __data_end;\n\n    __attribute__ (( visibility( \"default\" ) )) extern \"C\" void MemWasmTriggerCallback(fpAllocationInfo callback, u32 index, void* mem, u32 firstPage, u32 numPages, void* tag, void* userData) {\n        if (callback != 0) {\n        callback(index, mem, firstPage, numPages, tag, userData);\n        }\n    }\n#endif\n\n// Don't disable these\n#define MEM_ENABLE_SUBALLOCATORS        1\n\nvoid* gHeap = 0;\n\n\n#if MEM_ENABLE_ALLOCGUARD\n#define MEM_ALLOCATION_magicHead        0\n#define MEM_ALLOCATION_startPage        4\n#define MEM_ALLOCATION_pageCount        6\n#define MEM_ALLOCATION_allocPrev        8\n#define MEM_ALLOCATION_allocNext        12\n#define MEM_ALLOCATION_tag              16\n#define MEM_ALLOCATION_magicTail        24\n#define MEM_ALLOCATION_padding          28\n#else\n#define MEM_ALLOCATION_startPage        0\n#define MEM_ALLOCATION_pageCount        2\n#define MEM_ALLOCATION_allocPrev        4\n#define MEM_ALLOCATION_allocNext        8\n#define MEM_ALLOCATION_tag              12\n#define MEM_ALLOCATION_padding          20\n#endif\n\n#define MEM_ALLOCATOR_heapSizeBytes     0\n#define MEM_ALLOCATOR_overheadPages     4\n#define MEM_ALLOCATOR_firstPage         8\n#define MEM_ALLOCATOR_activeAllocs      12\n#define MEM_ALLOCATOR_subAllocFree1     16\n#define MEM_ALLOCATOR_subAllocSize1     20\n#define MEM_ALLOCATOR_subAllocFree2     24\n#define MEM_ALLOCATOR_subAllocSize2     28\n#define MEM_ALLOCATOR_subAllocFree3     32\n#define MEM_ALLOCATOR_subAllocSize3     36\n#define MEM_ALLOCATOR_activePages       40\n#define MEM_ALLOCATOR_mostActivePages   44\n\n#define MEM_ALLOCACTION_MAGIC_MAIN       (((u32)'m' << 0) | ((u32)'e' << 8) | ((u32)'m' << 16) | ((u32)'_' << 24))    // 1601004909\n#define MEM_ALLOCACTION_MAGIC_SUB_ACTIVE (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'a' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_SUB_FREE   (((u32)'s' << 0) | ((u32)'u' << 8) | ((u32)'b' << 16) | ((u32)'f' << 24))    // \n#define MEM_ALLOCACTION_MAGIC_RELEASED   (((u32)'f' << 0) | ((u32)'r' << 8) | ((u32)'e' << 16) | ((u32)'e' << 24))    // 1701147238\n\n\n#if 1\n#define MEM_READU16(ptr, offset)        (*(u16*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU16(ptr, offset, val)  (*(u16*)((u8*)(ptr) + (offset)) = (u16)(val))\n\n#define MEM_READU32(ptr, offset)        (*(u32*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU32(ptr, offset, val)  (*(u32*)((u8*)(ptr) + (offset)) = (u32)(val))\n\n#define MEM_READU64(ptr, offset)        (*(u64*)((u8*)(ptr) + (offset)))\n#define MEM_WRITEU64(ptr, offset, val)  (*(u64*)((u8*)(ptr) + (offset)) = (u64)(val))\n\n#define MEM_SUBALLOCSIZE(ptr, index)    (*(u32*)((u8*)(ptr) + 20 + ((index) * 8)))\n#define MEM_GETSUBALLOCOFFSET(ptr, idx) (*(u32*)((u8*)(ptr) + 16 + ((idx) * 8)))\n#define MEM_SETSUBALLOCOFFSET(ptr,i,v)  (*(u32*)((u8*)(ptr) + 16 + ((i) * 8)) = (u32)(v))\n#define MEM_PAGEMASKPTR(ptr)            ( (u32*)((u8*)(ptr) + MEM_ALLOCATOR_SIZE))\n#define MEM_HEAPSIZE(ptr)               (*(u32*)((u8*)(ptr) + 0 ))\n#define MEM_ACTIVEALLOCSOFFSET(ptr)     (*(u32*)((u8*)(ptr) + 12))\n#define MEM_FIRSTPAGEOFFSET(ptr)        (*(u32*)((u8*)(ptr) + 8 ))\n#define MEM_FIRSTPAGEPTR(ptr)           (       ((u8*)(ptr) + MEM_FIRSTPAGEOFFSET(ptr)))\n#define MEM_GETPAGEPTR(ptr, page)       ((u8*)MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * (page)))\n\n#else\n\ninline u16 MEM_READU16(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u16 low =  u8_ptr[offset];\n    u16 high = u8_ptr[offset + 1];\n\n    return low | (high << 8);\n}\n\ninline void MEM_WRITEU16(void* ptr, u32 offset, u16 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n\n    u8_ptr[offset] = b1;\n    u8_ptr[offset + 1] = b2;\n}\n\ninline u32 MEM_READU32(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u32 b1 = u8_ptr[offset + 0];\n    u32 b2 = u8_ptr[offset + 1];\n    u32 b3 = u8_ptr[offset + 2];\n    u32 b4 = u8_ptr[offset + 3];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24);\n}\n\ninline void MEM_WRITEU32(void* ptr, u32 offset, u32 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u8 b1 = (val & (255));\n    u8 b2 = (val & (255 << 8)) >> 8;\n    u8 b3 = (val & (255 << 16)) >> 16;\n    u8 b4 = (val & (255 << 24)) >> 24;\n\n    u8_ptr[offset + 0] = b1;\n    u8_ptr[offset + 1] = b2;\n    u8_ptr[offset + 2] = b3;\n    u8_ptr[offset + 3] = b4;\n}\n\ninline u64 MEM_READU64(void* ptr, u32 offset) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n    u64 b1 = u8_ptr[offset + 0];\n    u64 b2 = u8_ptr[offset + 1];\n    u64 b3 = u8_ptr[offset + 2];\n    u64 b4 = u8_ptr[offset + 3];\n    u64 b5 = u8_ptr[offset + 4];\n    u64 b6 = u8_ptr[offset + 5];\n    u64 b7 = u8_ptr[offset + 6];\n    u64 b8 = u8_ptr[offset + 7];\n\n    return b1 | (b2 << 8) | (b3 << 16) | (b4 << 24) | (b5 << 32) | (b6 << 40) | (b7 << 48) || (b8 << 56);\n}\n\ninline void MEM_WRITEU64(void* ptr, u32 offset, u64 val) {\n    unsigned char* u8_ptr = (unsigned char*)ptr;\n\n    u32 a = (val << 32) >> 32;\n    u32 b = val >> 32;\n\n    MEM_WRITEU32(ptr, offset, a);\n    MEM_WRITEU32(ptr, offset + sizeof(u32), b);\n}\n\ninline u32 MEM_SUBALLOCSIZE(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocSize1 + index * 8);\n}\n\ninline u32 MEM_GETSUBALLOCOFFSET(void* ptr, u32 index) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8);\n}\n\ninline void MEM_SETSUBALLOCOFFSET(void* ptr, u32 index, u32 value) {\n    MEM_WRITEU32(ptr, MEM_ALLOCATOR_subAllocFree1 + index * 8, value);\n}\n\ninline u32* MEM_PAGEMASKPTR(void* ptr) {\n    u8* target = (u8*)ptr + MEM_ALLOCATOR_SIZE;\n    return (u32*)target;\n}\n\ninline u32 MEM_HEAPSIZE(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_heapSizeBytes);\n}\n\ninline u32 MEM_ACTIVEALLOCSOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_activeAllocs);\n}\n\ninline u32 MEM_FIRSTPAGEOFFSET(void* ptr) {\n    return MEM_READU32(ptr, MEM_ALLOCATOR_firstPage);\n}\n\ninline u8* MEM_FIRSTPAGEPTR(void* ptr) {\n    return (u8*)ptr + MEM_FIRSTPAGEOFFSET(ptr);\n}\n\ninline u8* MEM_GETPAGEPTR(void* ptr, u32 page) {\n    return MEM_FIRSTPAGEPTR(ptr) + (MEM_PAGE_SIZE * page);\n}\n#endif\n\nvoid* operator new(platform_t, void* p) {\n    return p;\n}\n\n#if MEM_PLATFORM_WASM\nvoid operator delete(void* p)  throw() {\n    PlatformAssert(false, __LOCATION__);\n}\n#endif\n\nstatic void MemInternal_ActivePagesAdded(u8* heap, u32 delta) {\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    u32 maxPages = MEM_READU32(heap, MEM_ALLOCATOR_mostActivePages);\n    activePages += delta;\n    if (activePages > maxPages) {\n        maxPages = activePages;\n        MEM_WRITEU32(heap, MEM_ALLOCATOR_mostActivePages, maxPages);\n    }\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activePages, activePages);\n}\n\nstatic void MemInternal_ActivePagesRemoved(u8* heap, u32 delta) {\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    PlatformAssert(activePages >= delta, __LOCATION__);\n    activePages -= delta;\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activePages, activePages);\n}\n\nmem_cfunc u32 MemGetCurrentNumPages(void* heap) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n    u32 activePages = MEM_READU32(heap, MEM_ALLOCATOR_activePages);\n    return activePages;\n}\n\nmem_cfunc u32 MemGetMostPagesUsedAtOne(void* heap) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n    u32 maxPages = MEM_READU32(heap, MEM_ALLOCATOR_mostActivePages);\n    return maxPages;\n}\n\n\nmem_cfunc i32 MemRelease(void* target) {\n    return MemReleaseFromHeap(gHeap, target);\n}\n\nmem_cfunc void* MemAllocate(u32 bytes, u32 alignment, void* tag) {\n    return MemAllocateOnHeap(gHeap, bytes, alignment, tag);\n}\n\nmem_cfunc void* MemReallocate(void* src, u32 newBytes, void* newTag) {\n    return MemReallocateOnHeap(gHeap, src, newBytes, newTag);\n}\n\nmem_cfunc u32 MemForEachAllocation(fpAllocationInfo callback, void* userData) {\n    return MemForEachAllocationOnHeap(gHeap, callback, userData);\n}\n\nmem_cfunc void* MemPlatformAllocate(u32 bytes) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    return VirtualAlloc(0, bytes, MEM_COMMIT, PAGE_READWRITE);\n#elif defined(MEM_PLATFORM_WASM)\n    return &__heap_base;\n#endif\n}\n\nmem_cfunc void MemPlatformRelease(void* mem) {\n#if defined(MEM_PLATFORM_WINDOWS)\n    VirtualFree(mem, 0, MEM_RELEASE);\n#endif\n}\n\n// Can only manage up to 4 GiB of RAM. This is because internally pointers are keps as offsets\n// and each offset is stored as a u32\nmem_cfunc void* MemInitializeHeap(void* heap, u32 heapSize) {\n    PlatformAssert(heapSize > MEM_PAGE_SIZE * 3, __LOCATION__); // Arbitrary\n\n    // Align to be on a 4 byte boundary. This will cause all masks to be on a 4 byte boundary as well\n    // and will make sure that the page mask is 4 byte aligned (since the header is 40 bytes, and the mask starts right after)\n    u64 alignment = sizeof(u32); // 4\n    u8* align_heap = (u8*)heap;\n    if ((u64)align_heap % alignment != 0) {\n        u64 remainder = (u64)align_heap % alignment;\n        align_heap += (u32)alignment - (u32)remainder;\n        heapSize -= (u32)alignment - (u32)remainder;\n    }\n    gHeap = align_heap;\n\n    u32 numPages = heapSize / MEM_PAGE_SIZE;\n    u32 pageMaskCount = (numPages / 32) + (numPages % 32 != 0 ? 1 : 0);\n\n    PlatformAssert(numPages >= 0, __LOCATION__);\n\n    u32 overheadBytes = (MEM_ALLOCATOR_SIZE + pageMaskCount * sizeof(u32));\n\n    u32 overheadPageCount = (overheadBytes / MEM_PAGE_SIZE) + (overheadBytes % MEM_PAGE_SIZE != 0 ? 1 : 0);\n    u32 firstPageOffset = overheadPageCount * MEM_PAGE_SIZE; // 0 = 0, 1 = 4096, etc...\n\n    // As arguments, you pass in how big each sub-alloctors chunks should be. IE, i want this sub-allocator\n    // to allocate 72 byte chunks. Then there would be \"pageSize / (72 + sizeof(header))\" blocks in each page\n\n    // If you request an allocation that's MemAlloc(72, 4), it wouldn't fit into the allocator, because that\n    // allocation needs 72 + 4 bytes. So it would bucket over to the next allocator.\n\n    // In the above examples, 72 would be written to the allocator struct as a sub allocator size.\n    u32 subAlloc1Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 8)) / 8;\n    u32 subAlloc2Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 4)) / 4;\n    u32 subAlloc3Size = ((MEM_PAGE_SIZE - sizeof(u32)) - (MEM_ALLOCATION_HEADER_SIZE * 2)) / 2;\n\n    // struct Allocator (40 bytes)\n    /* u32 heapSizeBytes */ MEM_WRITEU32(align_heap, sizeof(u32) * 0, heapSize);             // 0\n    /* u32 overheadPages */ MEM_WRITEU32(align_heap, sizeof(u32) * 1, overheadPageCount);    // 4\n    /* u32 firstPage     */ MEM_WRITEU32(align_heap, sizeof(u32) * 2, firstPageOffset);      // 8\n    /* u32 activeAllocs  */ MEM_WRITEU32(align_heap, sizeof(u32) * 3, 0);                    // 12\n    /* u32 subAllocFree1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 4, 0);                    // 16\n    /* u32 subAllocSize1 */ MEM_WRITEU32(align_heap, sizeof(u32) * 5, subAlloc1Size);        // 20\n    /* u32 subAllocFree2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 6, 0);                    // 24\n    /* u32 subAllocSize2 */ MEM_WRITEU32(align_heap, sizeof(u32) * 7, subAlloc2Size);        // 28\n    /* u32 subAllocFree3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 8, 0);                    // 32\n    /* u32 subAllocSize3 */ MEM_WRITEU32(align_heap, sizeof(u32) * 9, subAlloc3Size);        // 36\n    /* u32 usedPages     */ MEM_WRITEU32(align_heap, sizeof(u32) * 10, overheadPageCount);   // 40\n    /* u32 maxUedAtOnce  */ MEM_WRITEU32(align_heap, sizeof(u32) * 11, overheadPageCount);   // 44\n\n    // Clear page mask (and set overhead pages)\n    for (u32 page = 0; page < pageMaskCount; ++page) {\n        MEM_WRITEU32(align_heap, MEM_ALLOCATOR_SIZE + page * sizeof(u32), (page < overheadPageCount));\n    }\n\n    return align_heap;\n}\n\n// Returns true if all memory has been released. \nmem_cfunc int MemShutdownHeap(void* heap) {\n#if _DEBUG\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    u32 numUnreleasedAllocations = 0;\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* label = (const char*)_label;\n\n#if MEM_ENABLE_ALLOCGUARD\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED, __LOCATION__);\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED, __LOCATION__);\n#endif\n\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        numUnreleasedAllocations += 1;\n    }\n#endif\n\n    bool allAllocationsReleased = MEM_ACTIVEALLOCSOFFSET(heap) == 0;\n    bool subAllocPool0Empty = MEM_GETSUBALLOCOFFSET(heap, 0) == 0;\n    bool subAllocPool1Empty = MEM_GETSUBALLOCOFFSET(heap, 1) == 0;\n    bool subAllocPool2Empty = MEM_GETSUBALLOCOFFSET(heap, 2) == 0;\n\n    PlatformAssert(allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty, __LOCATION__);\n    return allAllocationsReleased && subAllocPool0Empty && subAllocPool1Empty && subAllocPool2Empty;\n}\n\nmem_cfunc u32 MemGetPageSize() {\n    return MEM_PAGE_SIZE;\n}\n\nmem_cfunc u32* MemGetPageMask() {\n    return (u32*)((u8*)gHeap + MEM_ALLOCATOR_SIZE);\n}\n\nmem_cfunc u32 MemGetHeapSize() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_heapSizeBytes);\n}\n\nmem_cfunc u32 MemGetNumOverheadPages() {\n    return MEM_READU32(gHeap, MEM_ALLOCATOR_overheadPages);\n}\n\nmem_cfunc u64 MemGetTag64(void* _mem) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    return MEM_READU64(header, MEM_ALLOCATION_tag);\n}\n\nmem_cfunc void MemSetTag64(void* _mem, u64 tag) {\n    u8* mem = (u8*)_mem;\n    u16 padding = MEM_READU16((u8*)_mem - 2, 0);\n    u8* header = mem - padding - MEM_ALLOCATION_HEADER_SIZE;\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);\n}\n\nmem_cfunc u32 MemGetTag32(void* _mem) {\n    return (u32)MemGetTag64(_mem);\n}\n\nmem_cfunc void MemSetTag32(void* _mem, u32 tag) {\n    MemSetTag64(_mem, tag);\n}\n\n// Returns 0 on error, or the index of the page where a range of numPages starts\nstatic u32 MemInternal_FindFreePages(void* heap, u32 numPages) {\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(numPages >= 1, __LOCATION__);\n\n    // Find the required number of pages\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    u32 heapNumPages = MEM_HEAPSIZE(heap) / MEM_PAGE_SIZE;\n\n    // Find available pages\n    u32 startPage = 0; // Page 0 is invalid. First page must be reserved for overhead\n    u32 pageCount = 0;\n    for (u32 i = 1; i < heapNumPages; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n\n        if (pageMask[index] & (1 << bit)) { // Page is in use\n            startPage = 0;\n            pageCount = 0;\n        }\n        else { // Free page\n            if (startPage == 0) { // New range\n                startPage = i;\n                pageCount = 1;\n                if (numPages == 1) {\n                    break;\n                }\n            }\n            else { // Expand range\n                pageCount += 1;\n                if (pageCount == numPages) {\n                    break;\n                }\n            }\n        }\n    }\n\n    PlatformAssert(startPage != 0, __LOCATION__);\n    PlatformAssert(pageCount == numPages, __LOCATION__);\n\n    return startPage;\n}\n\nstatic bool MemInternal_ClaimPages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if ((pageMask[index] & (1 << bit))) {\n            PlatformAssert(false, __LOCATION__);\n            return false; // Error\n        }\n        pageMask[index] |= (1 << bit);\n    }\n\n    return true;\n}\n\nmem_cfunc bool MemIsPageUsed(u32 pageIndex, void* heap) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    u32 index = pageIndex / 32;\n    u32 bit = pageIndex % 32;\n\n    return (bool)(pageMask[index] & (1 << bit));\n}\n\nstatic bool MemInternal_ReleasePages(void* heap, u32 startPage, u32 pageCount) {\n    if (startPage == 0 || pageCount == 0) {\n        return false;\n    }\n\n    u32* pageMask = MEM_PAGEMASKPTR(heap);\n    for (u32 i = startPage, count = startPage + pageCount; i < count; ++i) {\n        u32 index = i / 32;\n        u32 bit = i % 32;\n        if (!(pageMask[index] & (1 << bit))) {\n            PlatformAssert(false, __LOCATION__);\n            return false; // Error\n        }\n        pageMask[index] &= ~(1 << bit);\n    }\n\n    return true;\n}\n\nstatic void MemInternal_WriteAllocationHeader(void* header, u32 startPage, u32 pageCount, u32 allocPrev, u32 allocNext, u64 tag) {\n    PlatformAssert(header != 0, __LOCATION__);\n\n    // struct Allocation\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 startPage    */ MEM_WRITEU16(header, MEM_ALLOCATION_startPage, startPage);   // 0\n    /* u16 pageCount    */ MEM_WRITEU16(header, MEM_ALLOCATION_pageCount, pageCount);   // 2\n    /* u32 allocPrev    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, allocPrev);   // 4\n    /* u32 allocNext    */ MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, allocNext);   // 8\n    /* u64 tag          */ MEM_WRITEU64(header, MEM_ALLOCATION_tag, tag);               // 12\n#if MEM_ENABLE_ALLOCGUARD\n    /* u32 magic        */ MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, pageCount == 0 ? (MEM_ALLOCACTION_MAGIC_SUB_ACTIVE) : (MEM_ALLOCACTION_MAGIC_MAIN));\n#endif\n    /* u16 padding      */ MEM_WRITEU16(header, MEM_ALLOCATION_padding, 0);// Only sub-allocators use padding\n}\n\nstatic void MemInternal_AddAllocationToActiveListList(void* heap, void* header) {\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(header != 0, __LOCATION__);\n    PlatformAssert(header > heap, __LOCATION__);\n\n    u32 offset = (u8*)header - (u8*)heap;\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset != 0) {\n        u8* headHeader = (u8*)heap + headOffset;\n        // Replace the prev \"pointer\" (really offset), which should be 0 (assert?) with our own\n        MEM_WRITEU32(headHeader, MEM_ALLOCATION_allocPrev, offset); // Set the prev pointer of the old head to the current allocation\n    }\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, headOffset); // Set the next ptr of current allocation to old head\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, offset); // Set the current allocation as the new head\n}\n\n#if MEM_ENABLE_ALLOCGUARD\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header, u32 magic) {\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == magic);\n    PlatformAssert(magicTail == magic);\n#else\nstatic void MemInternal_RemoveAllocationFromActiveList(void* heap, void* header) {\n#endif\n\n    u32 offset = (u8*)header - (u8*)heap;\n    u32 prev = MEM_READU32(header, MEM_ALLOCATION_allocPrev);\n    u32 next = MEM_READU32(header, MEM_ALLOCATION_allocNext);\n\n    if (next != 0) { // Reling next\n        u8* nextPtr = (u8*)heap + next;\n        MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n    }\n\n    if (prev != 0) { // Relink prev\n        u8* prevPtr = (u8*)heap + prev;\n        MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n    }\n\n    u32 headOffset = MEM_READU32(heap, MEM_ALLOCATOR_activeAllocs);\n    if (headOffset == offset) { // Update list head\n        MEM_WRITEU32(heap, MEM_ALLOCATOR_activeAllocs, next); // Head was detached, next is new head\n    }\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, 0);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, 0);\n\n    // Header magic is expected to be set to free by caller\n}\n\nstatic void MemInternal_RemoveSubAllocationsFromFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    PlatformAssert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* allocPtr = (u8*)(mask + 2);\n\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / (u32)stride;\n    for (u32 i = 0; i < numAllocationsInBlock; ++i) {\n        u32 offset = (u8*)allocPtr - (u8*)heap;\n        u32 prev = MEM_READU32(allocPtr, MEM_ALLOCATION_allocPrev);\n        u32 next = MEM_READU32(allocPtr, MEM_ALLOCATION_allocNext);\n\n        if (next != 0) { // Relink next\n            u8* nextPtr = (u8*)heap + next;\n            MEM_WRITEU32(nextPtr, MEM_ALLOCATION_allocPrev, prev);\n        }\n\n        if (prev != 0) { // Relink prev\n            u8* prevPtr = (u8*)heap + prev;\n            MEM_WRITEU32(prevPtr, MEM_ALLOCATION_allocNext, next);\n        }\n\n        // Remove any list headers\n        if (offset == MEM_GETSUBALLOCOFFSET(heap, 0)) {\n            MEM_SETSUBALLOCOFFSET(heap, 0, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 1)) {\n            MEM_SETSUBALLOCOFFSET(heap, 1, next);\n        }\n        else if (offset == MEM_GETSUBALLOCOFFSET(heap, 2)) {\n            MEM_SETSUBALLOCOFFSET(heap, 2, next);\n        }\n\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocPrev, 0);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_allocNext, 0);\n\n#if MEM_ENABLE_ALLOCGUARD\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n        MEM_WRITEU32(allocPtr, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n        u8* write = allocPtr + MEM_ALLOCATION_magicTail + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n        write = allocPtr + MEM_ALLOCATION_magicHead + sizeof(u32);\n        *write = '\\0'; // Null out bit after magic\n#endif\n\n        allocPtr = allocPtr + stride;\n    }\n}\n\nstatic void MemInternal_AddSubAllocationToFreeList(void* heap, u8 * header) {\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n\n    u32 subAllocatorIndex = 0;\n    u32 subAlloc1Stride = MEM_SUBALLOCSIZE(heap, 0) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc2Stride = MEM_SUBALLOCSIZE(heap, 1) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 subAlloc3Stride = MEM_SUBALLOCSIZE(heap, 2) + MEM_ALLOCATION_HEADER_SIZE;\n    if (stride == (u16)subAlloc1Stride) {\n        subAllocatorIndex = 0;\n    }\n    else if (stride == (u16)subAlloc2Stride) {\n        subAllocatorIndex = 1;\n    }\n    else if (stride == (u16)subAlloc3Stride) {\n        subAllocatorIndex = 2;\n    }\n    else {\n        PlatformAssert(false, __LOCATION__);//  Stride should be one of the known sub-allocator strides\n    }\n\n    u32 prev = 0; // Adding as head, always 0\n    u32 next = MEM_GETSUBALLOCOFFSET(heap, subAllocatorIndex); // Current head\n\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocPrev, prev);\n    MEM_WRITEU32(header, MEM_ALLOCATION_allocNext, next);\n\n    u32 headerOffset = header - (u8*)heap;\n    if (next != 0) { // Set next prev to this\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, headerOffset);\n    }\n\n    MEM_SETSUBALLOCOFFSET(heap, subAllocatorIndex, headerOffset); // Set list head to this\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n}\n\nstatic void* MemInternal_SubAllocate(void* heap, u32 subAlloctorIndex, u32 bytes, u32 alignment, u64 tag) {\n    PlatformAssert(subAlloctorIndex <= 2, __LOCATION__);\n    PlatformAssert(heap != 0, __LOCATION__);\n    PlatformAssert(bytes != 0, __LOCATION__);\n\n    u32 subAllocHeaderStride = MEM_SUBALLOCSIZE(heap, subAlloctorIndex) + MEM_ALLOCATION_HEADER_SIZE;\n    u32 numAllocationsInBlock = (MEM_PAGE_SIZE - sizeof(u32)) / subAllocHeaderStride; // First 32 bits in sub-alloc page is a flags mask.\n    PlatformAssert(numAllocationsInBlock >= 2, __LOCATION__);\n    u32 freeListOffset = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex);\n\n    // If free blocks for this sub-allocator don't exist, create some.\n    if (freeListOffset == 0) {\n        u32 page = MemInternal_FindFreePages(heap, 1);\n        PlatformAssert(page > 0, __LOCATION__);\n        if (!MemInternal_ClaimPages(heap, page, 1)) {\n            PlatformAssert(false, __LOCATION__);\n            return 0;\n        }\n        MemInternal_ActivePagesAdded((u8*)heap, 1);\n\n        u8* header = MEM_GETPAGEPTR(heap, page);\n        u16* subAllocationMask = (u16*)header;\n        *subAllocationMask = 0;\n        u16* subAllocationStride = subAllocationMask + 1;\n        *subAllocationStride = subAllocHeaderStride;\n\n        header += sizeof(u32);\n\n        for (u32 i = 0; i < numAllocationsInBlock; ++i) { // struct Allocation\n            u32 prev = 0; // Adding as head, always 0\n            u32 next = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n\n            MemInternal_WriteAllocationHeader(header, page, 0, prev, next, (u64)\"uninitialized\"); // Sub allocation fence is active\n            //\n            MemInternal_AddSubAllocationToFreeList(heap, header); // Sub allocation fence is free\n\n            header += subAllocHeaderStride;\n        }\n    }\n\n    // Free block is guaranteed to exist. Grab one.\n    u32 head = MEM_GETSUBALLOCOFFSET(heap, subAlloctorIndex); // Current head\n    u8* allocHeader = (u8*)heap + head;\n\n    // Align the allocation (if needed)\n    u8* allocation = allocHeader + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    u16 padding = 0;\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        padding = (u16)(alignment - (u32)remainder);\n        allocation += padding;\n    }\n\n    // Update header data\n    MEM_WRITEU64(allocHeader, MEM_ALLOCATION_tag, tag); // Update tag\n    MEM_WRITEU16(allocHeader, MEM_ALLOCATION_padding, padding);\n    MEM_WRITEU16(allocation - 2, 0, padding);\n    \n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n    PlatformAssert(MEM_READU32(allocHeader, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_SUB_FREE);\n#endif\n\n    // Get the pointer to the current pages used bitmask, and find the right bit\n    u32 page = MEM_READU16(allocHeader, MEM_ALLOCATION_startPage);//head / MEM_PAGE_SIZE; // Also stored in allocHeader\n    u16* mask = (u16*)MEM_GETPAGEPTR(heap, page);\n    u8* firstAllocPtr = (u8*)mask + sizeof(u16) + sizeof(u16);\n\n    // Claim the allocation as used\n    u32 index = (allocHeader - firstAllocPtr) / subAllocHeaderStride;\n    u16 _mask = *mask;\n    PlatformAssert(!(_mask & (1 << index)), __LOCATION__); // Assume it was off before\n    _mask |= (1 << index);\n    *mask = _mask;\n\n    // If there is a next pointer, unhook this from it's prev, and set it as the new sub-alloc header\n    u32 next = MEM_READU32(allocHeader, MEM_ALLOCATION_allocNext);\n    if (next != 0) {\n        u8* nextHeader = (u8*)heap + next;\n        MEM_WRITEU32(nextHeader, MEM_ALLOCATION_allocPrev, 0); // Set next prev to 0 (unlink head)\n    }\n    MEM_SETSUBALLOCOFFSET(heap, subAlloctorIndex, next); // Set next to be the new head\n\n    MemInternal_AddAllocationToActiveListList(heap, allocHeader); // Will reset allocHeader prev and next pointers\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    MEM_WRITEU32(allocHeader, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    return allocation;\n}\n\nstatic i32 MemInternal_SubRelease(void* heap, void* target) {\n    PlatformAssert(target != 0, __LOCATION__);\n\n    u8* allocation = (u8*)target;\n    u16 padding = MEM_READU16(allocation - 2, 0);\n    u8* header = allocation - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n    PlatformAssert(magicTail == MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#endif\n\n    u32 page = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16* mask = (u16*)(MEM_GETPAGEPTR(heap, page));\n    u16 stride = *(mask + 1);\n    u8* firstAllocPtr = (u8*)(mask + 2);\n    u32 index = (header - firstAllocPtr) / (u32)stride;\n\n    u64 _tag = MEM_READU64(header, MEM_ALLOCATION_tag);\n    const char* tag = (const char*)_tag;\n    PlatformAssert(MEM_READU16(header, MEM_ALLOCATION_pageCount) == 0, __LOCATION__);\n\n    // Release (sub allocation) mask\n    u16 _mask = *mask;\n    if (!(_mask & (1 << index))) {  // Assume it was on before\n        PlatformAssert(false, __LOCATION__);\n        return 0;\n    }\n    _mask &= ~(1 << index);\n    *mask = _mask;\n\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_SUB_ACTIVE);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n    MemInternal_AddSubAllocationToFreeList(heap, header);\n\n    if (_mask == 0) { // Page is empty, release it\n        MemInternal_RemoveSubAllocationsFromFreeList(heap, header);  // Sets header magic\n        MemInternal_ReleasePages(heap, page, 1);\n        MemInternal_ActivePagesRemoved((u8*)heap, 1);\n    }\n\n    return 1;\n}\n\nmem_cfunc void* MemAllocateOnHeap(void* heap, u32 bytes, u32 alignment, void* _tag) {\n    u64 tag = (u64)_tag;\n\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (bytes == 0) {\n        return 0;\n    }\n\n    // Early out for any sub-allocators\n#if MEM_ENABLE_SUBALLOCATORS\n    if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 0)) {\n        return MemInternal_SubAllocate(heap, 0, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 1)) {\n        return MemInternal_SubAllocate(heap, 1, bytes, alignment, tag);\n    }\n    else if (bytes + alignment < MEM_SUBALLOCSIZE(heap, 2)) {\n        return MemInternal_SubAllocate(heap, 2, bytes, alignment, tag);\n    }\n#endif\n\n    u32 totalAllocationSize = bytes + alignment + MEM_ALLOCATION_HEADER_SIZE;\n    u32 pageCount = totalAllocationSize / MEM_PAGE_SIZE + (totalAllocationSize % MEM_PAGE_SIZE == 0 ? 0 : 1);\n\n    // Find and claim available pages\n    u32 startPage = MemInternal_FindFreePages(heap, pageCount);\n    PlatformAssert(startPage != 0, __LOCATION__);\n    if (!MemInternal_ClaimPages(heap, startPage, pageCount)) {\n        PlatformAssert(false, __LOCATION__);\n        return 0; // Error\n    }\n\n    // Create allocation header\n    u8* memory = MEM_GETPAGEPTR(heap, startPage);\n    u8* allocation = memory + MEM_ALLOCATION_HEADER_SIZE;\n    u64 address = (u64)allocation; // Align the allocation\n    if (alignment != 0 && address % alignment != 0) {\n        u64 remainder = address % alignment;\n        allocation += alignment - (u32)remainder;\n    }\n    u8* header = allocation - MEM_ALLOCATION_HEADER_SIZE;\n\n    MemInternal_WriteAllocationHeader(header, startPage, pageCount, 0, 0, tag);\n    MemInternal_AddAllocationToActiveListList(heap, header); // Will set header prev and next pointers\n    MemInternal_ActivePagesAdded((u8*)heap, pageCount);\n\n    return allocation;\n}\n\n// Returns true if the memory was successfully released\n// Returns true if the memory being passed in is NULL\nmem_cfunc i32 MemReleaseFromHeap(void* heap, void* target) {\n    if (heap == 0) {\n        heap = gHeap;\n    }\n\n    if (target == 0) { // Sage release\n        return true;\n    }\n\n    u16 padding = MEM_READU16((u8*)target - 2, 0);\n    u8* header = (u8*)target - padding - MEM_ALLOCATION_HEADER_SIZE;\n    u32 offset = header - (u8*)heap;\n\n    u16 startPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u16 pageCount = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n\n    // Delegate to sub-allocator\n#if MEM_ENABLE_SUBALLOCATORS\n    if (pageCount == 0) { // No page count means it's a sub-allocator\n        return MemInternal_SubRelease(heap, target);\n    }\n#endif\n\n\n#if MEM_ENABLE_ALLOCGUARD\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) == MEM_ALLOCACTION_MAGIC_MAIN);\n    PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) == MEM_ALLOCACTION_MAGIC_MAIN);\n#endif\n\n    // Clear the pages that where in use\n    MemInternal_ReleasePages(heap, startPage, pageCount);\n    MemInternal_ActivePagesRemoved((u8*)heap, pageCount);\n\n#if MEM_ENABLE_ALLOCGUARD\n    MemInternal_RemoveAllocationFromActiveList(heap, header, MEM_ALLOCACTION_MAGIC_MAIN);\n#else\n    MemInternal_RemoveAllocationFromActiveList(heap, header);\n#endif\n\n#if MEM_ENABLE_ALLOCGUARD\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicHead, MEM_ALLOCACTION_MAGIC_RELEASED);\n    MEM_WRITEU32(header, MEM_ALLOCATION_magicTail, MEM_ALLOCACTION_MAGIC_RELEASED);\n\n    u8* write = header + MEM_ALLOCATION_magicHead + sizeof(u32);\n    *write = '\\0';\n    write = header + MEM_ALLOCATION_magicTail + sizeof(u32);\n    *write = '\\0';\n#endif\n\n    return 1;\n}\n\nmem_cfunc u32 MemForEachAllocationOnHeap(void* heap, fpAllocationInfo callback, void* userData) {\n    u32 numAllocations = 0;\n\n    u32 allocationOffset = MEM_ACTIVEALLOCSOFFSET(heap);\n    while (allocationOffset != 0) {\n        u8* header = (u8*)heap + allocationOffset;\n        u8* mem = header + MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicHead) != MEM_ALLOCACTION_MAGIC_RELEASED);\n        PlatformAssert(MEM_READU32(header, MEM_ALLOCATION_magicTail) != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n        u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n        u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n        allocationOffset = MEM_READU32(header, MEM_ALLOCATION_allocNext); // Iterate to next element\n        u64 _label = MEM_READU64(header, MEM_ALLOCATION_tag);\n        const char* loc = (const char*)_label;\n\n        if (callback != 0) {\n            callback(numAllocations, mem, firstPage, numPages, (void*)_label, userData);\n        }\n        numAllocations += 1;\n    }\n\n    return numAllocations;\n}\n\nmem_cfunc void* MemClear(void* dst, u32 bytes) {\n    return MemSet(dst, 0, bytes);\n}\n\nmem_cfunc void* MemReallocateOnHeap(void* heap, void* src, u32 newBytes, void* newTag) {\n    if (src == 0) {\n        return MemAllocateOnHeap(heap, newBytes, 4, newTag);\n    }\n    u16 padding = MEM_READU16((u8*)src - 2, 0);\n    u8* header = (u8*)src - padding - MEM_ALLOCATION_HEADER_SIZE;\n\n#if MEM_ENABLE_ALLOCGUARD\n    u32 magicHead = MEM_READU32(header, MEM_ALLOCATION_magicHead);\n    u32 magicTail = MEM_READU32(header, MEM_ALLOCATION_magicTail);\n\n    PlatformAssert(magicHead != MEM_ALLOCACTION_MAGIC_RELEASED);\n    PlatformAssert(magicTail != MEM_ALLOCACTION_MAGIC_RELEASED);\n#endif\n\n    u32 firstPage = MEM_READU16(header, MEM_ALLOCATION_startPage);\n    u32 numPages = MEM_READU16(header, MEM_ALLOCATION_pageCount);\n    if (numPages == 0) {\n        numPages = 1;\n    }\n\n    u8* lastByte = MEM_GETPAGEPTR(heap, firstPage);\n    lastByte += numPages * MEM_PAGE_SIZE;\n    u32 maxAllocBytes = lastByte - (u8*)src;\n\n    u32 bytesToCopy = newBytes;\n    if (maxAllocBytes < bytesToCopy) {\n        bytesToCopy = maxAllocBytes;\n    }\n\n    void* newMem = MemAllocateOnHeap(heap, newBytes, 4, newTag); // Realloc is always 4 byte aligned. Consider storing alignment in each allocation as well?\n    if (bytesToCopy < newBytes) {\n        MemSet((u8*)newMem + bytesToCopy, 0, newBytes - bytesToCopy);\n    }\n    MemCopy(newMem, src, bytesToCopy);\n    MemRelease(src);\n\n    return newMem;\n}\n\nmem_cfunc void* MemCopy(void* _dst, const void* _src, u32 bytes) {\n    u8* dst = (u8*)_dst;\n    const u8* src = (const u8*)_src;\n\n    u32 delta = 0; // Check for overlap\n    if ((u32)dst < (u32)src) {\n        delta = (u32)src - (u32)dst;\n    }\n    else {\n        delta = (u32)dst - (u32)src;\n    }\n    PlatformAssert(delta >= bytes, __LOCATION__);\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = src[b];\n    }\n\n    return dst;\n}\n\nmem_cfunc void* MemSet(void* _dst, u8 val, u32 bytes) {\n    u8* dst = (u8*)_dst;\n\n    for (unsigned int b = 0; b < bytes; ++b) {\n        dst[b] = val;\n    }\n\n    return dst;\n}\n\nmem_cfunc i32 MemCompare(const void* _a, const void* _b, u32 bytes) {\n    const u8* a = (const u8*)_a;\n    const u8* b = (const u8*)_b;\n    for (u32 i = 0; i < bytes; ++i) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        else if (b[i] < a[i]) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nmem_cfunc void* MemMove(void* destination, const void* source, u32 num) {\n    void* tmp = MemAlloc(num);\n    MemCopy(tmp, source, num);\n    MemCopy(destination, tmp, num);\n    MemRelease(tmp);\n    return destination;\n}","#include \"window.h\"\n\nextern \"C\" u32 AsciiToScancode(char val) {\n\tif (val >= 'a' && val <= 'z') {\n\t\treturn KeyboardCodeA + (val = 'a');\n\t}\n\tif (val >= 'A' && val <= 'Z') {\n\t\treturn KeyboardCodeA + (val = 'A');\n\t}\n\tif (val >= '0' && val <= '9') {\n\t\treturn KeyboardCode0 + (val = '0');\n\t}\n\n\tswitch (val) {\n\tcase '\\t': return KeyboardCodeTab;\n\tcase '\\\\': return KeyboardCodeBackslash;\n\tcase '\\'': return KeyboardCodeQoute;\n\tcase '`': return KeyboardCodeTick;\n\tcase '~': return KeyboardCodeTilde;\n\tcase '!': return KeyboardCode1;\n\tcase '@': return KeyboardCode2;\n\tcase '#': return KeyboardCode3;\n\tcase '$': return KeyboardCode4;\n\tcase '%': return KeyboardCode5;\n\tcase '^': return KeyboardCode6;\n\tcase '&': return KeyboardCode7;\n\tcase '*': return KeyboardCode8;\n\tcase '(': return KeyboardCode9;\n\tcase ')': return KeyboardCode0;\n\tcase '_': return KeyboardCodeUnderscore;\n\tcase '+': return KeyboardCodePlus;\n\tcase '-': return KeyboardCodeMinus;\n\tcase '=': return KeyboardCodeEquals;\n\tcase '[': return KeyboardCodeLBracket;\n\tcase '{': return KeyboardCodeLBrace;\n\tcase ']': return KeyboardCodeRbracket;\n\tcase '}': return KeyboardCodeRBrace;\n\tcase '|': return KeyboardCodeCarray;\n\tcase ';': return KeyboardCodeSemicolon;\n\tcase ':': return KeyboardCodeColon;\n\tcase '\"': return KeyboardCodeQoute;\n\tcase ',': return KeyboardCodeComma;\n\tcase '<': return KeyboardCodeLess;\n\tcase '.': return KeyboardCodePeriod;\n\tcase '>': return KeyboardCodeGreater;\n\tcase '/': return KeyboardCodeSlash;\n\tcase '?': return KeyboardCodeQuestionmark;\n\tdefault: return 0;\n\t}\n\n\treturn 0;\n}\n\nextern \"C\" char ScanCodeToAscii(u32 scanCode, bool shift) {\n\tif (scanCode >= KeyboardCodeA && scanCode <= KeyboardCodeZ) {\n\t\tif (shift) {\n\t\t\treturn 'A' + (scanCode - KeyboardCodeA);\n\t\t}\n\t\telse {\n\t\t\treturn 'a' + (scanCode - KeyboardCodeA);\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeDelete) {\n\t\treturn '\\a'; // Hacky at best :(\n\t}\n\telse if (scanCode == KeyboardCodeBackspace) { //    3\n\t\treturn '\\b';\n\t}\n\telse if (scanCode == KeyboardCodeReturn) { //    5\n\t\treturn '\\n';\n\t}\n\telse if (scanCode == KeyboardCodeSpace) { //   11\n\t\treturn ' ';\n\t}\n\telse if (scanCode == KeyboardCode0) { //   17\n\t\tif (shift) {\n\t\t\treturn ')';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode1) { //   18\n\t\tif (shift) {\n\t\t\treturn '!';\n\t\t}\n\t\telse {\n\t\t\treturn '1';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode2) { //   19\n\t\tif (shift) {\n\t\t\treturn '@';\n\t\t}\n\t\telse {\n\t\t\treturn '2';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode3) { //   20\n\t\tif (shift) {\n\t\t\treturn '#';\n\t\t}\n\t\telse {\n\t\t\treturn '3';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode4) { //   21\n\t\tif (shift) {\n\t\t\treturn '$';\n\t\t}\n\t\telse {\n\t\t\treturn '4';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode5) { //   22\n\t\tif (shift) {\n\t\t\treturn '%';\n\t\t}\n\t\telse {\n\t\t\treturn '5';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode6) { //   23\n\t\tif (shift) {\n\t\t\treturn '^';\n\t\t}\n\t\telse {\n\t\t\treturn '6';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode7) { //   24\n\t\tif (shift) {\n\t\t\treturn '&';\n\t\t}\n\t\telse {\n\t\t\treturn '7';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode8) { //   25\n\t\tif (shift) {\n\t\t\treturn '*';\n\t\t}\n\t\telse {\n\t\t\treturn '8';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCode9) { //   26\n\t\tif (shift) {\n\t\t\treturn '(';\n\t\t}\n\t\telse {\n\t\t\treturn '9';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeColon) { //   53\n\t\tif (shift) {\n\t\t\treturn ':';\n\t\t}\n\t\telse {\n\t\t\treturn ';';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeEquals) { //   54\n\t\tif (shift) {\n\t\t\treturn '+';\n\t\t}\n\t\telse {\n\t\t\treturn '=';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeLess) { //   55\n\t\tif (shift) {\n\t\t\treturn '<';\n\t\t}\n\t\telse {\n\t\t\treturn ',';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeUnderscore) { //   56\n\t\tif (shift) {\n\t\t\treturn '_';\n\t\t}\n\t\telse {\n\t\t\treturn '-';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeGreater) { //   57\n\t\tif (shift) {\n\t\t\treturn '>';\n\t\t}\n\t\telse {\n\t\t\treturn '.';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeQuestionmark) { //   58\n\t\tif (shift) {\n\t\t\treturn '?';\n\t\t}\n\t\telse {\n\t\t\treturn '/';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeTick) { //   59\n\t\tif (shift) {\n\t\t\treturn '~';\n\t\t}\n\t\telse {\n\t\t\treturn '`';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeLBrace) { //   60\n\t\tif (shift) {\n\t\t\treturn '{';\n\t\t}\n\t\telse {\n\t\t\treturn '[';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeCarray) { //   61\n\t\tif (shift) {\n\t\t\treturn '|';\n\t\t}\n\t\telse {\n\t\t\treturn '\\\\';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeRBrace) { //   62\n\t\tif (shift) {\n\t\t\treturn '}';\n\t\t}\n\t\telse {\n\t\t\treturn ']';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeQoute) { //   63\n\t\tif (shift) {\n\t\t\treturn '\"';\n\t\t}\n\t\telse {\n\t\t\treturn '\\'';\n\t\t}\n\t}\n\telse if (scanCode == KeyboardCodeTab) { //   64\n\t\treturn '\\t';\n\t}\n\n\treturn 0;\n}","#include \"sort.h\"\n#include \"../debt/qsort.h\"\n\nstatic void SortInternal_Swap(void* a, void* b, unsigned int bytes) {\n\tunsigned char* x = (unsigned char*)a;\n\tunsigned char* y = (unsigned char*)b;\n\tunsigned char z = 0;\n\tfor (unsigned int b = 0; b < bytes; ++b) {\n\t\tz = x[b];\n\t\tx[b] = y[b];\n\t\ty[b] = z;\n\t}\n}\n\nvoid QSort(void* base, unsigned int nitems, unsigned int size, int (*compare)(const void*, const void*)) {\n\tunsigned char* m = (unsigned char*)base;\n\n#define QSRT_LESS(x, y) (compare(m + (x) * size, m + (y) * size) < 0)\n#define QSRT_SWAP(i, j) SortInternal_Swap(m + (i) * size, m + (j) * size, size)\n\tQSORT(nitems, QSRT_LESS, QSRT_SWAP);\n#undef QSRT_LESS\n#undef QSRT_SWAP\n}","#include \"draw2d.h\"\n\n#include \"../platform/memory.h\"\n#include \"../platform/math.h\"\n#include \"../framework/mat4.h\"\n#include \"../platform/graphics.h\"\n#include \"../debt/stb_image.h\"\n#include \"../platform/loader.h\"\n#include \"../debt/stb_truetype.h\"\n#include \"../debt/stb_rect_pack.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"vector.h\"\n\n#define DRAW2D_MAXVERTS 30000\n#define DRAW2D_MAXINDICES 100000\n#define DRAW2D_MAX_IMAGES 5\n#define DRAW2D_TEXTURE_PACKER_ATLAS_SIZE 1024\n#define DRAW2D_FONT_MAX_LINE_HEIGHT 512\n#define DRAW2D_NUM_ELLIPSE_SEGMENTS 45\n\nnamespace Draw2D {\n    namespace Internal {\n        struct Image {\n            u32 id; // Graphics System Texture ID\n            u32 width;\n            u32 height;\n        };\n\n        struct Vertex { // 36\n            vec2 position;\n            vec2 uv;\n            vec4 color;\n            u16 texture;\n            u16 padding;\n        };\n\n        struct Buffer {\n            u32 vboId;\n            u32 iboId;\n            u32 vaoId;\n        };\n\n        struct AsciiFontInstance {\n            u32 lineHeight;\n            f32 stbScale;\n            f32 scaledLineGap;\n            int advances[256];\n            ivec4 renderRects[256];\n            stbrp_rect packedGlyphs[256];\n            struct AsciiFont* prototype;\n        };\n\n        struct AsciiFont {\n            stbtt_fontinfo fontInfo;\n            i32 unscaledLineGap;\n            bool ownsMemory; // NOTE: Could stuff this into stbtt_fontinfo::userdata\n            bool active; // NOTE: Same as above, make the pointer into a bit mask.\n            Vector<AsciiFontInstance> instances;\n        };\n\n        struct State {\n            Vector<vec4> clipStack;\n            vec4 activeClip;\n\n            Vector<AsciiFont> loadedFonts;\n            Vector<Image> loadedImages;\n\n            u32 fontAtlas;\n            stbrp_context fontPacker;\n            stbrp_node* fontPackerNodes;\n            unsigned char* glyphBuffer;\n\n            u32 designWidth;\n            u32 designHeight;\n            f32 designDpi;\n            u32 displayWidth;\n            u32 displayHeight;\n\n            // Flushable\n            Vertex* vertices;\n            u32   numVertices;\n\n            u16* indices;\n            u32   numIndices;\n\n            u32 boundImages[DRAW2D_MAX_IMAGES];\n            u32 imgUniformSlots[DRAW2D_MAX_IMAGES];\n            u32 numBoundImages;\n\n            Buffer displayBuffer;\n\n            u32 imageShader; // Draw a tinted image.\n            //u32 imageShaderScreenSizeUniform;\n            u32 imageShaderAttribPosition;\n            u32 imageShaderAttribTexCoord;\n            u32 imageShaderAttribBlendColor;\n            u32 imageShaderAttribTexIndex;\n\n            u32 shaderToDraw; // Originally, i was going to support a shape only shader, etc. Keeping this here, but not using it for anything\n        };\n\n        State* gState;\n\n        inline vec2 MakeVertex(const vec2& position, const vec2& rotationPivot, float cosTheta, float sinTheta, const vec2& scale) {\n            vec2 vertex = (position - rotationPivot) * scale;\n\n            float x = (vertex.x * cosTheta) - (vertex.y * sinTheta);\n            float y = (vertex.x * sinTheta) + (vertex.y * cosTheta);\n\n            return vec2(x, y);\n        }\n\n        inline void SetVertexAttribs(Internal::Vertex* verts, u32 count, const vec2& uv, u16 texture, const vec4& color) {\n            for (u32 i = 0; i < count; ++i) {\n                verts[i].uv = uv;\n                verts[i].texture = texture;\n                verts[i].color = color;\n            }\n        }\n\n        inline vec4 UpdateClipStack() {\n            u32 globalClipLeft = 0;\n            u32 globalClipTop = 0;\n            u32 globalClipRight = gState->displayWidth;\n            u32 globalClipBottom = gState->displayHeight;\n\n            for (u32 i = 0, size = gState->clipStack.Count(); i < size; ++i) {\n                vec4 clipRect = gState->clipStack[i];\n\n                globalClipLeft = MathMaxF(clipRect.x, globalClipLeft);\n                globalClipTop = MathMaxF(clipRect.y, globalClipTop);\n                globalClipRight = MathMinF(globalClipLeft + clipRect.z, globalClipRight);\n                globalClipBottom = MathMinF(globalClipTop + clipRect.w, globalClipBottom);\n            }\n\n            vec4 clip(globalClipLeft, globalClipTop, globalClipRight - globalClipLeft, globalClipBottom - globalClipTop);\n\n            gState->activeClip = clip;\n            return clip;\n        }\n\n        void FlushAllDrawCommands() {\n            // Early out if there is nothing to flush\n            if (gState->numIndices == 0) {\n                return;\n            }\n\n            PlatformAssert(gState->numVertices != 0, __LOCATION__);\n            if (gState->shaderToDraw == 0) {\n                // No shader is bound, we shouldn't really get here....\n                // Try to recover gracefully, but break in debug\n                gState->numIndices = 0;\n                gState->numVertices = 0;\n                PlatformAssert(false, __LOCATION__);\n                return;\n            }\n\n            // Grab an iter from the free list\n            Buffer* iter = &gState->displayBuffer;\n\n            // Update Vertex and index data\n            GfxFillArrayBuffer(iter->vboId, gState->vertices, sizeof(Vertex) * gState->numVertices, false);\n            GfxFillIndexBuffer(iter->iboId, gState->indices, gState->numIndices * sizeof(u16), GfxIndexTypeShort, false);\n\n            float screenSize[3] = { (float)gState->displayWidth, (float)gState->displayHeight, (float)gState->designHeight };\n            PlatformAssert(gState->numBoundImages < 10, __LOCATION__); // Can only do single digits\n\n            // Fill out array objects for buffer, depending on what is being drawn\n            if (gState->shaderToDraw == gState->imageShader) {\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribPosition, iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, 0);\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribTexCoord, iter->vboId, 2, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * 2);\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribBlendColor, iter->vboId, 4, sizeof(Vertex), GfxBufferTypeFloat32, sizeof(float) * (2 + 2));\n                GfxAddBufferToLayout(iter->vaoId, gState->imageShaderAttribTexIndex, iter->vboId, 1, sizeof(Vertex), GfxBufferTypeInt16, sizeof(float) * (2 + 2 + 4));\n                GfxAddIndexBufferToLayout(iter->vaoId, iter->iboId);\n\n                //GfxSetUniform(gState->shaderToDraw, gState->imageShaderScreenSizeUniform, screenSize, GfxUniformTypeFloat3, 1);\n                for (u32 i = 0; i < gState->numBoundImages; ++i) {\n                    GfxSetUniformTexture(gState->shaderToDraw, gState->imgUniformSlots[i], gState->boundImages[i]);\n                }\n            }\n            else {\n                PlatformAssert(false, __LOCATION__);\n            }\n\n            // Submit the finalized draw call\n            GfxDraw(0, 0, iter->vaoId, GfxDrawModeTriangles, 0, gState->numIndices, 1);\n\n            // Reset the CPU side buffers now that the data lives on the GPU\n            gState->numVertices = 0;\n            gState->numIndices = 0;\n            Internal::gState->numBoundImages = 1; // Bind font atlas always\n            Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n        }\n\n        void FlushIfNeeded(u32 numNewVerts, u32 numNewIndices, u32 shaderId) {\n            // Flush if at vertex limit\n            if (Internal::gState->numVertices + numNewVerts >= DRAW2D_MAXVERTS) {\n                Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n            }\n\n            // Flush if at index limit\n            else if (Internal::gState->numIndices + numNewIndices >= DRAW2D_MAXINDICES) {\n                Internal::FlushAllDrawCommands(); // Will reset numRenderCommands to 0\n            }\n\n            // Flush if the image shader isn't bound\n            else if (Internal::gState->shaderToDraw != shaderId) {\n                if (Internal::gState->shaderToDraw != 0) {\n                    Internal::FlushAllDrawCommands();\n                }\n            }\n            // Next flush will happen with the image shader\n            Internal::gState->shaderToDraw = shaderId;\n        }\n\n        void ClearCodePoints(Internal::AsciiFontInstance* instance) {\n            stbtt_fontinfo* info = &instance->prototype->fontInfo;\n            for (u32 i = 0; i < 256; ++i) {\n                instance->packedGlyphs[i].id = i;\n                instance->packedGlyphs[i].was_packed = 0;\n\n                instance->packedGlyphs[i].x = 0;\n                instance->packedGlyphs[i].y = 0;\n                instance->packedGlyphs[i].w = 0;\n                instance->packedGlyphs[i].h = 0;\n\n                instance->advances[i] = 0;\n                instance->renderRects[i] = ivec4(0, 0, 0, 0);\n            }\n        }\n\n        inline Internal::AsciiFontInstance* GetFontInstance(u32 fontIndex, u32 lineHeight) {\n            Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n            PlatformAssert(font->active, __LOCATION__);\n\n            Internal::AsciiFontInstance* instance = 0;\n            for (u32 i = 0, size = font->instances.Count(); i < size; ++i) {\n                if (font->instances[i].lineHeight == lineHeight) {\n                    instance = &font->instances[i];\n                    break;\n                }\n            }\n\n            if (instance == 0) {\n                u32 index = font->instances.Count();\n                stbtt_fontinfo* info = &font->fontInfo;\n\n                font->instances.PushBack();\n                instance = &font->instances[index];\n                instance->prototype = font;\n                instance->lineHeight = lineHeight;\n                instance->stbScale = stbtt_ScaleForPixelHeight(info, (float)lineHeight);\n                instance->scaledLineGap = (float)font->unscaledLineGap * instance->stbScale;\n                Internal::ClearCodePoints(instance);\n            }\n\n            return instance;\n        }\n\n        AsciiFontInstance* MakeSureGlyphIsCached(Internal::AsciiFontInstance* instance, unsigned char codePoint) {\n            Internal::AsciiFont* font = instance->prototype;\n            f32 stbScale = instance->stbScale;\n            u32 lineHeight = instance->lineHeight;\n            f32 dpi = gState->designDpi;\n\n            stbrp_rect packedRect = instance->packedGlyphs[codePoint];\n            if (!packedRect.was_packed) { // Glyph does not exist\n                PlatformAssert(packedRect.id == codePoint, __LOCATION__);\n\n                int ix0, ix1, iy0, iy1;\n                stbtt_GetCodepointBitmapBox(&font->fontInfo, codePoint, stbScale, stbScale, &ix0, &iy0, &ix1, &iy1);\n                int bitmapWidth = instance->packedGlyphs[codePoint].w = f32(ix1 - ix0) * dpi;\n                int bitmapHeight = instance->packedGlyphs[codePoint].h = f32(iy1 - iy0) * dpi;\n                instance->renderRects[codePoint] = ivec4(ix0, iy0, ix1, iy1);\n\n                // Pad out by 1 pixel on left and right\n                bitmapWidth += 2;\n                bitmapHeight += 2;\n                // Pad row to 4 bytes for openGL. \n                int alignTo4Bytes = (4 - (bitmapWidth % 4));\n                bitmapWidth += alignTo4Bytes;\n\n                int advance = 0;\n                int leftBearing = 0;\n                stbtt_GetCodepointHMetrics(&font->fontInfo, codePoint, &advance, &leftBearing);\n                instance->advances[codePoint] = advance;\n\n                instance->packedGlyphs[codePoint].w = bitmapWidth;\n                instance->packedGlyphs[codePoint].h = bitmapHeight;\n                packedRect.x = packedRect.y = packedRect.was_packed = 0;\n                int result = stbrp_pack_rects(&Internal::gState->fontPacker, &instance->packedGlyphs[codePoint], 1);\n                packedRect = instance->packedGlyphs[codePoint];\n\n                if (!result) { // Reset all cache\n                    FlushAllDrawCommands();\n                    stbrp_init_target(&Internal::gState->fontPacker, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, Internal::gState->fontPackerNodes, 4096);\n\n                    for (u32 i = 0, size = gState->loadedFonts.Count(); i < size; ++i) {\n                        Internal::AsciiFont* clearFont = &gState->loadedFonts[i];\n                        clearFont->instances.~Vector(); // Reset instances\n                        new (&clearFont->instances) Vector<Internal::AsciiFontInstance>();\n                    }\n\n                    PlatformAssert(font->instances.Count() == 0, __LOCATION__);\n                    font->instances.PushBack();\n                    instance = &font->instances[0];\n                    instance->prototype = font;\n                    instance->lineHeight = lineHeight;\n                    instance->stbScale = stbScale = stbtt_ScaleForPixelHeight(&font->fontInfo, (float)lineHeight);\n                    instance->scaledLineGap = (float)font->unscaledLineGap * stbScale;\n                    ClearCodePoints(instance);\n\n                    instance->packedGlyphs[codePoint].w = bitmapWidth;\n                    instance->packedGlyphs[codePoint].h = bitmapHeight;\n                    instance->packedGlyphs[codePoint].x = 0;\n                    instance->packedGlyphs[codePoint].y = 0;\n                    instance->packedGlyphs[codePoint].was_packed = 0;\n                    int result = stbrp_pack_rects(&Internal::gState->fontPacker, &instance->packedGlyphs[codePoint], 1);\n                    packedRect = instance->packedGlyphs[codePoint];\n                }\n\n                // Remove padding now that it's packed\n                packedRect.w -= 2;\n                packedRect.h -= 2;\n                packedRect.w -= alignTo4Bytes;\n                instance->packedGlyphs[codePoint] = packedRect;\n\n                PlatformAssert(result == 1, __LOCATION__);\n\n                stbtt_MakeCodepointBitmap(&font->fontInfo, gState->glyphBuffer,\n                    bitmapWidth, bitmapHeight, bitmapWidth,\n                    stbScale * dpi, stbScale * dpi, codePoint);\n\n#if 0\n                int bytes = 0; // Debug code to make sure stbtt_MakeCodepointBitmap drew each glyph properly\n                unsigned char* png = stbi_write_png_to_mem(gState->glyphBuffer, bitmapWidth, bitmapWidth, bitmapHeight, 1, &bytes);\n                char path[6] = { codePoint, '.', 'p', 'n', 'g', '\\0' };\n                WriteDebugFile(path, png, bytes);\n                MemRelease(png); // It did\n#endif\n\n                GfxWriteToTexture(gState->fontAtlas, gState->glyphBuffer, GfxTextureFormatR8,\n                    packedRect.x, packedRect.y, bitmapWidth, bitmapHeight);\n\n            }\n\n            PlatformAssert(packedRect.was_packed, __LOCATION__);\n\n            return instance;\n        }\n    }\n\n    void Initialize() {\n        Internal::gState = (Internal::State*)MemAlloc(sizeof(Internal::State));\n        MemSet(Internal::gState, 0, sizeof(Internal::State));\n\n        Internal::gState->vertices = (Internal::Vertex*)MemAlloc(sizeof(Internal::Vertex) * DRAW2D_MAXVERTS);\n        Internal::gState->indices = (u16*)MemAlloc(sizeof(u16) * DRAW2D_MAXINDICES);\n        Internal::gState->numVertices = 0;\n        Internal::gState->numIndices = 0;\n\n        new (&Internal::gState->clipStack) Vector<vec4>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedFonts) Vector<Internal::AsciiFont>(); // Just allocated, do what the constructor does\n        new (&Internal::gState->loadedImages) Vector<Internal::Image>(); // Just allocated, do what the constructor does\n\n        Internal::gState->fontAtlas = GfxCreateTexture(0, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, GfxTextureFormatR8, GfxTextureFormatR8, false);\n        GfxSetTextureSampler(Internal::gState->fontAtlas, GfxWrapClamp, GfxWrapClamp, GfxFilterLinear, GfxFilterNone, GfxFilterLinear);\n        Internal::Image fontImage;\n        fontImage.width = DRAW2D_TEXTURE_PACKER_ATLAS_SIZE;\n        fontImage.height = DRAW2D_TEXTURE_PACKER_ATLAS_SIZE;\n        fontImage.id = Internal::gState->fontAtlas;\n        Internal::gState->loadedImages.PushBack(fontImage);\n        Internal::gState->numBoundImages = 1; // Bind font atlas always\n        Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n\n        Internal::gState->fontPackerNodes = (stbrp_node*)MemAlloc(sizeof(stbrp_node) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * 2);\n        stbrp_init_target(&Internal::gState->fontPacker, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE, Internal::gState->fontPackerNodes, DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * 2);\n        Internal::gState->glyphBuffer = (unsigned char*)MemAlloc(sizeof(unsigned char) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE);\n        MemSet(Internal::gState->glyphBuffer, 0, sizeof(unsigned char) * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE * DRAW2D_TEXTURE_PACKER_ATLAS_SIZE);\n\n        Internal::UpdateClipStack();\n\n        const char* vShader =\n            \"#version 300 es  \\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"in vec2 position;\\n\"\n            \"in vec2 texCoord;\\n\"\n            \"in vec4 blendColor;\\n\"\n            \"in int texIndex;\\n\"\n            \"out vec2 vTexCoord;\\n\"\n            \"out vec4 vBlendColor;\\n\"\n            \"flat out int vTexIndex;\\n\"\n            \"void main() {\\n\"\n            \"    vec2 ndc = vec2(position.x, 1.0 - position.y);\\n\"\n            \"    ndc = ndc * 2.0 - 1.0;\\n\"\n            \"    gl_Position = vec4(ndc, 0.0, 1.0);\\n\"\n            \"    vTexCoord = texCoord;\\n\"\n            \"    vBlendColor = blendColor;\\n\"\n            \"    vTexIndex = texIndex;\\n\"\n            \"}\\n\";\n\n        // Note, consider making variations of this shader that have less in the switch satatments\n        const char* fShader =\n            \"#version 300 es  \\n\"\n            \"precision highp float;\\n\"\n            \"precision highp int;\\n\"\n            \"flat in int vTexIndex;\\n\"\n            \"in vec2 vTexCoord;\\n\"\n            \"in vec4 vBlendColor;\\n\"\n            \"uniform sampler2D tex0;\\n\"\n            \"uniform sampler2D tex1;\\n\"\n            \"uniform sampler2D tex2;\\n\"\n            \"uniform sampler2D tex3;\\n\"\n            \"uniform sampler2D tex4;\\n\"\n            \"uniform sampler2D tex5;\\n\"\n            \"uniform sampler2D tex6;\\n\"\n            \"uniform sampler2D tex7;\\n\"\n            \"out vec4 outputColor;\\n\"\n            \"void main() {\\n\"\n            \"   vec4 texColor = vec4(0, 0, 0, 1);\\n\"\n            \"   switch (vTexIndex) {\\n\"\n            \"      case 0: texColor = vec4(vBlendColor.rgb, vBlendColor.a * texture(tex0, vTexCoord).r); break;\\n\"\n            \"      case 1: texColor = texture(tex1, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 2: texColor = texture(tex2, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 3: texColor = texture(tex3, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 4: texColor = texture(tex4, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 5: texColor = texture(tex5, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 6: texColor = texture(tex6, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 7: texColor = texture(tex7, vTexCoord) * vBlendColor; break;\\n\"\n            \"      case 8: texColor = vBlendColor; break;\\n\"\n            \"   }\\n\"\n            \"   outputColor = texColor;\\n\"\n            \"}\\n\";\n\n        Internal::gState->imageShader = GfxCreateShader(vShader, fShader);\n        //Internal::gState->imageShaderScreenSizeUniform = GfxGetUniformSlot(Internal::gState->imageShader, \"screenSize\");\n        Internal::gState->imageShaderAttribPosition = GfxGetAttributeSlot(Internal::gState->imageShader, \"position\");\n        Internal::gState->imageShaderAttribTexCoord = GfxGetAttributeSlot(Internal::gState->imageShader, \"texCoord\");\n        Internal::gState->imageShaderAttribBlendColor = GfxGetAttributeSlot(Internal::gState->imageShader, \"blendColor\");\n        Internal::gState->imageShaderAttribTexIndex = GfxGetAttributeSlot(Internal::gState->imageShader, \"texIndex\");\n\n        PlatformAssert(DRAW2D_MAX_IMAGES < 10, __LOCATION__);\n        char uniformName[] = { 't', 'e', 'x', '0', '\\0' };\n        for (u32 i = 0; i < DRAW2D_MAX_IMAGES; ++i) {\n            uniformName[3] = '0' + i;\n            Internal::gState->imgUniformSlots[i] = GfxGetUniformSlot(Internal::gState->imageShader, uniformName);\n        }\n\n        Internal::gState->displayBuffer.vboId = GfxCreateBuffer();\n        Internal::gState->displayBuffer.iboId = GfxCreateBuffer();\n        Internal::gState->displayBuffer.vaoId = GfxCreateVertexLayout(Internal::gState->imageShader);\n    }\n\n    void Shutdown() {\n        GfxDestroyBuffer(Internal::gState->displayBuffer.vboId);\n        GfxDestroyBuffer(Internal::gState->displayBuffer.iboId);\n        GfxDestroyShaderVertexLayout(Internal::gState->displayBuffer.vaoId);\n\n        MemRelease(Internal::gState->fontPackerNodes);\n        MemRelease(Internal::gState->glyphBuffer);\n\n        GfxDestroyShader(Internal::gState->imageShader);\n\n        // Destroy font\n        GfxDestroyTexture(Internal::gState->fontAtlas);\n        for (u32 i = 0, size = Internal::gState->loadedFonts.Count(); i < size; ++i) {\n            DestroyFont(i);\n        }\n        Internal::gState->loadedFonts.~Vector();\n\n        // Cleanup textures\n        // Image 0 is always the texture atlas, which is managed manually. Skip it.\n        for (u32 i = 1, size = Internal::gState->loadedImages.Count(); i < size; ++i) {\n            PlatformAssert(Internal::gState->loadedImages[i].id == 0, __LOCATION__);\n            if (Internal::gState->loadedImages[i].id != 0) {\n                GfxDestroyTexture(Internal::gState->loadedImages[i].id);\n            }\n        }\n        Internal::gState->loadedImages.~Vector();\n        Internal::gState->clipStack.~Vector();\n\n        MemRelease(Internal::gState->vertices);\n        MemRelease(Internal::gState->indices);\n        MemRelease(Internal::gState);\n    }\n\n    u32 LoadImage(void* memory, u32 bytes, Interpolation interp) {\n        i32 width = 0;\n        i32 height = 0;\n        i32 components = 0;\n\n        unsigned char* img_data = stbi_load_from_memory((unsigned char*)memory, bytes, &width, &height, &components, 0);\n        unsigned int format = (components == 4) ? GfxTextureFormatRGBA8 : GfxTextureFormatRGB8;\n        u32 imageId = GfxCreateTexture(img_data, width, height, format, format, true);\n        MemRelease(img_data);\n\n        Vector<Draw2D::Internal::Image>& loadedImages = Internal::gState->loadedImages;\n        // Loaded image 0 is always the texture atlas, skip it\n        for (u32 i = 1, size = loadedImages.Count(); i < size; ++i) {\n            if (loadedImages[i].id == 0) {\n                loadedImages[i].id = imageId;\n                loadedImages[i].width = width;\n                loadedImages[i].height = height;\n\n                return i;\n            }\n        }\n\n        if (interp == Interpolation::Step) {\n            GfxSetTextureSampler(imageId, GfxWrapClamp, GfxWrapClamp, GfxFilterNearest, GfxFilterNearest, GfxFilterNearest);\n        }\n\n        Internal::Image result = { imageId, (u32)width, (u32)height };\n        Internal::gState->loadedImages.PushBack(result);\n        return Internal::gState->loadedImages.Count() - 1;\n    }\n\n    Size GetImageSize(u32 imageId) {\n        return Size(Internal::gState->loadedImages[imageId].width, Internal::gState->loadedImages[imageId].height);\n    }\n\n    void DestroyImage(u32 imageId) {\n        u32 textureId = Internal::gState->loadedImages[imageId].id;\n        GfxDestroyTexture(textureId);\n        Internal::gState->loadedImages[imageId].id = 0;\n    }\n\n    OBB ImageTransform(f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotation) {\n        OBB result = { 0 };\n\n        float designScale = Internal::gState->designDpi;\n        \n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 screenSize(screenW, screenH);\n        vec2 screenPos(screenX, screenY);\n\n        float cosTheta = MathCos(rotation);\n        float sinTheta = MathSin(rotation);\n\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p1 = (Internal::MakeVertex(vec2(screenSize.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p2 = (Internal::MakeVertex(vec2(screenSize.x, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n\n        { // Fill out the sprites oriented bounding box\n            vec2 rightAxis = p1 - p0;\n            vec2 upAxis = p3 - p0;\n            result.extents.x = len(rightAxis) / 2.0f;\n            result.extents.y = len(upAxis) / 2.0f;\n            result.rotation = angle(rightAxis, vec2(1, 0));\n\n            //result.center = (p0 + p1 + p2 + p3) / 4.0f;\n            result.center = p0 + rightAxis * 0.5f + upAxis * 0.5f;\n        }\n\n        return result;\n    }\n\n    OBB DrawImage(u32 image, f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 sourceX, f32 sourceY, f32 sourceW, f32 sourceH, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotation, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        OBB result = { 0 };\n\n        Internal::FlushIfNeeded(4, 6, Internal::gState->imageShader);\n\n\n        // Flush if no more images can be bound\n        u32 textureId = Internal::gState->loadedImages[image].id;\n        PlatformAssert(textureId != 0, __LOCATION__);\n        float textureWidth = (float)Internal::gState->loadedImages[image].width;\n        float textureHeight = (float)Internal::gState->loadedImages[image].height;\n\n        bool found = false;\n        u32 imageIndex = 0;\n        for (u32 i = 0, size = Internal::gState->numBoundImages; i < size; ++i) {\n            if (Internal::gState->boundImages[i] == textureId) {\n                imageIndex = i;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (Internal::gState->numBoundImages >= DRAW2D_MAX_IMAGES) {\n                Internal::FlushAllDrawCommands(); // Will reset numBoundImages to 0\n            }\n            imageIndex = Internal::gState->numBoundImages++;\n        }\n        Internal::gState->boundImages[imageIndex] = textureId;\n\n        float designScale = Internal::gState->designDpi;\n\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 screenSize(screenW, screenH);\n        vec2 screenPos(screenX, screenY);\n\n        float cosTheta = MathCos(rotation);\n        float sinTheta = MathSin(rotation);\n\n        SetVertexAttribs(verts, 4, vec2(), imageIndex, vec4(blendR, blendG, blendB, blendA));\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[0].uv = vec2(sourceX / textureWidth, sourceY / textureHeight);\n        vec2 p1 = (Internal::MakeVertex(vec2(screenSize.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[1].uv = vec2((sourceX + sourceW) / textureWidth, sourceY / textureHeight);\n        vec2 p2 = (Internal::MakeVertex(vec2(screenSize.x, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[2].uv = vec2((sourceX + sourceW) / textureWidth, (sourceY + sourceH) / textureHeight);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, screenSize.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        verts[3].uv = vec2(sourceX / textureWidth, (sourceY + sourceH) / textureHeight);\n        \n        { // Fill out the sprites oriented bounding box\n            vec2 rightAxis = p1 - p0;\n            vec2 upAxis = p3 - p0;\n            result.extents.x = len(rightAxis) / 2.0f;\n            result.extents.y = len(upAxis) / 2.0f;\n            result.rotation = angle(rightAxis, vec2(1, 0));\n\n            //result.center = (p0 + p1 + p2 + p3) / 4.0f;\n            result.center = p0 + rightAxis * 0.5f + upAxis * 0.5f;\n\n        }\n\n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left = MathMinF(MathMinF(MathMinF(p0.x, p1.x), p2.x), p3.x);\n            f32 top = MathMinF(MathMinF(MathMinF(p0.y, p1.y), p2.y), p3.y);\n            f32 right = MathMaxF(MathMaxF(MathMaxF(p0.x, p1.x), p2.x), p3.x);\n            f32 bottom = MathMaxF(MathMaxF(MathMaxF(p0.y, p1.y), p2.y), p3.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 4;\n                return result; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n            verts[3].position = p3 * designScale / screenSize;\n        }\n\n        if (scaleX < 0.0f) {\n            float tmp = verts[0].uv.x;\n            verts[0].uv.x = verts[1].uv.x;\n            verts[1].uv.x = tmp;\n\n            tmp = verts[2].uv.x;\n            verts[2].uv.x = verts[3].uv.x;\n            verts[3].uv.x = tmp;\n        }\n\n        if (scaleY < 0.0f) {\n            float tmp = verts[0].uv.y;\n            verts[0].uv.y = verts[2].uv.y;\n            verts[2].uv.y = tmp;\n\n            tmp = verts[1].uv.y;\n            verts[1].uv.y = verts[3].uv.y;\n            verts[3].uv.y = tmp;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n\n        bool ccw = true;\n        /* This no longer matters. I made scale be always positive, and flip uv coords instead\n        if ((scaleX < 0 && scaleY > 0) || (scaleY < 0 && scaleX > 0)) {\n            ccw = false;\n        }*/\n\n        if (ccw) { // default\n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 3;\n            indices[2] = firstVertex + 2;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 0;\n            indices[5] = firstVertex + 3;\n        }\n        else {\n            indices[0] = firstVertex + 1;\n            indices[1] = firstVertex + 2;\n            indices[2] = firstVertex + 3;\n\n            indices[3] = firstVertex + 1;\n            indices[4] = firstVertex + 3;\n            indices[5] = firstVertex + 0;\n        }\n\n\n        return result;\n    }\n\n    void Begin(u32 designWidth, u32 designHeight, f32 designScale, u32 screenWidth, u32 screenHeight){\n        GfxDisableDepthTest();\n        GfxSetViewport(0, 0, screenWidth, screenHeight);\n\n        PlatformAssert(Internal::gState->numVertices == 0, __LOCATION__);\n        PlatformAssert(Internal::gState->numIndices == 0, __LOCATION__);\n        Internal::gState->numBoundImages = 1; // Bind font atlas always\n        Internal::gState->boundImages[0] = Internal::gState->loadedImages[0].id;\n\n        Internal::gState->displayWidth = screenWidth;\n        Internal::gState->displayHeight = screenHeight;\n\n        Internal::gState->designWidth = designWidth;\n        Internal::gState->designHeight = designHeight;\n        Internal::gState->designDpi = designScale;\n\n        Internal::UpdateClipStack();\n    }\n\n    void End()                                                                                                                                                {\n        PlatformAssert(Internal::gState->clipStack.Count() == 0, __LOCATION__);\n        while (Internal::gState->clipStack.Count() != 0) {\n            PopClip();\n        }\n\n        Internal::FlushAllDrawCommands();\n    }\n\n    void EnableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(true, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void DisableAlphaBlending() {\n        Internal::FlushAllDrawCommands();\n        u32 src = GfxBlendFuncSrcAlpha;\n        u32 dst = GfxBlendFuncOneMinusSrcAlpha;\n        u32 blend = GfxBlendEquationAdd;\n        GfxSetBlendState(false, 0, dst, dst, blend, blend, src, src);\n    }\n\n    void PushClip(f32 x, f32 y, f32 w, f32 h) {\n        Internal::FlushAllDrawCommands();\n        Internal::gState->clipStack.PushBack(vec4(x, y, w, h));\n        vec4 clip = Internal::UpdateClipStack();\n        \n        // Modify clip to be in window space\n        float dpi = Internal::gState->designDpi;\n        clip.y = Internal::gState->displayHeight - clip.y * dpi;\n        clip.y -= clip.w * dpi; // And be bottom left coordinates\n\n        GfxSetClipState(true, clip.x * dpi, clip.y, clip.z * dpi, clip.w * dpi);\n    }\n\n    void PopClip() {\n        Internal::FlushAllDrawCommands();\n        Internal::gState->clipStack.PopBack();\n        vec4 clip = Internal::UpdateClipStack();\n        \n        // Modify clip to be in window space\n        float dpi = Internal::gState->designDpi;\n        clip.y = Internal::gState->displayHeight - clip.y * dpi;\n        clip.y -= clip.w * dpi; // And be bottom left coordinates\n        \n        GfxSetClipState(Internal::gState->clipStack.Count() != 0, clip.x, clip.y, clip.z, clip.w);\n    }\n\n    u32 LoadFont(void* memory, u32 bytes, bool own) {\n        Internal::AsciiFont* font = 0;\n        u32 size = size = Internal::gState->loadedFonts.Count();\n        for (u32 i = 0; i < size; ++i) { // The only place it's actually used as size\n            if (!Internal::gState->loadedFonts[i].active) {\n                font = &Internal::gState->loadedFonts[i];\n                size = i; // Font index, not size.\n                break;\n            }\n        }\n        if (font == 0) {\n            Internal::gState->loadedFonts.PushBack();\n            font = &Internal::gState->loadedFonts[size]; // Used as font index, not size\n        }\n\n        PlatformAssert(font != 0, __LOCATION__);\n\n        font->active = stbtt_InitFont(&font->fontInfo, (const unsigned char*)memory, 0) != 0;\n        PlatformAssert(font->active, __LOCATION__);\n        new (&font->instances) Vector<Internal::AsciiFontInstance>(); // Initialize vector\n        font->ownsMemory = own; // If the memory is owned, DestroyFont calls free on stbtt_fontinfo::data, which is the memory argument being passed in.\n\n        i32 ascent = 0;\n        i32 descent = 0;\n        i32 linegap = 0;\n        stbtt_GetFontVMetrics(&font->fontInfo, &ascent, &descent, &linegap);\n        font->unscaledLineGap = ascent - descent + linegap;\n\n        return size; // It's the font index, not size. Just re-using the variable.\n    }\n\n    void DestroyFont(u32 fontIndex) {\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        font->active = false;\n\n        if (font->ownsMemory) {\n            MemRelease(font->fontInfo.data);\n            font->fontInfo.data = 0;\n            font->ownsMemory = false;\n        }\n        font->instances.~Vector();\n    }\n\n    Rect MeasureSubString(u32 font, u32 pixelHeight, const char* string, u32 startIndex, u32 len) {\n        if (string == 0) {\n            return Rect();\n        }\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        vec2 carrat;\n        vec2 reference;\n\n        int kern = 0;\n        float maxX = 0.0f;\n        u32 index = 0;\n        for (const char* iter = string; *iter != '\\0'; ++iter, ++index) {\n            char codePoint = *iter;\n\n            if (index == startIndex) {\n                reference = carrat;\n            }\n\n            if (index >= startIndex + len) {\n                break;\n            }\n\n            if (codePoint == '\\n') {\n                if (carrat.x > maxX) {\n                    maxX = carrat.x;\n                }\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        if (carrat.x > maxX) {\n            maxX = carrat.x;\n        }\n\n        return Rect(reference.x, reference.y, MathMaxF(maxX - reference.x, 0.0f),MathMaxF(carrat.y - reference.y + instance->scaledLineGap, 0.0f));\n    }\n\n    int FindStringIndex(u32 font, u32 pixelHeight, const char* string, const vec2& relativePoint) {\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n\n        vec2 carrat;\n        int kern = 0;\n        int index = 0;\n        for (const char* iter = string; *iter != '\\0'; ++iter, ++index) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            \n            if (relativePoint.x >= carrat.x && relativePoint.x <= carrat.x + f32(advance + kern) * stbScale) {\n                if (relativePoint.y >= carrat.y && relativePoint.y <= carrat.y + instance->scaledLineGap) {\n                    float midPoint = carrat.x + (f32(advance + kern) * stbScale) * 0.5f;\n                    return relativePoint.x < midPoint? index : index + 1;\n                }\n            }\n\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        return -1;\n    }\n\n    Size MeasureString(u32 font, u32 pixelHeight, const char* string) {\n        if (string == 0) {\n            return Size();\n        }\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(font, pixelHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        \n        vec2 carrat;\n        int kern = 0;\n        float maxX = 0.0f;\n        for (const char* iter = string; *iter != '\\0'; ++iter) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                if (carrat.x > maxX) {\n                    maxX = carrat.x;\n                }\n                carrat.x = 0;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n\n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            \n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n\n        if (carrat.x > maxX) {\n            maxX = carrat.x;\n        }\n\n        return Size(maxX, carrat.y + instance->scaledLineGap);\n    }\n\n    void DrawCodePoint(u32 fontIndex, u32 lineHeight, f32 x, f32 y, unsigned char codePoint, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        PlatformAssert(lineHeight <= DRAW2D_FONT_MAX_LINE_HEIGHT, __LOCATION__);\n        if (lineHeight > DRAW2D_FONT_MAX_LINE_HEIGHT) {\n            lineHeight = DRAW2D_FONT_MAX_LINE_HEIGHT; // Enforce a max line height...\n        }\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(fontIndex, lineHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        PlatformAssert(stbScale > 0.0f, __LOCATION__);\n\n        stbtt_fontinfo* info = &font->fontInfo;\n        u32 fontAtlas = 0; // The font atlas is always bound to slot 0 of loaded images\n\n        instance = MakeSureGlyphIsCached(instance, codePoint);\n        PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n        stbrp_rect packedGlyph = instance->packedGlyphs[codePoint];\n\n        f32 displayX = x + instance->renderRects[codePoint].x;\n        f32 displayY = y + instance->renderRects[codePoint].y;\n        f32 displayW = (instance->renderRects[codePoint].z - instance->renderRects[codePoint].x);\n        f32 displayH = (instance->renderRects[codePoint].w - instance->renderRects[codePoint].y);\n\n        f32 scale = 1.0f;\n\n        DrawImage(fontAtlas,\n            displayX, displayY, displayW, displayH,\n            packedGlyph.x, packedGlyph.y, packedGlyph.w, packedGlyph.h,\n            scale, scale, 0, 0, 0, blendR, blendG, blendB, blendA);\n    }\n\n    void DrawString(u32 fontIndex, u32 lineHeight, f32 x, f32 y, const char* string, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        if (string == 0) {\n            return;\n        }\n        PlatformAssert(lineHeight <= DRAW2D_FONT_MAX_LINE_HEIGHT, __LOCATION__);\n        if (lineHeight > DRAW2D_FONT_MAX_LINE_HEIGHT) {\n            lineHeight = DRAW2D_FONT_MAX_LINE_HEIGHT; // Enforce a max line height...\n        }\n        Internal::AsciiFont* font = &Internal::gState->loadedFonts[fontIndex];\n        PlatformAssert(font->active, __LOCATION__);\n        Internal::AsciiFontInstance* instance = Internal::GetFontInstance(fontIndex, lineHeight);\n        PlatformAssert(instance != 0, __LOCATION__);\n        f32 stbScale = instance->stbScale;\n        PlatformAssert(stbScale > 0.0f, __LOCATION__);\n        \n        stbtt_fontinfo* info = &font->fontInfo;\n\n        vec2 carrat(x, y);\n        u32 fontAtlas = 0; // The font atlas is always bound to slot 0 of loaded images\n\n        //char last = '\\0';\n        for (const char* iter = string; *iter != '\\0'; ++iter) {\n            char codePoint = *iter;\n\n            if (codePoint == '\\n') {\n                carrat.x = x;\n                carrat.y += instance->scaledLineGap;\n                continue;\n            }\n            \n            instance = MakeSureGlyphIsCached(instance, codePoint);\n            PlatformAssert(instance->packedGlyphs[codePoint].was_packed, __LOCATION__);\n\n            int advance = instance->advances[codePoint];\n            int kern = 0;// Disabled kerning to make font easier to measure. // stbtt_GetCodepointKernAdvance(info, last, codePoint);\n\n            stbrp_rect packedGlyph = instance->packedGlyphs[codePoint];\n            \n            f32 displayX = carrat.x + instance->renderRects[codePoint].x;\n            f32 displayY = carrat.y + instance->renderRects[codePoint].y;\n            f32 displayW = (instance->renderRects[codePoint].z - instance->renderRects[codePoint].x);\n            f32 displayH = (instance->renderRects[codePoint].w - instance->renderRects[codePoint].y);\n\n            f32 scale = 1.0f;\n\n            DrawImage(fontAtlas, \n                displayX, displayY, displayW, displayH,\n                packedGlyph.x, packedGlyph.y, packedGlyph.w, packedGlyph.h,\n                scale, scale, 0, 0, 0, blendR, blendG, blendB, blendA);\n\n            carrat.x += f32(advance + kern) * stbScale;\n        }\n    }\n\n    void DrawTriangle(f32 x0, f32 y0, f32 x1, f32 y1, f32 x2, f32 y2, f32 r, f32 g, f32 b) {\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(3, 3, Internal::gState->imageShader);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 3;\n\n        vec2 pivot(0, 0);\n        vec2 scale(1, 1);\n\n        float cosTheta = 1.0f;// MathCos(0);\n        float sinTheta = 0.0f;// MathSin(0);\n\n        SetVertexAttribs(verts, 3, vec2(), 8, vec4(r, g, b, 1.0f));\n\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + vec2(x0, y0));\n        vec2 p1 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + vec2(x1, y1));\n        vec2 p2 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + vec2(x2, y2));\n\n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left = MathMinF(MathMinF(p0.x, p1.x), p2.x);\n            f32 top = MathMinF(MathMinF(p0.y, p1.y), p2.y);\n            f32 right = MathMaxF(MathMaxF(p0.x, p1.x), p2.x);\n            f32 bottom = MathMaxF(MathMaxF(p0.y, p1.y), p2.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 3;\n                return; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 3;\n\n        indices[0] = firstVertex + 0;\n        indices[1] = firstVertex + 2;\n        indices[2] = firstVertex + 1;\n    }\n\n    void DrawRect(f32 _x, f32 _y, f32 _w, f32 _h,\n        f32 tlR, f32 tlG, f32 tlB,\n        f32 trR, f32 trG, f32 trB,\n        f32 blR, f32 blG, f32 blB,\n        f32 brR, f32 brG, f32 brB) {\n\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(4, 6, Internal::gState->imageShader);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(0, 0);\n        vec2 scale(1, 1);\n        vec2 size(_w, _h);\n        vec2 screenPos(_x, _y);\n\n        float cosTheta = 1.0f;// MathCos(0);\n        float sinTheta = 0.0f;// MathSin(0);\n\n        SetVertexAttribs(verts, 4, vec2(), 8, vec4(1.0f, 1.0f, 1.0f, 1.0f));\n\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p1 = (Internal::MakeVertex(vec2(size.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p2 = (Internal::MakeVertex(vec2(size.x, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n\n        verts[0].color = vec4(tlR, tlG, tlB, 1.0f);\n        verts[1].color = vec4(trR, trG, trB, 1.0f);\n        verts[2].color = vec4(blR, blG, blB, 1.0f);\n        verts[3].color = vec4(brR, brG, brB, 1.0f);\n\n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left = MathMinF(MathMinF(MathMinF(p0.x, p1.x), p2.x), p3.x);\n            f32 top = MathMinF(MathMinF(MathMinF(p0.y, p1.y), p2.y), p3.y);\n            f32 right = MathMaxF(MathMaxF(MathMaxF(p0.x, p1.x), p2.x), p3.x);\n            f32 bottom = MathMaxF(MathMaxF(MathMaxF(p0.y, p1.y), p2.y), p3.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 4;\n                return; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n            verts[3].position = p3 * designScale / screenSize;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n\n        indices[0] = firstVertex + 1;\n        indices[1] = firstVertex + 3;\n        indices[2] = firstVertex + 2;\n\n        indices[3] = firstVertex + 1;\n        indices[4] = firstVertex + 0;\n        indices[5] = firstVertex + 3;\n    }\n\n    void DrawCircleSlice(f32 cX, f32 cY, float radius, float startAngle, float endAngle, float red, float green, float blue) {\n        startAngle = MathFmod(startAngle, 2.0f * MATH_PI);\n        endAngle = MathFmod(endAngle, 2.0f * MATH_PI);\n        if (endAngle < startAngle) {\n            endAngle += 2.0f * MATH_PI;\n        }\n        float fillAngle = endAngle - startAngle;\n\n        float CIRCLE_RESOLUTION = 36;\n        int numTriangles = MathCeil(fillAngle / (2.0f * MATH_PI) * CIRCLE_RESOLUTION);\n\n        for (int i = 0; i < numTriangles; i++) {\n            float angle1 = startAngle + (float)i * fillAngle / numTriangles;\n            float angle2 = startAngle + (float)(i + 1) * fillAngle / numTriangles;\n\n            vec2 vertex1 = vec2(cX + radius * MathCos(angle1), cY + radius * MathSin(angle1));\n            vec2 vertex2 = vec2(cX + radius * MathCos(angle2), cY + radius * MathSin(angle2));\n\n            DrawTriangle(cX, cY, vertex1.x, vertex1.y, vertex2.x, vertex2.y, red, green, blue);\n        }\n    }\n\n    void DrawHollowCircle(f32 cx, f32 cy, f32 innerR, f32 outerR, f32 cr, f32 cg, f32 cb) {\n        i32 num_segments = 32;\n        for (int ii = 0; ii < num_segments; ii++) {\n            float theta = 2.0f * MATH_PI * float(ii) / float(num_segments);\n            float x = MathCos(theta);\n            float y = MathSin(theta);\n\n            vec2 this_vertex_outer(x * outerR + cx, y * outerR + cy);\n            vec2 this_vertex_inner(x * innerR + cx, y * innerR + cy);\n                                    \n            theta = 2.0f * MATH_PI * float((ii + 1) % num_segments) / float(num_segments);\n            x = MathCos(theta);\n            y = MathSin(theta);\n\n            vec2 next_vertex_outer(x * outerR + cx, y * outerR + cy);\n            vec2 next_vertex_inner(x * innerR + cx, y * innerR + cy);\n\n            DrawTriangle(\n                this_vertex_outer.x, this_vertex_outer.y,\n                this_vertex_inner.x, this_vertex_inner.y,\n                next_vertex_outer.x, next_vertex_outer.y,\n                cr, cg, cb);\n            DrawTriangle(\n                next_vertex_outer.x, next_vertex_outer.y,\n                next_vertex_inner.x, next_vertex_inner.y,\n                this_vertex_inner.x, this_vertex_inner.y,\n                cr, cg, cb);\n        }\n    }\n\n    void DrawRect(f32 _x, f32 _y, f32 _w, f32 _h, f32 blendR, f32 blendG, f32 blendB, f32 blendA, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotation) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(4, 6, Internal::gState->imageShader);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* verts = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += 4;\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 size(_w, _h);\n        vec2 screenPos(_x, _y);\n\n        float cosTheta = MathCos(rotation);\n        float sinTheta = MathSin(rotation);\n\n        SetVertexAttribs(verts, 4, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n        vec2 p0 = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p1 = (Internal::MakeVertex(vec2(size.x, 0), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p2 = (Internal::MakeVertex(vec2(size.x, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        vec2 p3 = (Internal::MakeVertex(vec2(0, size.y), pivot, cosTheta, sinTheta, scale) + screenPos);\n        \n        if (Internal::gState->clipStack.Count() > 0) { // Clip bounding box against screen bounds\n            f32 left =   MathMinF(MathMinF(MathMinF(p0.x, p1.x), p2.x), p3.x);\n            f32 top =    MathMinF(MathMinF(MathMinF(p0.y, p1.y), p2.y), p3.y);\n            f32 right =  MathMaxF(MathMaxF(MathMaxF(p0.x, p1.x), p2.x), p3.x);\n            f32 bottom = MathMaxF(MathMaxF(MathMaxF(p0.y, p1.y), p2.y), p3.y);\n\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x; // This prob needs to be scaled\n            f32 clipTop = clip.y;\n            f32 clipRight = (clip.x + clip.z);\n            f32 clipBotom = (clip.y + clip.w);\n\n            // If any of these are true, the box is invisible\n            if (left > clipRight || right < clipLeft || top > clipBotom || bottom < clipTop) {\n                Internal::gState->numVertices -= 4;\n                return; // Reset and early out\n            }\n        }\n\n        { //  After culling, move into design space, and then normalize to prep for shader\n            verts[0].position = p0 * designScale / screenSize;\n            verts[1].position = p1 * designScale / screenSize;\n            verts[2].position = p2 * designScale / screenSize;\n            verts[3].position = p3 * designScale / screenSize;\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += 6;\n        \n        indices[0] = firstVertex + 1;\n        indices[1] = firstVertex + 3;\n        indices[2] = firstVertex + 2;\n\n        indices[3] = firstVertex + 1;\n        indices[4] = firstVertex + 0;\n        indices[5] = firstVertex + 3;\n    }\n    \n    void DrawEllipse(f32 x, f32 y, f32 radiusX, f32 radiusY, f32 blendR, f32 blendG, f32 blendB, f32 blendA, f32 scaleX, f32 scaleY, f32 pivotX, f32 pivotY, f32 rotation) {\n        if (scaleX * scaleY == 0.0f) {\n            return;\n        }\n\n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        Internal::FlushIfNeeded(DRAW2D_NUM_ELLIPSE_SEGMENTS + 1, DRAW2D_NUM_ELLIPSE_SEGMENTS * 3, Internal::gState->imageShader);\n\n        vec2 pivot(pivotX, pivotY);\n        vec2 scale(MathAbsF(scaleX), MathAbsF(scaleY));\n        vec2 screenPos(x, y);\n\n        float cosTheta = MathCos(rotation);\n        float sinTheta = MathSin(rotation);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* vertices = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += DRAW2D_NUM_ELLIPSE_SEGMENTS + 1;\n\n        SetVertexAttribs(vertices, DRAW2D_NUM_ELLIPSE_SEGMENTS + 1, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n\n        vertices[0].position = (Internal::MakeVertex(vec2(0, 0), pivot, cosTheta, sinTheta, scale) + screenPos) * designScale / screenSize;\n\n        for (u32 i = 1; i < DRAW2D_NUM_ELLIPSE_SEGMENTS + 1; ++i) {\n            float theta = 2.0f * MathPI * float(i - 1) / float(DRAW2D_NUM_ELLIPSE_SEGMENTS - 1);\n            float xPos = radiusX * MathCos(theta);\n            float yPos = radiusY * MathSin(theta);\n\n            vertices[i].position = (Internal::MakeVertex(vec2(xPos, yPos), pivot, cosTheta, sinTheta, scale) + screenPos) * designScale / screenSize;\n        }\n\n        if (Internal::gState->clipStack.Count() > 0) {\n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x;\n            f32 clipTop =  clip.y;\n            f32 clipRight = clipLeft + clip.z;\n            f32 clipBotom =  clipTop + clip.w;\n\n            f32 boundsLeft = (x - radiusX);\n            f32 boundsTop = (y - radiusY);\n            f32 boundsRight = (x + radiusX);\n            f32 boundsBottom = (y + radiusY);\n\n            // If any of these are true, the box is invisible\n            if (boundsLeft > clipRight || boundsRight < clipLeft || boundsTop > clipBotom || boundsBottom < clipTop) {\n                Internal::gState->numVertices -= DRAW2D_NUM_ELLIPSE_SEGMENTS + 1;\n                return; // Reset and early out\n            }\n        }\n\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += DRAW2D_NUM_ELLIPSE_SEGMENTS * 3;\n        u32 pivotVertex = firstVertex;\n        for (u32 i = 0; i < DRAW2D_NUM_ELLIPSE_SEGMENTS; ++i) {\n            u32 vertex = (firstVertex + 1) + i;\n            u32 nextVertex = (firstVertex + 2) + i;\n            if (i + 1 >= DRAW2D_NUM_ELLIPSE_SEGMENTS) {\n                nextVertex = firstVertex + 1;\n            }\n            indices[i * 3 + 0] = pivotVertex;\n            indices[i * 3 + 1] = nextVertex;\n            indices[i * 3 + 2] = vertex;\n        }\n    }\n\n    // https://forum.libcinder.org/topic/smooth-thick-lines-using-geometry-shader\n    void DrawLine(f32* points, u32 numPoints, f32 thickness, f32 blendR, f32 blendG, f32 blendB, f32 blendA) {\n        thickness *= 0.5f;\n\n        PlatformAssert(numPoints >= 2, __LOCATION__);\n        const u32 numVertsNeeded = numPoints * 2;\n        const u32 numIndicesNeeded = (numPoints - 1) * 6;\n        Internal::FlushIfNeeded(numVertsNeeded, numIndicesNeeded, Internal::gState->imageShader);\n        \n        float designScale = Internal::gState->designDpi;\n        vec2 screenSize(Internal::gState->displayWidth, Internal::gState->displayHeight);\n\n        vec4 color(blendR, blendG, blendB, blendA);\n\n        u32 firstVertex = Internal::gState->numVertices;\n        Internal::Vertex* vertices = &Internal::gState->vertices[firstVertex];\n        Internal::gState->numVertices += numVertsNeeded;\n\n        SetVertexAttribs(vertices, numVertsNeeded, vec2(), 8, vec4(blendR, blendG, blendB, blendA));\n\n        vec2 p0(points[0], points[1]);\n        vec2 p1(points[2], points[3]);\n        vec2 line01 = p1 - p0;\n        vec2 dir01 = normalized(line01);\n        vec2 norm01(-dir01.y, dir01.x);\n\n        vec2 debug1 = p0 - norm01 * thickness;\n        vec2 debug2 = p0 + norm01 * thickness;\n        vertices[0].position = (p0 - norm01 * thickness) * designScale / screenSize;\n        vertices[1].position = (p0 + norm01 * thickness) * designScale / screenSize;\n\n        vec2 min = vertices[0].position;\n        vec2 max = min;\n\n        if (vertices[1].position.x < min.x) {\n            min.x = vertices[1].position.x;\n        }\n        if (vertices[1].position.y < min.y) {\n            min.y = vertices[1].position.y;\n        }\n        if (vertices[1].position.x > max.x) {\n            max.x = vertices[1].position.x;\n        }\n        if (vertices[1].position.y > max.y) {\n            max.y = vertices[1].position.y;\n        }\n\n        for (u32 i = 1; i < numPoints - 1; ++i) {\n            p0 = vec2(points[(i - 1) * 2 + 0], points[(i - 1) * 2 + 1]);\n            p1 = vec2(points[i * 2 + 0], points[i * 2 + 1]);\n            vec2 p2(points[(i + 1) * 2 + 0], points[(i + 1) * 2 + 1]);\n            \n            line01 = p1 - p0;\n            dir01 = normalized(line01);\n            norm01 = vec2(-dir01.y, dir01.x);\n\n            vec2 line12 = p2 - p1;\n            vec2 dir12 = normalized(line12);\n            vec2 norm12(-dir12.y, dir12.x);\n\n            vec2 tangent = normalized(dir01 + dir12);\n            vec2 miter(-tangent.y, tangent.x);\n            f32 length = thickness;\n            f32 dt = dot(miter, norm01);\n            if (dt != 0.0f) {\n                length = thickness / dot(miter, norm01);\n            }\n\n            vertices[i * 2 + 0].position = (p1 - miter * length) * designScale / screenSize;\n            vertices[i * 2 + 1].position = (p1 + miter * length) * designScale / screenSize;\n\n            if (vertices[i * 2 + 0].position.x < min.x) {\n                min.x = vertices[i * 2 + 0].position.x;\n            }\n            if (vertices[i * 2 + 0].position.y < min.y) {\n                min.y = vertices[i * 2 + 0].position.y;\n            }\n            if (vertices[i * 2 + 0].position.x > max.x) {\n                max.x = vertices[i * 2 + 0].position.x;\n            }\n            if (vertices[i * 2 + 0].position.y > max.y) {\n                max.y = vertices[i * 2 + 0].position.y;\n            }\n\n            if (vertices[i * 2 + 1].position.x < min.x) {\n                min.x = vertices[i * 2 + 1].position.x;\n            }\n            if (vertices[i * 2 + 1].position.y < min.y) {\n                min.y = vertices[i * 2 + 1].position.y;\n            }\n            if (vertices[i * 2 + 1].position.x > max.x) {\n                max.x = vertices[i * 2 + 1].position.x;\n            }\n            if (vertices[i * 2 + 1].position.y > max.y) {\n                max.y = vertices[i * 2 + 1].position.y;\n            }\n        }\n\n        // This is acutally p1 and p2. I just didn't want to declare new vartiables here for these\n        p0 = vec2(points[(numPoints - 2) * 2 + 0], points[(numPoints - 2) * 2 + 1]);\n        p1 = vec2(points[(numPoints - 1) * 2 + 0], points[(numPoints - 1) * 2 + 1]);\n        line01 = p1 - p0;\n        dir01 = normalized(line01);\n        norm01 = vec2(-dir01.y, dir01.x);\n\n        vertices[numPoints * 2 - 2].position = (p1 - norm01 * thickness) * designScale / screenSize;\n        vertices[numPoints * 2 - 1].position = (p1 + norm01 * thickness) * designScale / screenSize;\n\n        if (vertices[numPoints * 2 - 2].position.x < min.x) {\n            min.x = vertices[numPoints * 2 - 2].position.x;\n        }\n        if (vertices[numPoints * 2 - 2].position.y < min.y) {\n            min.y = vertices[numPoints * 2 - 2].position.y;\n        }\n        if (vertices[numPoints * 2 - 2].position.x > max.x) {\n            max.x = vertices[numPoints * 2 - 2].position.x;\n        }\n        if (vertices[numPoints * 2 - 2].position.y > max.y) {\n            max.y = vertices[numPoints * 2 - 2].position.y;\n        }\n\n        if (vertices[numPoints * 2 - 1].position.x < min.x) {\n            min.x = vertices[numPoints * 2 - 1].position.x;\n        }\n        if (vertices[numPoints * 2 - 1].position.y < min.y) {\n            min.y = vertices[numPoints * 2 - 1].position.y;\n        }\n        if (vertices[numPoints * 2 - 1].position.x > max.x) {\n            max.x = vertices[numPoints * 2 - 1].position.x;\n        }\n        if (vertices[numPoints * 2 - 1].position.y > max.y) {\n            max.y = vertices[numPoints * 2 - 1].position.y;\n        }\n        \n        if (Internal::gState->clipStack.Count() > 0) { \n            vec4 clip = Internal::gState->activeClip;\n            f32 clipLeft = clip.x * designScale / screenSize.x;\n            f32 clipTop = clip.y * designScale / screenSize.y;\n            f32 clipRight = (clip.x + clip.z) * designScale / screenSize.x;\n            f32 clipBotom = (clip.y +  clip.w) * designScale / screenSize.y;\n\n            f32 boundsLeft = min.x;\n            f32 boundsTop = min.y;\n            f32 boundsRight = max.x;\n            f32 boundsBottom = (max.y);\n\n            // If any of these are true, the box is invisible\n            if (boundsLeft > clipRight || boundsRight < clipLeft || boundsTop > clipBotom || boundsBottom < clipTop) {\n                Internal::gState->numVertices -= numPoints * 2;\n                return; // Reset and early out\n            }\n        }\n\n        // Generate indices\n        u16* indices = &Internal::gState->indices[Internal::gState->numIndices];\n        Internal::gState->numIndices += numIndicesNeeded;\n\n        u32 idx = 0;\n        for (u32 i = 0; i < (numPoints - 1); ++i) {\n            indices[idx++] = firstVertex + (2 * i) + 3;\n            indices[idx++] = firstVertex + (2 * i) + 2;\n            indices[idx++] = firstVertex + (2 * i) + 1;\n\n            indices[idx++] = firstVertex + (2 * i) + 1;\n            indices[idx++] = firstVertex + (2 * i) + 2;\n            indices[idx++] = firstVertex + (2 * i) + 0;\n        }\n    }\n}","#ifndef _H_GRAPHICS_\n#define _H_GRAPHICS_\n\ntypedef unsigned int u32;\ntypedef int i32;\ntypedef float f32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(f32) == 4, \"f32 should be a 4 byte type\");\nstatic_assert (sizeof(void*) >= 4, \"pointer should be >= 4 byte type\");\n\n#define GfxBufferTypeFloat32            0\n#define GfxBufferTypeInt16              3\n#define GfxBufferTypeInt32              5\n\n#define GfxIndexTypeByte                1\n#define GfxIndexTypeShort               2\n#define GfxIndexTypeInt                 4\n\n#define GfxTextureFormatRGB8            0\n#define GfxTextureFormatRGBA8           1\n#define GfxTextureFormatR32F            2\n#define GfxTextureFormatRGB32F          3\n#define GfxTextureFormatDepth           4\n#define GfxTextureFormatR8              5 \n// GfxTextureFormatDepth is only a target format, not a source format\n\n#define GfxFilterNearest                0\n#define GfxFilterLinear                 1\n#define GfxFilterNone                   2\n\n#define GfxWrapRepeat                   0\n#define GfxWrapClamp                    1\n\n#define GfxUniformTypeInt1              0\n#define GfxUniformTypeInt2              1\n#define GfxUniformTypeInt3              2\n#define GfxUniformTypeInt4              3\n#define GfxUniformTypeFloat1            4\n#define GfxUniformTypeFloat2            5\n#define GfxUniformTypeFloat3            6\n#define GfxUniformTypeFloat4            7\n#define GfxUniformTypeFloat9            8\n#define GfxUniformTypeFloat16           9\n#define GfxUniformTypeTexture           10\n\n#define GfxDepthFuncAlways              0\n#define GfxDepthFuncNever               1\n#define GfxDepthFuncEqual               2\n#define GfxDepthFuncLEqual              3\n#define GfxDepthFuncGreater             4\n#define GfxDepthFuncGEqual              5\n#define GfxDepthFuncNotEqual            6\n#define GfxDepthFuncLess                7\n\n#define GfxCullFaceOff                  0\n#define GfxCullFaceBack                 1\n#define GfxCullFaceFront                2\n#define GfxCullFaceFrontAndBack         3\n\n#define GfxFaceWindCounterClockwise     0\n#define GfxFaceWindClockwise            1\n\n#define GfxBlendFuncZero                1\n#define GfxBlendFuncOne                 2\n#define GfxBlendFuncSrcColor            3\n#define GfxBlendFuncOneMinusSrcColor    4\n#define GfxBlendFuncDstColor            5\n#define GfxBlendFuncOneMinusDstColor    6\n#define GfxBlendFuncSrcAlpha            7\n#define GfxBlendFuncOneMinusSrcAlpha    8\n#define GfxBlendFuncDstAlpha            9\n#define GfxBlendFuncOneMinusDstAlpha    10\n#define GfxBlendFuncConstColor          11\n#define GfxBlendFuncOneMinusConstColor  12\n#define GfxBlendFuncConstAlpha          13\n#define GfxBlendFuncOneMinusconstAlpha  14\n#define GfxBlendFuncSrcAlphaSaturate    15\n\n#define GfxBlendEquationAdd             0\n#define GfxBlendEquationSubtract        1\n#define GfxBlendEquationReverseSubtract 2\n#define GfxBlendEquationMin             3\n#define GfxBlendEquationMax             4\n\n#define GfxDrawModePoints               0\n#define GfxDrawModeLines                1\n#define GfxDrawModeLineStrip            2\n#define GfxDrawModeTriangles            3\n#define GfxDrawModeTriangleStrip        4\n#define GfxDrawModeTriangleFan          5\n\nextern \"C\" u32 GfxCreateBuffer();\nextern \"C\" void GfxDestroyBuffer(u32 bufferId);\n\nextern \"C\" void GfxFillArrayBuffer(u32 bufferId, void* input, u32 bytes, bool _static);\nextern \"C\" void GfxFillIndexBuffer(u32 bufferId, void* input, u32 bytes, u32 indexType, bool _static);\n\ninline u32 GfxCreateArrayBuffer(void* input, u32 bytes, bool _static) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillArrayBuffer(buffer, input, bytes, _static);\n    return buffer;\n}\n\ninline u32 GfxCreateIndexBuffer(void* input, u32 bytes, u32 indexType, bool _static = true) {\n    u32 buffer = GfxCreateBuffer();\n    GfxFillIndexBuffer(buffer, input, bytes, indexType, _static);\n    return buffer;\n}\n\nextern \"C\" u32 GfxCreateShader(const char* vsource, const char* fsource);\nextern \"C\" void GfxDestroyShader(u32 shaderId);\n\nextern \"C\" i32 GfxGetUniformSlot(u32 shaderId, const char* name);\nextern \"C\" i32 GfxGetAttributeSlot(u32 shaderId, const char* name);\n\nextern \"C\" u32 GfxCreateShaderVertexLayout(u32 shaderId);\n#define GfxCreateVertexLayout GfxCreateShaderVertexLayout\nextern \"C\" void GfxAddBufferToLayout(u32 layoutId, i32 attribSlot, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxAddBufferToLayoutByName(u32 layoutId, const char* name, u32 bufferId, u32 numComponents, u32 strideBytes, u32 bufferType, u32 dataOffsetBytes);\nextern \"C\" void GfxDestroyShaderVertexLayout(u32 layoutId);\n\ninline void GfxAddIndexBufferToLayout(u32 layoutId, u32 bufferId) {\n    GfxAddBufferToLayout(layoutId, -1, bufferId, 1, 0, GfxBufferTypeInt16, 0);\n}\n\nextern \"C\" u32 GfxCreateTexture(void* data, u32 width, u32 height, u32 sourceFormat, u32 targetFormat, bool genMips);\ninline u32 GfxCreateDepthTexture(u32 width, u32 height) {\n    return GfxCreateTexture(0, width, height, GfxTextureFormatDepth, GfxTextureFormatDepth, false);\n}\nextern \"C\" void GfxSetTextureSampler(u32 textureId, u32 wrapS, u32 wrapT, u32 minFilter, u32 mipFilter, u32 magFilter);\nextern \"C\" void GfxDestroyTexture(u32 textureId);\n\n// Data and texture format must match. IE, can't upload RGBA to an RGB texture\nextern \"C\" void GfxWriteToTexture(u32 textureId, void* data, u32 dataAndTextureFormat, u32 x, u32 y, u32 w, u32 h);\n\nextern \"C\" void GfxSetUniform(u32 shaderId, u32 uniformSlot, void* data, u32 uniformType, u32 count); \ninline void GfxSetUniformTexture(u32 shaderId, u32 uniformSlot, u32 textureId) {\n    GfxSetUniform(shaderId, uniformSlot, (void*)textureId, 10, 1);\n}\n\nextern \"C\" void GfxClearAll(u32 colorTargetId, u32 depthTargetId, float r, float g, float b, float d);\nextern \"C\" void GfxClearColor(u32 colorTargetTextureId, u32 depthTargetTextureId, float r, float g, float b);\nextern \"C\" void GfxClearDepth(u32 colorTargetTextureId, u32 depthTargetTextureId, float depth);\nextern \"C\" void GfxDraw(u32 colorTargetTextureId, u32 depthTargetTextureId, u32 vertexLayoutId, u32 drawMode, u32 startIndex, u32 indexCount, u32 instanceCount);\n\nextern \"C\" void GfxSetBlendState(bool blend, f32* optBlendColor, u32 blendDstRgb, u32 blendDstAlpha, u32 blendEquationRgb, u32 blendEquationAlpha, u32 blendSrcRgb, u32 blendSrcAlpha);\ninline void GfxEnableAlphaBlending() {\n\n}\nextern \"C\" void GfxSetCullState(u32 cullFace, u32 faceWind);\nextern \"C\" void GfxSetDepthState(bool enable, u32 depthFunc, f32* depthRange);\ninline void GfxEnableDepthTest() {\n    GfxSetDepthState(true, GfxDepthFuncLess, 0);\n}\ninline void GfxDisableDepthTest() {\n    GfxSetDepthState(false, GfxDepthFuncLess, 0);\n}\n\n// OpenGL style, bottom left / width and height\nextern \"C\" void GfxSetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\n#define GfxSetClipState GfxSetScissorState\nextern \"C\" void GfxSetWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void GfxSetViewport(u32 x, u32 y, u32 w, u32 h);\n\n// Initialize and shutdown functions exist, but you don't call them\n// the platform does. The void* that's being passed in is platform\n// specific, it contains whatever we need for OpenGL rendering \nextern \"C\" int GfxInitialize(void* in, void* out);\nextern \"C\" void GfxShutdown(void* userData);\nextern \"C\" void GfxFinish(); // This just calls glFinish, used to wait for vsynch on windows\n\n// Need to call at least once for GfxDraw to start tracking stats\nextern \"C\" void GfxEnableStats(bool enable);\n// Returns the number of verts since this was last called.\nextern \"C\" int GfxStatsIndexCount();\nextern \"C\" int GfxStatsDrawCount(); \n\n#endif","#ifndef _H_VECTOR_\n#define _H_VECTOR_\n\n#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n\ntemplate<typename T>\nclass Vector {\n    T* mData;\n    u32 mCount;\n    u32 mCapacity;\npublic:\n    inline Vector() {\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\n\n    inline Vector(u32 capacity) {\n        mData = (T*)MemAlloc(sizeof(T) * capacity);\n        mCount = 0;\n        mCapacity = capacity;\n    }\n\n\n    inline Vector(T* array, u32 count) {\n        mData = (T*)MemAlloc(sizeof(T) * count);\n        MemCopy(mData, array, count * sizeof(T));\n        mCount = count;\n        mCapacity = count;\n    }\n\n    inline Vector(const Vector<T>& other) {\n        mCapacity = other.mCapacity;\n        mCount = other.mCount;\n        mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n        MemCopy(mData, other.mData, mCapacity * sizeof(T));\n    }\n\n    inline Vector<T>& operator=(const Vector<T>& other) {\n        PlatformAssert(this != &other, __LOCATION__);\n        if (this != &other) {\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mCapacity = other.mCapacity;\n            mCount = other.mCount;\n            mData = (T*)MemAlloc(sizeof(T) * mCapacity);\n            MemCopy(mData, other.mData, mCapacity * sizeof(T));\n        }\n\n        return *this;\n    }\n\n    inline ~Vector() {\n        if (mData != 0) {\n            MemRelease(mData);\n        }\n        mData = 0;\n        mCount = 0;\n        mCapacity = 0;\n    }\npublic:\n    T& operator[](u32 i) { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i]; \n    }\n\n    const T& operator[](u32 i) const { \n        PlatformAssert(i < mCount, __LOCATION__);\n        PlatformAssert(mData != 0, __LOCATION__);\n        return mData[i];\n    }\n\n    inline void Reserve(u32 count) {\n        if (count < 1) {\n            count = 1;\n        }\n\n        if (count > mCapacity) {\n            T* newData = (T*)MemAlloc(sizeof(T) * count);\n            if (mCapacity > 0) {\n                MemCopy(newData, mData, mCapacity * sizeof(T));\n            }\n            mCapacity = count;\n            if (mData != 0) {\n                MemRelease(mData);\n            }\n            mData = newData;\n        }\n    }\n\n    inline void Resize(u32 count) {\n        Reserve(count);\n        mCount = count;\n    }\n    \n    inline void PushBack() {\n        if (mCapacity == 0) {\n            Reserve(2);\n        }\n\n        if (mCapacity - mCount == 0) {\n            Reserve(mCapacity * 2);\n        }\n\n        MemSet(&mData[mCount++], 0, sizeof(T));\n    }\n\n    inline void PushBack(const T& val) {\n        if (mCapacity == 0) {\n            Reserve(2);\n        }\n        \n        if (mCapacity - mCount == 0) {\n            Reserve(mCapacity * 2);\n        }\n\n        MemCopy(&mData[mCount++], &val, sizeof(T));\n    }\n\n    inline void PopBack() {\n        if (mCount > 0) {\n            mCount -= 1;\n        }\n    }\n\n    inline void Append(const T* array, u32 size) {\n        Reserve(mCount + size);\n        MemCopy(&mData[mCount], array, sizeof(T) * size);\n        mCount += size;\n    }\n\n    inline T* PeekHead() {\n        if (mCount != 0) {\n            return &mData[0];\n        }\n        return 0;\n    }\n\n    inline T* PeekTail() {\n        if (mCount != 0) {\n            return &mData[mCount - 1];\n        }\n        return 0;\n    }\n\n    inline u32 Count() {\n        return mCount;\n    }\n\n    inline u32 Capacity() {\n        return mCapacity;\n    }\n};\n\n#endif","#ifndef _H_VEC4_\n#define _H_VEC4_\n\ntemplate<typename T>\nstruct TVec4 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t\tT z;\n\t\t\tT w;\n\t\t};\n\t\tT v[4];\n\t};\n\tinline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n\tinline TVec4(T _x, T _y, T _z, T _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) { }\n\tinline TVec4(T* fv) {\n\t\tif (fv != 0) {\n\t\t\tx = fv[0];\n\t\t\ty = fv[1];\n\t\t\tz = fv[2];\n\t\t\tw = fv[3];\n\t\t}\n\t\telse {\n\t\t\tx = y = z = w = 0.0f;\n\t\t}\n\t}\n};\n\ntypedef TVec4<float> vec4;\ntypedef TVec4<int> ivec4;\ntypedef TVec4<unsigned int> uivec4;\n\n#endif","// stb_truetype.h - v1.26 - public domain\n// authored from 2009-2021 by Sean Barrett / RAD Game Tools\n//\n// =======================================================================\n//\n//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES\n//\n// This library does no range checking of the offsets found in the file,\n// meaning an attacker can use it to read arbitrary memory.\n//\n// =======================================================================\n//\n//   This library processes TrueType files:\n//        parse files\n//        extract glyph metrics\n//        extract glyph shapes\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\n//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)\n//\n// ADDITIONAL CONTRIBUTORS\n//\n//   Mikko Mononen: compound shape support, more cmap formats\n//   Tor Andersson: kerning, subpixel rendering\n//   Dougall Johnson: OpenType / Type 2 font handling\n//   Daniel Ribeiro Maciel: basic GPOS-based kerning\n//\n//   Misc other:\n//       Ryan Gordon\n//       Simon Glass\n//       github:IntellectualKitty\n//       Imanol Celaya\n//       Daniel Ribeiro Maciel\n//\n//   Bug/warning reports/fixes:\n//       \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen   github:NiLuJe\n//       Cass Everitt               Martins Mozeiko       github:aloucks\n//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam\n//       Brian Hook                 Omar Cornut           github:vassvik\n//       Walter van Niftrik         Ryan Griege\n//       David Gow                  Peter LaValle\n//       David Given                Sergey Popov\n//       Ivan-Assen Ivanov          Giumo X. Clanjor\n//       Anthony Pesch              Higor Euripedes\n//       Johan Duparc               Thomas Fields\n//       Hou Qiming                 Derek Vinyard\n//       Rob Loach                  Cort Stratton\n//       Kenney Phillis Jr.         Brian Costabile\n//       Ken Voskuil (kaesve)\n//\n// VERSION HISTORY\n//\n//   1.26 (2021-08-28) fix broken rasterizer\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     variant PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//\n//   Full history can be found at the end of this file.\n//\n// LICENSE\n//\n//   See end of file for license information.\n//\n// USAGE\n//\n//   Include this file in whatever places need to refer to it. In ONE C/C++\n//   file, write:\n//      #define STB_TRUETYPE_IMPLEMENTATION\n//   before the include of this file. This expands out the actual\n//   implementation into that C/C++ file.\n//\n//   To make the implementation private to the file that generates the implementation,\n//      #define STBTT_STATIC\n//\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start)\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\n//\n//   Improved 3D API (more shippable):\n//            \"stb_rect_pack.h\"           -- optional, but you really want it\n//           stbtt_PackBegin()\n//           stbtt_PackSetOversampling()          -- for improved quality on small fonts\n//           stbtt_PackFontRanges()               -- pack and renders\n//           stbtt_PackEnd()\n//           stbtt_GetPackedQuad()\n//\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\n//           stbtt_InitFont()\n//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections\n//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections\n//\n//   Render a unicode codepoint to a bitmap\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\n//\n//   Character advance/positioning\n//           stbtt_GetCodepointHMetrics()\n//           stbtt_GetFontVMetrics()\n//           stbtt_GetFontVMetricsOS2()\n//           stbtt_GetCodepointKernAdvance()\n//\n//   Starting with version 1.06, the rasterizer was replaced with a new,\n//   faster and generally-more-precise rasterizer. The new rasterizer more\n//   accurately measures pixel coverage for anti-aliasing, except in the case\n//   where multiple shapes overlap, in which case it overestimates the AA pixel\n//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If\n//   this turns out to be a problem, you can re-enable the old rasterizer with\n//        #define STBTT_RASTERIZER_VERSION 1\n//   which will incur about a 15% speed hit.\n//\n// ADDITIONAL DOCUMENTATION\n//\n//   Immediately after this block comment are a series of sample programs.\n//\n//   After the sample programs is the \"header file\" section. This section\n//   includes documentation for each API function.\n//\n//   Some important concepts to understand to use this library:\n//\n//      Codepoint\n//         Characters are defined by unicode codepoints, e.g. 65 is\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\n//         the hiragana for \"ma\".\n//\n//      Glyph\n//         A visual character shape (every codepoint is rendered as\n//         some glyph)\n//\n//      Glyph index\n//         A font-specific integer ID representing a glyph\n//\n//      Baseline\n//         Glyph shapes are defined relative to a baseline, which is the\n//         bottom of uppercase characters. Characters extend both above\n//         and below the baseline.\n//\n//      Current Point\n//         As you draw text to the screen, you keep track of a \"current point\"\n//         which is the origin of each character. The current point's vertical\n//         position is the baseline. Even \"baked fonts\" use this model.\n//\n//      Vertical Font Metrics\n//         The vertical qualities of the font, used to vertically position\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\n//\n//      Font Size in Pixels or Points\n//         The preferred interface for specifying font sizes in stb_truetype\n//         is to specify how tall the font's vertical extent should be in pixels.\n//         If that sounds good enough, skip the next paragraph.\n//\n//         Most font APIs instead use \"points\", which are a common typographic\n//         measurement for describing font size, defined as 72 points per inch.\n//         stb_truetype provides a point API for compatibility. However, true\n//         \"per inch\" conventions don't make much sense on computer displays\n//         since different monitors have different number of pixels per\n//         inch. For example, Windows traditionally uses a convention that\n//         there are 96 pixels per inch, thus making 'inch' measurements have\n//         nothing to do with inches, and thus effectively defining a point to\n//         be 1.333 pixels. Additionally, the TrueType font data provides\n//         an explicit scale factor to scale a given font's glyphs to points,\n//         but the author has observed that this scale factor is often wrong\n//         for non-commercial fonts, thus making fonts scaled in points\n//         according to the TrueType spec incoherently sized in practice.\n//\n// DETAILED USAGE:\n//\n//  Scale:\n//    Select how high you want the font to be, in points or pixels.\n//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute\n//    a scale factor SF that will be used by all other functions.\n//\n//  Baseline:\n//    You need to select a y-coordinate that is the baseline of where\n//    your text will appear. Call GetFontBoundingBox to get the baseline-relative\n//    bounding box for all characters. SF*-y0 will be the distance in pixels\n//    that the worst-case character could extend above the baseline, so if\n//    you want the top edge of characters to appear at the top of the\n//    screen where y=0, then you would set the baseline to SF*-y0.\n//\n//  Current point:\n//    Set the current point where the first character will appear. The\n//    first character could extend left of the current point; this is font\n//    dependent. You can either choose a current point that is the leftmost\n//    point and hope, or add some padding, or check the bounding box or\n//    left-side-bearing of the first character to be displayed and set\n//    the current point based on that.\n//\n//  Displaying a character:\n//    Compute the bounding box of the character. It will contain signed values\n//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,\n//    then the character should be displayed in the rectangle from\n//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).\n//\n//  Advancing for the next character:\n//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.\n//\n//\n// ADVANCED USAGE\n//\n//   Quality:\n//\n//    - Use the functions with Subpixel at the end to allow your characters\n//      to have subpixel positioning. Since the font is anti-aliased, not\n//      hinted, this is very import for quality. (This is not possible with\n//      baked fonts.)\n//\n//    - Kerning is now supported, and if you're supporting subpixel rendering\n//      then kerning is worth using to give your text a polished look.\n//\n//   Performance:\n//\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\n//      if you don't do this, stb_truetype is forced to do the conversion on\n//      every call.\n//\n//    - There are a lot of memory allocations. We should modify it to take\n//      a temp buffer and allocate from the temp buffer (without freeing),\n//      should help performance a lot.\n//\n// NOTES\n//\n//   The system uses the raw data found in the .ttf file without changing it\n//   and without building auxiliary data structures. This is a bit inefficient\n//   on little-endian systems (the data is big-endian), but assuming you're\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\n//\n//   It appears to be very hard to programmatically determine what font a\n//   given file is in a general way. I provide an API for this, but I don't\n//   recommend it.\n//\n//\n// PERFORMANCE MEASUREMENTS FOR 1.06:\n//\n//                      32-bit     64-bit\n//   Previous release:  8.83 s     7.68 s\n//   Pool allocations:  7.72 s     6.34 s\n//   Inline sort     :  6.54 s     5.65 s\n//   New rasterizer  :  5.63 s     5.00 s\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////  SAMPLE PROGRAMS\n////\n//\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.\n//  See \"tests/truetype_demo_win32.c\" for a complete version.\n//\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program (this compiles): get a single bitmap, print as ASCII art\n//\n//\n// Output:\n//\n//     .ii.\n//    @@@@@@.\n//   V@Mio@@o\n//   :i.  V@V\n//     :oM@@M\n//   :@@@MM@M\n//   @@o  o@M\n//  :@@.  M@M\n//   @@@o@@@@\n//   :M@@V:@@.\n//\n//////////////////////////////////////////////////////////////////////////////\n//\n// Complete program: print \"Hello World!\" banner, with bugs\n//\n\n//////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n////\n////   INTEGRATION WITH YOUR CODEBASE\n////\n////   The following sections allow you to supply alternate definitions\n////   of C library functions used by stb_truetype, e.g. if you don't\n////   link with the C runtime library.\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n   // #define your own (u)stbtt_int8/16/32 before including to override this\n   #ifndef stbtt_uint8\n   typedef unsigned char   stbtt_uint8;\n   typedef signed   char   stbtt_int8;\n   typedef unsigned short  stbtt_uint16;\n   typedef signed   short  stbtt_int16;\n   typedef unsigned int    stbtt_uint32;\n   typedef signed   int    stbtt_int32;\n   #endif\n\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\n\n   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\n   #ifndef STBTT_ifloor\n   #define STBTT_ifloor(x)   ((int) floor(x))\n   #define STBTT_iceil(x)    ((int) ceil(x))\n   #endif\n\n   #ifndef STBTT_sqrt\n   #define STBTT_sqrt(x)      sqrt(x)\n   #define STBTT_pow(x,y)     pow(x,y)\n   #endif\n\n   #ifndef STBTT_fmod\n   #define STBTT_fmod(x,y)    fmod(x,y)\n   #endif\n\n   #ifndef STBTT_cos\n   #define STBTT_cos(x)       cos(x)\n   #define STBTT_acos(x)      acos(x)\n   #endif\n\n   #ifndef STBTT_fabs\n   #define STBTT_fabs(x)      fabs(x)\n   #endif\n\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\n   #ifndef STBTT_malloc\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\n   #define STBTT_free(x,u)    ((void)(u),free(x))\n   #endif\n\n   #ifndef STBTT_assert\n   #define STBTT_assert(x)    assert(x)\n   #endif\n\n   #ifndef STBTT_strlen\n   #define STBTT_strlen(x)    strlen(x)\n   #endif\n\n   #ifndef STBTT_memcpy\n   #define STBTT_memcpy       memcpy\n   #define STBTT_memset       memset\n   #endif\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   INTERFACE\n////\n////\n\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\n#define __STB_INCLUDE_STB_TRUETYPE_H__\n\n#ifdef STBTT_STATIC\n#define STBTT_DEF static\n#else\n#define STBTT_DEF extern\n#endif\n\n\n// private structure\ntypedef struct\n{\n   unsigned char *data;\n   int cursor;\n   int size;\n} stbtt__buf;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// TEXTURE BAKING API\n//\n// If you use this API, you only have to call two functions ever.\n//\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n} stbtt_bakedchar;\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\n// if return is positive, the first unused row of the bitmap\n// if return is negative, returns the negative of the number of characters that fit\n// if return is 0, no characters fit and no rows were used\n// This uses a very crappy packing.\n\ntypedef struct\n{\n   float x0,y0,s0,t0; // top-left\n   float x1,y1,s1,t1; // bottom-right\n} stbtt_aligned_quad;\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\n// Call GetBakedQuad with char_index = 'character - first_char', and it\n// creates the quad you need to draw and advances the current position.\n//\n// The coordinate system used assumes y increases downwards.\n//\n// Characters will extend both above and below the current position;\n// see discussion of \"BASELINE\" above.\n//\n// It's inefficient; you might want to c&p it and optimize it.\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);\n// Query the font vertical metrics without having to create a font first.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// NEW TEXTURE BAKING API\n//\n// This provides options for packing multiple fonts into one atlas, not\n// perfectly but better than nothing.\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\n   float xoff,yoff,xadvance;\n   float xoff2,yoff2;\n} stbtt_packedchar;\n\ntypedef struct stbtt_pack_context stbtt_pack_context;\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\n#ifndef STB_RECT_PACK_VERSION\ntypedef struct stbrp_rect stbrp_rect;\n#endif\n\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\n// Initializes a packing context stored in the passed-in stbtt_pack_context.\n// Future calls using this context will pack characters into the bitmap passed\n// in here: a 1-channel bitmap that is width * height. stride_in_bytes is\n// the distance from one row to the next (or 0 to mean they are packed tightly\n// together). \"padding\" is the amount of padding to leave between each\n// character (normally you want '1' for bitmaps you'll use as textures with\n// bilinear filtering).\n//\n// Returns 0 on failure, 1 on success.\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\n// Cleans up the packing context and frees all memory.\n\n#define STBTT_POINT_SIZE(x)   (-(x))\n\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\n// Creates character bitmaps from the font_index'th font found in fontdata (use\n// font_index=0 if you don't know what that is). It creates num_chars_in_range\n// bitmaps for characters with unicode values starting at first_unicode_char_in_range\n// and increasing. Data for how to render them is stored in chardata_for_range;\n// pass these to stbtt_GetPackedQuad to get back renderable quads.\n//\n// font_size is the full height of the character from ascender to descender,\n// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed\n// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()\n// and pass that result as 'font_size':\n//       ...,                  20 , ... // font max minus min y is 20 pixels tall\n//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall\n\ntypedef struct\n{\n   float font_size;\n   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint\n   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints\n   int num_chars;\n   stbtt_packedchar *chardata_for_range; // output\n   unsigned char h_oversample, v_oversample; // don't set these, they're used internally\n} stbtt_pack_range;\n\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\n// Creates character bitmaps from multiple ranges of characters stored in\n// ranges. This will usually create a better-packed bitmap than multiple\n// calls to stbtt_PackFontRange. Note that you can call this multiple\n// times within a single PackBegin/PackEnd.\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\n// Oversampling a font increases the quality by allowing higher-quality subpixel\n// positioning, and is especially valuable at smaller text sizes.\n//\n// This function sets the amount of oversampling for all following calls to\n// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given\n// pack context. The default (no oversampling) is achieved by h_oversample=1\n// and v_oversample=1. The total number of pixels required is\n// h_oversample*v_oversample larger than the default; for example, 2x2\n// oversampling requires 4x the storage of 1x1. For best results, render\n// oversampled textures with bilinear filtering. Look at the readme in\n// stb/tests/oversample for information about oversampled fonts\n//\n// To use with PackFontRangesGather etc., you must set it before calls\n// call to PackFontRangesGatherRects.\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);\n// If skip != 0, this tells stb_truetype to skip any codepoints for which\n// there is no corresponding glyph. If skip=0, which is the default, then\n// codepoints without a glyph recived the font's \"missing character\" glyph,\n// typically an empty box by convention.\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above\n                               int char_index,             // character to display\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\n                               stbtt_aligned_quad *q,      // output: quad to draw\n                               int align_to_integer);\n\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\n// Calling these functions in sequence is roughly equivalent to calling\n// stbtt_PackFontRanges(). If you more control over the packing of multiple\n// fonts, or if you want to pack custom data into a font texture, take a look\n// at the source to of stbtt_PackFontRanges() and create a custom version\n// using these functions, e.g. call GatherRects multiple times,\n// building up a single array of rects, then call PackRects once,\n// then call RenderIntoRects repeatedly. This may result in a\n// better packing than calling PackFontRanges multiple times\n// (or it may not).\n\n// this is an opaque structure that you shouldn't mess with which holds\n// all the context needed from PackBegin to PackEnd.\nstruct stbtt_pack_context {\n   void *user_allocator_context;\n   void *pack_info;\n   int   width;\n   int   height;\n   int   stride_in_bytes;\n   int   padding;\n   int   skip_missing;\n   unsigned int   h_oversample, v_oversample;\n   unsigned char *pixels;\n   void  *nodes;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// FONT LOADING\n//\n//\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\n// This function will determine the number of fonts in a font file.  TrueType\n// collection (.ttc) files may contain multiple fonts, while TrueType font\n// (.ttf) files only contain one font. The number of fonts can be used for\n// indexing with the previous function where the index is between zero and one\n// less than the total fonts. If an error occurs, -1 is returned.\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\n// index number starting from 0. Call this function to get the font offset for\n// a given index; it returns -1 if the index is out of range. A regular .ttf\n// file will only define one font and it always be at offset 0, so it will\n// return '0' for index 0, and -1 for all other indices.\n\n// The following structure is defined publicly so you can declare one on\n// the stack or as a global or etc, but you should treat it as opaque.\nstruct stbtt_fontinfo\n{\n   void           * userdata;\n   unsigned char  * data;              // pointer to .ttf file\n   int              fontstart;         // offset of start of font\n\n   int numGlyphs;                     // number of glyphs, needed for range checking\n\n   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf\n   int index_map;                     // a cmap mapping for our chosen character encoding\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\n\n   stbtt__buf cff;                    // cff font data\n   stbtt__buf charstrings;            // the charstring index\n   stbtt__buf gsubrs;                 // global charstring subroutines index\n   stbtt__buf subrs;                  // private charstring subroutines index\n   stbtt__buf fontdicts;              // array of font dicts\n   stbtt__buf fdselect;               // map from glyph to fontdict\n};\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\n// Given an offset into the file that defines a font, this function builds\n// the necessary cached info for the rest of the system. You must allocate\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\n// need to do anything special to free it, because the contents are pure\n// value data with no additional data structures. Returns 0 on failure.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\n// If you're going to perform multiple operations on the same character\n// and you want a speed-up, call this function with the character you're\n// going to process, then use glyph-based functions instead of the\n// codepoint-based functions.\n// Returns 0 if the character codepoint is not defined in the font.\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CHARACTER PROPERTIES\n//\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\n// Height is measured as the distance from the highest ascender to the lowest\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\n// and computing:\n//       scale = pixels / (ascent - descent)\n// so if you prefer to measure height by the ascent only, use a similar calculation.\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\n// computes a scale factor to produce a font whose EM size is mapped to\n// 'pixels' tall. This is probably what traditional APIs compute, but\n// I'm not positive.\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\n// ascent is the coordinate above the baseline the font extends; descent\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\n// lineGap is the spacing between one row's descent and the next row's ascent...\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\n//   these are expressed in unscaled coordinates, so you must multiply by\n//   the scale factor for a given size\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\n// analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2\n// table (specific to MS/Windows TTF files).\n//\n// Returns 1 on success (table present), 0 on failure.\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\n// the bounding box around all possible characters\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\n//   these are expressed in unscaled coordinates\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\n// an additional amount to add to the 'advance' value between ch1 and ch2\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n// as above, but takes one or more glyph indices for greater efficiency\n\ntypedef struct stbtt_kerningentry\n{\n   int glyph1; // use stbtt_FindGlyphIndex\n   int glyph2;\n   int advance;\n} stbtt_kerningentry;\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);\nSTBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);\n// Retrieves a complete list of all of the kerning pairs provided by the font\n// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.\n// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// GLYPH SHAPES (you probably don't need these, but they have to go before\n// the bitmaps for C declaration-order reasons)\n//\n\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\n   enum {\n      STBTT_vmove=1,\n      STBTT_vline,\n      STBTT_vcurve,\n      STBTT_vcubic\n   };\n#endif\n\n#ifndef stbtt_vertex // you can predefine this to use different values\n                   // (we share this with other code at RAD)\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\n   typedef struct\n   {\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\n      unsigned char type,padding;\n   } stbtt_vertex;\n#endif\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\n// returns non-zero if nothing is drawn for this glyph\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\n// returns # of vertices and fills *vertices with the pointer to them\n//   these are expressed in \"unscaled\" coordinates\n//\n// The shape is a series of contours. Each one starts with\n// a STBTT_moveto, then consists of a series of mixed\n// STBTT_lineto and STBTT_curveto segments. A lineto\n// draws a line from previous endpoint to its x,y; a curveto\n// draws a quadratic bezier from previous endpoint to\n// its x,y, using cx,cy as the bezier control point.\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\n// frees the data allocated above\n\nSTBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);\n// fills svg with the character's SVG data.\n// returns data size or 0 if SVG not found.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BITMAP RENDERING\n//\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\n// frees the bitmap allocated below\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// allocates a large-enough single-channel 8bpp bitmap and renders the\n// specified character/glyph at the specified scale into it, with\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\n// *width & *height are filled out with the width & height of the bitmap,\n// which is stored left-to-right, top-to-bottom.\n//\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\n// width and height and positioning info for it first.\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\n// shift for the character\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\n// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering\n// is performed (see stbtt_PackSetOversampling)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// get the bbox of the bitmap centered around the glyph origin; so the\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\n// the bitmap top left is (leftSideBearing*scale,iy0).\n// (Note that the bitmap uses y-increases-down, but the shape uses\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\n// shift for the character\n\n// the following functions are equivalent to the above functions, but operate\n// on glyph indices instead of Unicode codepoints (for efficiency)\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n\n\ntypedef struct\n{\n   int w,h,stride;\n   unsigned char *pixels;\n} stbtt__bitmap;\n\n// rasterize a shape with quadratic beziers into a bitmap\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into\n                               float flatness_in_pixels,     // allowable error of curve in pixels\n                               stbtt_vertex *vertices,       // array of vertices defining shape\n                               int num_verts,                // number of vertices in above array\n                               float scale_x, float scale_y, // scale applied to input vertices\n                               float shift_x, float shift_y, // translation applied to input vertices\n                               int x_off, int y_off,         // another translation applied to input\n                               int invert,                   // if non-zero, vertically flip shape\n                               void *userdata);              // context for to STBTT_MALLOC\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Signed Distance Function (or Field) rendering\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\n// frees the SDF bitmap allocated below\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\n// These functions compute a discretized SDF field for a single character, suitable for storing\n// in a single-channel texture, sampling with bilinear filtering, and testing against\n// larger than some threshold to produce scalable fonts.\n//        info              --  the font\n//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap\n//        glyph/codepoint   --  the character to generate the SDF for\n//        padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0),\n//                                 which allows effects like bit outlines\n//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)\n//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale)\n//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside\n//        width,height      --  output height & width of the SDF bitmap (including padding)\n//        xoff,yoff         --  output origin of the character\n//        return value      --  a 2D array of bytes 0..255, width*height in size\n//\n// pixel_dist_scale & onedge_value are a scale & bias that allows you to make\n// optimal use of the limited 0..255 for your application, trading off precision\n// and special effects. SDF values outside the range 0..255 are clamped to 0..255.\n//\n// Example:\n//      scale = stbtt_ScaleForPixelHeight(22)\n//      padding = 5\n//      onedge_value = 180\n//      pixel_dist_scale = 180/5.0 = 36.0\n//\n//      This will create an SDF bitmap in which the character is about 22 pixels\n//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled\n//      shape, sample the SDF at each pixel and fill the pixel if the SDF value\n//      is greater than or equal to 180/255. (You'll actually want to antialias,\n//      which is beyond the scope of this example.) Additionally, you can compute\n//      offset outlines (e.g. to stroke the character border inside & outside,\n//      or only outside). For example, to fill outside the character up to 3 SDF\n//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above\n//      choice of variables maps a range from 5 pixels outside the shape to\n//      2 pixels inside the shape to 0..255; this is intended primarily for apply\n//      outside effects only (the interior range is needed to allow proper\n//      antialiasing of the font at *smaller* sizes)\n//\n// The function computes the SDF analytically at each SDF pixel, not by e.g.\n// building a higher-res bitmap and approximating it. In theory the quality\n// should be as high as possible for an SDF of this size & representation, but\n// unclear if this is true in practice (perhaps building a higher-res bitmap\n// and computing from that can allow drop-out prevention).\n//\n// The algorithm has not been optimized at all, so expect it to be slow\n// if computing lots of characters or very large sizes.\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Finding the right font...\n//\n// You should really just solve this offline, keep your own tables\n// of what font is what, and don't try to get it out of the .ttf file.\n// That's because getting it out of the .ttf file is really hard, because\n// the names in the file can appear in many possible encodings, in many\n// possible languages, and e.g. if you need a case-insensitive comparison,\n// the details of that depend on the encoding & language in a complex way\n// (actually underspecified in truetype, but also gigantic).\n//\n// But you can use the provided functions in two possible ways:\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\n//             unicode-encoded names to try to find the font you want;\n//             you can run this before calling stbtt_InitFont()\n//\n//     stbtt_GetFontNameString() lets you get any of the various strings\n//             from the file yourself and do your own comparisons on them.\n//             You have to have called stbtt_InitFont() first.\n\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\n// returns the offset (not index) of the font that matches, or -1 if none\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\n//   if you use any other flag, use a font name like \"Arial\"; this checks\n//     the 'macStyle' header field; i don't know if fonts set this consistently\n#define STBTT_MACSTYLE_DONTCARE     0\n#define STBTT_MACSTYLE_BOLD         1\n#define STBTT_MACSTYLE_ITALIC       2\n#define STBTT_MACSTYLE_UNDERSCORE   4\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\n// returns 1/0 whether the first string interpreted as utf8 is identical to\n// the second string interpreted as big-endian utf16... useful for strings from next func\n\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\n// returns the string (which may be big-endian double byte, e.g. for unicode)\n// and puts the length in bytes in *length.\n//\n// some of the values for the IDs are below; for more see the truetype spec:\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\n//     http://www.microsoft.com/typography/otspec/name.htm\n\nenum { // platformID\n   STBTT_PLATFORM_ID_UNICODE   =0,\n   STBTT_PLATFORM_ID_MAC       =1,\n   STBTT_PLATFORM_ID_ISO       =2,\n   STBTT_PLATFORM_ID_MICROSOFT =3\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\n   STBTT_UNICODE_EID_ISO_10646      =2,\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\n   STBTT_MS_EID_SYMBOL        =0,\n   STBTT_MS_EID_UNICODE_BMP   =1,\n   STBTT_MS_EID_SHIFTJIS      =2,\n   STBTT_MS_EID_UNICODE_FULL  =10\n};\n\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\n};\n\nenum { // languageID for STBTT_PLATFORM_ID_MAC\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\n};\n\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////\n////\n////   IMPLEMENTATION\n////\n////\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n\n#ifndef STBTT_MAX_OVERSAMPLE\n#define STBTT_MAX_OVERSAMPLE   8\n#endif\n\n#if STBTT_MAX_OVERSAMPLE > 255\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\n#endif\n\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\n\n#ifndef STBTT_RASTERIZER_VERSION\n#define STBTT_RASTERIZER_VERSION 2\n#endif\n\n#ifdef _MSC_VER\n#define STBTT__NOTUSED(v)  (void)(v)\n#else\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n//////////////////////////////////////////////////////////////////////////\n//\n// stbtt__buf helpers to parse data from file\n//\n\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}\n\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}\n\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\n{\n   STBTT_assert(!(o > b->size || o < 0));\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\n}\n\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}\n\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}\n\nstatic stbtt__buf stbtt__new_buf(const void *p, unsigned int size)\n{\n   stbtt__buf r;\n   STBTT_assert(size < 0x40000000);\n   r.data = (stbtt_uint8*) p;\n   r.size = (int) size;\n   r.cursor = 0;\n   return r;\n}\n\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\n\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(0, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}\n\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\n{\n   int count, start, offsize;\n   start = b->cursor;\n   count = stbtt__buf_get16(b);\n   if (count) {\n      offsize = stbtt__buf_get8(b);\n      STBTT_assert(offsize >= 1 && offsize <= 4);\n      stbtt__buf_skip(b, offsize * count);\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\n   }\n   return stbtt__buf_range(b, start, b->cursor - start);\n}\n\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\n{\n   int b0 = stbtt__buf_get8(b);\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\n   else if (b0 == 28)               return stbtt__buf_get16(b);\n   else if (b0 == 29)               return stbtt__buf_get32(b);\n   STBTT_assert(0);\n   return 0;\n}\n\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\n   int v, b0 = stbtt__buf_peek8(b);\n   STBTT_assert(b0 >= 28);\n   if (b0 == 30) {\n      stbtt__buf_skip(b, 1);\n      while (b->cursor < b->size) {\n         v = stbtt__buf_get8(b);\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\n            break;\n      }\n   } else {\n      stbtt__cff_int(b);\n   }\n}\n\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\n{\n   stbtt__buf_seek(b, 0);\n   while (b->cursor < b->size) {\n      int start = b->cursor, end, op;\n      while (stbtt__buf_peek8(b) >= 28)\n         stbtt__cff_skip_operand(b);\n      end = b->cursor;\n      op = stbtt__buf_get8(b);\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\n      if (op == key) return stbtt__buf_range(b, start, end-start);\n   }\n   return stbtt__buf_range(b, 0, 0);\n}\n\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\n{\n   int i;\n   stbtt__buf operands = stbtt__dict_get(b, key);\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\n      out[i] = stbtt__cff_int(&operands);\n}\n\nstatic int stbtt__cff_index_count(stbtt__buf *b)\n{\n   stbtt__buf_seek(b, 0);\n   return stbtt__buf_get16(b);\n}\n\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\n{\n   int count, offsize, start, end;\n   stbtt__buf_seek(&b, 0);\n   count = stbtt__buf_get16(&b);\n   offsize = stbtt__buf_get8(&b);\n   STBTT_assert(i >= 0 && i < count);\n   STBTT_assert(offsize >= 1 && offsize <= 4);\n   stbtt__buf_skip(&b, i*offsize);\n   start = stbtt__buf_get(&b, offsize);\n   end = stbtt__buf_get(&b, offsize);\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\n}\n\n//////////////////////////////////////////////////////////////////////////\n//\n// accessors to parse data from file\n//\n\n// on platforms that don't allow misaligned reads, if we want to allow\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\n\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\n#define ttFixed(p)    ttLONG(p)\n\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\n\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\n\nstatic int stbtt__isfont(stbtt_uint8 *font)\n{\n   // check the version number\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\n   if (stbtt_tag(font, \"true\"))   return 1; // Apple specification for TrueType fonts\n   return 0;\n}\n\n// @OPTIMIZE: binary search\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\n{\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\n   stbtt_uint32 tabledir = fontstart + 12;\n   stbtt_int32 i;\n   for (i=0; i < num_tables; ++i) {\n      stbtt_uint32 loc = tabledir + 16*i;\n      if (stbtt_tag(data+loc+0, tag))\n         return ttULONG(data+loc+8);\n   }\n   return 0;\n}\n\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\n{\n   // if it's just a font, there's only one valid index\n   if (stbtt__isfont(font_collection))\n      return index == 0 ? 0 : -1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         stbtt_int32 n = ttLONG(font_collection+8);\n         if (index >= n)\n            return -1;\n         return ttULONG(font_collection+12+index*4);\n      }\n   }\n   return -1;\n}\n\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\n{\n   // if it's just a font, there's only one valid font\n   if (stbtt__isfont(font_collection))\n      return 1;\n\n   // check if it's a TTC\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      // version 1?\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         return ttLONG(font_collection+8);\n      }\n   }\n   return 0;\n}\n\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\n{\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\n   stbtt__buf pdict;\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(0, 0);\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\n   if (!subrsoff) return stbtt__new_buf(0, 0);\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\n   return stbtt__cff_get_index(&cff);\n}\n\n// since most people won't use this, find this table the first time it's needed\nstatic int stbtt__get_svg(stbtt_fontinfo *info)\n{\n   stbtt_uint32 t;\n   if (info->svg < 0) {\n      t = stbtt__find_table(info->data, info->fontstart, \"SVG \");\n      if (t) {\n         stbtt_uint32 offset = ttULONG(info->data + t + 2);\n         info->svg = t + offset;\n      } else {\n         info->svg = 0;\n      }\n   }\n   return info->svg;\n}\n\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\n{\n   stbtt_uint32 cmap, t;\n   stbtt_int32 i,numTables;\n\n   info->data = data;\n   info->fontstart = fontstart;\n   info->cff = stbtt__new_buf(0, 0);\n\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\n   info->gpos = stbtt__find_table(data, fontstart, \"GPOS\"); // not required\n\n   if (!cmap || !info->head || !info->hhea || !info->hmtx)\n      return 0;\n   if (info->glyf) {\n      // required for truetype\n      if (!info->loca) return 0;\n   } else {\n      // initialization for CFF / Type2 fonts (OTF)\n      stbtt__buf b, topdict, topdictidx;\n      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;\n      stbtt_uint32 cff;\n\n      cff = stbtt__find_table(data, fontstart, \"CFF \");\n      if (!cff) return 0;\n\n      info->fontdicts = stbtt__new_buf(0, 0);\n      info->fdselect = stbtt__new_buf(0, 0);\n\n      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);\n      b = info->cff;\n\n      // read the header\n      stbtt__buf_skip(&b, 2);\n      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize\n\n      // but we just use the first one.\n      stbtt__cff_get_index(&b);  // name INDEX\n      topdictidx = stbtt__cff_get_index(&b);\n      topdict = stbtt__cff_index_get(topdictidx, 0);\n      stbtt__cff_get_index(&b);  // string INDEX\n      info->gsubrs = stbtt__cff_get_index(&b);\n\n      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);\n      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);\n      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);\n      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);\n      info->subrs = stbtt__get_subrs(b, topdict);\n\n      // we only support Type 2 charstrings\n      if (cstype != 2) return 0;\n      if (charstrings == 0) return 0;\n\n      if (fdarrayoff) {\n         // looks like a CID font\n         if (!fdselectoff) return 0;\n         stbtt__buf_seek(&b, fdarrayoff);\n         info->fontdicts = stbtt__cff_get_index(&b);\n         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);\n      }\n\n      stbtt__buf_seek(&b, charstrings);\n      info->charstrings = stbtt__cff_get_index(&b);\n   }\n\n   t = stbtt__find_table(data, fontstart, \"maxp\");\n   if (t)\n      info->numGlyphs = ttUSHORT(data+t+4);\n   else\n      info->numGlyphs = 0xffff;\n\n   info->svg = -1;\n\n   // find a cmap encoding table we understand *now* to avoid searching\n   // later. \n   // the same regardless of glyph.\n   numTables = ttUSHORT(data + cmap + 2);\n   info->index_map = 0;\n   for (i=0; i < numTables; ++i) {\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\n      // find an encoding we understand:\n      switch(ttUSHORT(data+encoding_record)) {\n         case STBTT_PLATFORM_ID_MICROSOFT:\n            switch (ttUSHORT(data+encoding_record+2)) {\n               case STBTT_MS_EID_UNICODE_BMP:\n               case STBTT_MS_EID_UNICODE_FULL:\n                  // MS/Unicode\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\n                  break;\n            }\n            break;\n        case STBTT_PLATFORM_ID_UNICODE:\n            // Mac/iOS has these\n            // all the encodingIDs are unicode, so we don't bother to check it\n            info->index_map = cmap + ttULONG(data+encoding_record+4);\n            break;\n      }\n   }\n   if (info->index_map == 0)\n      return 0;\n\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\n   return 1;\n}\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint32 index_map = info->index_map;\n\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\n   if (format == 0) { // apple byte encoding\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\n      if (unicode_codepoint < bytes-6)\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\n      return 0;\n   } else if (format == 6) {\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\n      return 0;\n   } else if (format == 2) {\n      STBTT_assert(0); \n      return 0;\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\n\n      // do a binary search of the segments\n      stbtt_uint32 endCount = index_map + 14;\n      stbtt_uint32 search = endCount;\n\n      if (unicode_codepoint > 0xffff)\n         return 0;\n\n      // they lie from endCount .. endCount + segCount\n      // but searchRange is the nearest power of two, so...\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\n         search += rangeShift*2;\n\n      // now decrement to bias correctly to find smallest\n      search -= 2;\n      while (entrySelector) {\n         stbtt_uint16 end;\n         searchRange >>= 1;\n         end = ttUSHORT(data + search + searchRange*2);\n         if (unicode_codepoint > end)\n            search += searchRange*2;\n         --entrySelector;\n      }\n      search += 2;\n\n      {\n         stbtt_uint16 offset, start, last;\n         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);\n\n         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\n         last = ttUSHORT(data + endCount + 2*item);\n         if (unicode_codepoint < start || unicode_codepoint > last)\n            return 0;\n\n         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\n         if (offset == 0)\n            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\n\n         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\n      }\n   } else if (format == 12 || format == 13) {\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\n      stbtt_int32 low,high;\n      low = 0; high = (stbtt_int32)ngroups;\n      // Binary search the right group.\n      while (low < high) {\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\n         if ((stbtt_uint32) unicode_codepoint < start_char)\n            high = mid;\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\n            low = mid+1;\n         else {\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\n            if (format == 12)\n               return start_glyph + unicode_codepoint-start_char;\n            else // format == 13\n               return start_glyph;\n         }\n      }\n      return 0; // not found\n   }\n   STBTT_assert(0);\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}\n\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}\n\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\n{\n   int g1,g2;\n\n   STBTT_assert(!info->cff.size);\n\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\n\n   if (info->indexToLocFormat == 0) {\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\n   } else {\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\n   }\n\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n\nSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   if (info->cff.size) {\n      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);\n   } else {\n      int g = stbtt__GetGlyfOffset(info, glyph_index);\n      if (g < 0) return 0;\n\n      if (x0) *x0 = ttSHORT(info->data + g + 2);\n      if (y0) *y0 = ttSHORT(info->data + g + 4);\n      if (x1) *x1 = ttSHORT(info->data + g + 6);\n      if (y1) *y1 = ttSHORT(info->data + g + 8);\n   }\n   return 1;\n}\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt_int16 numberOfContours;\n   int g;\n   if (info->cff.size)\n      return stbtt__GetGlyphInfoT2(info, glyph_index, 0, 0, 0, 0) == 0;\n   g = stbtt__GetGlyfOffset(info, glyph_index);\n   if (g < 0) return 1;\n   numberOfContours = ttSHORT(info->data + g);\n   return numberOfContours == 0;\n}\n\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\n{\n   if (start_off) {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\n   } else {\n      if (was_off)\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\n      else\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\n   }\n   return num_vertices;\n}\n\nstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   stbtt_int16 numberOfContours;\n   stbtt_uint8 *endPtsOfContours;\n   stbtt_uint8 *data = info->data;\n   stbtt_vertex *vertices=0;\n   int num_vertices=0;\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\n\n   *pvertices = 0;\n\n   if (g < 0) return 0;\n\n   numberOfContours = ttSHORT(data + g);\n\n   if (numberOfContours > 0) {\n      stbtt_uint8 flags=0,flagcount;\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\n      stbtt_uint8 *points;\n      endPtsOfContours = (data + g + 10);\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\n\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\n\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\n      if (vertices == 0)\n         return 0;\n\n      next_move = 0;\n      flagcount=0;\n\n      // in first pass, we load uninterpreted data into the allocated array\n      // above, shifted to the end of the array so we won't overwrite it when\n      // we create our final data starting from the front\n\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\n\n      // first load flags\n\n      for (i=0; i < n; ++i) {\n         if (flagcount == 0) {\n            flags = *points++;\n            if (flags & 8)\n               flagcount = *points++;\n         } else\n            --flagcount;\n         vertices[off+i].type = flags;\n      }\n\n      // now load x coordinates\n      x=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 2) {\n            stbtt_int16 dx = *points++;\n            x += (flags & 16) ? dx : -dx; // ???\n         } else {\n            if (!(flags & 16)) {\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].x = (stbtt_int16) x;\n      }\n\n      // now load y coordinates\n      y=0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         if (flags & 4) {\n            stbtt_int16 dy = *points++;\n            y += (flags & 32) ? dy : -dy; // ???\n         } else {\n            if (!(flags & 32)) {\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\n               points += 2;\n            }\n         }\n         vertices[off+i].y = (stbtt_int16) y;\n      }\n\n      // now convert them to our format\n      num_vertices=0;\n      sx = sy = cx = cy = scx = scy = 0;\n      for (i=0; i < n; ++i) {\n         flags = vertices[off+i].type;\n         x     = (stbtt_int16) vertices[off+i].x;\n         y     = (stbtt_int16) vertices[off+i].y;\n\n         if (next_move == i) {\n            if (i != 0)\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n\n            // now start the new one\n            start_off = !(flags & 1);\n            if (start_off) {\n               // if we start off with an off-curve point, then when we need to find a point on the curve\n               // where we can start, and we need to save some state for when we wraparound.\n               scx = x;\n               scy = y;\n               if (!(vertices[off+i+1].type & 1)) {\n                  // next point is also a curve point, so interpolate an on-point curve\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n               } else {\n                  // otherwise just use the next point as our start point\n                  sx = (stbtt_int32) vertices[off+i+1].x;\n                  sy = (stbtt_int32) vertices[off+i+1].y;\n                  ++i; // we're using point i+1 as the starting point, so skip it\n               }\n            } else {\n               sx = x;\n               sy = y;\n            }\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\n            was_off = 0;\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\n            ++j;\n         } else {\n            if (!(flags & 1)) { // if it's a curve\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n               cx = x;\n               cy = y;\n               was_off = 1;\n            } else {\n               if (was_off)\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\n               else\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\n               was_off = 0;\n            }\n         }\n      }\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\n   } else if (numberOfContours < 0) {\n      // Compound shapes.\n      int more = 1;\n      stbtt_uint8 *comp = data + g + 10;\n      num_vertices = 0;\n      vertices = 0;\n      while (more) {\n         stbtt_uint16 flags, gidx;\n         int comp_num_verts = 0, i;\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\n\n         flags = ttSHORT(comp); comp+=2;\n         gidx = ttSHORT(comp); comp+=2;\n\n         if (flags & 2) { // XY values\n            if (flags & 1) { // shorts\n               mtx[4] = ttSHORT(comp); comp+=2;\n               mtx[5] = ttSHORT(comp); comp+=2;\n            } else {\n               mtx[4] = ttCHAR(comp); comp+=1;\n               mtx[5] = ttCHAR(comp); comp+=1;\n            }\n         }\n         else {\n            STBTT_assert(0);\n         }\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = mtx[2] = 0;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\n         }\n\n         // Find transformation scales.\n         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\n         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\n\n         // Get indexed glyph.\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\n         if (comp_num_verts > 0) {\n            // Transform vertices.\n            for (i = 0; i < comp_num_verts; ++i) {\n               stbtt_vertex* v = &comp_verts[i];\n               stbtt_vertex_type x,y;\n               x=v->x; y=v->y;\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n               x=v->cx; y=v->cy;\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\n            }\n            // Append vertices.\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\n            if (!tmp) {\n               if (vertices) STBTT_free(vertices, info->userdata);\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\n               return 0;\n            }\n            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\n            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\n            if (vertices) STBTT_free(vertices, info->userdata);\n            vertices = tmp;\n            STBTT_free(comp_verts, info->userdata);\n            num_vertices += comp_num_verts;\n         }\n         // More components ?\n         more = flags & (1<<5);\n      }\n   } else {\n      // numberOfCounters == 0, do nothing\n   }\n\n   *pvertices = vertices;\n   return num_vertices;\n}\n\ntypedef struct\n{\n   int bounds;\n   int started;\n   float first_x, first_y;\n   float x, y;\n   stbtt_int32 min_x, max_x, min_y, max_y;\n\n   stbtt_vertex *pvertices;\n   int num_vertices;\n} stbtt__csctx;\n\n#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, 0, 0}\n\nstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)\n{\n   if (x > c->max_x || !c->started) c->max_x = x;\n   if (y > c->max_y || !c->started) c->max_y = y;\n   if (x < c->min_x || !c->started) c->min_x = x;\n   if (y < c->min_y || !c->started) c->min_y = y;\n   c->started = 1;\n}\n\nstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)\n{\n   if (c->bounds) {\n      stbtt__track_vertex(c, x, y);\n      if (type == STBTT_vcubic) {\n         stbtt__track_vertex(c, cx, cy);\n         stbtt__track_vertex(c, cx1, cy1);\n      }\n   } else {\n      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);\n      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;\n      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;\n   }\n   c->num_vertices++;\n}\n\nstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)\n{\n   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)\n      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}\n\nstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)\n{\n   float cx1 = ctx->x + dx1;\n   float cy1 = ctx->y + dy1;\n   float cx2 = cx1 + dx2;\n   float cy2 = cy1 + dy2;\n   ctx->x = cx2 + dx3;\n   ctx->y = cy2 + dy3;\n   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);\n}\n\nstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)\n{\n   int count = stbtt__cff_index_count(&idx);\n   int bias = 107;\n   if (count >= 33900)\n      bias = 32768;\n   else if (count >= 1240)\n      bias = 1131;\n   n += bias;\n   if (n < 0 || n >= count)\n      return stbtt__new_buf(0, 0);\n   return stbtt__cff_index_get(idx, n);\n}\n\nstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)\n{\n   stbtt__buf fdselect = info->fdselect;\n   int nranges, start, end, v, fmt, fdselector = -1, i;\n\n   stbtt__buf_seek(&fdselect, 0);\n   fmt = stbtt__buf_get8(&fdselect);\n   if (fmt == 0) {\n      // untested\n      stbtt__buf_skip(&fdselect, glyph_index);\n      fdselector = stbtt__buf_get8(&fdselect);\n   } else if (fmt == 3) {\n      nranges = stbtt__buf_get16(&fdselect);\n      start = stbtt__buf_get16(&fdselect);\n      for (i = 0; i < nranges; i++) {\n         v = stbtt__buf_get8(&fdselect);\n         end = stbtt__buf_get16(&fdselect);\n         if (glyph_index >= start && glyph_index < end) {\n            fdselector = v;\n            break;\n         }\n         start = end;\n      }\n   }\n   if (fdselector == -1) stbtt__new_buf(0, 0);\n   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));\n}\n\nstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)\n{\n   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;\n   int has_subrs = 0, clear_stack;\n   float s[48];\n   stbtt__buf subr_stack[10], subrs = info->subrs, b;\n   float f;\n\n#define STBTT__CSERR(s) (0)\n\n   // this currently ignores the initial width value, which isn't needed if we have hmtx\n   b = stbtt__cff_index_get(info->charstrings, glyph_index);\n   while (b.cursor < b.size) {\n      i = 0;\n      clear_stack = 1;\n      b0 = stbtt__buf_get8(&b);\n      switch (b0) {\n      case 0x13: // hintmask\n      case 0x14: // cntrmask\n         if (in_header)\n            maskbits += (sp / 2); // implicit \"vstem\"\n         in_header = 0;\n         stbtt__buf_skip(&b, (maskbits + 7) / 8);\n         break;\n\n      case 0x01: // hstem\n      case 0x03: // vstem\n      case 0x12: // hstemhm\n      case 0x17: // vstemhm\n         maskbits += (sp / 2);\n         break;\n\n      case 0x15: // rmoveto\n         in_header = 0;\n         if (sp < 2) return STBTT__CSERR(\"rmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);\n         break;\n      case 0x04: // vmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"vmoveto stack\");\n         stbtt__csctx_rmove_to(c, 0, s[sp-1]);\n         break;\n      case 0x16: // hmoveto\n         in_header = 0;\n         if (sp < 1) return STBTT__CSERR(\"hmoveto stack\");\n         stbtt__csctx_rmove_to(c, s[sp-1], 0);\n         break;\n\n      case 0x05: // rlineto\n         if (sp < 2) return STBTT__CSERR(\"rlineto stack\");\n         for (; i + 1 < sp; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical\n      // starting from a different place.\n\n      case 0x07: // vlineto\n         if (sp < 1) return STBTT__CSERR(\"vlineto stack\");\n         goto vlineto;\n      case 0x06: // hlineto\n         if (sp < 1) return STBTT__CSERR(\"hlineto stack\");\n         for (;;) {\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, s[i], 0);\n            i++;\n      vlineto:\n            if (i >= sp) break;\n            stbtt__csctx_rline_to(c, 0, s[i]);\n            i++;\n         }\n         break;\n\n      case 0x1F: // hvcurveto\n         if (sp < 4) return STBTT__CSERR(\"hvcurveto stack\");\n         goto hvcurveto;\n      case 0x1E: // vhcurveto\n         if (sp < 4) return STBTT__CSERR(\"vhcurveto stack\");\n         for (;;) {\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);\n            i += 4;\n      hvcurveto:\n            if (i + 3 >= sp) break;\n            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);\n            i += 4;\n         }\n         break;\n\n      case 0x08: // rrcurveto\n         if (sp < 6) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x18: // rcurveline\n         if (sp < 8) return STBTT__CSERR(\"rcurveline stack\");\n         for (; i + 5 < sp - 2; i += 6)\n            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         if (i + 1 >= sp) return STBTT__CSERR(\"rcurveline stack\");\n         stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         break;\n\n      case 0x19: // rlinecurve\n         if (sp < 8) return STBTT__CSERR(\"rlinecurve stack\");\n         for (; i + 1 < sp - 6; i += 2)\n            stbtt__csctx_rline_to(c, s[i], s[i+1]);\n         if (i + 5 >= sp) return STBTT__CSERR(\"rlinecurve stack\");\n         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);\n         break;\n\n      case 0x1A: // vvcurveto\n      case 0x1B: // hhcurveto\n         if (sp < 4) return STBTT__CSERR(\"(vv|hh)curveto stack\");\n         f = 0.0;\n         if (sp & 1) { f = s[i]; i++; }\n         for (; i + 3 < sp; i += 4) {\n            if (b0 == 0x1B)\n               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);\n            else\n               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);\n            f = 0.0;\n         }\n         break;\n\n      case 0x0A: // callsubr\n         if (!has_subrs) {\n            if (info->fdselect.size)\n               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);\n            has_subrs = 1;\n         }\n         // FALLTHROUGH\n      case 0x1D: // callgsubr\n         if (sp < 1) return STBTT__CSERR(\"call(g|)subr stack\");\n         v = (int) s[--sp];\n         if (subr_stack_height >= 10) return STBTT__CSERR(\"recursion limit\");\n         subr_stack[subr_stack_height++] = b;\n         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);\n         if (b.size == 0) return STBTT__CSERR(\"subr not found\");\n         b.cursor = 0;\n         clear_stack = 0;\n         break;\n\n      case 0x0B: // return\n         if (subr_stack_height <= 0) return STBTT__CSERR(\"return outside subr\");\n         b = subr_stack[--subr_stack_height];\n         clear_stack = 0;\n         break;\n\n      case 0x0E: // endchar\n         stbtt__csctx_close_shape(c);\n         return 1;\n\n      case 0x0C: { // two-byte escape\n         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;\n         float dx, dy;\n         int b1 = stbtt__buf_get8(&b);\n         switch (b1) {\n         // and always draw beziers.\n         case 0x22: // hflex\n            if (sp < 7) return STBTT__CSERR(\"hflex stack\");\n            dx1 = s[0];\n            dx2 = s[1];\n            dy2 = s[2];\n            dx3 = s[3];\n            dx4 = s[4];\n            dx5 = s[5];\n            dx6 = s[6];\n            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);\n            break;\n\n         case 0x23: // flex\n            if (sp < 13) return STBTT__CSERR(\"flex stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = s[10];\n            dy6 = s[11];\n            //fd is s[12]\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         case 0x24: // hflex1\n            if (sp < 9) return STBTT__CSERR(\"hflex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dx4 = s[5];\n            dx5 = s[6];\n            dy5 = s[7];\n            dx6 = s[8];\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);\n            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));\n            break;\n\n         case 0x25: // flex1\n            if (sp < 11) return STBTT__CSERR(\"flex1 stack\");\n            dx1 = s[0];\n            dy1 = s[1];\n            dx2 = s[2];\n            dy2 = s[3];\n            dx3 = s[4];\n            dy3 = s[5];\n            dx4 = s[6];\n            dy4 = s[7];\n            dx5 = s[8];\n            dy5 = s[9];\n            dx6 = dy6 = s[10];\n            dx = dx1+dx2+dx3+dx4+dx5;\n            dy = dy1+dy2+dy3+dy4+dy5;\n            if (STBTT_fabs(dx) > STBTT_fabs(dy))\n               dy6 = -dy;\n            else\n               dx6 = -dx;\n            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);\n            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);\n            break;\n\n         default:\n            return STBTT__CSERR(\"unimplemented\");\n         }\n      } break;\n\n      default:\n         if (b0 != 255 && b0 != 28 && b0 < 32)\n            return STBTT__CSERR(\"reserved operator\");\n\n         // push immediate\n         if (b0 == 255) {\n            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;\n         } else {\n            stbtt__buf_skip(&b, -1);\n            f = (float)(stbtt_int16)stbtt__cff_int(&b);\n         }\n         if (sp >= 48) return STBTT__CSERR(\"push stack overflow\");\n         s[sp++] = f;\n         clear_stack = 0;\n         break;\n      }\n      if (clear_stack) sp = 0;\n   }\n   return STBTT__CSERR(\"no endchar\");\n\n#undef STBTT__CSERR\n}\n\nstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   // runs the charstring twice, once to count and once to output (to avoid realloc)\n   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);\n   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);\n   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {\n      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);\n      output_ctx.pvertices = *pvertices;\n      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {\n         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);\n         return output_ctx.num_vertices;\n      }\n   }\n   *pvertices = 0;\n   return 0;\n}\n\nstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\n{\n   stbtt__csctx c = STBTT__CSCTX_INIT(1);\n   int r = stbtt__run_charstring(info, glyph_index, &c);\n   if (x0)  *x0 = r ? c.min_x : 0;\n   if (y0)  *y0 = r ? c.min_y : 0;\n   if (x1)  *x1 = r ? c.max_x : 0;\n   if (y1)  *y1 = r ? c.max_y : 0;\n   return r ? c.num_vertices : 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\n{\n   if (!info->cff.size)\n      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);\n   else\n      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);\n}\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\n   if (glyph_index < numOfLongHorMetrics) {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\n   } else {\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\n   }\n}\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   return ttUSHORT(data+10);\n}\n\nSTBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   int k, length;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   length = ttUSHORT(data+10);\n   if (table_length < length)\n      length = table_length;\n\n   for (k = 0; k < length; k++)\n   {\n      table[k].glyph1 = ttUSHORT(data+18+(k*6));\n      table[k].glyph2 = ttUSHORT(data+20+(k*6));\n      table[k].advance = ttSHORT(data+22+(k*6));\n   }\n\n   return length;\n}\n\nstatic int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint8 *data = info->data + info->kern;\n   stbtt_uint32 needle, straw;\n   int l, r, m;\n\n   // we only look at the first table. it must be 'horizontal' and format 0.\n   if (!info->kern)\n      return 0;\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\n      return 0;\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\n      return 0;\n\n   l = 0;\n   r = ttUSHORT(data+10) - 1;\n   needle = glyph1 << 16 | glyph2;\n   while (l <= r) {\n      m = (l + r) >> 1;\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\n      if (needle < straw)\n         r = m - 1;\n      else if (needle > straw)\n         l = m + 1;\n      else\n         return ttSHORT(data+22+(m*6));\n   }\n   return 0;\n}\n\nstatic stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)\n{\n   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);\n   switch (coverageFormat) {\n      case 1: {\n         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);\n\n         // Binary search.\n         stbtt_int32 l=0, r=glyphCount-1, m;\n         int straw, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *glyphArray = coverageTable + 4;\n            stbtt_uint16 glyphID;\n            m = (l + r) >> 1;\n            glyphID = ttUSHORT(glyphArray + 2 * m);\n            straw = glyphID;\n            if (needle < straw)\n               r = m - 1;\n            else if (needle > straw)\n               l = m + 1;\n            else {\n               return m;\n            }\n         }\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);\n         stbtt_uint8 *rangeArray = coverageTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=rangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *rangeRecord;\n            m = (l + r) >> 1;\n            rangeRecord = rangeArray + 6 * m;\n            strawStart = ttUSHORT(rangeRecord);\n            strawEnd = ttUSHORT(rangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else {\n               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);\n               return startCoverageIndex + glyph - strawStart;\n            }\n         }\n         break;\n      }\n\n      default: return -1; // unsupported\n   }\n\n   return -1;\n}\n\nstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)\n{\n   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);\n   switch (classDefFormat)\n   {\n      case 1: {\n         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);\n         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);\n         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;\n\n         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)\n            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));\n         break;\n      }\n\n      case 2: {\n         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);\n         stbtt_uint8 *classRangeRecords = classDefTable + 4;\n\n         // Binary search.\n         stbtt_int32 l=0, r=classRangeCount-1, m;\n         int strawStart, strawEnd, needle=glyph;\n         while (l <= r) {\n            stbtt_uint8 *classRangeRecord;\n            m = (l + r) >> 1;\n            classRangeRecord = classRangeRecords + 6 * m;\n            strawStart = ttUSHORT(classRangeRecord);\n            strawEnd = ttUSHORT(classRangeRecord + 2);\n            if (needle < strawStart)\n               r = m - 1;\n            else if (needle > strawEnd)\n               l = m + 1;\n            else\n               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);\n         }\n         break;\n      }\n\n      default:\n         return -1; // Unsupported definition type, return an error.\n   }\n\n   // \"All glyphs not assigned to a class fall into class 0\". (OpenType spec)\n   return 0;\n}\n\n// Define to STBTT_assert(x) if you want to break on unimplemented formats.\n#define STBTT_GPOS_TOD_assert(x)\n\nstatic stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\n{\n   stbtt_uint16 lookupListOffset;\n   stbtt_uint8 *lookupList;\n   stbtt_uint16 lookupCount;\n   stbtt_uint8 *data;\n   stbtt_int32 i, sti;\n\n   if (!info->gpos) return 0;\n\n   data = info->data + info->gpos;\n\n   if (ttUSHORT(data+0) != 1) return 0; // Major version 1\n   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0\n\n   lookupListOffset = ttUSHORT(data+8);\n   lookupList = data + lookupListOffset;\n   lookupCount = ttUSHORT(lookupList);\n\n   for (i=0; i<lookupCount; ++i) {\n      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);\n      stbtt_uint8 *lookupTable = lookupList + lookupOffset;\n\n      stbtt_uint16 lookupType = ttUSHORT(lookupTable);\n      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);\n      stbtt_uint8 *subTableOffsets = lookupTable + 6;\n      if (lookupType != 2) // Pair Adjustment Positioning Subtable\n         continue;\n\n      for (sti=0; sti<subTableCount; sti++) {\n         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);\n         stbtt_uint8 *table = lookupTable + subtableOffset;\n         stbtt_uint16 posFormat = ttUSHORT(table);\n         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);\n         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);\n         if (coverageIndex == -1) continue;\n\n         switch (posFormat) {\n            case 1: {\n               stbtt_int32 l, r, m;\n               int straw, needle;\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_int32 valueRecordPairSizeInBytes = 2;\n                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);\n                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);\n                  stbtt_uint8 *pairValueTable = table + pairPosOffset;\n                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);\n                  stbtt_uint8 *pairValueArray = pairValueTable + 2;\n\n                  if (coverageIndex >= pairSetCount) return 0;\n\n                  needle=glyph2;\n                  r=pairValueCount-1;\n                  l=0;\n\n                  // Binary search.\n                  while (l <= r) {\n                     stbtt_uint16 secondGlyph;\n                     stbtt_uint8 *pairValue;\n                     m = (l + r) >> 1;\n                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;\n                     secondGlyph = ttUSHORT(pairValue);\n                     straw = secondGlyph;\n                     if (needle < straw)\n                        r = m - 1;\n                     else if (needle > straw)\n                        l = m + 1;\n                     else {\n                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);\n                        return xAdvance;\n                     }\n                  }\n               } else\n                  return 0;\n               break;\n            }\n\n            case 2: {\n               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);\n               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);\n               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?\n                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);\n                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);\n                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);\n                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);\n\n                  stbtt_uint16 class1Count = ttUSHORT(table + 12);\n                  stbtt_uint16 class2Count = ttUSHORT(table + 14);\n                  stbtt_uint8 *class1Records, *class2Records;\n                  stbtt_int16 xAdvance;\n\n                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed\n                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed\n\n                  class1Records = table + 16;\n                  class2Records = class1Records + 2 * (glyph1class * class2Count);\n                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);\n                  return xAdvance;\n               } else\n                  return 0;\n               break;\n            }\n\n            default:\n               return 0; // Unsupported position format\n         }\n      }\n   }\n\n   return 0;\n}\n\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\n{\n   *x0 = ttSHORT(info->data + info->head + 36);\n   *y0 = ttSHORT(info->data + info->head + 38);\n   *x1 = ttSHORT(info->data + info->head + 40);\n   *y1 = ttSHORT(info->data + info->head + 42);\n}\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\n{\n#if 0\n    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\n    return (float)height / fheight;\n#endif\n    int fheight = ttSHORT(info->data + info->hhea + 4) ; // Gabor: Taking the descent out of the calculation made the pixel height match what i need much closer\n    return (float)height / fheight;\n}\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\n{\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\n   return pixels / unitsPerEm;\n}\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\n{\n   STBTT_free(v, info->userdata);\n}\n\nSTBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)\n{\n   int i;\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);\n\n   int numEntries = ttUSHORT(svg_doc_list);\n   stbtt_uint8 *svg_docs = svg_doc_list + 2;\n\n   for(i=0; i<numEntries; i++) {\n      stbtt_uint8 *svg_doc = svg_docs + (12 * i);\n      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))\n         return svg_doc;\n   }\n   return 0;\n}\n\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)\n{\n   stbtt_uint8 *data = info->data;\n   stbtt_uint8 *svg_doc;\n\n   if (info->svg == 0)\n      return 0;\n\n   svg_doc = stbtt_FindSVGDoc(info, gl);\n   if (svg_doc != 0) {\n      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);\n      return ttULONG(svg_doc + 8);\n   } else {\n      return 0;\n   }\n}\n\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// antialiasing software rasterizer\n//\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {\n      // e.g. space character\n      if (ix0) *ix0 = 0;\n      if (iy0) *iy0 = 0;\n      if (ix1) *ix1 = 0;\n      if (iy1) *iy1 = 0;\n   } else {\n      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?\n      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);\n      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);\n      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);\n      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);\n   }\n}\n\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Rasterizer\n\ntypedef struct stbtt__hheap_chunk\n{\n   struct stbtt__hheap_chunk *next;\n} stbtt__hheap_chunk;\n\ntypedef struct stbtt__hheap\n{\n   struct stbtt__hheap_chunk *head;\n   void   *first_free;\n   int    num_remaining_in_head_chunk;\n} stbtt__hheap;\n\nstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, unsigned int size, void *userdata)\n{\n   if (hh->first_free) {\n      void *p = hh->first_free;\n      hh->first_free = * (void **) p;\n      return p;\n   } else {\n      if (hh->num_remaining_in_head_chunk == 0) {\n         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);\n         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);\n         if (c == 0)\n            return 0;\n         c->next = hh->head;\n         hh->head = c;\n         hh->num_remaining_in_head_chunk = count;\n      }\n      --hh->num_remaining_in_head_chunk;\n      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;\n   }\n}\n\nstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)\n{\n   *(void **) p = hh->first_free;\n   hh->first_free = p;\n}\n\nstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}\n\ntypedef struct stbtt__edge {\n   float x0,y0, x1,y1;\n   int invert;\n} stbtt__edge;\n\n\ntypedef struct stbtt__active_edge\n{\n   struct stbtt__active_edge *next;\n   #if STBTT_RASTERIZER_VERSION==1\n   int x,dx;\n   float ey;\n   int direction;\n   #elif STBTT_RASTERIZER_VERSION==2\n   float fx,fdx,fdy;\n   float direction;\n   float sy;\n   float ey;\n   #else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n   #endif\n} stbtt__active_edge;\n\n#if STBTT_RASTERIZER_VERSION == 1\n#define STBTT_FIXSHIFT   10\n#define STBTT_FIX        (1 << STBTT_FIXSHIFT)\n#define STBTT_FIXMASK    (STBTT_FIX-1)\n\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != 0);\n   if (!z) return z;\n\n   // round dx down to avoid overshooting\n   if (dxdy < 0)\n      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);\n   else\n      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);\n\n   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount\n   z->x -= off_x * STBTT_FIX;\n\n   z->ey = e->y1;\n   z->next = 0;\n   z->direction = e->invert ? 1 : -1;\n   return z;\n}\n#elif STBTT_RASTERIZER_VERSION == 2\nstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)\n{\n   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\n   STBTT_assert(z != 0);\n   //STBTT_assert(e->y0 <= start_point);\n   if (!z) return z;\n   z->fdx = dxdy;\n   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;\n   z->fx = e->x0 + dxdy * (start_point - e->y0);\n   z->fx -= off_x;\n   z->direction = e->invert ? 1.0f : -1.0f;\n   z->sy = e->y0;\n   z->ey = e->y1;\n   z->next = 0;\n   return z;\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#if STBTT_RASTERIZER_VERSION == 1\n// note: this routine clips fills that extend off the edges... ideally this\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\n// are wrong, or if the user supplies a too-small bitmap\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\n{\n   // non-zero winding fill\n   int x0=0, w=0;\n\n   while (e) {\n      if (w == 0) {\n         // if we're currently at zero, we need to record the edge start point\n         x0 = e->x; w += e->direction;\n      } else {\n         int x1 = e->x; w += e->direction;\n         // if we went to zero, we need to draw\n         if (w == 0) {\n            int i = x0 >> STBTT_FIXSHIFT;\n            int j = x1 >> STBTT_FIXSHIFT;\n\n            if (i < len && j >= 0) {\n               if (i == j) {\n                  // x0,x1 are the same pixel, so compute combined coverage\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);\n               } else {\n                  if (i >= 0) // add antialiasing for x0\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     i = -1; // clip\n\n                  if (j < len) // add antialiasing for x1\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);\n                  else\n                     j = len; // clip\n\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\n               }\n            }\n         }\n      }\n\n      e = e->next;\n   }\n}\n\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = 0;\n   int y,j=0;\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\n   int s; // vertical subsample index\n   unsigned char scanline_data[512], *scanline;\n\n   if (result->w > 512)\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\n   else\n      scanline = scanline_data;\n\n   y = off_y * vsubsample;\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\n\n   while (j < result->h) {\n      STBTT_memset(scanline, 0, result->w);\n      for (s=0; s < vsubsample; ++s) {\n         // find center of pixel for this scanline\n         float scan_y = y + 0.5f;\n         stbtt__active_edge **step = &active;\n\n         // update all active edges;\n         // remove all active edges that terminate before the center of this scanline\n         while (*step) {\n            stbtt__active_edge * z = *step;\n            if (z->ey <= scan_y) {\n               *step = z->next; \n               STBTT_assert(z->direction);\n               z->direction = 0;\n               stbtt__hheap_free(&hh, z);\n            } else {\n               z->x += z->dx; // advance to position for current scanline\n               step = &((*step)->next); // advance through list\n            }\n         }\n\n         // resort the list if needed\n         for(;;) {\n            int changed=0;\n            step = &active;\n            while (*step && (*step)->next) {\n               if ((*step)->x > (*step)->next->x) {\n                  stbtt__active_edge *t = *step;\n                  stbtt__active_edge *q = t->next;\n\n                  t->next = q->next;\n                  q->next = t;\n                  *step = q;\n                  changed = 1;\n               }\n               step = &(*step)->next;\n            }\n            if (!changed) break;\n         }\n\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\n         while (e->y0 <= scan_y) {\n            if (e->y1 > scan_y) {\n               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);\n               if (z != 0) {\n                  // find insertion point\n                  if (active == 0)\n                     active = z;\n                  else if (z->x < active->x) {\n                     // insert at front\n                     z->next = active;\n                     active = z;\n                  } else {\n                     // find thing to insert AFTER\n                     stbtt__active_edge *p = active;\n                     while (p->next && p->next->x < z->x)\n                        p = p->next;\n                     // at this point, p->next->x is NOT < z->x\n                     z->next = p->next;\n                     p->next = z;\n                  }\n               }\n            }\n            ++e;\n         }\n\n         // now process all active edges in XOR fashion\n         if (active)\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\n\n         ++y;\n      }\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n\n#elif STBTT_RASTERIZER_VERSION == 2\n\n// the edge passed in here does not cross the vertical line at x or the vertical line at x+1\n// (i.e. it has already been clipped to those)\nstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)\n{\n   if (y0 == y1) return;\n   STBTT_assert(y0 < y1);\n   STBTT_assert(e->sy <= e->ey);\n   if (y0 > e->ey) return;\n   if (y1 < e->sy) return;\n   if (y0 < e->sy) {\n      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);\n      y0 = e->sy;\n   }\n   if (y1 > e->ey) {\n      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);\n      y1 = e->ey;\n   }\n\n   if (x0 == x)\n      STBTT_assert(x1 <= x+1);\n   else if (x0 == x+1)\n      STBTT_assert(x1 >= x);\n   else if (x0 <= x)\n      STBTT_assert(x1 <= x);\n   else if (x0 >= x+1)\n      STBTT_assert(x1 >= x+1);\n   else\n      STBTT_assert(x1 >= x && x1 <= x+1);\n\n   if (x0 <= x && x1 <= x)\n      scanline[x] += e->direction * (y1-y0);\n   else if (x0 >= x+1 && x1 >= x+1)\n      ;\n   else {\n      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);\n      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position\n   }\n}\n\nstatic float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) / 2.0f * height;\n}\n\nstatic float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)\n{\n   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);\n}\n\nstatic float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width / 2;\n}\n\nstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)\n{\n   float y_bottom = y_top+1;\n\n   while (e) {\n      // brute force every pixel\n\n      // compute intersection points with top & bottom\n      STBTT_assert(e->ey >= y_top);\n\n      if (e->fdx == 0) {\n         float x0 = e->fx;\n         if (x0 < len) {\n            if (x0 >= 0) {\n               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);\n               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);\n            } else {\n               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);\n            }\n         }\n      } else {\n         float x0 = e->fx;\n         float dx = e->fdx;\n         float xb = x0 + dx;\n         float x_top, x_bottom;\n         float sy0,sy1;\n         float dy = e->fdy;\n         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);\n\n         // compute endpoints of line segment clipped to this scanline (if the\n         // line segment starts on this scanline. x0 is the intersection of the\n         // line with y_top, but that may be off the line segment.\n         if (e->sy > y_top) {\n            x_top = x0 + dx * (e->sy - y_top);\n            sy0 = e->sy;\n         } else {\n            x_top = x0;\n            sy0 = y_top;\n         }\n         if (e->ey < y_bottom) {\n            x_bottom = x0 + dx * (e->ey - y_top);\n            sy1 = e->ey;\n         } else {\n            x_bottom = xb;\n            sy1 = y_bottom;\n         }\n\n         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {\n            // from here on, we don't have to range check x values\n\n            if ((int) x_top == (int) x_bottom) {\n               float height;\n               // simple case, only spans one pixel\n               int x = (int) x_top;\n               height = (sy1 - sy0) * e->direction;\n               STBTT_assert(x >= 0 && x < len);\n               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);\n               scanline_fill[x] += height; // everything right of this pixel is filled\n            } else {\n               int x,x1,x2;\n               float y_crossing, y_final, step, sign, area;\n               // covers 2+ pixels\n               if (x_top > x_bottom) {\n                  // flip scanline vertically; signed area is the same\n                  float t;\n                  sy0 = y_bottom - (sy0 - y_top);\n                  sy1 = y_bottom - (sy1 - y_top);\n                  t = sy0, sy0 = sy1, sy1 = t;\n                  t = x_bottom, x_bottom = x_top, x_top = t;\n                  dx = -dx;\n                  dy = -dy;\n                  t = x0, x0 = xb, xb = t;\n               }\n               STBTT_assert(dy >= 0);\n               STBTT_assert(dx >= 0);\n\n               x1 = (int) x_top;\n               x2 = (int) x_bottom;\n               // compute intersection with y axis at x1+1\n               y_crossing = y_top + dy * (x1+1 - x0);\n\n               // compute intersection with y axis at x2\n               y_final = y_top + dy * (x2 - x0);\n\n               //           x1    x_top                            x2    x_bottom\n               //     y_top  +------|-----+------------+------------+--------|---+------------+\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //       sy0  |      Txxxxx|............|............|............|............|\n               // y_crossing |            *xxxxx.......|............|............|............|\n               //            |            |     xxxxx..|............|............|............|\n               //            |            |     /-   xx*xxxx........|............|............|\n               //            |            | dy <       |    xxxxxx..|............|............|\n               //   y_final  |            |     \\-     |          xx*xxx.........|............|\n               //       sy1  |            |            |            |   xxxxxB...|............|\n               //            |            |            |            |            |            |\n               //            |            |            |            |            |            |\n               //  y_bottom  +------------+------------+------------+------------+------------+\n               //\n               // goal is to measure the area covered by '.' in each pixel\n\n               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057\n               if (y_crossing > y_bottom)\n                  y_crossing = y_bottom;\n\n               sign = e->direction;\n\n               // area of the rectangle covered from sy0..y_crossing\n               area = sign * (y_crossing-sy0);\n\n               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)\n               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);\n\n               // check if final y_crossing is blown up; no test case for this\n               if (y_final > y_bottom) {\n                  y_final = y_bottom;\n                  dy = (y_final - y_crossing ) / (x2 - (x1+1)); // if denom=0, y_final = y_crossing, so y_final <= y_bottom\n               }\n\n               // in second pixel, area covered by line segment found in first pixel\n               // is always a rectangle 1 wide * the height of that line segment; this\n               // is exactly what the variable 'area' stores. it also gets a contribution\n               // from the line segment within it. the THIRD pixel will get the first\n               // pixel's rectangle contribution, the second pixel's rectangle contribution,\n               // and its own contribution. the 'own contribution' is the same in every pixel except\n               // the leftmost and rightmost, a trapezoid that slides down in each pixel.\n               // the second pixel's contribution to the third pixel will be the\n               // rectangle 1 wide times the height change in the second pixel, which is dy.\n\n               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,\n               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x\n               // so the area advances by 'step' every time\n\n               for (x = x1+1; x < x2; ++x) {\n                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2\n                  area += step;\n               }\n               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down\n               STBTT_assert(sy1 > y_final-0.01f);\n\n               // area covered in the last pixel is the rectangle from all the pixels to the left,\n               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge\n               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);\n\n               // the rest of the line is filled based on the total height of the line segment in this pixel\n               scanline_fill[x2] += sign * (sy1-sy0);\n            }\n         } else {\n            // if edge goes outside of box we're drawing, we require\n            // clipping logic. since this does not match the intended use\n            // of this library, we use a different, very slow brute\n            // force implementation\n            // note though that this does happen some of the time because\n            // x_top and x_bottom can be extrapolated at the top & bottom of\n            // the shape and actually lie outside the bounding box\n            int x;\n            for (x=0; x < len; ++x) {\n               // cases:\n               //\n               // there can be up to two intersections with the pixel. any intersection\n               // with left or right edges can be handled by splitting into two (or three)\n               // regions. intersections with top & bottom do not necessitate case-wise logic.\n               //\n               // the old way of doing this found the intersections with the left & right edges,\n               // then used some simple logic to produce up to three segments in sorted order\n               // from top-to-bottom. however, this had a problem: if an x edge was epsilon\n               // across the x border, then the corresponding y position might not be distinct\n               // from the other y segment, and it might ignored as an empty segment. to avoid\n               // that, we need to explicitly produce segments based on x positions.\n\n               // rename variables to clearly-defined pairs\n               float y0 = y_top;\n               float x1 = (float) (x);\n               float x2 = (float) (x+1);\n               float x3 = xb;\n               float y3 = y_bottom;\n\n               // x = e->x + e->dx * (y-y_top)\n               // (y-y_top) = (x - e->x) / e->dx\n               // y = (x - e->x) / e->dx + y_top\n               float y1 = (x - x0) / dx + y_top;\n               float y2 = (x+1 - x0) / dx + y_top;\n\n               if (x0 < x1 && x3 > x2) {         // three segments descending down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);\n                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);\n               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);\n                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);\n               } else {  // one segment\n                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);\n               }\n            }\n         }\n      }\n      e = e->next;\n   }\n}\n\n// directly AA rasterize edges w/o supersampling\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\n{\n   stbtt__hheap hh = { 0, 0, 0 };\n   stbtt__active_edge *active = 0;\n   int y,j=0, i;\n   float scanline_data[129], *scanline, *scanline2;\n\n   STBTT__NOTUSED(vsubsample);\n\n   if (result->w > 64)\n      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);\n   else\n      scanline = scanline_data;\n\n   scanline2 = scanline + result->w;\n\n   y = off_y;\n   e[n].y0 = (float) (off_y + result->h) + 1;\n\n   while (j < result->h) {\n      // find center of pixel for this scanline\n      float scan_y_top    = y + 0.0f;\n      float scan_y_bottom = y + 1.0f;\n      stbtt__active_edge **step = &active;\n\n      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));\n      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));\n\n      // update all active edges;\n      // remove all active edges that terminate before the top of this scanline\n      while (*step) {\n         stbtt__active_edge * z = *step;\n         if (z->ey <= scan_y_top) {\n            *step = z->next; \n            STBTT_assert(z->direction);\n            z->direction = 0;\n            stbtt__hheap_free(&hh, z);\n         } else {\n            step = &((*step)->next); // advance through list\n         }\n      }\n\n      // insert all edges that start before the bottom of this scanline\n      while (e->y0 <= scan_y_bottom) {\n         if (e->y0 != e->y1) {\n            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);\n            if (z != 0) {\n               if (j == 0 && off_y != 0) {\n                  if (z->ey < scan_y_top) {\n                     // this can happen due to subpixel positioning and some kind of fp rounding error i think\n                     z->ey = scan_y_top;\n                  }\n               }\n               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds\n               // insert at front\n               z->next = active;\n               active = z;\n            }\n         }\n         ++e;\n      }\n\n      // now process all active edges\n      if (active)\n         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);\n\n      {\n         float sum = 0;\n         for (i=0; i < result->w; ++i) {\n            float k;\n            int m;\n            sum += scanline2[i];\n            k = scanline[i] + sum;\n            k = (float) STBTT_fabs(k)*255 + 0.5f;\n            m = (int) k;\n            if (m > 255) m = 255;\n            result->pixels[j*result->stride + i] = (unsigned char) m;\n         }\n      }\n      // advance all the edges\n      step = &active;\n      while (*step) {\n         stbtt__active_edge *z = *step;\n         z->fx += z->fdx; // advance to position for current scanline\n         step = &((*step)->next); // advance through list\n      }\n\n      ++y;\n      ++j;\n   }\n\n   stbtt__hheap_cleanup(&hh, userdata);\n\n   if (scanline != scanline_data)\n      STBTT_free(scanline, userdata);\n}\n#else\n#error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n\n#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)\n\nstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)\n{\n   int i,j;\n   for (i=1; i < n; ++i) {\n      stbtt__edge t = p[i], *a = &t;\n      j = i;\n      while (j > 0) {\n         stbtt__edge *b = &p[j-1];\n         int c = STBTT__COMPARE(a,b);\n         if (!c) break;\n         p[j] = p[j-1];\n         --j;\n      }\n      if (i != j)\n         p[j] = t;\n   }\n}\n\nstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)\n{\n   /* threshold for transitioning to insertion sort */\n   while (n > 12) {\n      stbtt__edge t;\n      int c01,c12,c,m,i,j;\n\n      /* compute median of three */\n      m = n >> 1;\n      c01 = STBTT__COMPARE(&p[0],&p[m]);\n      c12 = STBTT__COMPARE(&p[m],&p[n-1]);\n      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */\n      if (c01 != c12) {\n         /* otherwise, we'll need to swap something else to middle */\n         int z;\n         c = STBTT__COMPARE(&p[0],&p[n-1]);\n         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */\n         /* 0<mid && mid>n:  0>n => 0; 0<n => n */\n         z = (c == c12) ? 0 : n-1;\n         t = p[z];\n         p[z] = p[m];\n         p[m] = t;\n      }\n      /* now p[m] is the median-of-three */\n      /* swap it to the beginning so it won't move around */\n      t = p[0];\n      p[0] = p[m];\n      p[m] = t;\n\n      /* partition loop */\n      i=1;\n      j=n-1;\n      for(;;) {\n         /* handling of equality is crucial here */\n         /* for sentinels & efficiency with duplicates */\n         for (;;++i) {\n            if (!STBTT__COMPARE(&p[i], &p[0])) break;\n         }\n         for (;;--j) {\n            if (!STBTT__COMPARE(&p[0], &p[j])) break;\n         }\n         /* make sure we haven't crossed */\n         if (i >= j) break;\n         t = p[i];\n         p[i] = p[j];\n         p[j] = t;\n\n         ++i;\n         --j;\n      }\n      /* recurse on smaller side, iterate on larger */\n      if (j < (n-i)) {\n         stbtt__sort_edges_quicksort(p,j);\n         p = p+i;\n         n = n-i;\n      } else {\n         stbtt__sort_edges_quicksort(p+i, n-i);\n         n = j;\n      }\n   }\n}\n\nstatic void stbtt__sort_edges(stbtt__edge *p, int n)\n{\n   stbtt__sort_edges_quicksort(p, n);\n   stbtt__sort_edges_ins_sort(p, n);\n}\n\ntypedef struct\n{\n   float x,y;\n} stbtt__point;\n\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\n{\n   float y_scale_inv = invert ? -scale_y : scale_y;\n   stbtt__edge *e;\n   int n,i,j,k,m;\n#if STBTT_RASTERIZER_VERSION == 1\n   int vsubsample = result->h < 8 ? 15 : 5;\n#elif STBTT_RASTERIZER_VERSION == 2\n   int vsubsample = 1;\n#else\n   #error \"Unrecognized value of STBTT_RASTERIZER_VERSION\"\n#endif\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\n\n   // now we have to blow out the windings into explicit edge lists\n   n = 0;\n   for (i=0; i < windings; ++i)\n      n += wcount[i];\n\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\n   if (e == 0) return;\n   n = 0;\n\n   m=0;\n   for (i=0; i < windings; ++i) {\n      stbtt__point *p = pts + m;\n      m += wcount[i];\n      j = wcount[i]-1;\n      for (k=0; k < wcount[i]; j=k++) {\n         int a=k,b=j;\n         // skip the edge if horizontal\n         if (p[j].y == p[k].y)\n            continue;\n         // add edge from j to k to the list\n         e[n].invert = 0;\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\n            e[n].invert = 1;\n            a=j,b=k;\n         }\n         e[n].x0 = p[a].x * scale_x + shift_x;\n         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;\n         e[n].x1 = p[b].x * scale_x + shift_x;\n         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;\n         ++n;\n      }\n   }\n\n   // now sort the edges by their highest point (should snap to integer, and then by x)\n   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\n   stbtt__sort_edges(e, n);\n\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\n\n   STBTT_free(e, userdata);\n}\n\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; // during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}\n\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\n{\n   // midpoint\n   float mx = (x0 + 2*x1 + x2)/4;\n   float my = (y0 + 2*y1 + y2)/4;\n   // versus directly drawn line\n   float dx = (x0+x2)/2 - mx;\n   float dy = (y0+y2)/2 - my;\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return 1;\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x2,y2);\n      *num_points = *num_points+1;\n   }\n   return 1;\n}\n\nstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)\n{\n   float dx0 = x1-x0;\n   float dy0 = y1-y0;\n   float dx1 = x2-x1;\n   float dy1 = y2-y1;\n   float dx2 = x3-x2;\n   float dy2 = y3-y2;\n   float dx = x3-x0;\n   float dy = y3-y0;\n   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));\n   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);\n   float flatness_squared = longlen*longlen-shortlen*shortlen;\n\n   if (n > 16) // 65536 segments on one curve better be enough!\n      return;\n\n   if (flatness_squared > objspace_flatness_squared) {\n      float x01 = (x0+x1)/2;\n      float y01 = (y0+y1)/2;\n      float x12 = (x1+x2)/2;\n      float y12 = (y1+y2)/2;\n      float x23 = (x2+x3)/2;\n      float y23 = (y2+y3)/2;\n\n      float xa = (x01+x12)/2;\n      float ya = (y01+y12)/2;\n      float xb = (x12+x23)/2;\n      float yb = (y12+y23)/2;\n\n      float mx = (xa+xb)/2;\n      float my = (ya+yb)/2;\n\n      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);\n      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);\n   } else {\n      stbtt__add_point(points, *num_points,x3,y3);\n      *num_points = *num_points+1;\n   }\n}\n\n// returns number of contours\nstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\n{\n   stbtt__point *points=0;\n   int num_points=0;\n\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\n   int i,n=0,start=0, pass;\n\n   // count how many \"moves\" there are to get the contour count\n   for (i=0; i < num_verts; ++i)\n      if (vertices[i].type == STBTT_vmove)\n         ++n;\n\n   *num_contours = n;\n   if (n == 0) return 0;\n\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\n\n   if (*contour_lengths == 0) {\n      *num_contours = 0;\n      return 0;\n   }\n\n   // make two passes through the points so we don't need to realloc\n   for (pass=0; pass < 2; ++pass) {\n      float x=0,y=0;\n      if (pass == 1) {\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\n         if (points == 0) goto error;\n      }\n      num_points = 0;\n      n= -1;\n      for (i=0; i < num_verts; ++i) {\n         switch (vertices[i].type) {\n            case STBTT_vmove:\n               // start the next contour\n               if (n >= 0)\n                  (*contour_lengths)[n] = num_points - start;\n               ++n;\n               start = num_points;\n\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x,y);\n               break;\n            case STBTT_vline:\n               x = vertices[i].x, y = vertices[i].y;\n               stbtt__add_point(points, num_points++, x, y);\n               break;\n            case STBTT_vcurve:\n               stbtt__tesselate_curve(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n            case STBTT_vcubic:\n               stbtt__tesselate_cubic(points, &num_points, x,y,\n                                        vertices[i].cx, vertices[i].cy,\n                                        vertices[i].cx1, vertices[i].cy1,\n                                        vertices[i].x,  vertices[i].y,\n                                        objspace_flatness_squared, 0);\n               x = vertices[i].x, y = vertices[i].y;\n               break;\n         }\n      }\n      (*contour_lengths)[n] = num_points - start;\n   }\n\n   return points;\nerror:\n   STBTT_free(points, userdata);\n   STBTT_free(*contour_lengths, userdata);\n   *contour_lengths = 0;\n   *num_contours = 0;\n   return 0;\n}\n\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\n{\n   float scale            = scale_x > scale_y ? scale_y : scale_x;\n   int winding_count      = 0;\n   int *winding_lengths   = 0;\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\n   if (windings) {\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\n      STBTT_free(winding_lengths, userdata);\n      STBTT_free(windings, userdata);\n   }\n}\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   int ix0,iy0,ix1,iy1;\n   stbtt__bitmap gbm;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n\n   if (scale_x == 0) scale_x = scale_y;\n   if (scale_y == 0) {\n      if (scale_x == 0) {\n         STBTT_free(vertices, info->userdata);\n         return 0;\n      }\n      scale_y = scale_x;\n   }\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\n\n   // now we get the size\n   gbm.w = (ix1 - ix0);\n   gbm.h = (iy1 - iy0);\n   gbm.pixels = 0; // in case we error\n\n   if (width ) *width  = gbm.w;\n   if (height) *height = gbm.h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   if (gbm.w && gbm.h) {\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\n      if (gbm.pixels) {\n         gbm.stride = gbm.w;\n\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\n      }\n   }\n   STBTT_free(vertices, info->userdata);\n   return gbm.pixels;\n}\n\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\n{\n   int ix0,iy0;\n   stbtt_vertex *vertices;\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\n   stbtt__bitmap gbm;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\n   gbm.pixels = output;\n   gbm.w = out_w;\n   gbm.h = out_h;\n   gbm.stride = out_stride;\n\n   if (gbm.w && gbm.h)\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\n\n   STBTT_free(vertices, info->userdata);\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\n}\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\n{\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-CRAPPY packing to keep source code small\n\nstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\n                                float pixel_height,                     // height of font in pixels\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\n                                int first_char, int num_chars,          // characters to bake\n                                stbtt_bakedchar *chardata)\n{\n   float scale;\n   int x,y,bottom_y, i;\n   stbtt_fontinfo f;\n   f.userdata = 0;\n   if (!stbtt_InitFont(&f, data, offset))\n      return -1;\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n   x=y=1;\n   bottom_y = 1;\n\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\n\n   for (i=0; i < num_chars; ++i) {\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\n      gw = x1-x0;\n      gh = y1-y0;\n      if (x + gw + 1 >= pw)\n         y = bottom_y, x = 1; // advance to next row\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\n         return -i;\n      STBTT_assert(x+gw < pw);\n      STBTT_assert(y+gh < ph);\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\n      chardata[i].x0 = (stbtt_int16) x;\n      chardata[i].y0 = (stbtt_int16) y;\n      chardata[i].x1 = (stbtt_int16) (x + gw);\n      chardata[i].y1 = (stbtt_int16) (y + gh);\n      chardata[i].xadvance = scale * advance;\n      chardata[i].xoff     = (float) x0;\n      chardata[i].yoff     = (float) y0;\n      x = x + gw + 1;\n      if (y+gh+1 > bottom_y)\n         bottom_y = y+gh+1;\n   }\n   return bottom_y;\n}\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\n{\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_bakedchar *b = chardata + char_index;\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n\n   q->x0 = round_x + d3d_bias;\n   q->y0 = round_y + d3d_bias;\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// rectangle packing replacement routines if you don't have stb_rect_pack.h\n//\n\n#ifndef STB_RECT_PACK_VERSION\n\ntypedef int stbrp_coord;\n\n////////////////////////////////////////////////////////////////////////////////////\n//                                                                                //\n//                                                                                //\n// COMPILER WARNING ?!?!?                                                         //\n//                                                                                //\n//                                                                                //\n// if you get a compile warning due to these symbols being defined more than      //\n// once, move include \"stb_rect_pack.h\" before include \"stb_truetype.h\"         //\n//                                                                                //\n////////////////////////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n   int width,height;\n   int x,y,bottom_y;\n} stbrp_context;\n\ntypedef struct\n{\n   unsigned char x;\n} stbrp_node;\n\nstruct stbrp_rect\n{\n   stbrp_coord x,y;\n   int id,w,h,was_packed;\n};\n\nstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}\n\nstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)\n{\n   int i;\n   for (i=0; i < num_rects; ++i) {\n      if (con->x + rects[i].w > con->width) {\n         con->x = 0;\n         con->y = con->bottom_y;\n      }\n      if (con->y + rects[i].h > con->height)\n         break;\n      rects[i].x = con->x;\n      rects[i].y = con->y;\n      rects[i].was_packed = 1;\n      con->x += rects[i].w;\n      if (con->y + rects[i].h > con->bottom_y)\n         con->bottom_y = con->y + rects[i].h;\n   }\n   for (   ; i < num_rects; ++i)\n      rects[i].was_packed = 0;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// bitmap baking\n//\n// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If\n// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.\n\nSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)\n{\n   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);\n   int            num_nodes = pw - padding;\n   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);\n\n   if (context == 0 || nodes == 0) {\n      if (context != 0) STBTT_free(context, alloc_context);\n      if (nodes   != 0) STBTT_free(nodes  , alloc_context);\n      return 0;\n   }\n\n   spc->user_allocator_context = alloc_context;\n   spc->width = pw;\n   spc->height = ph;\n   spc->pixels = pixels;\n   spc->pack_info = context;\n   spc->nodes = nodes;\n   spc->padding = padding;\n   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;\n   spc->h_oversample = 1;\n   spc->v_oversample = 1;\n   spc->skip_missing = 0;\n\n   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);\n\n   if (pixels)\n      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\n\n   return 1;\n}\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)\n{\n   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);\n   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);\n   if (h_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->h_oversample = h_oversample;\n   if (v_oversample <= STBTT_MAX_OVERSAMPLE)\n      spc->v_oversample = v_oversample;\n}\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}\n\n#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)\n\nstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_w = w - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < h; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_w; ++i) {\n               total += pixels[i] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];\n               pixels[i] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < w; ++i) {\n         STBTT_assert(pixels[i] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += stride_in_bytes;\n   }\n}\n\nstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)\n{\n   unsigned char buffer[STBTT_MAX_OVERSAMPLE];\n   int safe_h = h - kernel_width;\n   int j;\n   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze\n   for (j=0; j < w; ++j) {\n      int i;\n      unsigned int total;\n      STBTT_memset(buffer, 0, kernel_width);\n\n      total = 0;\n\n      // make kernel_width a constant in common cases so compiler can optimize out the divide\n      switch (kernel_width) {\n         case 2:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);\n            }\n            break;\n         case 3:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);\n            }\n            break;\n         case 4:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);\n            }\n            break;\n         case 5:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);\n            }\n            break;\n         default:\n            for (i=0; i <= safe_h; ++i) {\n               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];\n               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];\n               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n            }\n            break;\n      }\n\n      for (; i < h; ++i) {\n         STBTT_assert(pixels[i*stride_in_bytes] == 0);\n         total -= buffer[i & STBTT__OVER_MASK];\n         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);\n      }\n\n      pixels += 1;\n   }\n}\n\nstatic float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   // The prefilter is a box filter of width \"oversample\",\n   // which shifts phase by (oversample - 1)/2 pixels in\n   // oversampled space. We want to shift in the opposite\n   // direction to counter this.\n   return (float)-(oversample - 1) / (2.0f * (float)oversample);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k;\n   int missing_glyph_added = 0;\n\n   k=0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      ranges[i].h_oversample = (unsigned char) spc->h_oversample;\n      ranges[i].v_oversample = (unsigned char) spc->v_oversample;\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         int x0,y0,x1,y1;\n         int codepoint = ranges[i].array_of_unicode_codepoints == 0 ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n         int glyph = stbtt_FindGlyphIndex(info, codepoint);\n         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {\n            rects[k].w = rects[k].h = 0;\n         } else {\n            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,\n                                            scale * spc->h_oversample,\n                                            scale * spc->v_oversample,\n                                            0,0,\n                                            &x0,&y0,&x1,&y1);\n            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);\n            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);\n            if (glyph == 0)\n               missing_glyph_added = 1;\n         }\n         ++k;\n      }\n   }\n\n   return k;\n}\n\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info,\n                                 output,\n                                 out_w - (prefilter_x - 1),\n                                 out_h - (prefilter_y - 1),\n                                 out_stride,\n                                 scale_x,\n                                 scale_y,\n                                 shift_x,\n                                 shift_y,\n                                 glyph);\n\n   if (prefilter_x > 1)\n      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);\n\n   if (prefilter_y > 1)\n      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);\n\n   *sub_x = stbtt__oversample_shift(prefilter_x);\n   *sub_y = stbtt__oversample_shift(prefilter_y);\n}\n\n// rects array must be big enough to accommodate all characters in the given ranges\nSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)\n{\n   int i,j,k, missing_glyph = -1, return_value = 1;\n\n   // save current values\n   int old_h_over = spc->h_oversample;\n   int old_v_over = spc->v_oversample;\n\n   k = 0;\n   for (i=0; i < num_ranges; ++i) {\n      float fh = ranges[i].font_size;\n      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);\n      float recip_h,recip_v,sub_x,sub_y;\n      spc->h_oversample = ranges[i].h_oversample;\n      spc->v_oversample = ranges[i].v_oversample;\n      recip_h = 1.0f / spc->h_oversample;\n      recip_v = 1.0f / spc->v_oversample;\n      sub_x = stbtt__oversample_shift(spc->h_oversample);\n      sub_y = stbtt__oversample_shift(spc->v_oversample);\n      for (j=0; j < ranges[i].num_chars; ++j) {\n         stbrp_rect *r = &rects[k];\n         if (r->was_packed && r->w != 0 && r->h != 0) {\n            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];\n            int advance, lsb, x0,y0,x1,y1;\n            int codepoint = ranges[i].array_of_unicode_codepoints == 0 ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];\n            int glyph = stbtt_FindGlyphIndex(info, codepoint);\n            stbrp_coord pad = (stbrp_coord) spc->padding;\n\n            // pad on left and top\n            r->x += pad;\n            r->y += pad;\n            r->w -= pad;\n            r->h -= pad;\n            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);\n            stbtt_GetGlyphBitmapBox(info, glyph,\n                                    scale * spc->h_oversample,\n                                    scale * spc->v_oversample,\n                                    &x0,&y0,&x1,&y1);\n            stbtt_MakeGlyphBitmapSubpixel(info,\n                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                          r->w - spc->h_oversample+1,\n                                          r->h - spc->v_oversample+1,\n                                          spc->stride_in_bytes,\n                                          scale * spc->h_oversample,\n                                          scale * spc->v_oversample,\n                                          0,0,\n                                          glyph);\n\n            if (spc->h_oversample > 1)\n               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->h_oversample);\n\n            if (spc->v_oversample > 1)\n               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,\n                                  r->w, r->h, spc->stride_in_bytes,\n                                  spc->v_oversample);\n\n            bc->x0       = (stbtt_int16)  r->x;\n            bc->y0       = (stbtt_int16)  r->y;\n            bc->x1       = (stbtt_int16) (r->x + r->w);\n            bc->y1       = (stbtt_int16) (r->y + r->h);\n            bc->xadvance =                scale * advance;\n            bc->xoff     =       (float)  x0 * recip_h + sub_x;\n            bc->yoff     =       (float)  y0 * recip_v + sub_y;\n            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;\n            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;\n\n            if (glyph == 0)\n               missing_glyph = j;\n         } else if (spc->skip_missing) {\n            return_value = 0;\n         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {\n            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];\n         } else {\n            return_value = 0; // if any fail, report failure\n         }\n\n         ++k;\n      }\n   }\n\n   // restore original values\n   spc->h_oversample = old_h_over;\n   spc->v_oversample = old_v_over;\n\n   return return_value;\n}\n\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)\n{\n   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);\n}\n\nSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)\n{\n   stbtt_fontinfo info;\n   int i,j,n, return_value = 1;\n   //stbrp_context *context = (stbrp_context *) spc->pack_info;\n   stbrp_rect    *rects;\n\n   // flag all characters as NOT packed\n   for (i=0; i < num_ranges; ++i)\n      for (j=0; j < ranges[i].num_chars; ++j)\n         ranges[i].chardata_for_range[j].x0 =\n         ranges[i].chardata_for_range[j].y0 =\n         ranges[i].chardata_for_range[j].x1 =\n         ranges[i].chardata_for_range[j].y1 = 0;\n\n   n = 0;\n   for (i=0; i < num_ranges; ++i)\n      n += ranges[i].num_chars;\n\n   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);\n   if (rects == 0)\n      return 0;\n\n   info.userdata = spc->user_allocator_context;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));\n\n   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);\n\n   stbtt_PackFontRangesPackRects(spc, rects, n);\n\n   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);\n\n   STBTT_free(rects, spc->user_allocator_context);\n   return return_value;\n}\n\nSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)\n{\n   stbtt_pack_range range;\n   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;\n   range.array_of_unicode_codepoints = 0;\n   range.num_chars                   = num_chars_in_range;\n   range.chardata_for_range          = chardata_for_range;\n   range.font_size                   = font_size;\n   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);\n}\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)\n{\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\n   const stbtt_packedchar *b = chardata + char_index;\n\n   if (align_to_integer) {\n      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);\n      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);\n      q->x0 = x;\n      q->y0 = y;\n      q->x1 = x + b->xoff2 - b->xoff;\n      q->y1 = y + b->yoff2 - b->yoff;\n   } else {\n      q->x0 = *xpos + b->xoff;\n      q->y0 = *ypos + b->yoff;\n      q->x1 = *xpos + b->xoff2;\n      q->y1 = *ypos + b->yoff2;\n   }\n\n   q->s0 = b->x0 * ipw;\n   q->t0 = b->y0 * iph;\n   q->s1 = b->x1 * ipw;\n   q->t1 = b->y1 * iph;\n\n   *xpos += b->xadvance;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// sdf computation\n//\n\n#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))\n#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))\n\nstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])\n{\n   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];\n   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];\n   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];\n   float roperp = orig[1]*ray[0] - orig[0]*ray[1];\n\n   float a = q0perp - 2*q1perp + q2perp;\n   float b = q1perp - q0perp;\n   float c = q0perp - roperp;\n\n   float s0 = 0., s1 = 0.;\n   int num_s = 0;\n\n   if (a != 0.0) {\n      float discr = b*b - a*c;\n      if (discr > 0.0) {\n         float rcpna = -1 / a;\n         float d = (float) STBTT_sqrt(discr);\n         s0 = (b+d) * rcpna;\n         s1 = (b-d) * rcpna;\n         if (s0 >= 0.0 && s0 <= 1.0)\n            num_s = 1;\n         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {\n            if (num_s == 0) s0 = s1;\n            ++num_s;\n         }\n      }\n   } else {\n      // 2*b*s + c = 0\n      // s = -c / (2*b)\n      s0 = c / (-2 * b);\n      if (s0 >= 0.0 && s0 <= 1.0)\n         num_s = 1;\n   }\n\n   if (num_s == 0)\n      return 0;\n   else {\n      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);\n      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;\n\n      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;\n      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;\n      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;\n      float rod = orig[0]*rayn_x + orig[1]*rayn_y;\n\n      float q10d = q1d - q0d;\n      float q20d = q2d - q0d;\n      float q0rd = q0d - rod;\n\n      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;\n      hits[0][1] = a*s0+b;\n\n      if (num_s > 1) {\n         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;\n         hits[1][1] = a*s1+b;\n         return 2;\n      } else {\n         return 1;\n      }\n   }\n}\n\nstatic int equal(float *a, float *b)\n{\n   return (a[0] == b[0] && a[1] == b[1]);\n}\n\nstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)\n{\n   int i;\n   float orig[2], ray[2] = { 1, 0 };\n   float y_frac;\n   int winding = 0;\n\n   // make sure y never passes through a vertex of the shape\n   y_frac = (float) STBTT_fmod(y, 1.0f);\n   if (y_frac < 0.01f)\n      y += 0.01f;\n   else if (y_frac > 0.99f)\n      y -= 0.01f;\n\n   orig[0] = x;\n   orig[1] = y;\n\n   // test a ray from (-infinity,y) to (x,y)\n   for (i=0; i < nverts; ++i) {\n      if (verts[i].type == STBTT_vline) {\n         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;\n         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;\n         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n            if (x_inter < x)\n               winding += (y0 < y1) ? 1 : -1;\n         }\n      }\n      if (verts[i].type == STBTT_vcurve) {\n         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;\n         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;\n         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;\n         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));\n         int by = STBTT_max(y0,STBTT_max(y1,y2));\n         if (y > ay && y < by && x > ax) {\n            float q0[2],q1[2],q2[2];\n            float hits[2][2];\n            q0[0] = (float)x0;\n            q0[1] = (float)y0;\n            q1[0] = (float)x1;\n            q1[1] = (float)y1;\n            q2[0] = (float)x2;\n            q2[1] = (float)y2;\n            if (equal(q0,q1) || equal(q1,q2)) {\n               x0 = (int)verts[i-1].x;\n               y0 = (int)verts[i-1].y;\n               x1 = (int)verts[i  ].x;\n               y1 = (int)verts[i  ].y;\n               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {\n                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;\n                  if (x_inter < x)\n                     winding += (y0 < y1) ? 1 : -1;\n               }\n            } else {\n               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);\n               if (num_hits >= 1)\n                  if (hits[0][0] < 0)\n                     winding += (hits[0][1] < 0 ? -1 : 1);\n               if (num_hits >= 2)\n                  if (hits[1][0] < 0)\n                     winding += (hits[1][1] < 0 ? -1 : 1);\n            }\n         }\n      }\n   }\n   return winding;\n}\n\nstatic float stbtt__cuberoot( float x )\n{\n   if (x<0)\n      return -(float) STBTT_pow(-x,1.0f/3.0f);\n   else\n      return  (float) STBTT_pow( x,1.0f/3.0f);\n}\n\n// x^3 + a*x^2 + b*x + c = 0\nstatic int stbtt__solve_cubic(float a, float b, float c, float* r)\n{\n   float s = -a / 3;\n   float p = b - a*a / 3;\n   float q = a * (2*a*a - 9*b) / 27 + c;\n   float p3 = p*p*p;\n   float d = q*q + 4*p3 / 27;\n   if (d >= 0) {\n      float z = (float) STBTT_sqrt(d);\n      float u = (-q + z) / 2;\n      float v = (-q - z) / 2;\n      u = stbtt__cuberoot(u);\n      v = stbtt__cuberoot(v);\n      r[0] = s + u + v;\n      return 1;\n   } else {\n      float u = (float) STBTT_sqrt(-p/3);\n      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative\n      float m = (float) STBTT_cos(v);\n      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;\n      r[0] = s + u * 2 * m;\n      r[1] = s - u * (m + n);\n      r[2] = s - u * (m - n);\n\n      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?\n      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);\n      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);\n      return 3;\n   }\n}\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   float scale_x = scale, scale_y = scale;\n   int ix0,iy0,ix1,iy1;\n   int w,h;\n   unsigned char *data;\n\n   if (scale == 0) return 0;\n\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);\n\n   // if empty, return 0\n   if (ix0 == ix1 || iy0 == iy1)\n      return 0;\n\n   ix0 -= padding;\n   iy0 -= padding;\n   ix1 += padding;\n   iy1 += padding;\n\n   w = (ix1 - ix0);\n   h = (iy1 - iy0);\n\n   if (width ) *width  = w;\n   if (height) *height = h;\n   if (xoff  ) *xoff   = ix0;\n   if (yoff  ) *yoff   = iy0;\n\n   // invert for y-downwards bitmaps\n   scale_y = -scale_y;\n\n   {\n      int x,y,i,j;\n      float *precompute;\n      stbtt_vertex *verts;\n      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);\n      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);\n      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);\n\n      for (i=0,j=num_verts-1; i < num_verts; j=i++) {\n         if (verts[i].type == STBTT_vline) {\n            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;\n            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));\n            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;\n         } else if (verts[i].type == STBTT_vcurve) {\n            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;\n            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;\n            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;\n            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n            float len2 = bx*bx + by*by;\n            if (len2 != 0.0f)\n               precompute[i] = 1.0f / (bx*bx + by*by);\n            else\n               precompute[i] = 0.0f;\n         } else\n            precompute[i] = 0.0f;\n      }\n\n      for (y=iy0; y < iy1; ++y) {\n         for (x=ix0; x < ix1; ++x) {\n            float val;\n            float min_dist = 999999.0f;\n            float sx = (float) x + 0.5f;\n            float sy = (float) y + 0.5f;\n            float x_gspace = (sx / scale_x);\n            float y_gspace = (sy / scale_y);\n\n            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path\n\n            for (i=0; i < num_verts; ++i) {\n               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;\n\n               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {\n                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;\n\n                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                  if (dist2 < min_dist*min_dist)\n                     min_dist = (float) STBTT_sqrt(dist2);\n\n                  // coarse culling against bbox\n                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&\n                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)\n                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];\n                  STBTT_assert(i != 0);\n                  if (dist < min_dist) {\n                     // check position along line\n                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)\n                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)\n                     float dx = x1-x0, dy = y1-y0;\n                     float px = x0-sx, py = y0-sy;\n                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy\n                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve\n                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);\n                     if (t >= 0.0f && t <= 1.0f)\n                        min_dist = dist;\n                  }\n               } else if (verts[i].type == STBTT_vcurve) {\n                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;\n                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;\n                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);\n                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);\n                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);\n                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);\n                  // coarse culling against bbox to avoid computing cubic unnecessarily\n                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {\n                     int num=0;\n                     float ax = x1-x0, ay = y1-y0;\n                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;\n                     float mx = x0 - sx, my = y0 - sy;\n                     float res[3] = {0.f,0.f,0.f};\n                     float px,py,t,it,dist2;\n                     float a_inv = precompute[i];\n                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula\n                        float a = 3*(ax*bx + ay*by);\n                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);\n                        float c = mx*ax+my*ay;\n                        if (a == 0.0) { // if a is 0, it's linear\n                           if (b != 0.0) {\n                              res[num++] = -c/b;\n                           }\n                        } else {\n                           float discriminant = b*b - 4*a*c;\n                           if (discriminant < 0)\n                              num = 0;\n                           else {\n                              float root = (float) STBTT_sqrt(discriminant);\n                              res[0] = (-b - root)/(2*a);\n                              res[1] = (-b + root)/(2*a);\n                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work\n                           }\n                        }\n                     } else {\n                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point\n                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;\n                        float d = (mx*ax+my*ay) * a_inv;\n                        num = stbtt__solve_cubic(b, c, d, res);\n                     }\n                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);\n                     if (dist2 < min_dist*min_dist)\n                        min_dist = (float) STBTT_sqrt(dist2);\n\n                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {\n                        t = res[0], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {\n                        t = res[1], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {\n                        t = res[2], it = 1.0f - t;\n                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;\n                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;\n                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);\n                        if (dist2 < min_dist * min_dist)\n                           min_dist = (float) STBTT_sqrt(dist2);\n                     }\n                  }\n               }\n            }\n            if (winding == 0)\n               min_dist = -min_dist;  // if outside the shape, value is negative\n            val = onedge_value + pixel_dist_scale * min_dist;\n            if (val < 0)\n               val = 0;\n            else if (val > 255)\n               val = 255;\n            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;\n         }\n      }\n      STBTT_free(precompute, info->userdata);\n      STBTT_free(verts, info->userdata);\n   }\n   return data;\n}\n\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)\n{\n   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);\n}\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// font name matching -- recommended not to use this\n//\n\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)\n{\n   stbtt_int32 i=0;\n\n   // convert utf16 to utf8 and compare the results while converting\n   while (len2) {\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\n      if (ch < 0x80) {\n         if (i >= len1) return -1;\n         if (s1[i++] != ch) return -1;\n      } else if (ch < 0x800) {\n         if (i+1 >= len1) return -1;\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\n         stbtt_uint32 c;\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\n         if (i+3 >= len1) return -1;\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\n         s2 += 2; // plus another 2 below\n         len2 -= 2;\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\n         return -1;\n      } else {\n         if (i+2 >= len1) return -1;\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\n      }\n      s2 += 2;\n      len2 -= 2;\n   }\n   return i;\n}\n\nstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)\n{\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);\n}\n\n// returns results in whatever encoding you request... but note that 2-byte encodings\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\n{\n   stbtt_int32 i,count,stringOffset;\n   stbtt_uint8 *fc = font->data;\n   stbtt_uint32 offset = font->fontstart;\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   count = ttUSHORT(fc+nm+2);\n   stringOffset = nm + ttUSHORT(fc+nm+4);\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\n         *length = ttUSHORT(fc+loc+8);\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\n{\n   stbtt_int32 i;\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\n\n   for (i=0; i < count; ++i) {\n      stbtt_uint32 loc = nm + 6 + 12 * i;\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\n      if (id == target_id) {\n         // find the encoding\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\n\n         // is this a Unicode encoding?\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\n            stbtt_int32 slen = ttUSHORT(fc+loc+8);\n            stbtt_int32 off = ttUSHORT(fc+loc+10);\n\n            // check if there's a prefix match\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\n            if (matchlen >= 0) {\n               // check for target_id+1 immediately following, with same encoding & language\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\n                  slen = ttUSHORT(fc+loc+12+8);\n                  off = ttUSHORT(fc+loc+12+10);\n                  if (slen == 0) {\n                     if (matchlen == nlen)\n                        return 1;\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\n                     ++matchlen;\n                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\n                        return 1;\n                  }\n               } else {\n                  // if nothing immediately following\n                  if (matchlen == nlen)\n                     return 1;\n               }\n            }\n         }\n\n      }\n   }\n   return 0;\n}\n\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\n{\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\n   stbtt_uint32 nm,hd;\n   if (!stbtt__isfont(fc+offset)) return 0;\n\n   // check italics/bold/underline flags in macStyle...\n   if (flags) {\n      hd = stbtt__find_table(fc, offset, \"head\");\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\n   }\n\n   nm = stbtt__find_table(fc, offset, \"name\");\n   if (!nm) return 0;\n\n   if (flags) {\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   } else {\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\n   }\n\n   return 0;\n}\n\nstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)\n{\n   stbtt_int32 i;\n   for (i=0;;++i) {\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\n      if (off < 0) return off;\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\n         return off;\n   }\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,\n                                float pixel_height, unsigned char *pixels, int pw, int ph,\n                                int first_char, int num_chars, stbtt_bakedchar *chardata)\n{\n   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);\n}\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)\n{\n   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);\n}\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)\n{\n   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif // STB_TRUETYPE_IMPLEMENTATION\n\n\n// FULL VERSION HISTORY\n//\n//   1.25 (2021-07-11) many fixes\n//   1.24 (2020-02-05) fix warning\n//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)\n//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined\n//   1.21 (2019-02-25) fix warning\n//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()\n//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod\n//   1.18 (2018-01-29) add missing function\n//   1.17 (2017-07-23) make more arguments const; doc fix\n//   1.16 (2017-07-12) SDF support\n//   1.15 (2017-03-03) make more arguments const\n//   1.14 (2017-01-16) num-fonts-in-TTC function\n//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts\n//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual\n//   1.11 (2016-04-02) fix unused-variable warning\n//   1.10 (2016-04-02) allow user-defined fabs() replacement\n//                     fix memory leak if fontsize=0.0\n//                     fix warning from duplicate typedef\n//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges\n//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges\n//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;\n//                     allow PackFontRanges to pack and render in separate phases;\n//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);\n//                     fixed an assert() bug in the new rasterizer\n//                     replace assert() with STBTT_assert() in new rasterizer\n//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)\n//                     also more precise AA rasterizer, except if shapes overlap\n//                     remove need for STBTT_sort\n//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC\n//   1.04 (2015-04-15) typo in example\n//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes\n//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++\n//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match\n//                        non-oversampled; STBTT_POINT_SIZE for packed case only\n//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling\n//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)\n//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID\n//   0.8b (2014-07-07) fix a warning\n//   0.8  (2014-05-25) fix a few more warnings\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\n//   0.6c (2012-07-24) improve documentation\n//   0.6b (2012-07-20) fix a few more warnings\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\n//   0.5  (2011-12-09) bugfixes:\n//                        subpixel glyph renderer computed wrong bounding box\n//                        first vertex of shape can be off-curve (FreeSans)\n//   0.4b (2011-12-03) fixed an error in the font baking example\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\n//                    bugfixes for:\n//                        codepoint-to-glyph conversion using table fmt=12\n//                        codepoint-to-glyph conversion using table fmt=4\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\n//                    updated Hello World! sample to use kerning and subpixel\n//                    fixed some warnings\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\n//                    userdata, malloc-from-userdata, non-zero fill (stb)\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\n//   0.1  (2009-03-09) First public release\n//\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","// stb_rect_pack.h - v1.01 - public domain - rectangle packing\n// Sean Barrett 2014\n//\n// Useful for e.g. packing rectangular textures into an atlas.\n// Does not do rotation.\n//\n// Before #including,\n//\n//    #define STB_RECT_PACK_IMPLEMENTATION\n//\n// in the file that you want to have the implementation.\n//\n// Not necessarily the awesomest packing method, but better than\n// the totally naive one in stb_truetype (which is primarily what\n// this is meant to replace).\n//\n// Has only had a few tests run, may have issues.\n//\n// More docs to come.\n//\n// No memory allocations; uses qsort() and assert() from stdlib.\n// Can override those by defining STBRP_SORT and STBRP_ASSERT.\n//\n// This library currently uses the Skyline Bottom-Left algorithm.\n//\n// Please note: better rectangle packers are welcome! Please\n// implement them to the same API, but with a different init\n// function.\n//\n// Credits\n//\n//  Library\n//    Sean Barrett\n//  Minor features\n//    Martins Mozeiko\n//    github:IntellectualKitty\n//\n//  Bugfixes / warning fixes\n//    Jeremy Jaussaud\n//    Fabian Giesen\n//\n// Version history:\n//\n//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section\n//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles\n//     0.99  (2019-02-07)  warning fixes\n//     0.11  (2017-03-03)  return packing success/fail result\n//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings\n//     0.09  (2016-08-27)  fix compiler warnings\n//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)\n//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)\n//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort\n//     0.05:  added STBRP_ASSERT to allow replacing assert\n//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support\n//     0.01:  initial release\n//\n// LICENSE\n//\n//   See end of file for license information.\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//       INCLUDE SECTION\n//\n\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\n#define STB_INCLUDE_STB_RECT_PACK_H\n\n#define STB_RECT_PACK_VERSION  1\n\n#ifdef STBRP_STATIC\n#define STBRP_DEF static\n#else\n#define STBRP_DEF extern\n#endif\n\ntypedef struct stbrp_context stbrp_context;\ntypedef struct stbrp_node    stbrp_node;\ntypedef struct stbrp_rect    stbrp_rect;\n\ntypedef int            stbrp_coord;\n\n#define STBRP__MAXVAL  0x7fffffff\n// Mostly for internal use, but this is the maximum supported coordinate value.\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context* context, stbrp_rect* rects, int num_rects);\n// Assign packed locations to rectangles. The rectangles are of type\n// 'stbrp_rect' defined below, stored in the array 'rects', and there\n// are 'num_rects' many of them.\n//\n// Rectangles which are successfully packed have the 'was_packed' flag\n// set to a non-zero value and 'x' and 'y' store the minimum location\n// on each axis (i.e. bottom-left in cartesian coordinates, top-left\n// if you imagine y increasing downwards). Rectangles which do not fit\n// have the 'was_packed' flag set to 0.\n//\n// You should not try to access the 'rects' array from another thread\n// while this function is running, as the function temporarily reorders\n// the array while it executes.\n//\n// To pack into another rectangle, you need to call stbrp_init_target\n// again. To continue packing into the same rectangle, you can call\n// this function again. Calling this multiple times with multiple rect\n// arrays will probably produce worse packing results than calling it\n// a single time with the full rectangle array, but the option is\n// available.\n//\n// The function returns 1 if all of the rectangles were successfully\n// packed and 0 otherwise.\n\nstruct stbrp_rect\n{\n    // reserved for your use:\n    int            id;\n\n    // input:\n    stbrp_coord    w, h;\n\n    // output:\n    stbrp_coord    x, y;\n    int            was_packed;  // non-zero if valid packing\n\n}; // 16 bytes, nominally\n\n\nSTBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes);\n// Initialize a rectangle packer to:\n//    pack a rectangle that is 'width' by 'height' in dimensions\n//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long\n//\n// You must call this function every time you start packing into a new target.\n//\n// There is no \"shutdown\" function. The 'nodes' memory must stay valid for\n// the following stbrp_pack_rects() call (or calls), but can be freed after\n// the call (or calls) finish.\n//\n// Note: to guarantee best results, either:\n//       1. make sure 'num_nodes' >= 'width'\n//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'\n//\n// If you don't do either of the above things, widths will be quantized to multiples\n// of small integers to guarantee the algorithm doesn't run out of temporary storage.\n//\n// If you do #2, then the non-quantized algorithm will be used, but the algorithm\n// may run out of temporary storage and be unable to pack some rectangles.\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem);\n// Optionally call this function after init but before doing any packing to\n// change the handling of the out-of-temp-memory scenario, described above.\n// If you call init again, this will be reset to the default (false).\n\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic);\n// Optionally select which packing heuristic the library should use. Different\n// heuristics will produce better/worse results for different data sets.\n// If you call init again, this will be reset to the default.\n\nenum\n{\n    STBRP_HEURISTIC_Skyline_default = 0,\n    STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\n    STBRP_HEURISTIC_Skyline_BF_sortHeight\n};\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// the details of the following structures don't matter to you, but they must\n// be visible so you can handle the memory allocations for them\n\nstruct stbrp_node\n{\n    stbrp_coord  x, y;\n    stbrp_node* next;\n};\n\nstruct stbrp_context\n{\n    int width;\n    int height;\n    int align;\n    int init_mode;\n    int heuristic;\n    int num_nodes;\n    stbrp_node* active_head;\n    stbrp_node* free_head;\n    stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'\n};\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//     IMPLEMENTATION SECTION\n//\n\n#ifdef STB_RECT_PACK_IMPLEMENTATION\n#ifndef STBRP_SORT\n#include <stdlib.h>\n#define STBRP_SORT qsort\n#endif\n\n#ifndef STBRP_ASSERT\n#include <assert.h>\n#define STBRP_ASSERT assert\n#endif\n\n#ifdef _MSC_VER\n#define STBRP__NOTUSED(v)  (void)(v)\n#define STBRP__CDECL       __cdecl\n#else\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\n#define STBRP__CDECL\n#endif\n\nenum\n{\n    STBRP__INIT_skyline = 1\n};\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic)\n{\n    switch (context->init_mode) {\n    case STBRP__INIT_skyline:\n        STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\n        context->heuristic = heuristic;\n        break;\n    default:\n        STBRP_ASSERT(0);\n    }\n}\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem)\n{\n    if (allow_out_of_mem)\n        // if it's ok to run out of memory, then don't bother aligning them;\n        // this gives better packing, but may fail due to OOM (even though\n        // the rectangles easily fit).  a smarter approach would be to only\n        // quantize once we've hit OOM, then we could get rid of this parameter.\n        context->align = 1;\n    else {\n        // if it's not ok to run out of memory, then quantize the widths\n        // so that num_nodes is always enough nodes.\n        //\n        // I.e. num_nodes * align >= width\n        //                  align >= width / num_nodes\n        //                  align = ceil(width/num_nodes)\n\n        context->align = (context->width + context->num_nodes - 1) / context->num_nodes;\n    }\n}\n\nSTBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes)\n{\n    int i;\n\n    for (i = 0; i < num_nodes - 1; ++i)\n        nodes[i].next = &nodes[i + 1];\n    nodes[i].next = 0;\n    context->init_mode = STBRP__INIT_skyline;\n    context->heuristic = STBRP_HEURISTIC_Skyline_default;\n    context->free_head = &nodes[0];\n    context->active_head = &context->extra[0];\n    context->width = width;\n    context->height = height;\n    context->num_nodes = num_nodes;\n    stbrp_setup_allow_out_of_mem(context, 0);\n\n    // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)\n    context->extra[0].x = 0;\n    context->extra[0].y = 0;\n    context->extra[0].next = &context->extra[1];\n    context->extra[1].x = (stbrp_coord)width;\n    context->extra[1].y = (1 << 30);\n    context->extra[1].next = 0;\n}\n\n// find minimum y position if it starts at x1\nstatic int stbrp__skyline_find_min_y(stbrp_context* c, stbrp_node* first, int x0, int width, int* pwaste)\n{\n    stbrp_node* node = first;\n    int x1 = x0 + width;\n    int min_y, visited_width, waste_area;\n\n    STBRP__NOTUSED(c);\n\n    STBRP_ASSERT(first->x <= x0);\n\n#if 0\n    // skip in case we're past the node\n    while (node->next->x <= x0)\n        ++node;\n#else\n    STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency\n#endif\n\n    STBRP_ASSERT(node->x <= x0);\n\n    min_y = 0;\n    waste_area = 0;\n    visited_width = 0;\n    while (node->x < x1) {\n        if (node->y > min_y) {\n            // raise min_y higher.\n            // we've accounted for all waste up to min_y,\n            // but we'll now add more waste for everything we've visted\n            waste_area += visited_width * (node->y - min_y);\n            min_y = node->y;\n            // the first time through, visited_width might be reduced\n            if (node->x < x0)\n                visited_width += node->next->x - x0;\n            else\n                visited_width += node->next->x - node->x;\n        }\n        else {\n            // add waste area\n            int under_width = node->next->x - node->x;\n            if (under_width + visited_width > width)\n                under_width = width - visited_width;\n            waste_area += under_width * (min_y - node->y);\n            visited_width += under_width;\n        }\n        node = node->next;\n    }\n\n    *pwaste = waste_area;\n    return min_y;\n}\n\ntypedef struct\n{\n    int x, y;\n    stbrp_node** prev_link;\n} stbrp__findresult;\n\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context* c, int width, int height)\n{\n    int best_waste = (1 << 30), best_x, best_y = (1 << 30);\n    stbrp__findresult fr;\n    stbrp_node** prev, * node, * tail, ** best = 0;\n\n    // align to multiple of c->align\n    width = (width + c->align - 1);\n    width -= width % c->align;\n    STBRP_ASSERT(width % c->align == 0);\n\n    // if it can't possibly fit, bail immediately\n    if (width > c->width || height > c->height) {\n        fr.prev_link = 0;\n        fr.x = fr.y = 0;\n        return fr;\n    }\n\n    node = c->active_head;\n    prev = &c->active_head;\n    while (node->x + width <= c->width) {\n        int y, waste;\n        y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\n        if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL\n            // bottom left\n            if (y < best_y) {\n                best_y = y;\n                best = prev;\n            }\n        }\n        else {\n            // best-fit\n            if (y + height <= c->height) {\n                // can only use it if it first vertically\n                if (y < best_y || (y == best_y && waste < best_waste)) {\n                    best_y = y;\n                    best_waste = waste;\n                    best = prev;\n                }\n            }\n        }\n        prev = &node->next;\n        node = node->next;\n    }\n\n    best_x = (best == 0) ? 0 : (*best)->x;\n\n    // if doing best-fit (BF), we also have to try aligning right edge to each node position\n    //\n    // e.g, if fitting\n    //\n    //     ____________________\n    //    |____________________|\n    //\n    //            into\n    //\n    //   |                         |\n    //   |             ____________|\n    //   |____________|\n    //\n    // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned\n    //\n    // This makes BF take about 2x the time\n\n    if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\n        tail = c->active_head;\n        node = c->active_head;\n        prev = &c->active_head;\n        // find first node that's admissible\n        while (tail->x < width)\n            tail = tail->next;\n        while (tail) {\n            int xpos = tail->x - width;\n            int y, waste;\n            STBRP_ASSERT(xpos >= 0);\n            // find the left position that matches this\n            while (node->next->x <= xpos) {\n                prev = &node->next;\n                node = node->next;\n            }\n            STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\n            y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\n            if (y + height <= c->height) {\n                if (y <= best_y) {\n                    if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {\n                        best_x = xpos;\n                        STBRP_ASSERT(y <= best_y);\n                        best_y = y;\n                        best_waste = waste;\n                        best = prev;\n                    }\n                }\n            }\n            tail = tail->next;\n        }\n    }\n\n    fr.prev_link = best;\n    fr.x = best_x;\n    fr.y = best_y;\n    return fr;\n}\n\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context* context, int width, int height)\n{\n    // find best position according to heuristic\n    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\n    stbrp_node* node, * cur;\n\n    // bail if:\n    //    1. it failed\n    //    2. the best node doesn't fit (we don't always check this)\n    //    3. we're out of memory\n    if (res.prev_link == 0 || res.y + height > context->height || context->free_head == 0) {\n        res.prev_link = 0;\n        return res;\n    }\n\n    // on success, create new node\n    node = context->free_head;\n    node->x = (stbrp_coord)res.x;\n    node->y = (stbrp_coord)(res.y + height);\n\n    context->free_head = node->next;\n\n    // insert the new node into the right starting point, and\n    // let 'cur' point to the remaining nodes needing to be\n    // stiched back in\n\n    cur = *res.prev_link;\n    if (cur->x < res.x) {\n        // preserve the existing one, so start testing with the next one\n        stbrp_node* next = cur->next;\n        cur->next = node;\n        cur = next;\n    }\n    else {\n        *res.prev_link = node;\n    }\n\n    // from here, traverse cur and free the nodes, until we get to one\n    // that shouldn't be freed\n    while (cur->next && cur->next->x <= res.x + width) {\n        stbrp_node* next = cur->next;\n        // move the current node to the free list\n        cur->next = context->free_head;\n        context->free_head = cur;\n        cur = next;\n    }\n\n    // stitch the list back in\n    node->next = cur;\n\n    if (cur->x < res.x + width)\n        cur->x = (stbrp_coord)(res.x + width);\n\n#ifdef _DEBUG\n    cur = context->active_head;\n    while (cur->x < context->width) {\n        STBRP_ASSERT(cur->x < cur->next->x);\n        cur = cur->next;\n    }\n    STBRP_ASSERT(cur->next == 0);\n\n    {\n        int count = 0;\n        cur = context->active_head;\n        while (cur) {\n            cur = cur->next;\n            ++count;\n        }\n        cur = context->free_head;\n        while (cur) {\n            cur = cur->next;\n            ++count;\n        }\n        STBRP_ASSERT(count == context->num_nodes + 2);\n    }\n#endif\n\n    return res;\n}\n\nstatic int STBRP__CDECL rect_height_compare(const void* a, const void* b)\n{\n    const stbrp_rect* p = (const stbrp_rect*)a;\n    const stbrp_rect* q = (const stbrp_rect*)b;\n    if (p->h > q->h)\n        return -1;\n    if (p->h < q->h)\n        return  1;\n    return (p->w > q->w) ? -1 : (p->w < q->w);\n}\n\nstatic int STBRP__CDECL rect_original_order(const void* a, const void* b)\n{\n    const stbrp_rect* p = (const stbrp_rect*)a;\n    const stbrp_rect* q = (const stbrp_rect*)b;\n    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\n}\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context* context, stbrp_rect* rects, int num_rects)\n{\n    int i, all_rects_packed = 1;\n\n    // we use the 'was_packed' field internally to allow sorting/unsorting\n    for (i = 0; i < num_rects; ++i) {\n        rects[i].was_packed = i;\n    }\n\n    // sort according to heuristic\n    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\n\n    for (i = 0; i < num_rects; ++i) {\n        if (rects[i].w == 0 || rects[i].h == 0) {\n            rects[i].x = rects[i].y = 0;  // empty rect needs no space\n        }\n        else {\n            stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\n            if (fr.prev_link) {\n                rects[i].x = (stbrp_coord)fr.x;\n                rects[i].y = (stbrp_coord)fr.y;\n            }\n            else {\n                rects[i].x = rects[i].y = STBRP__MAXVAL;\n            }\n        }\n    }\n\n    // unsort\n    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\n\n    // set was_packed flags and all_rects_packed status\n    for (i = 0; i < num_rects; ++i) {\n        rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\n        if (!rects[i].was_packed)\n            all_rects_packed = 0;\n    }\n\n    // return the all_rects_packed status\n    return all_rects_packed;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#ifndef _H_MATH_\n#define _H_MATH_\n\n#ifdef __cplusplus\n#define c_func extern \"C\"\n#else\n#define c_func \n#endif\n\n#define MATH_EPSILON 0.0001f\n#define MATH_DEG2RAD 0.0174533f\n#define MATH_RAD2DEG 57.2958f\n\n#define MathPI 3.14159265358979323846f\n#define MATH_PI 3.14159265358979323846f\n\nc_func float  MathRound(float x);\nc_func float  MathCeil(float x);\nc_func float  MathFloor(float x);\nc_func float  MathSin(float x);\nc_func float  MathCos(float x);\nc_func float  MathACos(float x);\nc_func float  MathTan(float x);\nc_func float  MathSqrt(float x);\nc_func float  MathExp(float x);\nc_func float  MathLog(float x);\nc_func float  MathPow(float x, float y);\nc_func double MathLdexp(double x, int exp);\nc_func float  MathRandom();\nc_func float  MathAtan2(float y, float x);\n\ninline float Math01(float v) {\n\tif (v < 0.0f) {\n\t\treturn 0.0f;\n\t}\n\tif (v > 1.0f) {\n\t\treturn 1.0f;\n\t}\n\treturn v;\n}\n\ninline float MathRadToDeg(float rad) {\n    return rad * 57.2958f;\n}\n\ninline float MathDegToRad(float deg) {\n    return deg * 0.0174533f;\n}\n\ninline float MathTrunc(float d) { \n    if (d > 0) { // Floor\n        return MathFloor(d);\n    }\n    // else { // Ceil\n    return MathCeil(d);\n}\n\ninline float MathFmod(float x, float y) {\n  return x - MathTrunc(x / y) * y;\n}\n\ninline float MathAbsF(float f) {\n    if (f < 0.0f) {\n        return -f;\n    }\n    return f;\n}\n\ninline int MathAbsI(int f) {\n    if (f < 0) {\n        return -f;\n    }\n    return f;\n}\n\ninline float MathMaxF(float a, float b) {\n\tif (b > a) {\n\t\treturn b;\n\t}\n\treturn a;\n}\n\ninline float MathMaxI(int a, int b) {\n\tif (b > a) {\n\t\treturn b;\n\t}\n\treturn a;\n}\n\ninline float MathMinF(float a, float b) {\n\tif (b < a) {\n\t\treturn b;\n\t}\n\treturn a;\n}\n\ninline float MathMinI(int a, int b) {\n\tif (b < a) {\n\t\treturn b;\n\t}\n\treturn a;\n}\n\ninline float MathLerpF(float a, float b, float t) {\n\treturn a + (b - a) * t;\n}\n\ninline char MathIsSpace(unsigned char c) {\n\tif (c == (unsigned char)(' ') ||\n\t\tc == (unsigned char)('\\f') ||\n\t\tc == (unsigned char)('\\n') ||\n\t\tc == (unsigned char)('\\r') ||\n\t\tc == (unsigned char)('\\t') ||\n\t\tc == (unsigned char)('\\v'))\n\t\treturn 1;\n\treturn 0;\n}\n\ninline long MathAToI(const char* s) {\n\tlong rv = 0;\n\tchar sign = 0;\n\n\t/* skip till we find either a digit or '+' or '-' */\n\twhile (*s) {\n\t\tif (*s <= '9' && *s >= '0')\n\t\t\tbreak;\n\t\tif (*s == '-' || *s == '+')\n\t\t\tbreak;\n\t\ts++;\n\t}\n\n\tsign = (*s == '-');\n\tif (*s == '-' || *s == '+') s++;\n\n\twhile (*s && *s >= '0' && *s <= '9') {\n\t\trv = (rv * 10) + (*s - '0');\n\t\ts++;\n\t}\n\n\treturn (sign ? -rv : rv);\n}\n\n// atof: https://github.com/darconeous/sdcc/blob/master/device/lib/pic16/libc/stdlib/atof.c\ninline float MathAToF(const char* s) {\n\tfloat value, fraction;\n\tchar iexp;\n\tchar sign;\n\n\t//Skip leading blanks\n\twhile (MathIsSpace(*s)) s++;\n\n\t//Get the sign\n\tif (*s == '-')\n\t{\n\t\tsign = 1;\n\t\ts++;\n\t}\n\telse\n\t{\n\t\tsign = 0;\n\t\tif (*s == '+') s++;\n\t}\n\n\t//Get the integer part\n\tfor (value = 0.0; (unsigned char)(*s) >= '0' && (unsigned char)(*s) <= '9'; s++)\n\t{\n\t\tvalue = 10.0 * value + (*s - '0');\n\t}\n\n\t//Get the fraction\n\tif (*s == '.')\n\t{\n\t\ts++;\n\t\tfor (fraction = 0.1; (unsigned char)(*s) >= '0' && (unsigned char)(*s) <= '9'; s++)\n\t\t{\n\t\t\tvalue += (*s - '0') * fraction;\n\t\t\tfraction *= 0.1;\n\t\t}\n\t}\n\n\t//Finally, the exponent (not very efficient, but enough for now*/\n\tif (*s == 'E' || *s == 'e')\n\t{\n\t\ts++;\n\t\tiexp = (char)MathAToI(s);\n\t\t{\n\t\t\twhile (iexp != 0)\n\t\t\t{\n\t\t\t\tif (iexp < 0)\n\t\t\t\t{\n\t\t\t\t\tvalue *= 0.1;\n\t\t\t\t\tiexp++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvalue *= 10.0;\n\t\t\t\t\tiexp--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sign) value *= -1.0;\n\treturn (value);\n}\n\n#endif","/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb\n                                  no warranty implied; use at your own risk\n\n   Do this:\n      #define STB_IMAGE_IMPLEMENTATION\n   before you include this file in *one* C or C++ file to create the implementation.\n\n   // i.e. it should look like this:\n   #include ...\n   #include ...\n   #include ...\n   #define STB_IMAGE_IMPLEMENTATION\n   #include \"stb_image.h\"\n\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\n\n\n   QUICK NOTES:\n      Primarily of interest to game developers and other people who can\n          avoid problematic images and only need the trivial interface\n\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\n      PNG 1/2/4/8/16-bit-per-channel\n\n      TGA (not sure what subset, if a subset)\n      BMP non-1bpp, non-RLE\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\n\n      GIF (*comp always reports as 4-channel)\n      HDR (radiance rgbE format)\n      PIC (Softimage PIC)\n      PNM (PPM and PGM binary only)\n\n      Animated GIF still needs a proper API, but here's one way to do it:\n          http://gist.github.com/urraka/685d9a6340b26b830d49\n\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\n      - decode from arbitrary I/O callbacks\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\n\n   Full documentation under \"DOCUMENTATION\" below.\n\n\nLICENSE\n\n  See end of file for license information.\n\nRECENT REVISION HISTORY:\n\n      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes\n      2.26  (2020-07-13) many minor fixes\n      2.25  (2020-02-02) fix warnings\n      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically\n      2.23  (2019-08-11) fix clang static analysis warning\n      2.22  (2019-03-04) gif fixes, fix warnings\n      2.21  (2019-02-25) fix typo in comment\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\n                         RGB-format JPEG; remove white matting in PSD;\n                         allocate large structures on the stack;\n                         correct channel count for PNG & BMP\n      2.10  (2016-01-22) avoid warning introduced in 2.09\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\n\n   See end of file for full revision history.\n\n\n ============================    Contributors    =========================\n\n Image formats                          Extensions, features\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\n    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)\n                                           socks-the-fox (16-bit PNG)\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\n Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)\n    Fabian \"ryg\" Giesen                    Anael Seghezzi (is-16-bit query)\n    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)\n    John-Mark Allen\n    Carmelo J Fdez-Aguera\n\n Bug & warning fixes\n    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski\n    Phil Jordan                                Dave Moore           Roy Eltham\n    Hayaki Saito            Nathan Reed        Won Chun\n    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community\n    Thomas Ruf              Ronny Chevalier                         github:rlyeh\n    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou\n    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk\n    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar\n    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex\n    Cass Everitt            Ryamond Barbiero                        github:grim210\n    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw\n    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus\n    Josh Tobin                                 Matthew Gregan       github:poppolopoppo\n    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji\n    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007\n                            Brad Weinberger    Matvey Cherevko      github:mosra\n    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]\n    Ryan C. Gordon          [reserved]                              [reserved]\n                     DO NOT ADD YOUR NAME HERE\n\n                     Jacko Dirks\n\n  To add your name to the credits, pick a random blank space in the middle and fill it.\n  80% of merge conflicts on stb PRs are due to people adding their name at the end\n  of the credits.\n*/\n\n#ifndef STBI_INCLUDE_STB_IMAGE_H\n#define STBI_INCLUDE_STB_IMAGE_H\n\n// DOCUMENTATION\n//\n// Limitations:\n//    - no 12-bit-per-channel JPEG\n//    - no JPEGs with arithmetic coding\n//    - GIF always returns *comp=4\n//\n// Basic usage (see HDR discussion below for HDR usage):\n//    int x,y,n;\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\n//    // ... process data if not NULL ...\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\n//    // ... but 'n' will always be the number that it would have been if you said 0\n//    stbi_image_free(data)\n//\n// Standard parameters:\n//    int *x                 -- outputs image width in pixels\n//    int *y                 -- outputs image height in pixels\n//    int *channels_in_file  -- outputs # of image components in image file\n//    int desired_channels   -- if non-zero, # of image components requested in result\n//\n// The return value from an image loader is an 'unsigned char *' which points\n// to the pixel data, or NULL on an allocation failure or if the image is\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\n// with each pixel consisting of N interleaved 8-bit components; the first\n// pixel pointed to is top-left-most in the image. There is no padding between\n// image scanlines or between pixels, regardless of format. The number of\n// components N is 'desired_channels' if desired_channels is non-zero, or\n// *channels_in_file otherwise. If desired_channels is non-zero,\n// *channels_in_file has the number of components that _would_ have been\n// output otherwise. E.g. if you set desired_channels to 4, you will always\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\n// opaque because e.g. there were only 3 channels in the source image.\n//\n// An output image with N components has the following components interleaved\n// in this order in each pixel:\n//\n//     N=#comp     components\n//       1           grey\n//       2           grey, alpha\n//       3           red, green, blue\n//       4           red, green, blue, alpha\n//\n// If image loading fails for any reason, the return value will be NULL,\n// and *x, *y, *channels_in_file will be unchanged. The function\n// stbi_failure_reason() can be queried for an extremely brief, end-user\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\n// more user-friendly ones.\n//\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\n//\n// To query the width, height and component count of an image without having to\n// decode the full file, you can use the stbi_info family of functions:\n//\n//   int x,y,n,ok;\n//   ok = stbi_info(filename, &x, &y, &n);\n//   // returns ok=1 and sets x, y, n if image is a supported format,\n//   // 0 otherwise.\n//\n// Note that stb_image pervasively uses ints in its public API for sizes,\n// including sizes of memory buffers. This is now part of the API and thus\n// hard to change without causing breakage. As a result, the various image\n// loaders all have certain limits on image size; these differ somewhat\n// by format but generally boil down to either just under 2GB or just under\n// 1GB. When the decoded image would be larger than this, stb_image decoding\n// will fail.\n//\n// Additionally, stb_image will reject image files that have any of their\n// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,\n// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,\n// the only way to have an image with such dimensions load correctly\n// is for it to have a rather extreme aspect ratio. Either way, the\n// assumption here is that such larger images are likely to be malformed\n// or malicious. If you do need to load an image with individual dimensions\n// larger than that, and it still fits in the overall size limit, you can\n// #define STBI_MAX_DIMENSIONS on your own to be something larger.\n//\n// ===========================================================================\n//\n// UNICODE:\n//\n//   If compiling for Windows and you wish to use Unicode filenames, compile\n//   with\n//       #define STBI_WINDOWS_UTF8\n//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert\n//   Windows wchar_t filenames to utf8.\n//\n// ===========================================================================\n//\n// Philosophy\n//\n// stb libraries are designed with the following priorities:\n//\n//    1. easy to use\n//    2. easy to maintain\n//    3. good performance\n//\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\n// and for best performance I may provide less-easy-to-use APIs that give higher\n// performance, in addition to the easy-to-use ones. Nevertheless, it's important\n// to keep in mind that from the standpoint of you, a client of this library,\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\n//\n// Some secondary priorities arise directly from the first two, some of which\n// provide more explicit reasons why performance can't be emphasized.\n//\n//    - Portable (\"ease of use\")\n//    - Small source code footprint (\"easy to maintain\")\n//    - No dependencies (\"ease of use\")\n//\n// ===========================================================================\n//\n// I/O callbacks\n//\n// I/O callbacks allow you to read from arbitrary sources, like packaged\n// files or some other source. Data read from callbacks are processed\n// through a small internal buffer (currently 128 bytes) to try to reduce\n// overhead.\n//\n// The three functions you must define are \"read\" (reads some bytes of data),\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\n//\n// ===========================================================================\n//\n// SIMD support\n//\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\n// supported by the compiler. For ARM Neon support, you must explicitly\n// request it.\n//\n// (The old do-it-yourself SIMD API is no longer supported in the current\n// code.)\n//\n// On x86, SSE2 will automatically be used when available based on a run-time\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\n// the typical path is to have separate builds for NEON and non-NEON devices\n// (at least this is true for iOS and Android). Therefore, the NEON support is\n// toggled by a build flag: define STBI_NEON to get NEON loops.\n//\n// If for some reason you do not want to use any of SIMD code, or if\n// you have issues compiling it, you can disable it entirely by\n// defining STBI_NO_SIMD.\n//\n// ===========================================================================\n//\n// HDR image support   (disable by defining STBI_NO_HDR)\n//\n// stb_image supports loading HDR images in general, and currently the Radiance\n// .HDR file format specifically. You can still load any file through the existing\n// interface; if you attempt to load an HDR file, it will be automatically remapped\n// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\n// both of these constants can be reconfigured through this interface:\n//\n//     stbi_hdr_to_ldr_gamma(2.2f);\n//     stbi_hdr_to_ldr_scale(1.0f);\n//\n// (note, do not use _inverse_ constants; stbi_image will invert them\n// appropriately).\n//\n// Additionally, there is a new, parallel interface for loading files as\n// (linear) floats to preserve the full dynamic range:\n//\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\n//\n// If you load LDR images through this interface, those images will\n// be promoted to floating point values, run through the inverse of\n// constants corresponding to the above:\n//\n//     stbi_ldr_to_hdr_scale(1.0f);\n//     stbi_ldr_to_hdr_gamma(2.2f);\n//\n// Finally, given a filename (or an open file or memory block--see header\n// file for details) containing image data, you can query for the \"most\n// appropriate\" interface to use (that is, whether the image is HDR or\n// not), using:\n//\n//     stbi_is_hdr(char *filename);\n//\n// ===========================================================================\n//\n// iPhone PNG support:\n//\n// We optionally support converting iPhone-formatted PNGs (which store\n// premultiplied BGRA) back to RGB, even though they're internally encoded\n// differently. To enable this conversion, call\n// stbi_convert_iphone_png_to_rgb(1).\n//\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\n// says there's premultiplied data (currently only happens in iPhone images,\n// and only if iPhone convert-to-rgb processing is on).\n//\n// ===========================================================================\n//\n// ADDITIONAL CONFIGURATION\n//\n//  - You can suppress implementation of any of the decoders to reduce\n//    your code footprint by #defining one or more of the following\n//    symbols before creating the implementation.\n//\n//        STBI_NO_JPEG\n//        STBI_NO_PNG\n//        STBI_NO_BMP\n//        STBI_NO_PSD\n//        STBI_NO_TGA\n//        STBI_NO_GIF\n//        STBI_NO_HDR\n//        STBI_NO_PIC\n//        STBI_NO_PNM   (.ppm and .pgm)\n//\n//  - You can request *only* certain decoders and suppress all other ones\n//    (this will be more forward-compatible, as addition of new decoders\n//    doesn't require you to disable them explicitly):\n//\n//        STBI_ONLY_JPEG\n//        STBI_ONLY_PNG\n//        STBI_ONLY_BMP\n//        STBI_ONLY_PSD\n//        STBI_ONLY_TGA\n//        STBI_ONLY_GIF\n//        STBI_ONLY_HDR\n//        STBI_ONLY_PIC\n//        STBI_ONLY_PNM   (.ppm and .pgm)\n//\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\n//\n//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater\n//    than that size (in either width or height) without further processing.\n//    This is to let programs in the wild set an upper bound to prevent\n//    denial-of-service attacks on untrusted data, as one could generate a\n//    valid image of gigantic dimensions and force stb_image to allocate a\n//    huge block of memory and spend disproportionate time decoding it. By\n//    default this is set to (1 << 24), which is 16777216, but that's still\n//    very big.\n\n#define STBI_NO_STDIO\n#define STBI_NO_PSD\n#define STBI_NO_GIF\n#define STBI_NO_HDR\n#define STBI_NO_PIC\n#define STBI_NO_PNM\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif // STBI_NO_STDIO\n\n#define STBI_VERSION 1\n\nenum\n{\n   STBI_default = 0, // only used for desired_channels\n\n   STBI_grey       = 1,\n   STBI_grey_alpha = 2,\n   STBI_rgb        = 3,\n   STBI_rgb_alpha  = 4\n};\n\n//#include <stdlib.h>\ntypedef unsigned char stbi_uc;\ntypedef unsigned short stbi_us;\n\n#ifndef STBIDEF\n#ifdef STB_IMAGE_STATIC\n#define STBIDEF static\n#else\n#define STBIDEF extern\n#endif\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PRIMARY API - works on images of any type\n//\n\n//\n// load image by filename, open file, or memory buffer\n//\n\ntypedef struct\n{\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\n} stbi_io_callbacks;\n\n////////////////////////////////////\n//\n// 8-bits-per-channel interface\n//\n\nSTBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n// for stbi_load_from_file, file pointer is left pointing immediately after image\n#endif\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\n#endif\n\n#ifdef STBI_WINDOWS_UTF8\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, unsigned int bufferlen, const wchar_t* input);\n#endif\n\n////////////////////////////////////\n//\n// 16-bits-per-channel interface\n//\n\nSTBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\nSTBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n#endif\n\n////////////////////////////////////\n//\n// float-per-channel interface\n//\n#ifndef STBI_NO_LINEAR\n   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);\n\n   #ifndef STBI_NO_STDIO\n   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\n   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\n   #endif\n#endif\n\n#ifndef STBI_NO_HDR\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_LINEAR\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\n#endif // STBI_NO_LINEAR\n\n// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename);\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\n#endif // STBI_NO_STDIO\n\n\n// get a VERY brief reason for failure\n// on most compilers (and ALL modern mainstream compilers) this is threadsafe\nSTBIDEF const char *stbi_failure_reason  (void);\n\n// free the loaded image -- this is just free()\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\n\n// get image dimensions & components without fully decoding\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);\nSTBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);\nSTBIDEF int      stbi_is_16_bit          (char const *filename);\nSTBIDEF int      stbi_is_16_bit_from_file(FILE *f);\n#endif\n\n\n\n// for image formats that explicitly notate that they have premultiplied alpha,\n// we just return the colors as stored in the file. set this flag to force\n// unpremultiplication. results are undefined if the unpremultiply overflow.\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\n\n// indicate whether we should process iphone images back to canonical format,\n// or just pass them through \"as-is\"\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\n\n// flip the image vertically, so the first pixel in the output array is the bottom left\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\n\n// as above, but only applies to images loaded on the thread that calls the function\n// this function is only available if your compiler supports thread-local variables;\n// calling it will fail to link if your compiler doesn't\nSTBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);\n\n// ZLIB client - used by PNG, available for other purposes\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\n\n//\n//\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBI_INCLUDE_STB_IMAGE_H\n\n#ifdef STB_IMAGE_IMPLEMENTATION\n\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\n  || defined(STBI_ONLY_ZLIB)\n   #ifndef STBI_ONLY_JPEG\n   #define STBI_NO_JPEG\n   #endif\n   #ifndef STBI_ONLY_PNG\n   #define STBI_NO_PNG\n   #endif\n   #ifndef STBI_ONLY_BMP\n   #define STBI_NO_BMP\n   #endif\n   #ifndef STBI_ONLY_PSD\n   #define STBI_NO_PSD\n   #endif\n   #ifndef STBI_ONLY_TGA\n   #define STBI_NO_TGA\n   #endif\n   #ifndef STBI_ONLY_GIF\n   #define STBI_NO_GIF\n   #endif\n   #ifndef STBI_ONLY_HDR\n   #define STBI_NO_HDR\n   #endif\n   #ifndef STBI_ONLY_PIC\n   #define STBI_NO_PIC\n   #endif\n   #ifndef STBI_ONLY_PNM\n   #define STBI_NO_PNM\n   #endif\n#endif\n\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\n#define STBI_NO_ZLIB\n#endif\n\n\n//#include <stdarg.h>\n//#include <stddef.h> // ptrdiff_t on osx\n//#include <stdlib.h>\n//#include <string.h>\n//#include <limits.h>\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\n//#include <math.h>  // ldexp, MathPow\n#endif\n\n#ifndef STBI_NO_STDIO\n//#include <stdio.h>\n#endif\n\n#ifndef STBI_ASSERT\n//#include <assert.h>\n#define STBI_ASSERT(x) assert(x)\n#endif\n\n#define STBI_EXTERN\n\n\n#ifndef _MSC_VER\n   #ifdef __cplusplus\n   #define stbi_inline inline\n   #else\n   #define stbi_inline\n   #endif\n#else\n   #define stbi_inline __forceinline\n#endif\n\n#ifndef STBI_NO_THREAD_LOCALS\n   #if defined(__cplusplus) &&  __cplusplus >= 201103L\n      #define STBI_THREAD_LOCAL       thread_local\n   #elif defined(__GNUC__) && __GNUC__ < 5\n      #define STBI_THREAD_LOCAL       __thread\n   #elif defined(_MSC_VER)\n      #define STBI_THREAD_LOCAL       __declspec(thread)\n   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)\n      #define STBI_THREAD_LOCAL       _Thread_local\n   #endif\n\n   #ifndef STBI_THREAD_LOCAL\n      #if defined(__GNUC__)\n        #define STBI_THREAD_LOCAL       __thread\n      #endif\n   #endif\n#endif\n\n\ntypedef u16 stbi__uint16;\ntypedef i16  stbi__int16;\ntypedef u32 stbi__uint32;\ntypedef i32  stbi__int32;\n\n// should produce compiler error if size is wrong\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\n\n#ifdef _MSC_VER\n#define STBI_NOTUSED(v)  (void)(v)\n#else\n#define STBI_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef _MSC_VER\n#define STBI_HAS_LROTL\n#endif\n\n#ifdef STBI_HAS_LROTL\n   #define stbi_lrot(x,y)  _lrotl(x,y)\n#else\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))\n#endif\n\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\n// ok\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\n// ok\n#else\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\n#endif\n\n#ifndef STBI_MALLOC\n#define STBI_MALLOC(sz)           malloc(sz)\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\n#define STBI_FREE(p)              free(p)\n#endif\n\n#ifndef STBI_REALLOC_SIZED\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\n#endif\n\n// x86/x64 detection\n#if defined(__x86_64__) || defined(_M_X64)\n#define STBI__X64_TARGET\n#elif defined(__i386) || defined(_M_IX86)\n#define STBI__X86_TARGET\n#endif\n\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\n// but previous attempts to provide the SSE2 functions with runtime\n// detection caused numerous issues. The way architecture extensions are\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\n// New behavior: if compiled with -msse2, we use SSE2 without any\n// detection; if not, we don't use it at all.\n#define STBI_NO_SIMD\n#endif\n\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\n//\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\n// simultaneously enabling \"-mstackrealign\".\n//\n// See https://github.com/nothings/stb/issues/81 for more information.\n//\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\n#define STBI_NO_SIMD\n#endif\n\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\n#define STBI_SSE2\n#include <emmintrin.h>\n\n#ifdef _MSC_VER\n\n#if _MSC_VER >= 1400  // not VC6\n#include <intrin.h> // __cpuid\nstatic int stbi__cpuid3(void)\n{\n   int info[4];\n   __cpuid(info,1);\n   return info[3];\n}\n#else\nstatic int stbi__cpuid3(void)\n{\n   int res;\n   __asm {\n      mov  eax,1\n      cpuid\n      mov  res,edx\n   }\n   return res;\n}\n#endif\n\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   int info3 = stbi__cpuid3();\n   return ((info3 >> 26) & 1) != 0;\n}\n#endif\n\n#else // assume GCC-style if not VC++\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n\n#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)\nstatic int stbi__sse2_available(void)\n{\n   // If we're even attempting to compile this on GCC/Clang, that means\n   // -msse2 is on, which means the compiler is allowed to use SSE2\n   // instructions at will, and so are we.\n   return 1;\n}\n#endif\n\n#endif\n#endif\n\n// ARM NEON\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\n#undef STBI_NEON\n#endif\n\n#ifdef STBI_NEON\n#include <arm_neon.h>\n#ifdef _MSC_VER\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\n#else\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\n#endif\n#endif\n\n#ifndef STBI_SIMD_ALIGN\n#define STBI_SIMD_ALIGN(type, name) type name\n#endif\n\n#ifndef STBI_MAX_DIMENSIONS\n#define STBI_MAX_DIMENSIONS (1 << 24)\n#endif\n\n///////////////////////////////////////////////\n//\n//  stbi__context struct and start_xxx functions\n\n// stbi__context structure is our basic context used by all images, so it\n// contains all the IO context, plus some basic image information\ntypedef struct\n{\n   stbi__uint32 img_x, img_y;\n   int img_n, img_out_n;\n\n   stbi_io_callbacks io;\n   void *io_user_data;\n\n   int read_from_callbacks;\n   int buflen;\n   stbi_uc buffer_start[128];\n   int callback_already_read;\n\n   stbi_uc *img_buffer, *img_buffer_end;\n   stbi_uc *img_buffer_original, *img_buffer_original_end;\n} stbi__context;\n\n\nstatic void stbi__refill_buffer(stbi__context *s);\n\n// initialize a memory-decode context\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\n{\n   s->io.read = NULL;\n   s->read_from_callbacks = 0;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\n   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;\n}\n\n// initialize a callback-based context\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\n{\n   s->io = *c;\n   s->io_user_data = user;\n   s->buflen = sizeof(s->buffer_start);\n   s->read_from_callbacks = 1;\n   s->callback_already_read = 0;\n   s->img_buffer = s->img_buffer_original = s->buffer_start;\n   stbi__refill_buffer(s);\n   s->img_buffer_original_end = s->img_buffer_end;\n}\n\n#ifndef STBI_NO_STDIO\n\nstatic int stbi__stdio_read(void *user, char *data, int size)\n{\n   return (int) fread(data,1,size,(FILE*) user);\n}\n\nstatic void stbi__stdio_skip(void *user, int n)\n{\n   int ch;\n   fseek((FILE*) user, n, SEEK_CUR);\n   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */\n   if (ch != EOF) {\n      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */\n   }\n}\n\nstatic int stbi__stdio_eof(void *user)\n{\n   return feof((FILE*) user) || ferror((FILE *) user);\n}\n\nstatic stbi_io_callbacks stbi__stdio_callbacks =\n{\n   stbi__stdio_read,\n   stbi__stdio_skip,\n   stbi__stdio_eof,\n};\n\nstatic void stbi__start_file(stbi__context *s, FILE *f)\n{\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\n}\n\n//static void stop_file(stbi__context *s) { }\n\n#endif // !STBI_NO_STDIO\n\nstatic void stbi__rewind(stbi__context *s)\n{\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\n   // but we just rewind to the beginning of the initial buffer, because\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\n   s->img_buffer = s->img_buffer_original;\n   s->img_buffer_end = s->img_buffer_original_end;\n}\n\nenum\n{\n   STBI_ORDER_RGB,\n   STBI_ORDER_BGR\n};\n\ntypedef struct\n{\n   int bits_per_channel;\n   int num_channels;\n   int channel_order;\n} stbi__result_info;\n\n#ifndef STBI_NO_JPEG\nstatic int      stbi__jpeg_test(stbi__context *s);\nstatic void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNG\nstatic int      stbi__png_test(stbi__context *s);\nstatic void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__png_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_BMP\nstatic int      stbi__bmp_test(stbi__context *s);\nstatic void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_TGA\nstatic int      stbi__tga_test(stbi__context *s);\nstatic void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int      stbi__psd_test(stbi__context *s);\nstatic void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);\nstatic int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__psd_is16(stbi__context *s);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic int      stbi__hdr_test(stbi__context *s);\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int      stbi__pic_test(stbi__context *s);\nstatic void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_GIF\nstatic int      stbi__gif_test(stbi__context *s);\nstatic void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\n#endif\n\n#ifndef STBI_NO_PNM\nstatic int      stbi__pnm_test(stbi__context *s);\nstatic void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__pnm_is16(stbi__context *s);\n#endif\n\nstatic\n#ifdef STBI_THREAD_LOCAL\nSTBI_THREAD_LOCAL\n#endif\nconst char *stbi__g_failure_reason;\n\nSTBIDEF const char *stbi_failure_reason(void)\n{\n   return stbi__g_failure_reason;\n}\n\n#ifndef STBI_NO_FAILURE_STRINGS\nstatic int stbi__err(const char *str)\n{\n   stbi__g_failure_reason = str;\n   return 0;\n}\n#endif\n\nstatic void *stbi__malloc(unsigned int size)\n{\n    return STBI_MALLOC(size);\n}\n\n// stb_image uses ints pervasively, including for offset calculations.\n// therefore the largest decoded image size we can support with the\n// current code, even on 64-bit targets, is INT_MAX. this is not a\n// significant limitation for the intended use case.\n//\n// we do, however, need to make sure our size calculations don't\n// overflow. hence a few helper functions for size calculations that\n// multiply integers together, making sure that they're non-negative\n// and no overflow occurs.\n\n// return 1 if the sum is valid, 0 on overflow.\n// negative terms are considered invalid.\nstatic int stbi__addsizes_valid(int a, int b)\n{\n   if (b < 0) return 0;\n   // now 0 <= b <= INT_MAX, hence also\n   // 0 <= INT_MAX - b <= INTMAX.\n   // And \"a + b <= INT_MAX\" (which might overflow) is the\n   // same as a <= INT_MAX - b (no overflow)\n   return a <= STBI_INT_MAX - b;\n}\n\n// returns 1 if the product is valid, 0 on overflow.\n// negative factors are considered invalid.\nstatic int stbi__mul2sizes_valid(int a, int b)\n{\n   if (a < 0 || b < 0) return 0;\n   if (b == 0) return 1; // mul-by-0 is always safe\n   // portable way to check for no overflows in a*b\n   return a <= STBI_INT_MAX/b;\n}\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);\n}\n#endif\n\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__addsizes_valid(a*b*c, add);\n}\n\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\n{\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\n      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);\n}\n#endif\n\n#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)\n// mallocs with size overflow checking\nstatic void *stbi__malloc_mad2(int a, int b, int add)\n{\n   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\n   return stbi__malloc(a*b + add);\n}\n#endif\n\nstatic void *stbi__malloc_mad3(int a, int b, int c, int add)\n{\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\n   return stbi__malloc(a*b*c + add);\n}\n\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)\nstatic void *stbi__malloc_mad4(int a, int b, int c, int d, int add)\n{\n   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\n   return stbi__malloc(a*b*c*d + add);\n}\n#endif\n\n// stbi__err - error\n// stbi__errpf - error returning pointer to float\n// stbi__errpuc - error returning pointer to unsigned char\n\n#ifdef STBI_NO_FAILURE_STRINGS\n   #define stbi__err(x,y)  0\n#elif defined(STBI_FAILURE_USERMSG)\n   #define stbi__err(x,y)  stbi__err(y)\n#else\n   #define stbi__err(x,y)  stbi__err(x)\n#endif\n\n#define stbi__errpf(x,y)   ((float *)(unsigned int) (stbi__err(x,y)?NULL:NULL))\n#define stbi__errpuc(x,y)  ((unsigned char *)(unsigned int) (stbi__err(x,y)?NULL:NULL))\n\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\n{\n   STBI_FREE(retval_from_stbi_load);\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\n#endif\n\n#ifndef STBI_NO_HDR\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\n#endif\n\nstatic int stbi__vertically_flip_on_load_global = 0;\n\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;\n\nSTBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)\n{\n   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;\n   stbi__vertically_flip_on_load_set = 1;\n}\n\n#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \\\n                                         ? stbi__vertically_flip_on_load_local  \\\n                                         : stbi__vertically_flip_on_load_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   MemSet(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\n   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\n   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\n   ri->num_channels = 0;\n\n   // test the formats with a very explicit header first (at least a FOURCC\n   // or distinctive magic number first)\n   #ifndef STBI_NO_PNG\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);\n   #else\n   STBI_NOTUSED(bpc);\n   #endif\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   // then the formats that can end up attempting to load with just 1 or 2\n   // bytes matching expectations; these are prone to false positives, so\n   // try them later\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);\n   #endif\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\n   }\n   #endif\n\n   #ifndef STBI_NO_TGA\n   // test tga last because it's a crappy test!\n   if (stbi__tga_test(s))\n      return stbi__tga_load(s,x,y,comp,req_comp, ri);\n   #endif\n\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi_uc *reduced;\n\n   reduced = (stbi_uc *) stbi__malloc(img_len);\n   if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\n\n   STBI_FREE(orig);\n   return reduced;\n}\n\nstatic stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)\n{\n   int i;\n   int img_len = w * h * channels;\n   stbi__uint16 *enlarged;\n\n   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);\n   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   for (i = 0; i < img_len; ++i)\n      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\n\n   STBI_FREE(orig);\n   return enlarged;\n}\n\nstatic void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)\n{\n   int row;\n   unsigned int bytes_per_row = (unsigned int)w * bytes_per_pixel;\n   stbi_uc temp[2048];\n   stbi_uc *bytes = (stbi_uc *)image;\n\n   for (row = 0; row < (h>>1); row++) {\n      stbi_uc *row0 = bytes + row*bytes_per_row;\n      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;\n      // swap row0 with row1\n      unsigned int bytes_left = bytes_per_row;\n      while (bytes_left) {\n         unsigned int bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\n         MemCopy(temp, row0, bytes_copy);\n         MemCopy(row0, row1, bytes_copy);\n         MemCopy(row1, temp, bytes_copy);\n         row0 += bytes_copy;\n         row1 += bytes_copy;\n         bytes_left -= bytes_copy;\n      }\n   }\n}\n\n#ifndef STBI_NO_GIF\nstatic void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)\n{\n   int slice;\n   int slice_size = w * h * bytes_per_pixel;\n\n   stbi_uc *bytes = (stbi_uc *)image;\n   for (slice = 0; slice < z; ++slice) {\n      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);\n      bytes += slice_size;\n   }\n}\n#endif\n\nstatic unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 8) {\n      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 8;\n   }\n\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\n   }\n\n   return (unsigned char *) result;\n}\n\nstatic stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__result_info ri;\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\n\n   if (result == NULL)\n      return NULL;\n\n   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.\n   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);\n\n   if (ri.bits_per_channel != 16) {\n      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\n      ri.bits_per_channel = 16;\n   }\n\n\n   if (stbi__vertically_flip_on_load) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\n   }\n\n   return (stbi__uint16 *) result;\n}\n\n#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)\nstatic void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)\n{\n   if (stbi__vertically_flip_on_load && result != NULL) {\n      int channels = req_comp ? req_comp : *comp;\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\n   }\n}\n#endif\n\n#ifndef STBI_NO_STDIO\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);\nSTBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);\n#endif\n\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\nSTBIDEF int stbi_convert_wchar_to_utf8(char *buffer, unsigned int bufferlen, const wchar_t* input)\n{\n\treturn WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);\n}\n#endif\n\nstatic FILE *stbi__fopen(char const *filename, char const *mode)\n{\n   FILE *f;\n#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)\n   wchar_t wMode[64];\n   wchar_t wFilename[1024];\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))\n      return 0;\n\n\tif (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))\n      return 0;\n\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n\tif (0 != _wfopen_s(&f, wFilename, wMode))\n\t\tf = 0;\n#else\n   f = _wfopen(wFilename, wMode);\n#endif\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != fopen_s(&f, filename, mode))\n      f=0;\n#else\n   f = fopen(filename, mode);\n#endif\n   return f;\n}\n\n\nSTBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   unsigned char *result;\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__uint16 *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n\nSTBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   stbi__uint16 *result;\n   if (!f) return (stbi_us *) stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file_16(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\n\n#endif //!STBI_NO_STDIO\n\nSTBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_GIF\nSTBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n\n   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);\n   if (stbi__vertically_flip_on_load) {\n      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );\n   }\n\n   return result;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *data;\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      stbi__result_info ri;\n      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);\n      if (hdr_data)\n         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);\n      return hdr_data;\n   }\n   #endif\n   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\n   if (data)\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nSTBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\nSTBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   float *result;\n   FILE *f = stbi__fopen(filename, \"rb\");\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_file(&s,f);\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\n}\n#endif // !STBI_NO_STDIO\n\n#endif // !STBI_NO_LINEAR\n\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\n// reports false!\n\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   int result=0;\n   if (f) {\n      result = stbi_is_hdr_from_file(f);\n      fclose(f);\n   }\n   return result;\n}\n\nSTBIDEF int stbi_is_hdr_from_file(FILE *f)\n{\n   #ifndef STBI_NO_HDR\n   long pos = ftell(f);\n   int res;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   res = stbi__hdr_test(&s);\n   fseek(f, pos, SEEK_SET);\n   return res;\n   #else\n   STBI_NOTUSED(f);\n   return 0;\n   #endif\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(clbk);\n   STBI_NOTUSED(user);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_LINEAR\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\n\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\n#endif\n\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\n\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Common code used by all image loaders\n//\n\nenum\n{\n   STBI__SCAN_load=0,\n   STBI__SCAN_type,\n   STBI__SCAN_header\n};\n\nstatic void stbi__refill_buffer(stbi__context *s)\n{\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\n   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);\n   if (n == 0) {\n      // at end of file, treat same as if from memory, but need to handle case\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\n      s->read_from_callbacks = 0;\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start+1;\n      *s->img_buffer = 0;\n   } else {\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start + n;\n   }\n}\n\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\n{\n   if (s->img_buffer < s->img_buffer_end)\n      return *s->img_buffer++;\n   if (s->read_from_callbacks) {\n      stbi__refill_buffer(s);\n      return *s->img_buffer++;\n   }\n   return 0;\n}\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstbi_inline static int stbi__at_eof(stbi__context *s)\n{\n   if (s->io.read) {\n      if (!(s->io.eof)(s->io_user_data)) return 0;\n      // if feof() is true, check if buffer = end\n      // special case: we've only got the special 0 character at the end\n      if (s->read_from_callbacks == 0) return 1;\n   }\n\n   return s->img_buffer >= s->img_buffer_end;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic void stbi__skip(stbi__context *s, int n)\n{\n   if (n == 0) return;  // already there!\n   if (n < 0) {\n      s->img_buffer = s->img_buffer_end;\n      return;\n   }\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         s->img_buffer = s->img_buffer_end;\n         (s->io.skip)(s->io_user_data, n - blen);\n         return;\n      }\n   }\n   s->img_buffer += n;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         int res, count;\n\n         MemCopy(buffer, s->img_buffer, blen);\n\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\n         res = (count == (n-blen));\n         s->img_buffer = s->img_buffer_end;\n         return res;\n      }\n   }\n\n   if (s->img_buffer+n <= s->img_buffer_end) {\n      MemCopy(buffer, s->img_buffer, n);\n      s->img_buffer += n;\n      return 1;\n   } else\n      return 0;\n}\n#endif\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic int stbi__get16be(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return (z << 8) + stbi__get8(s);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)\n// nothing\n#else\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16be(s);\n   return (z << 16) + stbi__get16be(s);\n}\n#endif\n\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\n// nothing\n#else\nstatic int stbi__get16le(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return z + (stbi__get8(s) << 8);\n}\n#endif\n\n#ifndef STBI_NO_BMP\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16le(s);\n   z += (stbi__uint32)stbi__get16le(s) << 16;\n   return z;\n}\n#endif\n\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\n\n#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\n//////////////////////////////////////////////////////////////////////////////\n//\n//  generic converter from built-in img_n to req_comp\n//    individual types do this automatically as much as possible (e.g. jpeg\n//    does all cases internally since it needs to colorspace convert anyway,\n//    and it never has alpha, so very few cases ). png can automatically\n//    interleave an alpha=255 channel, but falls back to this for other cases\n//\n//  assume data buffer is malloced, so malloc a new one and free that one\n//  only failure mode is malloc failing\n\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\n{\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)\n// nothing\n#else\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   unsigned char *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      unsigned char *src  = data + j * x * img_n   ;\n      unsigned char *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\n{\n   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n#endif\n\n#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)\n// nothing\n#else\nstatic stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   stbi__uint16 *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);\n   if (good == NULL) {\n      STBI_FREE(data);\n      return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      stbi__uint16 *src  = data + j * x * img_n   ;\n      stbi__uint16 *dest = good + j * x * req_comp;\n\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (STBI__COMBO(img_n, req_comp)) {\n         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;\n         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;\n         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;\n         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;\n         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc(\"unsupported\", \"Unsupported format conversion\");\n      }\n      #undef STBI__CASE\n   }\n\n   STBI_FREE(data);\n   return good;\n}\n#endif\n\n#ifndef STBI_NO_LINEAR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\n{\n   int i,k,n;\n   float *output;\n   if (!data) return NULL;\n   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         output[i*comp + k] = (float) (MathPow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\n      }\n   }\n   if (n < comp) {\n      for (i=0; i < x*y; ++i) {\n         output[i*comp + n] = data[i*comp + n]/255.0f;\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n#ifndef STBI_NO_HDR\n#define stbi__float2int(x)   ((int) (x))\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\n{\n   int i,k,n;\n   stbi_uc *output;\n   if (!data) return NULL;\n   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);\n   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         float z = (float) MathPow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n      if (k < comp) {\n         float z = data[i*comp+k] * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n   }\n   STBI_FREE(data);\n   return output;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  \"baseline\" JPEG/JFIF decoder\n//\n//    simple implementation\n//      - doesn't support delayed output of y-dimension\n//      - simple interface (only one output format: 8-bit interleaved RGB)\n//      - doesn't try to recover corrupt jpegs\n//      - doesn't allow partial loading, loading multiple at once\n//      - still fast on x86 (copying globals into locals doesn't help x86)\n//      - allocates lots of intermediate memory (full size of all components)\n//        - non-interleaved case requires this anyway\n//        - allows good upsampling (see next)\n//    high-quality\n//      - upsampled channels are bilinearly interpolated, even across blocks\n//      - quality integer IDCT derived from IJG's 'slow'\n//    performance\n//      - fast huffman; reasonable integer IDCT\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\n//      - uses a lot of intermediate memory, could cache poorly\n\n#ifndef STBI_NO_JPEG\n\n// huffman decoding acceleration\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\n\ntypedef struct\n{\n   stbi_uc  fast[1 << FAST_BITS];\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\n   stbi__uint16 code[256];\n   stbi_uc  values[256];\n   stbi_uc  size[257];\n   unsigned int maxcode[18];\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\n} stbi__huffman;\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi__huffman huff_dc[4];\n   stbi__huffman huff_ac[4];\n   stbi__uint16 dequant[4][64];\n   stbi__int16 fast_ac[4][1 << FAST_BITS];\n\n// sizes for components, interleaved MCUs\n   int img_h_max, img_v_max;\n   int img_mcu_x, img_mcu_y;\n   int img_mcu_w, img_mcu_h;\n\n// definition of jpeg image component\n   struct\n   {\n      int id;\n      int h,v;\n      int tq;\n      int hd,ha;\n      int dc_pred;\n\n      int x,y,w2,h2;\n      stbi_uc *data;\n      void *raw_data, *raw_coeff;\n      stbi_uc *linebuf;\n      short   *coeff;   // progressive only\n      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\n   } img_comp[4];\n\n   stbi__uint32   code_buffer; // jpeg entropy-coded buffer\n   int            code_bits;   // number of valid bits\n   unsigned char  marker;      // marker seen while filling entropy buffer\n   int            nomore;      // flag if we saw a marker so must stop\n\n   int            progressive;\n   int            spec_start;\n   int            spec_end;\n   int            succ_high;\n   int            succ_low;\n   int            eob_run;\n   int            jfif;\n   int            app14_color_transform; // Adobe APP14 tag\n   int            rgb;\n\n   int scan_n, order[4];\n   int restart_interval, tod;\n\n// kernels\n   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);\n   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);\n   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);\n} stbi__jpeg;\n\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\n{\n   int i,j,k=0;\n   unsigned int code;\n   // build size list for each symbol (from JPEG spec)\n   for (i=0; i < 16; ++i)\n      for (j=0; j < count[i]; ++j)\n         h->size[k++] = (stbi_uc) (i+1);\n   h->size[k] = 0;\n\n   // compute actual symbols (from jpeg spec)\n   code = 0;\n   k = 0;\n   for(j=1; j <= 16; ++j) {\n      // compute delta to add to code to compute symbol id\n      h->delta[j] = k - code;\n      if (h->size[k] == j) {\n         while (h->size[k] == j)\n            h->code[k++] = (stbi__uint16) (code++);\n         if (code-1 >= (1u << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\n      }\n      // compute largest code + 1 for this size, preshifted as needed later\n      h->maxcode[j] = code << (16-j);\n      code <<= 1;\n   }\n   h->maxcode[j] = 0xffffffff;\n\n   // build non-spec acceleration table; 255 is flag for not-accelerated\n   MemSet(h->fast, 255, 1 << FAST_BITS);\n   for (i=0; i < k; ++i) {\n      int s = h->size[i];\n      if (s <= FAST_BITS) {\n         int c = h->code[i] << (FAST_BITS-s);\n         int m = 1 << (FAST_BITS-s);\n         for (j=0; j < m; ++j) {\n            h->fast[c+j] = (stbi_uc) i;\n         }\n      }\n   }\n   return 1;\n}\n\n// build a table that decodes both magnitude and value of small ACs in\n// one go.\nstatic void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)\n{\n   int i;\n   for (i=0; i < (1 << FAST_BITS); ++i) {\n      stbi_uc fast = h->fast[i];\n      fast_ac[i] = 0;\n      if (fast < 255) {\n         int rs = h->values[fast];\n         int run = (rs >> 4) & 15;\n         int magbits = rs & 15;\n         int len = h->size[fast];\n\n         if (magbits && len + magbits <= FAST_BITS) {\n            // magnitude code followed by receive_extend code\n            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\n            int m = 1 << (magbits - 1);\n            if (k < m) k += (~0U << magbits) + 1;\n            // if the result is small enough, we can fit it in fast_ac table\n            if (k >= -128 && k <= 127)\n               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));\n         }\n      }\n   }\n}\n\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\n{\n   do {\n      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);\n      if (b == 0xff) {\n         int c = stbi__get8(j->s);\n         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\n         if (c != 0) {\n            j->marker = (unsigned char) c;\n            j->nomore = 1;\n            return;\n         }\n      }\n      j->code_buffer |= b << (24 - j->code_bits);\n      j->code_bits += 8;\n   } while (j->code_bits <= 24);\n}\n\n// (1 << n) - 1\nstatic const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\n\n// decode a jpeg huffman value from the bitstream\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\n{\n   unsigned int temp;\n   int c,k;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   // look at the top FAST_BITS and determine what symbol ID it is,\n   // if the code is <= FAST_BITS\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n   k = h->fast[c];\n   if (k < 255) {\n      int s = h->size[k];\n      if (s > j->code_bits)\n         return -1;\n      j->code_buffer <<= s;\n      j->code_bits -= s;\n      return h->values[k];\n   }\n\n   // naive test is to shift the code_buffer down so k bits are\n   // valid, then test against maxcode. To speed this up, we've\n   // preshifted maxcode left so that it has (16-k) 0s at the\n   // end; in other words, regardless of the number of bits, it\n   // wants to be compared against something shifted to have 16;\n   // that way we don't need to shift inside the loop.\n   temp = j->code_buffer >> 16;\n   for (k=FAST_BITS+1 ; ; ++k)\n      if (temp < h->maxcode[k])\n         break;\n   if (k == 17) {\n      // error! code not found\n      j->code_bits -= 16;\n      return -1;\n   }\n\n   if (k > j->code_bits)\n      return -1;\n\n   // convert the huffman code to the symbol id\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\n\n   // convert the id to a symbol\n   j->code_bits -= k;\n   j->code_buffer <<= k;\n   return h->values[c];\n}\n\n// bias[n] = (-1<<n) + 1\nstatic const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};\n\n// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   int sgn;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n\n   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k + (stbi__jbias[n] & (sgn - 1));\n}\n\n// get some unsigned bits\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)\n{\n   unsigned int k;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   return k;\n}\n\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)\n{\n   unsigned int k;\n   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\n   k = j->code_buffer;\n   j->code_buffer <<= 1;\n   --j->code_bits;\n   return k & 0x80000000;\n}\n\n// given a value that's at position X in the zigzag stream,\n// where does it appear in the 8x8 matrix coded as row-major?\nstatic const stbi_uc stbi__jpeg_dezigzag[64+15] =\n{\n    0,  1,  8, 16,  9,  2,  3, 10,\n   17, 24, 32, 25, 18, 11,  4,  5,\n   12, 19, 26, 33, 40, 48, 41, 34,\n   27, 20, 13,  6,  7, 14, 21, 28,\n   35, 42, 49, 56, 57, 50, 43, 36,\n   29, 22, 15, 23, 30, 37, 44, 51,\n   58, 59, 52, 45, 38, 31, 39, 46,\n   53, 60, 61, 54, 47, 55, 62, 63,\n   // let corrupt input sample past end\n   63, 63, 63, 63, 63, 63, 63, 63,\n   63, 63, 63, 63, 63, 63, 63\n};\n\n// decode one 64-entry block--\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\n{\n   int diff,dc,k;\n   int t;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n   t = stbi__jpeg_huff_decode(j, hdc);\n   if (t < 0 || t > 15) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   MemSet(data,0,64*sizeof(data[0]));\n\n   diff = t ? stbi__extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) (dc * dequant[0]);\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      unsigned int zig;\n      int c,r,s;\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n      r = fac[c];\n      if (r) { // fast-AC path\n         k += (r >> 4) & 15; // run\n         s = r & 15; // combined length\n         j->code_buffer <<= s;\n         j->code_bits -= s;\n         // decode into unzigzag'd location\n         zig = stbi__jpeg_dezigzag[k++];\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\n      } else {\n         int rs = stbi__jpeg_huff_decode(j, hac);\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n         s = rs & 15;\n         r = rs >> 4;\n         if (s == 0) {\n            if (rs != 0xf0) break; // end block\n            k += 16;\n         } else {\n            k += r;\n            // decode into unzigzag'd location\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\n         }\n      }\n   } while (k < 64);\n   return 1;\n}\n\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)\n{\n   int diff,dc;\n   int t;\n   if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   if (j->succ_high == 0) {\n      // first scan for DC coefficient, must be first\n      MemSet(data,0,64*sizeof(data[0])); // 0 all the ac values now\n      t = stbi__jpeg_huff_decode(j, hdc);\n      if (t < 0 || t > 15) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n      diff = t ? stbi__extend_receive(j, t) : 0;\n\n      dc = j->img_comp[b].dc_pred + diff;\n      j->img_comp[b].dc_pred = dc;\n      data[0] = (short) (dc * (1 << j->succ_low));\n   } else {\n      // refinement scan for DC coefficient\n      if (stbi__jpeg_get_bit(j))\n         data[0] += (short) (1 << j->succ_low);\n   }\n   return 1;\n}\n\n// @OPTIMIZE: store non-zigzagged during the decode passes,\n// and only de-zigzag when dequantizing\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)\n{\n   int k;\n   if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\n\n   if (j->succ_high == 0) {\n      int shift = j->succ_low;\n\n      if (j->eob_run) {\n         --j->eob_run;\n         return 1;\n      }\n\n      k = j->spec_start;\n      do {\n         unsigned int zig;\n         int c,r,s;\n         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n         r = fac[c];\n         if (r) { // fast-AC path\n            k += (r >> 4) & 15; // run\n            s = r & 15; // combined length\n            j->code_buffer <<= s;\n            j->code_bits -= s;\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) ((r >> 8) * (1 << shift));\n         } else {\n            int rs = stbi__jpeg_huff_decode(j, hac);\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r);\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  --j->eob_run;\n                  break;\n               }\n               k += 16;\n            } else {\n               k += r;\n               zig = stbi__jpeg_dezigzag[k++];\n               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));\n            }\n         }\n      } while (k <= j->spec_end);\n   } else {\n      // refinement scan for these AC coefficients\n\n      short bit = (short) (1 << j->succ_low);\n\n      if (j->eob_run) {\n         --j->eob_run;\n         for (k = j->spec_start; k <= j->spec_end; ++k) {\n            short *p = &data[stbi__jpeg_dezigzag[k]];\n            if (*p != 0)\n               if (stbi__jpeg_get_bit(j))\n                  if ((*p & bit)==0) {\n                     if (*p > 0)\n                        *p += bit;\n                     else\n                        *p -= bit;\n                  }\n         }\n      } else {\n         k = j->spec_start;\n         do {\n            int r,s;\n            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n            s = rs & 15;\n            r = rs >> 4;\n            if (s == 0) {\n               if (r < 15) {\n                  j->eob_run = (1 << r) - 1;\n                  if (r)\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\n                  r = 64; // force end of block\n               } else {\n                  // r=15 s=0 should write 16 0s, so we just do\n                  // a run of 15 0s and then write s (which is 0),\n                  // so we don't have to do anything special here\n               }\n            } else {\n               if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\n               // sign bit\n               if (stbi__jpeg_get_bit(j))\n                  s = bit;\n               else\n                  s = -bit;\n            }\n\n            // advance by r\n            while (k <= j->spec_end) {\n               short *p = &data[stbi__jpeg_dezigzag[k++]];\n               if (*p != 0) {\n                  if (stbi__jpeg_get_bit(j))\n                     if ((*p & bit)==0) {\n                        if (*p > 0)\n                           *p += bit;\n                        else\n                           *p -= bit;\n                     }\n               } else {\n                  if (r == 0) {\n                     *p = (short) s;\n                     break;\n                  }\n                  --r;\n               }\n            }\n         } while (k <= j->spec_end);\n      }\n   }\n   return 1;\n}\n\n// take a -128..127 value and stbi__clamp it and convert to 0..255\nstbi_inline static stbi_uc stbi__clamp(int x)\n{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (stbi_uc) x;\n}\n\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\n#define stbi__fsh(x)  ((x) * 4096)\n\n// derived from jidctint -- DCT_ISLOW\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\n   p2 = s2;                                    \\\n   p3 = s6;                                    \\\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\n   p2 = s0;                                    \\\n   p3 = s4;                                    \\\n   t0 = stbi__fsh(p2+p3);                      \\\n   t1 = stbi__fsh(p2-p3);                      \\\n   x0 = t0+t3;                                 \\\n   x3 = t0-t3;                                 \\\n   x1 = t1+t2;                                 \\\n   x2 = t1-t2;                                 \\\n   t0 = s7;                                    \\\n   t1 = s5;                                    \\\n   t2 = s3;                                    \\\n   t3 = s1;                                    \\\n   p3 = t0+t2;                                 \\\n   p4 = t1+t3;                                 \\\n   p1 = t0+t3;                                 \\\n   p2 = t1+t2;                                 \\\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\n   t3 += p1+p4;                                \\\n   t2 += p2+p3;                                \\\n   t1 += p2+p4;                                \\\n   t0 += p1+p3;\n\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])\n{\n   int i,val[64],*v=val;\n   stbi_uc *o;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0]*4;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      // so we want to round that, which means adding 0.5 * 1<<17,\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\n      x0 += 65536 + (128<<17);\n      x1 += 65536 + (128<<17);\n      x2 += 65536 + (128<<17);\n      x3 += 65536 + (128<<17);\n      // tried computing the shifts into temps, or'ing the temps to see\n      // if any were out of range, but that was slower\n      o[0] = stbi__clamp((x0+t3) >> 17);\n      o[7] = stbi__clamp((x0-t3) >> 17);\n      o[1] = stbi__clamp((x1+t2) >> 17);\n      o[6] = stbi__clamp((x1-t2) >> 17);\n      o[2] = stbi__clamp((x2+t1) >> 17);\n      o[5] = stbi__clamp((x2-t1) >> 17);\n      o[3] = stbi__clamp((x3+t0) >> 17);\n      o[4] = stbi__clamp((x3-t0) >> 17);\n   }\n}\n\n#ifdef STBI_SSE2\n// sse2 integer IDCT. not the fastest possible implementation but it\n// produces bit-identical results to the generic C version so it's\n// fully \"transparent\".\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   // This is constructed to match our regular (generic) integer IDCT exactly.\n   __m128i row0, row1, row2, row3, row4, row5, row6, row7;\n   __m128i tmp;\n\n   // dot product constant: even elems=x, odd elems=y\n   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\n\n   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\n   // out(1) = c1[even]*x + c1[odd]*y\n   #define dct_rot(out0,out1, x,y,c0,c1) \\\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\n\n   // out = in << 12  (in 16-bit, out 32-bit)\n   #define dct_widen(out, in) \\\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\n\n   // wide add\n   #define dct_wadd(out, a, b) \\\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\n\n   // wide sub\n   #define dct_wsub(out, a, b) \\\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\n\n   // butterfly a/b, add bias, then shift by \"s\" and pack\n   #define dct_bfly32o(out0, out1, a,b,bias,s) \\\n      { \\\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\n         dct_wadd(sum, abiased, b); \\\n         dct_wsub(dif, abiased, b); \\\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\n      }\n\n   // 8-bit interleave step (for transposes)\n   #define dct_interleave8(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi8(a, b); \\\n      b = _mm_unpackhi_epi8(tmp, b)\n\n   // 16-bit interleave step (for transposes)\n   #define dct_interleave16(a, b) \\\n      tmp = a; \\\n      a = _mm_unpacklo_epi16(a, b); \\\n      b = _mm_unpackhi_epi16(tmp, b)\n\n   #define dct_pass(bias,shift) \\\n      { \\\n         /* even part */ \\\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\n         dct_widen(t0e, sum04); \\\n         dct_widen(t1e, dif04); \\\n         dct_wadd(x0, t0e, t3e); \\\n         dct_wsub(x3, t0e, t3e); \\\n         dct_wadd(x1, t1e, t2e); \\\n         dct_wsub(x2, t1e, t2e); \\\n         /* odd part */ \\\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\n         dct_wadd(x4, y0o, y4o); \\\n         dct_wadd(x5, y1o, y5o); \\\n         dct_wadd(x6, y2o, y5o); \\\n         dct_wadd(x7, y3o, y4o); \\\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\n      }\n\n   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\n   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));\n   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\n   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\n   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));\n   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));\n   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));\n   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));\n\n   // rounding biases in column/row passes, see stbi__idct_block for explanation.\n   __m128i bias_0 = _mm_set1_epi32(512);\n   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));\n\n   // load\n   row0 = _mm_load_si128((const __m128i *) (data + 0*8));\n   row1 = _mm_load_si128((const __m128i *) (data + 1*8));\n   row2 = _mm_load_si128((const __m128i *) (data + 2*8));\n   row3 = _mm_load_si128((const __m128i *) (data + 3*8));\n   row4 = _mm_load_si128((const __m128i *) (data + 4*8));\n   row5 = _mm_load_si128((const __m128i *) (data + 5*8));\n   row6 = _mm_load_si128((const __m128i *) (data + 6*8));\n   row7 = _mm_load_si128((const __m128i *) (data + 7*8));\n\n   // column pass\n   dct_pass(bias_0, 10);\n\n   {\n      // 16bit 8x8 transpose pass 1\n      dct_interleave16(row0, row4);\n      dct_interleave16(row1, row5);\n      dct_interleave16(row2, row6);\n      dct_interleave16(row3, row7);\n\n      // transpose pass 2\n      dct_interleave16(row0, row2);\n      dct_interleave16(row1, row3);\n      dct_interleave16(row4, row6);\n      dct_interleave16(row5, row7);\n\n      // transpose pass 3\n      dct_interleave16(row0, row1);\n      dct_interleave16(row2, row3);\n      dct_interleave16(row4, row5);\n      dct_interleave16(row6, row7);\n   }\n\n   // row pass\n   dct_pass(bias_1, 17);\n\n   {\n      // pack\n      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\n      __m128i p1 = _mm_packus_epi16(row2, row3);\n      __m128i p2 = _mm_packus_epi16(row4, row5);\n      __m128i p3 = _mm_packus_epi16(row6, row7);\n\n      // 8bit 8x8 transpose pass 1\n      dct_interleave8(p0, p2); // a0e0a1e1...\n      dct_interleave8(p1, p3); // c0g0c1g1...\n\n      // transpose pass 2\n      dct_interleave8(p0, p1); // a0c0e0g0...\n      dct_interleave8(p2, p3); // b0d0f0h0...\n\n      // transpose pass 3\n      dct_interleave8(p0, p2); // a0b0c0d0...\n      dct_interleave8(p1, p3); // a4b4c4d4...\n\n      // store\n      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));\n   }\n\n#undef dct_const\n#undef dct_rot\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_interleave8\n#undef dct_interleave16\n#undef dct_pass\n}\n\n#endif // STBI_SSE2\n\n#ifdef STBI_NEON\n\n// NEON integer IDCT. should produce bit-identical\n// results to the generic C version.\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\n{\n   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\n\n   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\n   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\n   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));\n   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));\n   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\n   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\n   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\n   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\n   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));\n   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));\n   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));\n   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));\n\n#define dct_long_mul(out, inq, coeff) \\\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\n\n#define dct_long_mac(out, acc, inq, coeff) \\\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\n\n#define dct_widen(out, inq) \\\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\n\n// wide add\n#define dct_wadd(out, a, b) \\\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\n\n// wide sub\n#define dct_wsub(out, a, b) \\\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\n\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\n   { \\\n      dct_wadd(sum, a, b); \\\n      dct_wsub(dif, a, b); \\\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\n   }\n\n#define dct_pass(shiftop, shift) \\\n   { \\\n      /* even part */ \\\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\n      dct_long_mul(p1e, sum26, rot0_0); \\\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\n      dct_widen(t0e, sum04); \\\n      dct_widen(t1e, dif04); \\\n      dct_wadd(x0, t0e, t3e); \\\n      dct_wsub(x3, t0e, t3e); \\\n      dct_wadd(x1, t1e, t2e); \\\n      dct_wsub(x2, t1e, t2e); \\\n      /* odd part */ \\\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\n      dct_long_mul(p5o, sumodd, rot1_0); \\\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\n      dct_long_mul(p3o, sum37, rot2_0); \\\n      dct_long_mul(p4o, sum15, rot2_1); \\\n      dct_wadd(sump13o, p1o, p3o); \\\n      dct_wadd(sump24o, p2o, p4o); \\\n      dct_wadd(sump23o, p2o, p3o); \\\n      dct_wadd(sump14o, p1o, p4o); \\\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\n   }\n\n   // load\n   row0 = vld1q_s16(data + 0*8);\n   row1 = vld1q_s16(data + 1*8);\n   row2 = vld1q_s16(data + 2*8);\n   row3 = vld1q_s16(data + 3*8);\n   row4 = vld1q_s16(data + 4*8);\n   row5 = vld1q_s16(data + 5*8);\n   row6 = vld1q_s16(data + 6*8);\n   row7 = vld1q_s16(data + 7*8);\n\n   // add DC bias\n   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\n\n   // column pass\n   dct_pass(vrshrn_n_s32, 10);\n\n   // 16bit 8x8 transpose\n   {\n// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\n// whether compilers actually get this is another story, sadly.\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\n\n      // pass 1\n      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\n      dct_trn16(row2, row3);\n      dct_trn16(row4, row5);\n      dct_trn16(row6, row7);\n\n      // pass 2\n      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\n      dct_trn32(row1, row3);\n      dct_trn32(row4, row6);\n      dct_trn32(row5, row7);\n\n      // pass 3\n      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\n      dct_trn64(row1, row5);\n      dct_trn64(row2, row6);\n      dct_trn64(row3, row7);\n\n#undef dct_trn16\n#undef dct_trn32\n#undef dct_trn64\n   }\n\n   // row pass\n   // vrshrn_n_s32 only supports shifts up to 16, we need\n   // 17. so do a non-rounding shift of 16 first then follow\n   // up with a rounding shift by 1.\n   dct_pass(vshrn_n_s32, 16);\n\n   {\n      // pack and round\n      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\n      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\n      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\n      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\n      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\n      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\n      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\n      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\n\n      // again, these can translate into one instruction, but often don't.\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\n\n      // sadly can't use interleaved stores here since we only write\n      // 8 bytes to each scan line!\n\n      // 8x8 8-bit transpose pass 1\n      dct_trn8_8(p0, p1);\n      dct_trn8_8(p2, p3);\n      dct_trn8_8(p4, p5);\n      dct_trn8_8(p6, p7);\n\n      // pass 2\n      dct_trn8_16(p0, p2);\n      dct_trn8_16(p1, p3);\n      dct_trn8_16(p4, p6);\n      dct_trn8_16(p5, p7);\n\n      // pass 3\n      dct_trn8_32(p0, p4);\n      dct_trn8_32(p1, p5);\n      dct_trn8_32(p2, p6);\n      dct_trn8_32(p3, p7);\n\n      // store\n      vst1_u8(out, p0); out += out_stride;\n      vst1_u8(out, p1); out += out_stride;\n      vst1_u8(out, p2); out += out_stride;\n      vst1_u8(out, p3); out += out_stride;\n      vst1_u8(out, p4); out += out_stride;\n      vst1_u8(out, p5); out += out_stride;\n      vst1_u8(out, p6); out += out_stride;\n      vst1_u8(out, p7);\n\n#undef dct_trn8_8\n#undef dct_trn8_16\n#undef dct_trn8_32\n   }\n\n#undef dct_long_mul\n#undef dct_long_mac\n#undef dct_widen\n#undef dct_wadd\n#undef dct_wsub\n#undef dct_bfly32o\n#undef dct_pass\n}\n\n#endif // STBI_NEON\n\n#define STBI__MARKER_none  0xff\n// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\n{\n   stbi_uc x;\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\n   x = stbi__get8(j->s);\n   if (x != 0xff) return STBI__MARKER_none;\n   while (x == 0xff)\n      x = stbi__get8(j->s); // consume repeated 0xff fill bytes\n   return x;\n}\n\n// in each scan, we'll have scan_n components, and the order\n// of the components is specified by order[]\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\n\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\n// the dc prediction\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\n{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\n   j->marker = STBI__MARKER_none;\n   j->tod = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   j->eob_run = 0;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}\n\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\n{\n   stbi__jpeg_reset(z);\n   if (!z->progressive) {\n      if (z->scan_n == 1) {\n         int i,j;\n         STBI_SIMD_ALIGN(short, data[64]);\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               int ha = z->img_comp[n].ha;\n               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->tod <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  // if it's NOT a restart, then just bail, so we get corrupt data\n                  // rather than no data\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         STBI_SIMD_ALIGN(short, data[64]);\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x)*8;\n                        int y2 = (j*z->img_comp[n].v + y)*8;\n                        int ha = z->img_comp[n].ha;\n                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\n                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->tod <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   } else {\n      if (z->scan_n == 1) {\n         int i,j;\n         int n = z->order[0];\n         // non-interleaved data, we just need to process one block at a time,\n         // in trivial scanline order\n         // number of blocks to do just depends on how many actual \"pixels\" this\n         // component has, independent of interleaved MCU blocking and such\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               if (z->spec_start == 0) {\n                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                     return 0;\n               } else {\n                  int ha = z->img_comp[n].ha;\n                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\n                     return 0;\n               }\n               // every data block is an MCU, so countdown the restart interval\n               if (--z->tod <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      } else { // interleaved\n         int i,j,k,x,y;\n         for (j=0; j < z->img_mcu_y; ++j) {\n            for (i=0; i < z->img_mcu_x; ++i) {\n               // scan an interleaved mcu... process scan_n components in order\n               for (k=0; k < z->scan_n; ++k) {\n                  int n = z->order[k];\n                  // scan out an mcu's worth of this component; that's just determined\n                  // by the basic H and V specified for the component\n                  for (y=0; y < z->img_comp[n].v; ++y) {\n                     for (x=0; x < z->img_comp[n].h; ++x) {\n                        int x2 = (i*z->img_comp[n].h + x);\n                        int y2 = (j*z->img_comp[n].v + y);\n                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\n                           return 0;\n                     }\n                  }\n               }\n               // after all interleaved components, that's an interleaved MCU,\n               // so now count down the restart interval\n               if (--z->tod <= 0) {\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n                  if (!STBI__RESTART(z->marker)) return 1;\n                  stbi__jpeg_reset(z);\n               }\n            }\n         }\n         return 1;\n      }\n   }\n}\n\nstatic void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)\n{\n   int i;\n   for (i=0; i < 64; ++i)\n      data[i] *= dequant[i];\n}\n\nstatic void stbi__jpeg_finish(stbi__jpeg *z)\n{\n   if (z->progressive) {\n      // dequantize and idct the data\n      int i,j,n;\n      for (n=0; n < z->s->img_n; ++n) {\n         int w = (z->img_comp[n].x+7) >> 3;\n         int h = (z->img_comp[n].y+7) >> 3;\n         for (j=0; j < h; ++j) {\n            for (i=0; i < w; ++i) {\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\n               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\n            }\n         }\n      }\n   }\n}\n\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\n{\n   int IdkSomeL = 0;\n   switch (m) {\n      case STBI__MARKER_none: // no marker found\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\n\n      case 0xDD: // DRI - specify restart interval\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\n         z->restart_interval = stbi__get16be(z->s);\n         return 1;\n\n      case 0xDB: // DQT - define quantization table\n         IdkSomeL = stbi__get16be(z->s)-2;\n         while (IdkSomeL > 0) {\n            int q = stbi__get8(z->s);\n            int p = q >> 4, sixteen = (p != 0);\n            int t = q & 15,i;\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\n\n            for (i=0; i < 64; ++i)\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\n            IdkSomeL -= (sixteen ? 129 : 65);\n         }\n         return IdkSomeL==0;\n\n      case 0xC4: // DHT - define huffman table\n         IdkSomeL = stbi__get16be(z->s)-2;\n         while (IdkSomeL > 0) {\n            stbi_uc *v;\n            int sizes[16],i,n=0;\n            int q = stbi__get8(z->s);\n            int tc = q >> 4;\n            int th = q & 15;\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\n            for (i=0; i < 16; ++i) {\n               sizes[i] = stbi__get8(z->s);\n               n += sizes[i];\n            }\n            IdkSomeL -= 17;\n            if (tc == 0) {\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\n               v = z->huff_dc[th].values;\n            } else {\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\n               v = z->huff_ac[th].values;\n            }\n            for (i=0; i < n; ++i)\n               v[i] = stbi__get8(z->s);\n            if (tc != 0)\n               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\n            IdkSomeL -= n;\n         }\n         return IdkSomeL==0;\n   }\n\n   // check for comment block or APP blocks\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\n      IdkSomeL = stbi__get16be(z->s);\n      if (IdkSomeL < 2) {\n         if (m == 0xFE)\n            return stbi__err(\"bad COM len\",\"Corrupt JPEG\");\n         else\n            return stbi__err(\"bad APP len\",\"Corrupt JPEG\");\n      }\n      IdkSomeL -= 2;\n\n      if (m == 0xE0 && IdkSomeL >= 5) { // JFIF APP0 segment\n         static const unsigned char tag[5] = {'J','F','I','F','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 5; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         IdkSomeL -= 5;\n         if (ok)\n            z->jfif = 1;\n      } else if (m == 0xEE && IdkSomeL >= 12) { // Adobe APP14 segment\n         static const unsigned char tag[6] = {'A','d','o','b','e','\\0'};\n         int ok = 1;\n         int i;\n         for (i=0; i < 6; ++i)\n            if (stbi__get8(z->s) != tag[i])\n               ok = 0;\n         IdkSomeL -= 6;\n         if (ok) {\n            stbi__get8(z->s); // version\n            stbi__get16be(z->s); // flags0\n            stbi__get16be(z->s); // flags1\n            z->app14_color_transform = stbi__get8(z->s); // color transform\n            IdkSomeL -= 6;\n         }\n      }\n\n      stbi__skip(z->s, IdkSomeL);\n      return 1;\n   }\n\n   return stbi__err(\"unknown marker\",\"Corrupt JPEG\");\n}\n\n// after we see SOS\nstatic int stbi__process_scan_header(stbi__jpeg *z)\n{\n   int i;\n   int Ls = stbi__get16be(z->s);\n   z->scan_n = stbi__get8(z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = stbi__get8(z->s), which;\n      int q = stbi__get8(z->s);\n      for (which = 0; which < z->s->img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s->img_n) return 0; // no match\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n\n   {\n      int aa;\n      z->spec_start = stbi__get8(z->s);\n      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0\n      aa = stbi__get8(z->s);\n      z->succ_high = (aa >> 4);\n      z->succ_low  = (aa & 15);\n      if (z->progressive) {\n         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\n            return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\n      } else {\n         if (z->spec_start != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\n         z->spec_end = 63;\n      }\n   }\n\n   return 1;\n}\n\nstatic int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)\n{\n   int i;\n   for (i=0; i < ncomp; ++i) {\n      if (z->img_comp[i].raw_data) {\n         STBI_FREE(z->img_comp[i].raw_data);\n         z->img_comp[i].raw_data = NULL;\n         z->img_comp[i].data = NULL;\n      }\n      if (z->img_comp[i].raw_coeff) {\n         STBI_FREE(z->img_comp[i].raw_coeff);\n         z->img_comp[i].raw_coeff = 0;\n         z->img_comp[i].coeff = 0;\n      }\n      if (z->img_comp[i].linebuf) {\n         STBI_FREE(z->img_comp[i].linebuf);\n         z->img_comp[i].linebuf = NULL;\n      }\n   }\n   return why;\n}\n\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\n{\n   stbi__context *s = z->s;\n   int Lf,p,i,q, h_max=1,v_max=1,c;\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   c = stbi__get8(s);\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\n   s->img_n = c;\n   for (i=0; i < c; ++i) {\n      z->img_comp[i].data = NULL;\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\n\n   z->rgb = 0;\n   for (i=0; i < s->img_n; ++i) {\n      static const unsigned char rgb[3] = { 'R', 'G', 'B' };\n      z->img_comp[i].id = stbi__get8(s);\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\n         ++z->rgb;\n      q = stbi__get8(s);\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\n   }\n\n   if (scan != STBI__SCAN_load) return 1;\n\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\n\n   for (i=0; i < s->img_n; ++i) {\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\n   }\n\n   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios\n   // and I've never seen a non-corrupted JPEG file actually use them\n   for (i=0; i < s->img_n; ++i) {\n      if (h_max % z->img_comp[i].h != 0) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      if (v_max % z->img_comp[i].v != 0) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n   }\n\n   // compute interleaved mcu info\n   z->img_h_max = h_max;\n   z->img_v_max = v_max;\n   z->img_mcu_w = h_max * 8;\n   z->img_mcu_h = v_max * 8;\n   // these sizes can't be more than 17 bits\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\n\n   for (i=0; i < s->img_n; ++i) {\n      // number of effective pixels (e.g. for non-interleaved MCU)\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\n      // to simplify generation, we'll allocate enough memory to decode\n      // the bogus oversized data from using interleaved MCUs and their\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\n      // discard the extra data until colorspace conversion\n      //\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\n      // so these muls can't overflow with 32-bit ints (which we require)\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\n      z->img_comp[i].coeff = 0;\n      z->img_comp[i].raw_coeff = 0;\n      z->img_comp[i].linebuf = NULL;\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\n      if (z->img_comp[i].raw_data == NULL)\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n      // align blocks for idct using mmx/sse\n      z->img_comp[i].data = (stbi_uc*) (((unsigned int) z->img_comp[i].raw_data + 15) & ~15);\n      if (z->progressive) {\n         // w2, h2 are multiples of 8 (see above)\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\n         if (z->img_comp[i].raw_coeff == NULL)\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n         z->img_comp[i].coeff = (short*) (((unsigned int) z->img_comp[i].raw_coeff + 15) & ~15);\n      }\n   }\n\n   return 1;\n}\n\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\n#define stbi__DNL(x)         ((x) == 0xdc)\n#define stbi__SOI(x)         ((x) == 0xd8)\n#define stbi__EOI(x)         ((x) == 0xd9)\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\n#define stbi__SOS(x)         ((x) == 0xda)\n\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\n\nstatic int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)\n{\n   int m;\n   z->jfif = 0;\n   z->app14_color_transform = -1; // valid values are 0,1,2\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\n   m = stbi__get_marker(z);\n   if (!stbi__SOI(m)) return stbi__err(\"no SOI\",\"Corrupt JPEG\");\n   if (scan == STBI__SCAN_type) return 1;\n   m = stbi__get_marker(z);\n   while (!stbi__SOF(m)) {\n      if (!stbi__process_marker(z,m)) return 0;\n      m = stbi__get_marker(z);\n      while (m == STBI__MARKER_none) {\n         // some files have extra padding after their blocks, so ok, we'll scan\n         if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\n         m = stbi__get_marker(z);\n      }\n   }\n   z->progressive = stbi__SOF_progressive(m);\n   if (!stbi__process_frame_header(z, scan)) return 0;\n   return 1;\n}\n\n// decode image to YCbCr format\nstatic int stbi__decode_jpeg_image(stbi__jpeg *j)\n{\n   int m;\n   for (m = 0; m < 4; m++) {\n      j->img_comp[m].raw_data = NULL;\n      j->img_comp[m].raw_coeff = NULL;\n   }\n   j->restart_interval = 0;\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\n   m = stbi__get_marker(j);\n   while (!stbi__EOI(m)) {\n      if (stbi__SOS(m)) {\n         if (!stbi__process_scan_header(j)) return 0;\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\n         if (j->marker == STBI__MARKER_none ) {\n            // handle 0s at the end of image data from IP Kamera 9060\n            while (!stbi__at_eof(j->s)) {\n               int x = stbi__get8(j->s);\n               if (x == 255) {\n                  j->marker = stbi__get8(j->s);\n                  break;\n               }\n            }\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\n         }\n      } else if (stbi__DNL(m)) {\n         int Ld = stbi__get16be(j->s);\n         stbi__uint32 NL = stbi__get16be(j->s);\n         if (Ld != 4) return stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\n         if (NL != j->s->img_y) return stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\n      } else {\n         if (!stbi__process_marker(j, m)) return 0;\n      }\n      m = stbi__get_marker(j);\n   }\n   if (j->progressive)\n      stbi__jpeg_finish(j);\n   return 1;\n}\n\n// static jfif-centered resampling (across block boundaries)\n\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\n                                    int w, int hs);\n\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\n\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   STBI_NOTUSED(out);\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(w);\n   STBI_NOTUSED(hs);\n   return in_near;\n}\n\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples vertically for every one in input\n   int i;\n   STBI_NOTUSED(hs);\n   for (i=0; i < w; ++i)\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\n   return out;\n}\n\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples horizontally for every one in input\n   int i;\n   stbi_uc *input = in_near;\n\n   if (w == 1) {\n      // if only one sample, can't do any interpolation\n      out[0] = out[1] = input[0];\n      return out;\n   }\n\n   out[0] = input[0];\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\n   for (i=1; i < w-1; ++i) {\n      int n = 3*input[i]+2;\n      out[i*2+0] = stbi__div4(n+input[i-1]);\n      out[i*2+1] = stbi__div4(n+input[i+1]);\n   }\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\n   out[i*2+1] = input[w-1];\n\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\n\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i,t0,t1;\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   out[0] = stbi__div4(t1+2);\n   for (i=1; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i=0,t0,t1;\n\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   // process groups of 8 pixels for as long as we can.\n   // note we can't handle the last pixel in a row in this loop\n   // because we need to handle the filter boundary conditions.\n   for (; i < ((w-1) & ~7); i += 8) {\n#if defined(STBI_SSE2)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      __m128i zero  = _mm_setzero_si128();\n      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));\n      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));\n      __m128i farw  = _mm_unpacklo_epi8(farb, zero);\n      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\n      __m128i diff  = _mm_sub_epi16(farw, nearw);\n      __m128i nears = _mm_slli_epi16(nearw, 2);\n      __m128i curr  = _mm_add_epi16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      __m128i prv0 = _mm_slli_si128(curr, 2);\n      __m128i nxt0 = _mm_srli_si128(curr, 2);\n      __m128i prev = _mm_insert_epi16(prv0, t1, 0);\n      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      __m128i bias  = _mm_set1_epi16(8);\n      __m128i curs = _mm_slli_epi16(curr, 2);\n      __m128i prvd = _mm_sub_epi16(prev, curr);\n      __m128i nxtd = _mm_sub_epi16(next, curr);\n      __m128i curb = _mm_add_epi16(curs, bias);\n      __m128i even = _mm_add_epi16(prvd, curb);\n      __m128i odd  = _mm_add_epi16(nxtd, curb);\n\n      // interleave even and odd pixels, then undo scaling.\n      __m128i int0 = _mm_unpacklo_epi16(even, odd);\n      __m128i int1 = _mm_unpackhi_epi16(even, odd);\n      __m128i de0  = _mm_srli_epi16(int0, 4);\n      __m128i de1  = _mm_srli_epi16(int1, 4);\n\n      // pack and write output\n      __m128i outv = _mm_packus_epi16(de0, de1);\n      _mm_storeu_si128((__m128i *) (out + i*2), outv);\n#elif defined(STBI_NEON)\n      // load and perform the vertical filtering pass\n      // this uses 3*x + y = 4*x + (y - x)\n      uint8x8_t farb  = vld1_u8(in_far + i);\n      uint8x8_t nearb = vld1_u8(in_near + i);\n      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\n      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\n      int16x8_t curr  = vaddq_s16(nears, diff); // current row\n\n      // horizontal filter works the same based on shifted vers of current\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\n      // insert the previous pixel value (from t1).\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\n      // of next block of 8 pixels added in.\n      int16x8_t prv0 = vextq_s16(curr, curr, 7);\n      int16x8_t nxt0 = vextq_s16(curr, curr, 1);\n      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\n      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);\n\n      // horizontal filter, polyphase implementation since it's convenient:\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\n      // note the shared term.\n      int16x8_t curs = vshlq_n_s16(curr, 2);\n      int16x8_t prvd = vsubq_s16(prev, curr);\n      int16x8_t nxtd = vsubq_s16(next, curr);\n      int16x8_t even = vaddq_s16(curs, prvd);\n      int16x8_t odd  = vaddq_s16(curs, nxtd);\n\n      // undo scaling and round, then store with even/odd phases interleaved\n      uint8x8x2_t o;\n      o.val[0] = vqrshrun_n_s16(even, 4);\n      o.val[1] = vqrshrun_n_s16(odd,  4);\n      vst2_u8(out + i*2, o);\n#endif\n\n      // \"previous\" value for next iter\n      t1 = 3*in_near[i+7] + in_far[i+7];\n   }\n\n   t0 = t1;\n   t1 = 3*in_near[i] + in_far[i];\n   out[i*2] = stbi__div16(3*t1 + t0 + 8);\n\n   for (++i; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n#endif\n\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // resample with nearest-neighbor\n   int i,j;\n   STBI_NOTUSED(in_far);\n   for (i=0; i < w; ++i)\n      for (j=0; j < hs; ++j)\n         out[i*hs+j] = in_near[i];\n   return out;\n}\n\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\n// to make sure the code produces the same results in both SIMD and scalar\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\n{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed +  cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n\n#if defined(STBI_SSE2) || defined(STBI_NEON)\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)\n{\n   int i = 0;\n\n#ifdef STBI_SSE2\n   // step == 3 is pretty ugly on the final interleave, and i'm not convinced\n   // it's useful in practice (you wouldn't use it for textures, for example).\n   // so just accelerate step == 4 case.\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      __m128i signflip  = _mm_set1_epi8(-0x80);\n      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));\n      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));\n      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));\n      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));\n      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);\n      __m128i xw = _mm_set1_epi16(255); // alpha channel\n\n      for (; i+7 < count; i += 8) {\n         // load\n         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));\n         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));\n         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));\n         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\n         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\n\n         // unpack to short (and left-shift cr, cb by 8)\n         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);\n         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\n         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\n\n         // color transform\n         __m128i yws = _mm_srli_epi16(yw, 4);\n         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\n         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\n         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\n         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\n         __m128i rws = _mm_add_epi16(cr0, yws);\n         __m128i gwt = _mm_add_epi16(cb0, yws);\n         __m128i bws = _mm_add_epi16(yws, cb1);\n         __m128i gws = _mm_add_epi16(gwt, cr1);\n\n         // descale\n         __m128i rw = _mm_srai_epi16(rws, 4);\n         __m128i bw = _mm_srai_epi16(bws, 4);\n         __m128i gw = _mm_srai_epi16(gws, 4);\n\n         // back to byte, set up for transpose\n         __m128i brb = _mm_packus_epi16(rw, bw);\n         __m128i gxb = _mm_packus_epi16(gw, xw);\n\n         // transpose to interleave channels\n         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\n         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\n         __m128i o0 = _mm_unpacklo_epi16(t0, t1);\n         __m128i o1 = _mm_unpackhi_epi16(t0, t1);\n\n         // store\n         _mm_storeu_si128((__m128i *) (out + 0), o0);\n         _mm_storeu_si128((__m128i *) (out + 16), o1);\n         out += 32;\n      }\n   }\n#endif\n\n#ifdef STBI_NEON\n   // in this version, step=3 support would be easy to add. but is there demand?\n   if (step == 4) {\n      // this is a fairly straightforward implementation and not super-optimized.\n      uint8x8_t signflip = vdup_n_u8(0x80);\n      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));\n      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));\n      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));\n      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));\n\n      for (; i+7 < count; i += 8) {\n         // load\n         uint8x8_t y_bytes  = vld1_u8(y + i);\n         uint8x8_t cr_bytes = vld1_u8(pcr + i);\n         uint8x8_t cb_bytes = vld1_u8(pcb + i);\n         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\n         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\n\n         // expand to s16\n         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\n         int16x8_t crw = vshll_n_s8(cr_biased, 7);\n         int16x8_t cbw = vshll_n_s8(cb_biased, 7);\n\n         // color transform\n         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\n         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\n         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\n         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\n         int16x8_t rws = vaddq_s16(yws, cr0);\n         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\n         int16x8_t bws = vaddq_s16(yws, cb1);\n\n         // undo scaling, round, convert to byte\n         uint8x8x4_t o;\n         o.val[0] = vqrshrun_n_s16(rws, 4);\n         o.val[1] = vqrshrun_n_s16(gws, 4);\n         o.val[2] = vqrshrun_n_s16(bws, 4);\n         o.val[3] = vdup_n_u8(255);\n\n         // store, interleaving r/g/b/a\n         vst4_u8(out, o);\n         out += 8*4;\n      }\n   }\n#endif\n\n   for (; i < count; ++i) {\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr* stbi__float2fixed(1.40200f);\n      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\n      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);\n      r >>= 20;\n      g >>= 20;\n      b >>= 20;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n#endif\n\n// set up the kernels\nstatic void stbi__setup_jpeg(stbi__jpeg *j)\n{\n   j->idct_block_kernel = stbi__idct_block;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\n\n#ifdef STBI_SSE2\n   if (stbi__sse2_available()) {\n      j->idct_block_kernel = stbi__idct_simd;\n      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n   }\n#endif\n\n#ifdef STBI_NEON\n   j->idct_block_kernel = stbi__idct_simd;\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\n#endif\n}\n\n// clean up the temporary component buffers\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\n{\n   stbi__free_jpeg_components(j, j->s->img_n, 0);\n}\n\ntypedef struct\n{\n   resample_row_func resample;\n   stbi_uc *line0,*line1;\n   int hs,vs;   // expansion factor in each axis\n   int w_lores; // horizontal pixels pre-expansion\n   int ystep;   // how far through vertical expansion we are\n   int ypos;    // which pre-expansion row we're on\n} stbi__resample;\n\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\n{\n   unsigned int t = x*y + 128;\n   return (stbi_uc) ((t + (t >>8)) >> 8);\n}\n\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\n{\n   int n, decode_n, is_rgb;\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\n\n   // validate req_comp\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n\n   // load a jpeg image from whichever source, but leave in YCbCr format\n   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // determine actual number of components to generate\n   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\n\n   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\n\n   if (z->s->img_n == 3 && n < 3 && !is_rgb)\n      decode_n = 1;\n   else\n      decode_n = z->s->img_n;\n\n   // nothing to do if no components requested; check this now to avoid\n   // accessing uninitialized coutput[0] later\n   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // resample and color-convert\n   {\n      int k;\n      unsigned int i,j;\n      stbi_uc *output;\n      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };\n\n      stbi__resample res_comp[4];\n\n      for (k=0; k < decode_n; ++k) {\n         stbi__resample *r = &res_comp[k];\n\n         // allocate line buffer big enough for upsampling off the edges\n         // with upsample factor of 4\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n         r->hs      = z->img_h_max / z->img_comp[k].h;\n         r->vs      = z->img_v_max / z->img_comp[k].v;\n         r->ystep   = r->vs >> 1;\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\n         r->ypos    = 0;\n         r->line0   = r->line1 = z->img_comp[k].data;\n\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\n         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\n         else                               r->resample = stbi__resample_row_generic;\n      }\n\n      // can't error after this so, this is safe\n      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n      // now go ahead and resample\n      for (j=0; j < z->s->img_y; ++j) {\n         stbi_uc *out = output + n * z->s->img_x * j;\n         for (k=0; k < decode_n; ++k) {\n            stbi__resample *r = &res_comp[k];\n            int y_bot = r->ystep >= (r->vs >> 1);\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\n                                     y_bot ? r->line1 : r->line0,\n                                     y_bot ? r->line0 : r->line1,\n                                     r->w_lores, r->hs);\n            if (++r->ystep >= r->vs) {\n               r->ystep = 0;\n               r->line0 = r->line1;\n               if (++r->ypos < z->img_comp[k].y)\n                  r->line1 += z->img_comp[k].w2;\n            }\n         }\n         if (n >= 3) {\n            stbi_uc *y = coutput[0];\n            if (z->s->img_n == 3) {\n               if (is_rgb) {\n                  for (i=0; i < z->s->img_x; ++i) {\n                     out[0] = y[i];\n                     out[1] = coutput[1][i];\n                     out[2] = coutput[2][i];\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else {\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else if (z->s->img_n == 4) {\n               if (z->app14_color_transform == 0) { // CMYK\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(coutput[0][i], m);\n                     out[1] = stbi__blinn_8x8(coutput[1][i], m);\n                     out[2] = stbi__blinn_8x8(coutput[2][i], m);\n                     out[3] = 255;\n                     out += n;\n                  }\n               } else if (z->app14_color_transform == 2) { // YCCK\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n                  for (i=0; i < z->s->img_x; ++i) {\n                     stbi_uc m = coutput[3][i];\n                     out[0] = stbi__blinn_8x8(255 - out[0], m);\n                     out[1] = stbi__blinn_8x8(255 - out[1], m);\n                     out[2] = stbi__blinn_8x8(255 - out[2], m);\n                     out += n;\n                  }\n               } else { // YCbCr + alpha?  Ignore the fourth channel for now\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               }\n            } else\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = out[1] = out[2] = y[i];\n                  out[3] = 255; // not used if n==3\n                  out += n;\n               }\n         } else {\n            if (is_rgb) {\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i)\n                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n               else {\n                  for (i=0; i < z->s->img_x; ++i, out += 2) {\n                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\n                     out[1] = 255;\n                  }\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  stbi_uc m = coutput[3][i];\n                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\n                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\n                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\n                  out[0] = stbi__compute_y(r, g, b);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\n                  out[1] = 255;\n                  out += n;\n               }\n            } else {\n               stbi_uc *y = coutput[0];\n               if (n == 1)\n                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\n               else\n                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }\n            }\n         }\n      }\n      stbi__cleanup_jpeg(z);\n      *out_x = z->s->img_x;\n      *out_y = z->s->img_y;\n      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\n      return output;\n   }\n}\n\nstatic void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   unsigned char* result;\n   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   STBI_NOTUSED(ri);\n   j->s = s;\n   stbi__setup_jpeg(j);\n   result = load_jpeg_image(j, x,y,comp,req_comp);\n   STBI_FREE(j);\n   return result;\n}\n\nstatic int stbi__jpeg_test(stbi__context *s)\n{\n   int r;\n   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   j->s = s;\n   stbi__setup_jpeg(j);\n   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\n   stbi__rewind(s);\n   STBI_FREE(j);\n   return r;\n}\n\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\n{\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\n      stbi__rewind( j->s );\n      return 0;\n   }\n   if (x) *x = j->s->img_x;\n   if (y) *y = j->s->img_y;\n   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\n   return 1;\n}\n\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int result;\n   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));\n   if (!j) return stbi__err(\"outofmem\", \"Out of memory\");\n   j->s = s;\n   result = stbi__jpeg_info_raw(j, x, y, comp);\n   STBI_FREE(j);\n   return result;\n}\n#endif\n\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\n//    simple implementation\n//      - all input must be provided in an upfront buffer\n//      - all output is written to a single output buffer (can malloc/realloc)\n//    performance\n//      - fast huffman\n\n#ifndef STBI_NO_ZLIB\n\n// fast-way is faster to check than jpeg huffman, but slow way is slower\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\n#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet\n\n// zlib-style huffman encoding\n// (jpegs packs from left, zlib from right, so can't share code)\ntypedef struct\n{\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\n   stbi__uint16 firstcode[16];\n   int maxcode[17];\n   stbi__uint16 firstsymbol[16];\n   stbi_uc  size[STBI__ZNSYMS];\n   stbi__uint16 value[STBI__ZNSYMS];\n} stbi__zhuffman;\n\nstbi_inline static int stbi__bitreverse16(int n)\n{\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\n  return n;\n}\n\nstbi_inline static int stbi__bit_reverse(int v, int bits)\n{\n   STBI_ASSERT(bits <= 16);\n   // to bit reverse n bits, reverse 16 and shift\n   // e.g. 11 bits, bit reverse and shift away 5\n   return stbi__bitreverse16(v) >> (16-bits);\n}\n\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)\n{\n   int i,k=0;\n   int code, next_code[16], sizes[17];\n\n   // DEFLATE spec for generating codes\n   MemSet(sizes, 0, sizeof(sizes));\n   MemSet(z->fast, 0, sizeof(z->fast));\n   for (i=0; i < num; ++i)\n      ++sizes[sizelist[i]];\n   sizes[0] = 0;\n   for (i=1; i < 16; ++i)\n      if (sizes[i] > (1 << i))\n         return stbi__err(\"bad sizes\", \"Corrupt PNG\");\n   code = 0;\n   for (i=1; i < 16; ++i) {\n      next_code[i] = code;\n      z->firstcode[i] = (stbi__uint16) code;\n      z->firstsymbol[i] = (stbi__uint16) k;\n      code = (code + sizes[i]);\n      if (sizes[i])\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\n      code <<= 1;\n      k += sizes[i];\n   }\n   z->maxcode[16] = 0x10000; // sentinel\n   for (i=0; i < num; ++i) {\n      int s = sizelist[i];\n      if (s) {\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\n         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);\n         z->size [c] = (stbi_uc     ) s;\n         z->value[c] = (stbi__uint16) i;\n         if (s <= STBI__ZFAST_BITS) {\n            int j = stbi__bit_reverse(next_code[s],s);\n            while (j < (1 << STBI__ZFAST_BITS)) {\n               z->fast[j] = fastv;\n               j += (1 << s);\n            }\n         }\n         ++next_code[s];\n      }\n   }\n   return 1;\n}\n\n// zlib-from-memory implementation for PNG reading\n//    because PNG allows splitting the zlib stream arbitrarily,\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\n//    we require PNG read all the IDATs and combine them into a single\n//    memory buffer\n\ntypedef struct\n{\n   stbi_uc *zbuffer, *zbuffer_end;\n   int num_bits;\n   stbi__uint32 code_buffer;\n\n   char *zout;\n   char *zout_start;\n   char *zout_end;\n   int   z_expandable;\n\n   stbi__zhuffman z_length, z_distance;\n} stbi__zbuf;\n\nstbi_inline static int stbi__zeof(stbi__zbuf *z)\n{\n   return (z->zbuffer >= z->zbuffer_end);\n}\n\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\n{\n   return stbi__zeof(z) ? 0 : *z->zbuffer++;\n}\n\nstatic void stbi__fill_bits(stbi__zbuf *z)\n{\n   do {\n      if (z->code_buffer >= (1U << z->num_bits)) {\n        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */\n        return;\n      }\n      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;\n      z->num_bits += 8;\n   } while (z->num_bits <= 24);\n}\n\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\n{\n   unsigned int k;\n   if (z->num_bits < n) stbi__fill_bits(z);\n   k = z->code_buffer & ((1 << n) - 1);\n   z->code_buffer >>= n;\n   z->num_bits -= n;\n   return k;\n}\n\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s,k;\n   // not resolved by fast table, so compute it the slow way\n   // use jpeg approach, which requires MSbits at top\n   k = stbi__bit_reverse(a->code_buffer, 16);\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\n      if (k < z->maxcode[s])\n         break;\n   if (s >= 16) return -1; // invalid code!\n   // code size is s, so:\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\n   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!\n   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.\n   a->code_buffer >>= s;\n   a->num_bits -= s;\n   return z->value[b];\n}\n\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s;\n   if (a->num_bits < 16) {\n      if (stbi__zeof(a)) {\n         return -1;   /* report error for unexpected end of data. */\n      }\n      stbi__fill_bits(a);\n   }\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\n   if (b) {\n      s = b >> 9;\n      a->code_buffer >>= s;\n      a->num_bits -= s;\n      return b & 511;\n   }\n   return stbi__zhuffman_decode_slowpath(a, z);\n}\n\nstatic int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes\n{\n   char *q;\n   unsigned int cur, limit, old_limit;\n   z->zout = zout;\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\n   cur   = (unsigned int) (z->zout - z->zout_start);\n   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);\n   if (STBI_UINT_MAX - cur < (unsigned) n) return stbi__err(\"outofmem\", \"Out of memory\");\n   while (cur + n > limit) {\n      if(limit > STBI_UINT_MAX / 2) return stbi__err(\"outofmem\", \"Out of memory\");\n      limit *= 2;\n   }\n   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\n   STBI_NOTUSED(old_limit);\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n   z->zout_start = q;\n   z->zout       = q + cur;\n   z->zout_end   = q + limit;\n   return 1;\n}\n\nstatic const int stbi__zlength_base[31] = {\n   3,4,5,6,7,8,9,10,11,13,\n   15,17,19,23,27,31,35,43,51,59,\n   67,83,99,115,131,163,195,227,258,0,0 };\n\nstatic const int stbi__zlength_extra[31]=\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n\nstatic const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n\nstatic const int stbi__zdist_extra[32] =\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\n{\n   char *zout = a->zout;\n   for(;;) {\n      int z = stbi__zhuffman_decode(a, &a->z_length);\n      if (z < 256) {\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\n         if (zout >= a->zout_end) {\n            if (!stbi__zexpand(a, zout, 1)) return 0;\n            zout = a->zout;\n         }\n         *zout++ = (char) z;\n      } else {\n         stbi_uc *p;\n         int len,dist;\n         if (z == 256) {\n            a->zout = zout;\n            return 1;\n         }\n         z -= 257;\n         len = stbi__zlength_base[z];\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\n         z = stbi__zhuffman_decode(a, &a->z_distance);\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\");\n         dist = stbi__zdist_base[z];\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\n         if (zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\n         if (zout + len > a->zout_end) {\n            if (!stbi__zexpand(a, zout, len)) return 0;\n            zout = a->zout;\n         }\n         p = (stbi_uc *) (zout - dist);\n         if (dist == 1) { // run of one byte; common in images.\n            stbi_uc v = *p;\n            if (len) { do *zout++ = v; while (--len); }\n         } else {\n            if (len) { do *zout++ = *p++; while (--len); }\n         }\n      }\n   }\n}\n\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\n{\n   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n   stbi__zhuffman z_codelength;\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\n   stbi_uc codelength_sizes[19];\n   int i,n;\n\n   int hlit  = stbi__zreceive(a,5) + 257;\n   int hdist = stbi__zreceive(a,5) + 1;\n   int hclen = stbi__zreceive(a,4) + 4;\n   int ntot  = hlit + hdist;\n\n   MemSet(codelength_sizes, 0, sizeof(codelength_sizes));\n   for (i=0; i < hclen; ++i) {\n      int s = stbi__zreceive(a,3);\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\n   }\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\n\n   n = 0;\n   while (n < ntot) {\n      int c = stbi__zhuffman_decode(a, &z_codelength);\n      if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n      if (c < 16)\n         lencodes[n++] = (stbi_uc) c;\n      else {\n         stbi_uc fill = 0;\n         if (c == 16) {\n            c = stbi__zreceive(a,2)+3;\n            if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n            fill = lencodes[n-1];\n         } else if (c == 17) {\n            c = stbi__zreceive(a,3)+3;\n         } else if (c == 18) {\n            c = stbi__zreceive(a,7)+11;\n         } else {\n            return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         }\n         if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\n         MemSet(lencodes+n, fill, c);\n         n += c;\n      }\n   }\n   if (n != ntot) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\n   return 1;\n}\n\nstatic int stbi__parse_uncompressed_block(stbi__zbuf *a)\n{\n   stbi_uc header[4];\n   int len,nlen,k;\n   if (a->num_bits & 7)\n      stbi__zreceive(a, a->num_bits & 7); // discard\n   // drain the bit-packed data into header\n   k = 0;\n   while (a->num_bits > 0) {\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\n      a->code_buffer >>= 8;\n      a->num_bits -= 8;\n   }\n   if (a->num_bits < 0) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   // now fill header the normal way\n   while (k < 4)\n      header[k++] = stbi__zget8(a);\n   len  = header[1] * 256 + header[0];\n   nlen = header[3] * 256 + header[2];\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\n   if (a->zout + len > a->zout_end)\n      if (!stbi__zexpand(a, a->zout, len)) return 0;\n   MemCopy(a->zout, a->zbuffer, len);\n   a->zbuffer += len;\n   a->zout += len;\n   return 1;\n}\n\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\n{\n   int cmf   = stbi__zget8(a);\n   int cm    = cmf & 15;\n   /* int cinfo = cmf >> 4; */\n   int flg   = stbi__zget8(a);\n   if (stbi__zeof(a)) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\n   return 1;\n}\n\nstatic const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =\n{\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\n};\nstatic const stbi_uc stbi__zdefault_distance[32] =\n{\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\n};\n/*\nInit algorithm:\n{\n   int i;   // use <= to match clearly with spec\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\n\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\n}\n*/\n\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\n{\n   int final, type;\n   if (parse_header)\n      if (!stbi__parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   do {\n      final = stbi__zreceive(a,1);\n      type = stbi__zreceive(a,2);\n      if (type == 0) {\n         if (!stbi__parse_uncompressed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\n         } else {\n            if (!stbi__compute_huffman_codes(a)) return 0;\n         }\n         if (!stbi__parse_huffman_block(a)) return 0;\n      }\n   } while (!final);\n   return 1;\n}\n\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\n{\n   a->zout_start = obuf;\n   a->zout       = obuf;\n   a->zout_end   = obuf + olen;\n   a->z_expandable = exp;\n\n   return stbi__parse_zlib(a, parse_header);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\n{\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(16384);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer+len;\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      STBI_FREE(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n#endif\n\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\n//    simple implementation\n//      - only 8-bit samples\n//      - no CRC checking\n//      - allocates lots of intermediate memory\n//        - avoids problem of streaming data between subsystems\n//        - avoids explicit window management\n//    performance\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\n\n#ifndef STBI_NO_PNG\ntypedef struct\n{\n   stbi__uint32 length;\n   stbi__uint32 type;\n} stbi__pngchunk;\n\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\n{\n   stbi__pngchunk c;\n   c.length = stbi__get32be(s);\n   c.type   = stbi__get32be(s);\n   return c;\n}\n\nstatic int stbi__check_png_header(stbi__context *s)\n{\n   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\n   int i;\n   for (i=0; i < 8; ++i)\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\n   return 1;\n}\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi_uc *idata, *expanded, *out;\n   int depth;\n} stbi__png;\n\n\nenum {\n   STBI__F_none=0,\n   STBI__F_sub=1,\n   STBI__F_up=2,\n   STBI__F_avg=3,\n   STBI__F_paeth=4,\n   // synthetic filters used for first scanline to avoid needing a dummy row of 0s\n   STBI__F_avg_first,\n   STBI__F_paeth_first\n};\n\nstatic stbi_uc first_row_filter[5] =\n{\n   STBI__F_none,\n   STBI__F_sub,\n   STBI__F_none,\n   STBI__F_avg_first,\n   STBI__F_paeth_first\n};\n\nstatic int stbi__paeth(int a, int b, int c)\n{\n   int p = a + b - c;\n   int pa = MathAbsI(p-a);\n   int pb = MathAbsI(p-b);\n   int pc = MathAbsI(p-c);\n   if (pa <= pb && pa <= pc) return a;\n   if (pb <= pc) return b;\n   return c;\n}\n\nstatic const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\n\n// create the png data from post-deflated data\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\n{\n   int bytes = (depth == 16? 2 : 1);\n   stbi__context *s = a->s;\n   stbi__uint32 i,j,stride = x*out_n*bytes;\n   stbi__uint32 img_len, img_width_bytes;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n\n   int output_bytes = out_n*bytes;\n   int filter_bytes = img_n*bytes;\n   int width = x;\n\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\n   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err(\"too large\", \"Corrupt PNG\");\n   img_width_bytes = (((img_n * x * depth) + 7) >> 3);\n   img_len = (img_width_bytes + 1) * y;\n\n   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\n   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\n   // so just check for raw_len < img_len always.\n   if (raw_len < img_len) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\n\n   for (j=0; j < y; ++j) {\n      stbi_uc *cur = a->out + stride*j;\n      stbi_uc *prior;\n      int filter = *raw++;\n\n      if (filter > 4)\n         return stbi__err(\"invalid filter\",\"Corrupt PNG\");\n\n      if (depth < 8) {\n         if (img_width_bytes > x) return stbi__err(\"invalid width\",\"Corrupt PNG\");\n         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place\n         filter_bytes = 1;\n         width = img_width_bytes;\n      }\n      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above\n\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n\n      // handle first byte explicitly\n      for (k=0; k < filter_bytes; ++k) {\n         switch (filter) {\n            case STBI__F_none       : cur[k] = raw[k]; break;\n            case STBI__F_sub        : cur[k] = raw[k]; break;\n            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\n            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;\n            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;\n            case STBI__F_avg_first  : cur[k] = raw[k]; break;\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n\n      if (depth == 8) {\n         if (img_n != out_n)\n            cur[img_n] = 255; // first pixel\n         raw += img_n;\n         cur += out_n;\n         prior += out_n;\n      } else if (depth == 16) {\n         if (img_n != out_n) {\n            cur[filter_bytes]   = 255; // first pixel top byte\n            cur[filter_bytes+1] = 255; // first pixel bottom byte\n         }\n         raw += filter_bytes;\n         cur += output_bytes;\n         prior += output_bytes;\n      } else {\n         raw += 1;\n         cur += 1;\n         prior += 1;\n      }\n\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (depth < 8 || img_n == out_n) {\n         int nk = (width - 1)*filter_bytes;\n         #define STBI__CASE(f) \\\n             case f:     \\\n                for (k=0; k < nk; ++k)\n         switch (filter) {\n            // \"none\" filter turns into a MemCopy here; make that explicit.\n            case STBI__F_none:         MemCopy(cur, raw, nk); break;\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;\n         }\n         #undef STBI__CASE\n         raw += nk;\n      } else {\n         STBI_ASSERT(img_n+1 == out_n);\n         #define STBI__CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \\\n                   for (k=0; k < filter_bytes; ++k)\n         switch (filter) {\n            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;\n         }\n         #undef STBI__CASE\n\n         // the loop above sets the high byte of the pixels' alpha, but for\n         // 16 bit png files we also need the low byte set. we'll do that here.\n         if (depth == 16) {\n            cur = a->out + stride*j; // start at the beginning of the row again\n            for (i=0; i < x; ++i,cur+=output_bytes) {\n               cur[filter_bytes+1] = 255;\n            }\n         }\n      }\n   }\n\n   // we make a separate pass to expand bits to pixels; for performance,\n   // this could run two scanlines behind the above code, so it won't\n   // intefere with filtering but will still be in the cache.\n   if (depth < 8) {\n      for (j=0; j < y; ++j) {\n         stbi_uc *cur = a->out + stride*j;\n         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;\n         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit\n         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop\n         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\n\n         // note that the final byte might overshoot and write more data than desired.\n         // we can allocate enough data that this never writes out of memory, but it\n         // could also overwrite the next scanline. can it overwrite non-empty data\n         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.\n         // so we need to explicitly clamp the final ones\n\n         if (depth == 4) {\n            for (k=x*img_n; k >= 2; k-=2, ++in) {\n               *cur++ = scale * ((*in >> 4)       );\n               *cur++ = scale * ((*in     ) & 0x0f);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 4)       );\n         } else if (depth == 2) {\n            for (k=x*img_n; k >= 4; k-=4, ++in) {\n               *cur++ = scale * ((*in >> 6)       );\n               *cur++ = scale * ((*in >> 4) & 0x03);\n               *cur++ = scale * ((*in >> 2) & 0x03);\n               *cur++ = scale * ((*in     ) & 0x03);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 6)       );\n            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);\n            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);\n         } else if (depth == 1) {\n            for (k=x*img_n; k >= 8; k-=8, ++in) {\n               *cur++ = scale * ((*in >> 7)       );\n               *cur++ = scale * ((*in >> 6) & 0x01);\n               *cur++ = scale * ((*in >> 5) & 0x01);\n               *cur++ = scale * ((*in >> 4) & 0x01);\n               *cur++ = scale * ((*in >> 3) & 0x01);\n               *cur++ = scale * ((*in >> 2) & 0x01);\n               *cur++ = scale * ((*in >> 1) & 0x01);\n               *cur++ = scale * ((*in     ) & 0x01);\n            }\n            if (k > 0) *cur++ = scale * ((*in >> 7)       );\n            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);\n            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);\n            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);\n            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);\n            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);\n            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);\n         }\n         if (img_n != out_n) {\n            int q;\n            // insert alpha = 255\n            cur = a->out + stride*j;\n            if (img_n == 1) {\n               for (q=x-1; q >= 0; --q) {\n                  cur[q*2+1] = 255;\n                  cur[q*2+0] = cur[q];\n               }\n            } else {\n               STBI_ASSERT(img_n == 3);\n               for (q=x-1; q >= 0; --q) {\n                  cur[q*4+3] = 255;\n                  cur[q*4+2] = cur[q*3+2];\n                  cur[q*4+1] = cur[q*3+1];\n                  cur[q*4+0] = cur[q*3+0];\n               }\n            }\n         }\n      }\n   } else if (depth == 16) {\n      // force the image data from big-endian to platform-native.\n      // this is done in a separate pass due to the decoding relying\n      // on the data being untouched, but could probably be done\n      // per-line during decode if care is taken.\n      stbi_uc *cur = a->out;\n      stbi__uint16 *cur16 = (stbi__uint16*)cur;\n\n      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {\n         *cur16 = (cur[0] << 8) | cur[1];\n      }\n   }\n\n   return 1;\n}\n\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\n{\n   int bytes = (depth == 16 ? 2 : 1);\n   int out_bytes = out_n * bytes;\n   stbi_uc *final;\n   int p;\n   if (!interlaced)\n      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\n\n   // de-interlacing\n   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\n   if (!final) return stbi__err(\"outofmem\", \"Out of memory\");\n   for (p=0; p < 7; ++p) {\n      int xorig[] = { 0,4,0,2,0,1,0 };\n      int yorig[] = { 0,0,4,0,2,0,1 };\n      int xspc[]  = { 8,8,4,4,2,2,1 };\n      int yspc[]  = { 8,8,8,4,4,2,2 };\n      int i,j,x,y;\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\n      if (x && y) {\n         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\n         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\n            STBI_FREE(final);\n            return 0;\n         }\n         for (j=0; j < y; ++j) {\n            for (i=0; i < x; ++i) {\n               int out_y = j*yspc[p]+yorig[p];\n               int out_x = i*xspc[p]+xorig[p];\n               MemCopy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,\n                      a->out + (j*x+i)*out_bytes, out_bytes);\n            }\n         }\n         STBI_FREE(a->out);\n         image_data += img_len;\n         image_data_len -= img_len;\n      }\n   }\n   a->out = final;\n\n   return 1;\n}\n\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 255 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i=0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 255);\n         p += 2;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi__uint16 *p = (stbi__uint16*) z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 65535 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i = 0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 65535);\n         p += 2;\n      }\n   } else {\n      for (i = 0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\n{\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\n   stbi_uc *p, *temp_out, *orig = a->out;\n\n   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // between here and free(out) below, exitting would leak\n   temp_out = p;\n\n   if (pal_img_n == 3) {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p += 3;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p[3] = palette[n+3];\n         p += 4;\n      }\n   }\n   STBI_FREE(a->out);\n   a->out = temp_out;\n\n   STBI_NOTUSED(len);\n\n   return 1;\n}\n\nstatic int stbi__unpremultiply_on_load_global = 0;\nstatic int stbi__de_iphone_flag_global = 0;\n\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_global = flag_true_if_should_convert;\n}\n\n#ifndef STBI_THREAD_LOCAL\n#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global\n#define stbi__de_iphone_flag  stbi__de_iphone_flag_global\n#else\nstatic STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;\nstatic STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;\n\nSTBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;\n   stbi__unpremultiply_on_load_set = 1;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag_local = flag_true_if_should_convert;\n   stbi__de_iphone_flag_set = 1;\n}\n\n#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \\\n                                       ? stbi__unpremultiply_on_load_local      \\\n                                       : stbi__unpremultiply_on_load_global)\n#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \\\n                                ? stbi__de_iphone_flag_local                    \\\n                                : stbi__de_iphone_flag_global)\n#endif // STBI_THREAD_LOCAL\n\nstatic void stbi__de_iphone(stbi__png *z)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   if (s->img_out_n == 3) {  // convert bgr to rgb\n      for (i=0; i < pixel_count; ++i) {\n         stbi_uc t = p[0];\n         p[0] = p[2];\n         p[2] = t;\n         p += 3;\n      }\n   } else {\n      STBI_ASSERT(s->img_out_n == 4);\n      if (stbi__unpremultiply_on_load) {\n         // convert bgr to rgb and unpremultiply\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc a = p[3];\n            stbi_uc t = p[0];\n            if (a) {\n               stbi_uc half = a / 2;\n               p[0] = (p[2] * 255 + half) / a;\n               p[1] = (p[1] * 255 + half) / a;\n               p[2] = ( t   * 255 + half) / a;\n            } else {\n               p[0] = p[2];\n               p[2] = t;\n            }\n            p += 4;\n         }\n      } else {\n         // convert bgr to rgb\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc t = p[0];\n            p[0] = p[2];\n            p[2] = t;\n            p += 4;\n         }\n      }\n   }\n}\n\n#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))\n\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\n{\n   stbi_uc palette[1024], pal_img_n=0;\n   stbi_uc has_trans=0, tc[3]={0};\n   stbi__uint16 tc16[3];\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\n   int first=1,k,interlace=0, color=0, is_iphone=0;\n   stbi__context *s = z->s;\n\n   z->expanded = NULL;\n   z->idata = NULL;\n   z->out = NULL;\n\n   if (!stbi__check_png_header(s)) return 0;\n\n   if (scan == STBI__SCAN_type) return 1;\n\n   for (;;) {\n      stbi__pngchunk c = stbi__get_chunk_header(s);\n      switch (c.type) {\n         case STBI__PNG_TYPE('C','g','B','I'):\n            is_iphone = 1;\n            stbi__skip(s, c.length);\n            break;\n         case STBI__PNG_TYPE('I','H','D','R'): {\n            int comp,filter;\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\n            first = 0;\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\n            s->img_x = stbi__get32be(s);\n            s->img_y = stbi__get32be(s);\n            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\",\"PNG not supported: 1/2/4/8/16-bit only\");\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\n            if (!pal_img_n) {\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\n               if (scan == STBI__SCAN_header) return 1;\n            } else {\n               // if paletted, then pal_n is our final components, and\n               // img_n is # components to decompress/filter.\n               s->img_n = 1;\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\n               // if SCAN_header, have to scan to see if we have a tRNS\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('P','L','T','E'):  {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            pal_len = c.length / 3;\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            for (i=0; i < pal_len; ++i) {\n               palette[i*4+0] = stbi__get8(s);\n               palette[i*4+1] = stbi__get8(s);\n               palette[i*4+2] = stbi__get8(s);\n               palette[i*4+3] = 255;\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('t','R','N','S'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\n            if (pal_img_n) {\n               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               pal_img_n = 4;\n               for (i=0; i < c.length; ++i)\n                  palette[i*4+3] = stbi__get8(s);\n            } else {\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               has_trans = 1;\n               if (z->depth == 16) {\n                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\n               } else {\n                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\n               }\n            }\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','D','A','T'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\n            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\n            if (ioff + c.length > idata_limit) {\n               stbi__uint32 idata_limit_old = idata_limit;\n               stbi_uc *p;\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\n               while (ioff + c.length > idata_limit)\n                  idata_limit *= 2;\n               STBI_NOTUSED(idata_limit_old);\n               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n               z->idata = p;\n            }\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\n            ioff += c.length;\n            break;\n         }\n\n         case STBI__PNG_TYPE('I','E','N','D'): {\n            stbi__uint32 raw_len, bpl;\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (scan != STBI__SCAN_load) return 1;\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\n            // initial guess for decoded data size to avoid unnecessary reallocs\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);\n            if (z->expanded == NULL) return 0; // zlib should set error\n            STBI_FREE(z->idata); z->idata = NULL;\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\n               s->img_out_n = s->img_n+1;\n            else\n               s->img_out_n = s->img_n;\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\n            if (has_trans) {\n               if (z->depth == 16) {\n                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\n               } else {\n                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\n               }\n            }\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\n               stbi__de_iphone(z);\n            if (pal_img_n) {\n               // pal_img_n == 3 or 4\n               s->img_n = pal_img_n; // record the actual colors we had\n               s->img_out_n = pal_img_n;\n               if (req_comp >= 3) s->img_out_n = req_comp;\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\n                  return 0;\n            } else if (has_trans) {\n               // non-paletted image with tRNS -> source image has (constant) alpha\n               ++s->img_n;\n            }\n            STBI_FREE(z->expanded); z->expanded = NULL;\n            // end of PNG chunk, read and skip CRC\n            stbi__get32be(s);\n            return 1;\n         }\n\n         default:\n            // if critical, fail\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if ((c.type & (1 << 29)) == 0) {\n               #ifndef STBI_NO_FAILURE_STRINGS\n               // not threadsafe\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\n               #endif\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\n            }\n            stbi__skip(s, c.length);\n            break;\n      }\n      // end of PNG chunk, read and skip CRC\n      stbi__get32be(s);\n   }\n}\n\nstatic void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)\n{\n   void *result=NULL;\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\n      if (p->depth <= 8)\n         ri->bits_per_channel = 8;\n      else if (p->depth == 16)\n         ri->bits_per_channel = 16;\n      else\n         return stbi__errpuc(\"bad bits_per_channel\", \"PNG not supported: unsupported color depth\");\n      result = p->out;\n      p->out = NULL;\n      if (req_comp && req_comp != p->s->img_out_n) {\n         if (ri->bits_per_channel == 8)\n            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         else\n            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         p->s->img_out_n = req_comp;\n         if (result == NULL) return result;\n      }\n      *x = p->s->img_x;\n      *y = p->s->img_y;\n      if (n) *n = p->s->img_n;\n   }\n   STBI_FREE(p->out);      p->out      = NULL;\n   STBI_FREE(p->expanded); p->expanded = NULL;\n   STBI_FREE(p->idata);    p->idata    = NULL;\n\n   return result;\n}\n\nstatic void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__do_png(&p, x,y,comp,req_comp, ri);\n}\n\nstatic int stbi__png_test(stbi__context *s)\n{\n   int r;\n   r = stbi__check_png_header(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\n{\n   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\n      stbi__rewind( p->s );\n      return 0;\n   }\n   if (x) *x = p->s->img_x;\n   if (y) *y = p->s->img_y;\n   if (comp) *comp = p->s->img_n;\n   return 1;\n}\n\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__png_info_raw(&p, x, y, comp);\n}\n\nstatic int stbi__png_is16(stbi__context *s)\n{\n   stbi__png p;\n   p.s = s;\n   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))\n\t   return 0;\n   if (p.depth != 16) {\n      stbi__rewind(p.s);\n      return 0;\n   }\n   return 1;\n}\n#endif\n\n// Microsoft/Windows BMP image\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_test_raw(stbi__context *s)\n{\n   int r;\n   int sz;\n   if (stbi__get8(s) != 'B') return 0;\n   if (stbi__get8(s) != 'M') return 0;\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   stbi__get32le(s); // discard data offset\n   sz = stbi__get32le(s);\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\n   return r;\n}\n\nstatic int stbi__bmp_test(stbi__context *s)\n{\n   int r = stbi__bmp_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\n\n// returns 0..31 for the highest set bit\nstatic int stbi__high_bit(unsigned int z)\n{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) { n += 16; z >>= 16; }\n   if (z >= 0x00100) { n +=  8; z >>=  8; }\n   if (z >= 0x00010) { n +=  4; z >>=  4; }\n   if (z >= 0x00004) { n +=  2; z >>=  2; }\n   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }\n   return n;\n}\n\nstatic int stbi__bitcount(unsigned int a)\n{\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\n   a = (a + (a >> 8)); // max 16 per 8 bits\n   a = (a + (a >> 16)); // max 32 per 8 bits\n   return a & 0xff;\n}\n\n// extract an arbitrarily-aligned N-bit value (N=bits)\n// from v, and then make it 8-bits long and fractionally\n// extend it to full full range.\nstatic int stbi__shiftsigned(unsigned int v, int shift, int bits)\n{\n   static unsigned int mul_table[9] = {\n      0,\n      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,\n      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,\n   };\n   static unsigned int shift_table[9] = {\n      0, 0,0,1,0,2,4,6,0,\n   };\n   if (shift < 0)\n      v <<= -shift;\n   else\n      v >>= shift;\n   STBI_ASSERT(v < 256);\n   v >>= (8-bits);\n   STBI_ASSERT(bits >= 0 && bits <= 8);\n   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];\n}\n\ntypedef struct\n{\n   int bpp, offset, hsz;\n   unsigned int mr,mg,mb,ma, all_a;\n   int extra_read;\n} stbi__bmp_data;\n\nstatic int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)\n{\n   // BI_BITFIELDS specifies masks explicitly, don't override\n   if (compress == 3)\n      return 1;\n\n   if (compress == 0) {\n      if (info->bpp == 16) {\n         info->mr = 31u << 10;\n         info->mg = 31u <<  5;\n         info->mb = 31u <<  0;\n      } else if (info->bpp == 32) {\n         info->mr = 0xffu << 16;\n         info->mg = 0xffu <<  8;\n         info->mb = 0xffu <<  0;\n         info->ma = 0xffu << 24;\n         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\n      } else {\n         // otherwise, use defaults, which is all-0\n         info->mr = info->mg = info->mb = info->ma = 0;\n      }\n      return 1;\n   }\n   return 0; // error\n}\n\nstatic void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)\n{\n   int hsz;\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   info->offset = stbi__get32le(s);\n   info->hsz = hsz = stbi__get32le(s);\n   info->mr = info->mg = info->mb = info->ma = 0;\n   info->extra_read = 14;\n\n   if (info->offset < 0) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\n   if (hsz == 12) {\n      s->img_x = stbi__get16le(s);\n      s->img_y = stbi__get16le(s);\n   } else {\n      s->img_x = stbi__get32le(s);\n      s->img_y = stbi__get32le(s);\n   }\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n   info->bpp = stbi__get16le(s);\n   if (hsz != 12) {\n      int compress = stbi__get32le(s);\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\n      if (compress >= 4) return stbi__errpuc(\"BMP JPEG/PNG\", \"BMP type not supported: unsupported compression\"); // this includes PNG/JPEG modes\n      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc(\"bad BMP\", \"bad BMP\"); // bitfields requires 16 or 32 bits/pixel\n      stbi__get32le(s); // discard sizeof\n      stbi__get32le(s); // discard hres\n      stbi__get32le(s); // discard vres\n      stbi__get32le(s); // discard colorsused\n      stbi__get32le(s); // discard max important\n      if (hsz == 40 || hsz == 56) {\n         if (hsz == 56) {\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n         }\n         if (info->bpp == 16 || info->bpp == 32) {\n            if (compress == 0) {\n               stbi__bmp_set_mask_defaults(info, compress);\n            } else if (compress == 3) {\n               info->mr = stbi__get32le(s);\n               info->mg = stbi__get32le(s);\n               info->mb = stbi__get32le(s);\n               info->extra_read += 12;\n               // not documented, but generated by photoshop and handled by mspaint\n               if (info->mr == info->mg && info->mg == info->mb) {\n                  // ?!?!?\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n               }\n            } else\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         }\n      } else {\n         // V4/V5 header\n         int i;\n         if (hsz != 108 && hsz != 124)\n            return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         info->mr = stbi__get32le(s);\n         info->mg = stbi__get32le(s);\n         info->mb = stbi__get32le(s);\n         info->ma = stbi__get32le(s);\n         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs\n            stbi__bmp_set_mask_defaults(info, compress);\n         stbi__get32le(s); // discard color space\n         for (i=0; i < 12; ++i)\n            stbi__get32le(s); // discard color space parameters\n         if (hsz == 124) {\n            stbi__get32le(s); // discard rendering intent\n            stbi__get32le(s); // discard offset of profile data\n            stbi__get32le(s); // discard size of profile data\n            stbi__get32le(s); // discard reserved\n         }\n      }\n   }\n   return (void *) 1;\n}\n\n\nstatic void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;\n   stbi_uc pal[256][4];\n   int psize=0,i,j,width;\n   int flip_vertically, pad, target;\n   stbi__bmp_data info;\n   STBI_NOTUSED(ri);\n\n   info.all_a = 255;\n   if (stbi__bmp_parse_header(s, &info) == NULL)\n      return NULL; // error code already set\n\n   flip_vertically = ((int) s->img_y) > 0;\n   s->img_y = MathAbsI((int) s->img_y);\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   mr = info.mr;\n   mg = info.mg;\n   mb = info.mb;\n   ma = info.ma;\n   all_a = info.all_a;\n\n   if (info.hsz == 12) {\n      if (info.bpp < 24)\n         psize = (info.offset - info.extra_read - 24) / 3;\n   } else {\n      if (info.bpp < 16)\n         psize = (info.offset - info.extra_read - info.hsz) >> 2;\n   }\n   if (psize == 0) {\n      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {\n        return stbi__errpuc(\"bad offset\", \"Corrupt BMP\");\n      }\n   }\n\n   if (info.bpp == 24 && ma == 0xff000000)\n      s->img_n = 3;\n   else\n      s->img_n = ma ? 4 : 3;\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\n      target = req_comp;\n   else\n      target = s->img_n; // if they want monochrome, we'll post-convert\n\n   // sanity-check size\n   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt BMP\");\n\n   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (info.bpp < 16) {\n      int z=0;\n      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\n      for (i=0; i < psize; ++i) {\n         pal[i][2] = stbi__get8(s);\n         pal[i][1] = stbi__get8(s);\n         pal[i][0] = stbi__get8(s);\n         if (info.hsz != 12) stbi__get8(s);\n         pal[i][3] = 255;\n      }\n      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\n      if (info.bpp == 1) width = (s->img_x + 7) >> 3;\n      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;\n      else if (info.bpp == 8) width = s->img_x;\n      else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\n      pad = (-width)&3;\n      if (info.bpp == 1) {\n         for (j=0; j < (int) s->img_y; ++j) {\n            int bit_offset = 7, v = stbi__get8(s);\n            for (i=0; i < (int) s->img_x; ++i) {\n               int color = (v>>bit_offset)&0x1;\n               out[z++] = pal[color][0];\n               out[z++] = pal[color][1];\n               out[z++] = pal[color][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               if((--bit_offset) < 0) {\n                  bit_offset = 7;\n                  v = stbi__get8(s);\n               }\n            }\n            stbi__skip(s, pad);\n         }\n      } else {\n         for (j=0; j < (int) s->img_y; ++j) {\n            for (i=0; i < (int) s->img_x; i += 2) {\n               int v=stbi__get8(s),v2=0;\n               if (info.bpp == 4) {\n                  v2 = v & 15;\n                  v >>= 4;\n               }\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n               if (i+1 == (int) s->img_x) break;\n               v = (info.bpp == 8) ? stbi__get8(s) : v2;\n               out[z++] = pal[v][0];\n               out[z++] = pal[v][1];\n               out[z++] = pal[v][2];\n               if (target == 4) out[z++] = 255;\n            }\n            stbi__skip(s, pad);\n         }\n      }\n   } else {\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\n      int z = 0;\n      int easy=0;\n      stbi__skip(s, info.offset - info.extra_read - info.hsz);\n      if (info.bpp == 24) width = 3 * s->img_x;\n      else if (info.bpp == 16) width = 2*s->img_x;\n      else /* bpp = 32 and pad = 0 */ width=0;\n      pad = (-width) & 3;\n      if (info.bpp == 24) {\n         easy = 1;\n      } else if (info.bpp == 32) {\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\n            easy = 2;\n      }\n      if (!easy) {\n         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n         // right shift amt to put high bit in position #7\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\n         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n      }\n      for (j=0; j < (int) s->img_y; ++j) {\n         if (easy) {\n            for (i=0; i < (int) s->img_x; ++i) {\n               unsigned char a;\n               out[z+2] = stbi__get8(s);\n               out[z+1] = stbi__get8(s);\n               out[z+0] = stbi__get8(s);\n               z += 3;\n               a = (easy == 2 ? stbi__get8(s) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = a;\n            }\n         } else {\n            int bpp = info.bpp;\n            for (i=0; i < (int) s->img_x; ++i) {\n               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));\n               unsigned int a;\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\n               all_a |= a;\n               if (target == 4) out[z++] = STBI__BYTECAST(a);\n            }\n         }\n         stbi__skip(s, pad);\n      }\n   }\n\n   // if alpha channel is all 0s, replace with all 255s\n   if (target == 4 && all_a == 0)\n      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)\n         out[i] = 255;\n\n   if (flip_vertically) {\n      stbi_uc t;\n      for (j=0; j < (int) s->img_y>>1; ++j) {\n         stbi_uc *p1 = out +      j     *s->img_x*target;\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\n         for (i=0; i < (int) s->img_x*target; ++i) {\n            t = p1[i]; p1[i] = p2[i]; p2[i] = t;\n         }\n      }\n   }\n\n   if (req_comp && req_comp != target) {\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n   return out;\n}\n#endif\n\n// Targa Truevision - TGA\n// by Jonathan Dummer\n#ifndef STBI_NO_TGA\n// returns STBI_rgb or whatever, 0 on error\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\n{\n   // only RGB or RGBA (incl. 16bit) or grey allowed\n   if (is_rgb16) *is_rgb16 = 0;\n   switch(bits_per_pixel) {\n      case 8:  return STBI_grey;\n      case 16: if(is_grey) return STBI_grey_alpha;\n               // fallthrough\n      case 15: if(is_rgb16) *is_rgb16 = 1;\n               return STBI_rgb;\n      case 24: // fallthrough\n      case 32: return bits_per_pixel/8;\n      default: return 0;\n   }\n}\n\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\n{\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\n    int sz, tga_colormap_type;\n    stbi__get8(s);                   // discard Offset\n    tga_colormap_type = stbi__get8(s); // colormap type\n    if( tga_colormap_type > 1 ) {\n        stbi__rewind(s);\n        return 0;      // only RGB or indexed allowed\n    }\n    tga_image_type = stbi__get8(s); // image type\n    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image\n        if (tga_image_type != 1 && tga_image_type != 9) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n        sz = stbi__get8(s);    //   check bits per palette color entry\n        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {\n            stbi__rewind(s);\n            return 0;\n        }\n        stbi__skip(s,4);       // skip image x and y origin\n        tga_colormap_bpp = sz;\n    } else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\n        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {\n            stbi__rewind(s);\n            return 0; // only RGB or grey allowed, +/- RLE\n        }\n        stbi__skip(s,9); // skip colormap specification and image x/y origin\n        tga_colormap_bpp = 0;\n    }\n    tga_w = stbi__get16le(s);\n    if( tga_w < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test width\n    }\n    tga_h = stbi__get16le(s);\n    if( tga_h < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test height\n    }\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\n    stbi__get8(s); // ignore alpha bits\n    if (tga_colormap_bpp != 0) {\n        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\n            // I don't think anything but 8 or 16bit indexes makes sense\n            stbi__rewind(s);\n            return 0;\n        }\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\n    } else {\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\n    }\n    if(!tga_comp) {\n      stbi__rewind(s);\n      return 0;\n    }\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp;\n    return 1;                   // seems to have passed everything\n}\n\nstatic int stbi__tga_test(stbi__context *s)\n{\n   int res = 0;\n   int sz, tga_color_type;\n   stbi__get8(s);      //   discard Offset\n   tga_color_type = stbi__get8(s);   //   color type\n   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed\n   sz = stbi__get8(s);   //   image type\n   if ( tga_color_type == 1 ) { // colormapped (paletted) image\n      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\n      stbi__skip(s,4);       // skip index of first colormap entry and number of entries\n      sz = stbi__get8(s);    //   check bits per palette color entry\n      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n      stbi__skip(s,4);       // skip image x and y origin\n   } else { // \"normal\" image w/o colormap\n      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE\n      stbi__skip(s,9); // skip colormap specification and image x/y origin\n   }\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height\n   sz = stbi__get8(s);   //   bits per pixel\n   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index\n   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\n\n   res = 1; // if we got this far, everything's good and we can return 1 instead of 0\n\nerrorEnd:\n   stbi__rewind(s);\n   return res;\n}\n\n// read 16bit value and convert to 24bit RGB\nstatic void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)\n{\n   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\n   stbi__uint16 fiveBitMask = 31;\n   // we have 3 channels with 5bits each\n   int r = (px >> 10) & fiveBitMask;\n   int g = (px >> 5) & fiveBitMask;\n   int b = px & fiveBitMask;\n   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\n   out[0] = (stbi_uc)((r * 255)/31);\n   out[1] = (stbi_uc)((g * 255)/31);\n   out[2] = (stbi_uc)((b * 255)/31);\n\n   // some people claim that the most significant bit might be used for alpha\n   // (possibly if an alpha-bit is set in the \"image descriptor byte\")\n   // but that only made 16bit test images completely translucent..\n   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\n}\n\nstatic void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   //   read in the TGA header stuff\n   int tga_offset = stbi__get8(s);\n   int tga_indexed = stbi__get8(s);\n   int tga_image_type = stbi__get8(s);\n   int tga_is_RLE = 0;\n   int tga_palette_start = stbi__get16le(s);\n   int tga_palette_len = stbi__get16le(s);\n   int tga_palette_bits = stbi__get8(s);\n   int tga_x_origin = stbi__get16le(s);\n   int tga_y_origin = stbi__get16le(s);\n   int tga_width = stbi__get16le(s);\n   int tga_height = stbi__get16le(s);\n   int tga_bits_per_pixel = stbi__get8(s);\n   int tga_comp, tga_rgb16=0;\n   int tga_inverted = stbi__get8(s);\n   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\n   //   image data\n   unsigned char *tga_data;\n   unsigned char *tga_palette = NULL;\n   int i, j;\n   unsigned char raw_data[4] = {0};\n   int RLE_count = 0;\n   int RLE_repeating = 0;\n   int read_next_pixel = 1;\n   STBI_NOTUSED(ri);\n   STBI_NOTUSED(tga_x_origin); //\n   STBI_NOTUSED(tga_y_origin); //\n\n   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   //   do a tiny bit of precessing\n   if ( tga_image_type >= 8 )\n   {\n      tga_image_type -= 8;\n      tga_is_RLE = 1;\n   }\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\n\n   //   If I'm paletted, then I'll use the number of bits from the palette\n   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\n   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\n\n   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\n      return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\n\n   //   tga info\n   *x = tga_width;\n   *y = tga_height;\n   if (comp) *comp = tga_comp;\n\n   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt TGA\");\n\n   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   // skip to the data's starting position (offset usually = 0)\n   stbi__skip(s, tga_offset );\n\n   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {\n      for (i=0; i < tga_height; ++i) {\n         int row = tga_inverted ? tga_height -i - 1 : i;\n         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;\n         stbi__getn(s, tga_row, tga_width * tga_comp);\n      }\n   } else  {\n      //   do I need to load a palette?\n      if ( tga_indexed)\n      {\n         if (tga_palette_len == 0) {  /* you have to have at least one entry! */\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n\n         //   any data to skip? (offset usually = 0)\n         stbi__skip(s, tga_palette_start );\n         //   load the palette\n         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\n         if (!tga_palette) {\n            STBI_FREE(tga_data);\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\n         }\n         if (tga_rgb16) {\n            stbi_uc *pal_entry = tga_palette;\n            STBI_ASSERT(tga_comp == STBI_rgb);\n            for (i=0; i < tga_palette_len; ++i) {\n               stbi__tga_read_rgb16(s, pal_entry);\n               pal_entry += tga_comp;\n            }\n         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\n               STBI_FREE(tga_data);\n               STBI_FREE(tga_palette);\n               return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n      }\n      //   load the data\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\n         if ( tga_is_RLE )\n         {\n            if ( RLE_count == 0 )\n            {\n               //   yep, get the next byte as a RLE command\n               int RLE_cmd = stbi__get8(s);\n               RLE_count = 1 + (RLE_cmd & 127);\n               RLE_repeating = RLE_cmd >> 7;\n               read_next_pixel = 1;\n            } else if ( !RLE_repeating )\n            {\n               read_next_pixel = 1;\n            }\n         } else\n         {\n            read_next_pixel = 1;\n         }\n         //   OK, if I need to read a pixel, do it now\n         if ( read_next_pixel )\n         {\n            //   load however much data we did have\n            if ( tga_indexed )\n            {\n               // read in index, then perform the lookup\n               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\n               if ( pal_idx >= tga_palette_len ) {\n                  // invalid index\n                  pal_idx = 0;\n               }\n               pal_idx *= tga_comp;\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = tga_palette[pal_idx+j];\n               }\n            } else if(tga_rgb16) {\n               STBI_ASSERT(tga_comp == STBI_rgb);\n               stbi__tga_read_rgb16(s, raw_data);\n            } else {\n               //   read in the data raw\n               for (j = 0; j < tga_comp; ++j) {\n                  raw_data[j] = stbi__get8(s);\n               }\n            }\n            //   clear the reading flag for the next pixel\n            read_next_pixel = 0;\n         } // end of reading a pixel\n\n         // copy data\n         for (j = 0; j < tga_comp; ++j)\n           tga_data[i*tga_comp+j] = raw_data[j];\n\n         //   in case we're in RLE mode, keep counting down\n         --RLE_count;\n      }\n      //   do I need to invert the image?\n      if ( tga_inverted )\n      {\n         for (j = 0; j*2 < tga_height; ++j)\n         {\n            int index1 = j * tga_width * tga_comp;\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\n            for (i = tga_width * tga_comp; i > 0; --i)\n            {\n               unsigned char temp = tga_data[index1];\n               tga_data[index1] = tga_data[index2];\n               tga_data[index2] = temp;\n               ++index1;\n               ++index2;\n            }\n         }\n      }\n      //   clear my palette, if I had one\n      if ( tga_palette != NULL )\n      {\n         STBI_FREE( tga_palette );\n      }\n   }\n\n   // swap RGB - if the source data was RGB16, it already is in the right order\n   if (tga_comp >= 3 && !tga_rgb16)\n   {\n      unsigned char* tga_pixel = tga_data;\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         unsigned char temp = tga_pixel[0];\n         tga_pixel[0] = tga_pixel[2];\n         tga_pixel[2] = temp;\n         tga_pixel += tga_comp;\n      }\n   }\n\n   // convert to target component count\n   if (req_comp && req_comp != tga_comp)\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\n\n   //   the things I do to get rid of an error message, and yet keep\n   //   Microsoft's C compilers happy... [8^(\n   tga_palette_start = tga_palette_len = tga_palette_bits =\n         tga_x_origin = tga_y_origin = 0;\n   STBI_NOTUSED(tga_palette_start);\n   //   OK, done\n   return tga_data;\n}\n#endif\n\n// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_test(stbi__context *s)\n{\n   int r = (stbi__get32be(s) == 0x38425053);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)\n{\n   int count, nleft, len;\n\n   count = 0;\n   while ((nleft = pixelCount - count) > 0) {\n      len = stbi__get8(s);\n      if (len == 128) {\n         // No-op.\n      } else if (len < 128) {\n         // Copy next len+1 bytes literally.\n         len++;\n         if (len > nleft) return 0; // corrupt data\n         count += len;\n         while (len) {\n            *p = stbi__get8(s);\n            p += 4;\n            len--;\n         }\n      } else if (len > 128) {\n         stbi_uc   val;\n         // Next -len+1 bytes in the dest are replicated from next source byte.\n         // (Interpret len as a negative 8-bit int.)\n         len = 257 - len;\n         if (len > nleft) return 0; // corrupt data\n         val = stbi__get8(s);\n         count += len;\n         while (len) {\n            *p = val;\n            p += 4;\n            len--;\n         }\n      }\n   }\n\n   return 1;\n}\n\nstatic void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\n{\n   int pixelCount;\n   int channelCount, compression;\n   int channel, i;\n   int bitdepth;\n   int w,h;\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\n\n   // Check file type version.\n   if (stbi__get16be(s) != 1)\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\n\n   // Skip 6 reserved bytes.\n   stbi__skip(s, 6 );\n\n   // Read the number of channels (R, G, B, A, etc).\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16)\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\n\n   // Read the rows and columns of the image.\n   h = stbi__get32be(s);\n   w = stbi__get32be(s);\n\n   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   // Make sure the depth is 8 bits.\n   bitdepth = stbi__get16be(s);\n   if (bitdepth != 8 && bitdepth != 16)\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\n\n   // Make sure the color mode is RGB.\n   // Valid options are:\n   //   0: Bitmap\n   //   1: Grayscale\n   //   2: Indexed color\n   //   3: RGB color\n   //   4: CMYK color\n   //   7: Multichannel\n   //   8: Duotone\n   //   9: Lab color\n   if (stbi__get16be(s) != 3)\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\n\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\n   stbi__skip(s,stbi__get32be(s) );\n\n   // Skip the image resources.  (resolution, pen tool paths, etc)\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Skip the reserved data.\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Find out if the data is compressed.\n   // Known values:\n   //   0: no compression\n   //   1: RLE compressed\n   compression = stbi__get16be(s);\n   if (compression > 1)\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\n\n   // Check size\n   if (!stbi__mad3sizes_valid(4, w, h, 0))\n      return stbi__errpuc(\"too large\", \"Corrupt PSD\");\n\n   // Create the destination image.\n\n   if (!compression && bitdepth == 16 && bpc == 16) {\n      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);\n      ri->bits_per_channel = 16;\n   } else\n      out = (stbi_uc *) stbi__malloc(4 * w*h);\n\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   pixelCount = w*h;\n\n   // Initialize the data to zero.\n   //MemSet( out, 0, pixelCount * 4 );\n\n   // Finally, the image data.\n   if (compression) {\n      // RLE as used by .PSD and .TIFF\n      // Loop until you get the number of unpacked bytes you are expecting:\n      //     Read the next source byte into n.\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\n      //     Else if n is 128, noop.\n      // Endloop\n\n      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,\n      // which we're going to just skip.\n      stbi__skip(s, h * channelCount * 2 );\n\n      // Read the RLE data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         stbi_uc *p;\n\n         p = out+channel;\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            for (i = 0; i < pixelCount; i++, p += 4)\n               *p = (channel == 3 ? 255 : 0);\n         } else {\n            // Read the RLE data.\n            if (!stbi__psd_decode_rle(s, p, pixelCount)) {\n               STBI_FREE(out);\n               return stbi__errpuc(\"corrupt\", \"bad RLE data\");\n            }\n         }\n      }\n\n   } else {\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\n      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\n\n      // Read the data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            if (bitdepth == 16 && bpc == 16) {\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               stbi__uint16 val = channel == 3 ? 65535 : 0;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = val;\n            } else {\n               stbi_uc *p = out+channel;\n               stbi_uc val = channel == 3 ? 255 : 0;\n               for (i = 0; i < pixelCount; i++, p += 4)\n                  *p = val;\n            }\n         } else {\n            if (ri->bits_per_channel == 16) {    // output bpc\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\n               for (i = 0; i < pixelCount; i++, q += 4)\n                  *q = (stbi__uint16) stbi__get16be(s);\n            } else {\n               stbi_uc *p = out+channel;\n               if (bitdepth == 16) {  // input bpc\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = (stbi_uc) (stbi__get16be(s) >> 8);\n               } else {\n                  for (i = 0; i < pixelCount; i++, p += 4)\n                     *p = stbi__get8(s);\n               }\n            }\n         }\n      }\n   }\n\n   // remove weird white matte from PSD\n   if (channelCount >= 4) {\n      if (ri->bits_per_channel == 16) {\n         for (i=0; i < w*h; ++i) {\n            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 65535) {\n               float a = pixel[3] / 65535.0f;\n               float ra = 1.0f / a;\n               float inv_a = 65535.0f * (1 - ra);\n               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);\n               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);\n               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);\n            }\n         }\n      } else {\n         for (i=0; i < w*h; ++i) {\n            unsigned char *pixel = out + 4*i;\n            if (pixel[3] != 0 && pixel[3] != 255) {\n               float a = pixel[3] / 255.0f;\n               float ra = 1.0f / a;\n               float inv_a = 255.0f * (1 - ra);\n               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);\n               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);\n               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);\n            }\n         }\n      }\n   }\n\n   // convert to desired output format\n   if (req_comp && req_comp != 4) {\n      if (ri->bits_per_channel == 16)\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);\n      else\n         out = stbi__convert_format(out, 4, req_comp, w, h);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   if (comp) *comp = 4;\n   *y = h;\n   *x = w;\n\n   return out;\n}\n#endif\n\n// *************************************************************************************************\n// Softimage PIC loader\n// by Tom Seddon\n//\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\n{\n   int i;\n   for (i=0; i<4; ++i)\n      if (stbi__get8(s) != (stbi_uc)str[i])\n         return 0;\n\n   return 1;\n}\n\nstatic int stbi__pic_test_core(stbi__context *s)\n{\n   int i;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\n      return 0;\n\n   for(i=0;i<84;++i)\n      stbi__get8(s);\n\n   if (!stbi__pic_is4(s,\"PICT\"))\n      return 0;\n\n   return 1;\n}\n\ntypedef struct\n{\n   stbi_uc size,type,channel;\n} stbi__pic_packet;\n\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\n{\n   int mask=0x80, i;\n\n   for (i=0; i<4; ++i, mask>>=1) {\n      if (channel & mask) {\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\n         dest[i]=stbi__get8(s);\n      }\n   }\n\n   return dest;\n}\n\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\n{\n   int mask=0x80,i;\n\n   for (i=0;i<4; ++i, mask>>=1)\n      if (channel&mask)\n         dest[i]=src[i];\n}\n\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\n{\n   int act_comp=0,num_packets=0,y,chained;\n   stbi__pic_packet packets[10];\n\n   // this will (should...) cater for even some bizarre stuff like having data\n    // for the same channel in multiple packets.\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return stbi__errpuc(\"bad format\",\"too many packets\");\n\n      packet = &packets[num_packets++];\n\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\n\n   for(y=0; y<height; ++y) {\n      int packet_idx;\n\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\n         stbi__pic_packet *packet = &packets[packet_idx];\n         stbi_uc *dest = result+y*width*4;\n\n         switch (packet->type) {\n            default:\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\n\n            case 0: {//uncompressed\n               int x;\n\n               for(x=0;x<width;++x, dest+=4)\n                  if (!stbi__readval(s,packet->channel,dest))\n                     return 0;\n               break;\n            }\n\n            case 1://Pure RLE\n               {\n                  int left=width, i;\n\n                  while (left>0) {\n                     stbi_uc count,value[4];\n\n                     count=stbi__get8(s);\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\n\n                     if (count > left)\n                        count = (stbi_uc) left;\n\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\n\n                     for(i=0; i<count; ++i,dest+=4)\n                        stbi__copyval(packet->channel,dest,value);\n                     left -= count;\n                  }\n               }\n               break;\n\n            case 2: {//Mixed RLE\n               int left=width;\n               while (left>0) {\n                  int count = stbi__get8(s), i;\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\n\n                  if (count >= 128) { // Repeated\n                     stbi_uc value[4];\n\n                     if (count==128)\n                        count = stbi__get16be(s);\n                     else\n                        count -= 127;\n                     if (count > left)\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     if (!stbi__readval(s,packet->channel,value))\n                        return 0;\n\n                     for(i=0;i<count;++i, dest += 4)\n                        stbi__copyval(packet->channel,dest,value);\n                  } else { // Raw\n                     ++count;\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     for(i=0;i<count;++i, dest+=4)\n                        if (!stbi__readval(s,packet->channel,dest))\n                           return 0;\n                  }\n                  left-=count;\n               }\n               break;\n            }\n         }\n      }\n   }\n\n   return result;\n}\n\nstatic void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   MemSet(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n#endif\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\n\n#ifndef STBI_NO_GIF\ntypedef struct\n{\n   stbi__int16 prefix;\n   stbi_uc first;\n   stbi_uc suffix;\n} stbi__gif_lzw;\n\ntypedef struct\n{\n   int w,h;\n   stbi_uc *out;                 // output buffer (always 4 components)\n   stbi_uc *background;          // The current \"background\" as far as a gif is concerned\n   stbi_uc *history;\n   int flags, bgindex, ratio, transparent, eflags;\n   stbi_uc  pal[256][4];\n   stbi_uc lpal[256][4];\n   stbi__gif_lzw codes[8192];\n   stbi_uc *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n   int delay;\n} stbi__gif;\n\nstatic int stbi__gif_test_raw(stbi__context *s)\n{\n   int sz;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\n   sz = stbi__get8(s);\n   if (sz != '9' && sz != '7') return 0;\n   if (stbi__get8(s) != 'a') return 0;\n   return 1;\n}\n\nstatic int stbi__gif_test(stbi__context *s)\n{\n   int r = stbi__gif_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\n{\n   int i;\n   for (i=0; i < num_entries; ++i) {\n      pal[i][2] = stbi__get8(s);\n      pal[i][1] = stbi__get8(s);\n      pal[i][0] = stbi__get8(s);\n      pal[i][3] = transp == i ? 0 : 255;\n   }\n}\n\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\n{\n   stbi_uc version;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   version = stbi__get8(s);\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\n   if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   stbi__g_failure_reason = \"\";\n   g->w = stbi__get16le(s);\n   g->h = stbi__get16le(s);\n   g->flags = stbi__get8(s);\n   g->bgindex = stbi__get8(s);\n   g->ratio = stbi__get8(s);\n   g->transparent = -1;\n\n   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\n\n   if (is_info) return 1;\n\n   if (g->flags & 0x80)\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\n\n   return 1;\n}\n\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\n   if (!g) return stbi__err(\"outofmem\", \"Out of memory\");\n   if (!stbi__gif_header(s, g, comp, 1)) {\n      STBI_FREE(g);\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = g->w;\n   if (y) *y = g->h;\n   STBI_FREE(g);\n   return 1;\n}\n\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\n{\n   stbi_uc *p, *c;\n   int idx;\n\n   // recurse to decode the prefixes, since the linked-list is backwards,\n   // and working backwards through an interleaved image would be nasty\n   if (g->codes[code].prefix >= 0)\n      stbi__out_gif_code(g, g->codes[code].prefix);\n\n   if (g->cur_y >= g->max_y) return;\n\n   idx = g->cur_x + g->cur_y;\n   p = &g->out[idx];\n   g->history[idx / 4] = 1;\n\n   c = &g->color_table[g->codes[code].suffix * 4];\n   if (c[3] > 128) { // don't render transparent pixels;\n      p[0] = c[2];\n      p[1] = c[1];\n      p[2] = c[0];\n      p[3] = c[3];\n   }\n   g->cur_x += 4;\n\n   if (g->cur_x >= g->max_x) {\n      g->cur_x = g->start_x;\n      g->cur_y += g->step;\n\n      while (g->cur_y >= g->max_y && g->parse > 0) {\n         g->step = (1 << g->parse) * g->line_size;\n         g->cur_y = g->start_y + (g->step >> 1);\n         --g->parse;\n      }\n   }\n}\n\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\n{\n   stbi_uc lzw_cs;\n   stbi__int32 len, init_code;\n   stbi__uint32 first;\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n   stbi__gif_lzw *p;\n\n   lzw_cs = stbi__get8(s);\n   if (lzw_cs > 12) return NULL;\n   clear = 1 << lzw_cs;\n   first = 1;\n   codesize = lzw_cs + 1;\n   codemask = (1 << codesize) - 1;\n   bits = 0;\n   valid_bits = 0;\n   for (init_code = 0; init_code < clear; init_code++) {\n      g->codes[init_code].prefix = -1;\n      g->codes[init_code].first = (stbi_uc) init_code;\n      g->codes[init_code].suffix = (stbi_uc) init_code;\n   }\n\n   // support no starting clear code\n   avail = clear+2;\n   oldcode = -1;\n\n   len = 0;\n   for(;;) {\n      if (valid_bits < codesize) {\n         if (len == 0) {\n            len = stbi__get8(s); // start new block\n            if (len == 0)\n               return g->out;\n         }\n         --len;\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\n         valid_bits += 8;\n      } else {\n         stbi__int32 code = bits & codemask;\n         bits >>= codesize;\n         valid_bits -= codesize;\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\n         if (code == clear) {  // clear code\n            codesize = lzw_cs + 1;\n            codemask = (1 << codesize) - 1;\n            avail = clear + 2;\n            oldcode = -1;\n            first = 0;\n         } else if (code == clear + 1) { // end of stream code\n            stbi__skip(s, len);\n            while ((len = stbi__get8(s)) > 0)\n               stbi__skip(s,len);\n            return g->out;\n         } else if (code <= avail) {\n            if (first) {\n               return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\n            }\n\n            if (oldcode >= 0) {\n               p = &g->codes[avail++];\n               if (avail > 8192) {\n                  return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\n               }\n\n               p->prefix = (stbi__int16) oldcode;\n               p->first = g->codes[oldcode].first;\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\n            } else if (code == avail)\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n\n            stbi__out_gif_code(g, (stbi__uint16) code);\n\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n               codesize++;\n               codemask = (1 << codesize) - 1;\n            }\n\n            oldcode = code;\n         } else {\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n         }\n      }\n   }\n}\n\n// this function is designed to support animated gifs, although stb_image doesn't support it\n// two back is the image from two frames ago, used for a very specific disposal format\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)\n{\n   int dispose;\n   int first_frame;\n   int pi;\n   int pcount;\n   STBI_NOTUSED(req_comp);\n\n   // on first frame, any non-written pixels get the background colour (non-transparent)\n   first_frame = 0;\n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\n      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\n         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n      pcount = g->w * g->h;\n      g->out = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->background = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->history = (stbi_uc *) stbi__malloc(pcount);\n      if (!g->out || !g->background || !g->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background;\n      // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n      // color refers to the color that was there the previous frame.\n      MemSet(g->out, 0x00, 4 * pcount);\n      MemSet(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\n      MemSet(g->history, 0x00, pcount);        // pixels that were affected previous frame\n      first_frame = 1;\n   } else {\n      // second frame - how do we dispose of the previous one?\n      dispose = (g->eflags & 0x1C) >> 2;\n      pcount = g->w * g->h;\n\n      if ((dispose == 3) && (two_back == 0)) {\n         dispose = 2; // if I don't have an image to revert back to, default to the old background\n      }\n\n      if (dispose == 3) { // use previous graphic\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               MemCopy( &g->out[pi * 4], &two_back[pi * 4], 4 );\n            }\n         }\n      } else if (dispose == 2) {\n         // restore what was changed last frame to background before that frame;\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               MemCopy( &g->out[pi * 4], &g->background[pi * 4], 4 );\n            }\n         }\n      } else {\n         // This is a non-disposal case eithe way, so just\n         // leave the pixels as is, and they will become the new background\n         // 1: do not dispose\n         // 0:  not specified.\n      }\n\n      // background is what out is after the undoing of the previou frame;\n      MemCopy( g->background, g->out, 4 * g->w * g->h );\n   }\n\n   // clear my history;\n   MemSet( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n\n   for (;;) {\n      int tag = stbi__get8(s);\n      switch (tag) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            // if the width of the specified rectangle is 0, that means\n            // we may not see *any* pixels or the image is malformed;\n            // to make sure this is caught, move the current y down to\n            // max_y (which is what out_gif_code checks).\n            if (w == 0)\n               g->cur_y = g->max_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;\n            } else if (g->flags & 0x80) {\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\n\n            o = stbi__process_gif_raster(s, g);\n            if (!o) return NULL;\n\n            // if this was the first frame,\n            pcount = g->w * g->h;\n            if (first_frame && (g->bgindex > 0)) {\n               // if first frame, any pixel not drawn to gets the background color\n               for (pi = 0; pi < pcount; ++pi) {\n                  if (g->history[pi] == 0) {\n                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;\n                     MemCopy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );\n                  }\n               }\n            }\n\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            int ext = stbi__get8(s);\n            if (ext == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\n\n                  // unset old transparent\n                  if (g->transparent >= 0) {\n                     g->pal[g->transparent][3] = 255;\n                  }\n                  if (g->eflags & 0x01) {\n                     g->transparent = stbi__get8(s);\n                     if (g->transparent >= 0) {\n                        g->pal[g->transparent][3] = 0;\n                     }\n                  } else {\n                     // don't need transparent\n                     stbi__skip(s, 1);\n                     g->transparent = -1;\n                  }\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            }\n            while ((len = stbi__get8(s)) != 0) {\n               stbi__skip(s, len);\n            }\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}\n\nstatic void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)\n{\n   STBI_FREE(g->out);\n   STBI_FREE(g->history);\n   STBI_FREE(g->background);\n\n   if (out) STBI_FREE(out);\n   if (delays && *delays) STBI_FREE(*delays);\n   return stbi__errpuc(\"outofmem\", \"Out of memory\");\n}\n\nstatic void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)\n{\n   if (stbi__gif_test(s)) {\n      int layers = 0;\n      stbi_uc *u = 0;\n      stbi_uc *out = 0;\n      stbi_uc *two_back = 0;\n      stbi__gif g;\n      int stride;\n      int out_size = 0;\n      int delays_size = 0;\n\n      STBI_NOTUSED(out_size);\n      STBI_NOTUSED(delays_size);\n\n      MemSet(&g, 0, sizeof(g));\n      if (delays) {\n         *delays = 0;\n      }\n\n      do {\n         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);\n         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n\n         if (u) {\n            *x = g.w;\n            *y = g.h;\n            ++layers;\n            stride = g.w * g.h * 4;\n\n            if (out) {\n               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );\n               if (!tmp)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               else {\n                   out = (stbi_uc*) tmp;\n                   out_size = layers * stride;\n               }\n\n               if (delays) {\n                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );\n                  if (!new_delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  *delays = new_delays;\n                  delays_size = layers * sizeof(int);\n               }\n            } else {\n               out = (stbi_uc*)stbi__malloc( layers * stride );\n               if (!out)\n                  return stbi__load_gif_main_outofmem(&g, out, delays);\n               out_size = layers * stride;\n               if (delays) {\n                  *delays = (int*) stbi__malloc( layers * sizeof(int) );\n                  if (!*delays)\n                     return stbi__load_gif_main_outofmem(&g, out, delays);\n                  delays_size = layers * sizeof(int);\n               }\n            }\n            MemCopy( out + ((layers - 1) * stride), u, stride );\n            if (layers >= 2) {\n               two_back = out - 2 * stride;\n            }\n\n            if (delays) {\n               (*delays)[layers - 1U] = g.delay;\n            }\n         }\n      } while (u != 0);\n\n      // free temp buffer;\n      STBI_FREE(g.out);\n      STBI_FREE(g.history);\n      STBI_FREE(g.background);\n\n      // do the final conversion after loading everything;\n      if (req_comp && req_comp != 4)\n         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);\n\n      *z = layers;\n      return out;\n   } else {\n      return stbi__errpuc(\"not GIF\", \"Image was not as a gif type.\");\n   }\n}\n\nstatic void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   MemSet(&g, 0, sizeof(g));\n   STBI_NOTUSED(ri);\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n\n      // moved conversion to after successful load so that the same\n      // can be done for multiple frames.\n      if (req_comp && req_comp != 4)\n         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n   } else if (g.out) {\n      // if there was an error and we allocated an image buffer, free it!\n      STBI_FREE(g.out);\n   }\n\n   // free buffers needed for multiple frame loading;\n   STBI_FREE(g.history);\n   STBI_FREE(g.background);\n\n   return u;\n}\n\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   return stbi__gif_info_raw(s,x,y,comp);\n}\n#endif\n\n// *************************************************************************************************\n// Radiance RGBE HDR loader\n// originally by Nicolas Schulz\n#ifndef STBI_NO_HDR\nstatic int stbi__hdr_test_core(stbi__context *s, const char *signature)\n{\n   int i;\n   for (i=0; signature[i]; ++i)\n      if (stbi__get8(s) != signature[i])\n          return 0;\n   stbi__rewind(s);\n   return 1;\n}\n\nstatic int stbi__hdr_test(stbi__context* s)\n{\n   int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\n   stbi__rewind(s);\n   if(!r) {\n       r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\n       stbi__rewind(s);\n   }\n   return r;\n}\n\n#define STBI__HDR_BUFLEN  1024\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\n{\n   int len=0;\n   char c = '\\0';\n\n   c = (char) stbi__get8(z);\n\n   while (!stbi__at_eof(z) && c != '\\n') {\n      buffer[len++] = c;\n      if (len == STBI__HDR_BUFLEN-1) {\n         // flush to end of line\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\n            ;\n         break;\n      }\n      c = (char) stbi__get8(z);\n   }\n\n   buffer[len] = 0;\n   return buffer;\n}\n\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\n{\n   if ( input[3] != 0 ) {\n      float f1;\n      // Exponent\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\n      if (req_comp <= 2)\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\n      else {\n         output[0] = input[0] * f1;\n         output[1] = input[1] * f1;\n         output[2] = input[2] * f1;\n      }\n      if (req_comp == 2) output[1] = 1;\n      if (req_comp == 4) output[3] = 1;\n   } else {\n      switch (req_comp) {\n         case 4: output[3] = 1; /* fallthrough */\n         case 3: output[0] = output[1] = output[2] = 0;\n                 break;\n         case 2: output[1] = 1; /* fallthrough */\n         case 1: output[0] = 0;\n                 break;\n      }\n   }\n}\n\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}\n\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int dummy;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (stbi__hdr_test(s) == 0) {\n       stbi__rewind( s );\n       return 0;\n   }\n\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *y = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *x = (int) strtol(token, NULL, 10);\n   *comp = 3;\n   return 1;\n}\n#endif // STBI_NO_HDR\n\n#ifndef STBI_NO_BMP\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   void *p;\n   stbi__bmp_data info;\n\n   info.all_a = 255;\n   p = stbi__bmp_parse_header(s, &info);\n   if (p == NULL) {\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = s->img_x;\n   if (y) *y = s->img_y;\n   if (comp) {\n      if (info.bpp == 24 && info.ma == 0xff000000)\n         *comp = 3;\n      else\n         *comp = info.ma ? 4 : 3;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PSD\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int channelCount, dummy, depth;\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *y = stbi__get32be(s);\n   *x = stbi__get32be(s);\n   depth = stbi__get16be(s);\n   if (depth != 8 && depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 3) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *comp = 4;\n   return 1;\n}\n\nstatic int stbi__psd_is16(stbi__context *s)\n{\n   int channelCount, depth;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   STBI_NOTUSED(stbi__get32be(s));\n   STBI_NOTUSED(stbi__get32be(s));\n   depth = stbi__get16be(s);\n   if (depth != 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n#endif\n\n#ifndef STBI_NO_PIC\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int act_comp=0,num_packets=0,chained,dummy;\n   stbi__pic_packet packets[10];\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\")) {\n      stbi__rewind(s);\n      return 0;\n   }\n\n   stbi__skip(s, 88);\n\n   *x = stbi__get16be(s);\n   *y = stbi__get16be(s);\n   if (stbi__at_eof(s)) {\n      stbi__rewind( s);\n      return 0;\n   }\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\n      stbi__rewind( s );\n      return 0;\n   }\n\n   stbi__skip(s, 8);\n\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return 0;\n\n      packet = &packets[num_packets++];\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s)) {\n          stbi__rewind( s );\n          return 0;\n      }\n      if (packet->size != 8) {\n          stbi__rewind( s );\n          return 0;\n      }\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3);\n\n   return 1;\n}\n#endif\n\n// *************************************************************************************************\n// Portable Gray Map and Portable Pixel Map loader\n// by Ken Miller\n//\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\n//\n// Known limitations:\n//    Does not support comments in the header section\n//    Does not support ASCII image data (formats P2 and P3)\n\n#ifndef STBI_NO_PNM\n\nstatic int      stbi__pnm_test(stbi__context *s)\n{\n   char p, t;\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind( s );\n       return 0;\n   }\n   return 1;\n}\n\nstatic void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n\n   if (req_comp && req_comp != s->img_n) {\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}\n\nstatic int      stbi__pnm_isspace(char c)\n{\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\n}\n\nstatic void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)\n{\n   for (;;) {\n      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\n         *c = (char) stbi__get8(s);\n\n      if (stbi__at_eof(s) || *c != '#')\n         break;\n\n      while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r' )\n         *c = (char) stbi__get8(s);\n   }\n}\n\nstatic int      stbi__pnm_isdigit(char c)\n{\n   return c >= '0' && c <= '9';\n}\n\nstatic int      stbi__pnm_getinteger(stbi__context *s, char *c)\n{\n   int value = 0;\n\n   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\n      value = value*10 + (*c - '0');\n      *c = (char) stbi__get8(s);\n   }\n\n   return value;\n}\n\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int maxv, dummy;\n   char c, p, t;\n\n   if (!x) x = &dummy;\n   if (!y) y = &dummy;\n   if (!comp) comp = &dummy;\n\n   stbi__rewind(s);\n\n   // Get identifier\n   p = (char) stbi__get8(s);\n   t = (char) stbi__get8(s);\n   if (p != 'P' || (t != '5' && t != '6')) {\n       stbi__rewind(s);\n       return 0;\n   }\n\n   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\n\n   c = (char) stbi__get8(s);\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *x = stbi__pnm_getinteger(s, &c); // read width\n   stbi__pnm_skip_whitespace(s, &c);\n\n   *y = stbi__pnm_getinteger(s, &c); // read height\n   stbi__pnm_skip_whitespace(s, &c);\n\n   maxv = stbi__pnm_getinteger(s, &c);  // read max value\n   if (maxv > 65535)\n      return stbi__err(\"max value > 65535\", \"PPM image supports only 8-bit and 16-bit images\");\n   else if (maxv > 255)\n      return 16;\n   else\n      return 8;\n}\n\nstatic int stbi__pnm_is16(stbi__context *s)\n{\n   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)\n\t   return 1;\n   return 0;\n}\n#endif\n\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\n{\n   #ifndef STBI_NO_JPEG\n   if (stbi__jpeg_info(s, x, y, comp)) return 1;\n   #endif\n\n   #ifndef STBI_NO_PNG\n   if (stbi__png_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_GIF\n   if (stbi__gif_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_BMP\n   if (stbi__bmp_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PIC\n   if (stbi__pic_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_info(s, x, y, comp))  return 1;\n   #endif\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_info(s, x, y, comp))  return 1;\n   #endif\n\n   // test tga last because it's a crappy test!\n   #ifndef STBI_NO_TGA\n   if (stbi__tga_info(s, x, y, comp))\n       return 1;\n   #endif\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nstatic int stbi__is_16_main(stbi__context *s)\n{\n   #ifndef STBI_NO_PNG\n   if (stbi__png_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PSD\n   if (stbi__psd_is16(s))  return 1;\n   #endif\n\n   #ifndef STBI_NO_PNM\n   if (stbi__pnm_is16(s))  return 1;\n   #endif\n   return 0;\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_info_from_file(f, x, y, comp);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__info_main(&s,x,y,comp);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n\nSTBIDEF int stbi_is_16_bit(char const *filename)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_is_16_bit_from_file(f);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_is_16_bit_from_file(FILE *f)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__is_16_main(&s);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__is_16_main(&s);\n}\n\nSTBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__is_16_main(&s);\n}\n\n#endif // STB_IMAGE_IMPLEMENTATION\n\n/*\n   revision history:\n      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs\n      2.19  (2018-02-11) fix warning\n      2.18  (2018-01-30) fix warnings\n      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug\n                         1-bit BMP\n                         *_is_16_bit api\n                         avoid warnings\n      2.16  (2017-07-23) all functions have 16-bit variants;\n                         STBI_NO_STDIO works again;\n                         compilation fixes;\n                         fix rounding in unpremultiply;\n                         optimize vertical flip;\n                         disable raw_len validation;\n                         documentation fixes\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\n                         warning fixes; disable run-time SSE detection on gcc;\n                         uniform handling of optional \"return\" values;\n                         thread-safe initialization of zlib tables\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\n      2.11  (2016-04-02) allocate large structures on the stack\n                         remove white matting for transparent PSD\n                         fix reported channel count for PNG & BMP\n                         re-enable SSE2 in non-gcc 64-bit\n                         support RGB-formatted JPEG\n                         read 16-bit PNGs (only as 8-bit)\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\n      2.09  (2016-01-16) allow comments in PNM files\n                         16-bit-per-pixel TGA (not bit-per-component)\n                         info() for TGA could break due to .hdr handling\n                         info() for BMP to shares code instead of sloppy parse\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\n                         code cleanup\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\n      2.07  (2015-09-13) fix compiler warnings\n                         partial animated GIF support\n                         limited 16-bpc PSD support\n                         #ifdef unused functions\n                         bug with < 92 byte PIC,PNM,HDR,TGA\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\n                         stbi_set_flip_vertically_on_load (nguillemot)\n                         fix NEON support; fix mingw support\n      2.02  (2015-01-19) fix incorrect assert, fix warning\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\n                         progressive JPEG (stb)\n                         PGM/PPM support (Ken Miller)\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\n                         GIF bugfix -- seemingly never worked\n                         STBI_NO_*, STBI_ONLY_*\n      1.48  (2014-12-14) fix incorrectly-named assert()\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\n                         optimize PNG (ryg)\n                         fix bug in interlaced PNG with user-specified channel count (stb)\n      1.46  (2014-08-26)\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\n      1.45  (2014-08-16)\n              fix MSVC-ARM internal compiler error by wrapping malloc\n      1.44  (2014-08-07)\n              various warning fixes from Ronny Chevalier\n      1.43  (2014-07-15)\n              fix MSVC-only compiler problem in code changed in 1.42\n      1.42  (2014-07-09)\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\n              fixes to stbi__cleanup_jpeg path\n              added STBI_ASSERT to avoid requiring assert.h\n      1.41  (2014-06-25)\n              fix search&replace from 1.36 that messed up comments/error messages\n      1.40  (2014-06-22)\n              fix gcc struct-initialization warning\n      1.39  (2014-06-15)\n              fix to TGA optimization when req_comp != number of components in TGA;\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\n              add support for BMP version 5 (more ignored fields)\n      1.38  (2014-06-06)\n              suppress MSVC warnings on integer casts truncating values\n              fix accidental rename of 'skip' field of I/O\n      1.37  (2014-06-04)\n              remove duplicate typedef\n      1.36  (2014-06-03)\n              convert to header file single-file library\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\n      1.35  (2014-05-27)\n              various warnings\n              fix broken STBI_SIMD path\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\n              fix broken non-easy path for 32-bit BMP (possibly never used)\n              TGA optimization by Arseny Kapoulkine\n      1.34  (unknown)\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\n      1.33  (2011-07-14)\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\n      1.32  (2011-07-13)\n              support for \"info\" function for all supported filetypes (SpartanJ)\n      1.31  (2011-06-20)\n              a few more leak fixes, bug in PNG handling (SpartanJ)\n      1.30  (2011-06-11)\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\n              removed deprecated format-specific test/load functions\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\n              fix inefficiency in decoding 32-bit BMP (David Woo)\n      1.29  (2010-08-16)\n              various warning fixes from Aurelien Pocheville\n      1.28  (2010-08-01)\n              fix bug in GIF palette transparency (SpartanJ)\n      1.27  (2010-08-01)\n              cast-to-stbi_uc to fix warnings\n      1.26  (2010-07-24)\n              fix bug in file buffering for PNG reported by SpartanJ\n      1.25  (2010-07-17)\n              refix trans_data warning (Won Chun)\n      1.24  (2010-07-12)\n              perf improvements reading from files on platforms with lock-heavy fgetc()\n              minor perf improvements for jpeg\n              deprecated type-specific functions so we'll get feedback if they're needed\n              attempt to fix trans_data warning (Won Chun)\n      1.23    fixed bug in iPhone support\n      1.22  (2010-07-10)\n              removed image *writing* support\n              stbi_info support from Jetro Lauha\n              GIF support from Jean-Marc Lienher\n              iPhone PNG-extensions from James Brown\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\n      1.20    added support for Softimage PIC, by Tom Seddon\n      1.19    bug in interlaced PNG corruption check (found by ryg)\n      1.18  (2008-08-02)\n              fix a threading bug (local mutable static)\n      1.17    support interlaced PNG\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\n      1.15    initialize some fields for thread safety\n      1.14    fix threadsafe conversion bug\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\n      1.13    threadsafe\n      1.12    const qualifiers in the API\n      1.11    Support installable IDCT, colorspace conversion routines\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\n              optimized upsampling by Fabian \"ryg\" Giesen\n      1.09    Fix format-conversion for PSD code (bad global variables!)\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\n      1.07    attempt to fix C++ warning/errors again\n      1.06    attempt to fix C++ warning/errors again\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\n      1.00    interface to zlib that skips zlib header\n      0.99    correct handling of alpha in palette\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\n      0.97    jpeg errors on too large a file; also catch another malloc failure\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\n      0.95    during header scan, seek to markers in case of padding\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\n      0.93    handle jpegtran output; verbose errors\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\n      0.91    output 24-bit Windows 3.0 BMP files\n      0.90    fix a few more warnings; bump version number to approach 1.0\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\n      0.60    fix compiling as c++\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\n      0.55    fix bug: restart_interval not initialized to 0\n      0.54    allow NULL for 'int *comp'\n      0.53    fix bug in png 3->4; speedup png decoding\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\n              on 'test' only check type, not whether we support this variant\n      0.50  (2006-11-19)\n              first released version\n*/\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#ifndef _H_DRAW2D_\n#define _H_DRAW2D_\n\n#include \"vec2.h\"\n#include \"vec3.h\"\n#include \"vec4.h\"\n#include \"../platform/math.h\"\n#include \"../platform/memory.h\"\n\nnamespace Draw2D {\n    ////////////////////////////////////////////////////////////////\n    // Core API\n    ////////////////////////////////////////////////////////////////\n\n    enum class Interpolation {\n        Linear = 0,\n        Step = 1\n    };\n\n    struct Size {\n        float w;\n        float h;\n\n        inline Size(float _w = 0.0f, float _h = 0.0f) :\n            w(_w), h(_h) { }\n    };\n\n    struct Rect {\n        float x;\n        float y;\n        float w;\n        float h;\n\n        inline Rect(float _x = 0.0f, float _y = 0.0f, float _w = 0.0f, float _h = 0.0f) :\n            x(_x), y(_y), w(_w), h(_h) { }\n    };\n\n    struct OBB {\n        vec2 center;\n        vec2 extents;\n        float rotation;\n\n        inline bool Contains(const vec2& point) {\n            vec2 rotVector = point - center;\n            rotVector = rotate(rotVector, -rotation);\n\n            vec2 localPoint = rotVector;// +extents;\n            \n            Rect localRect = { 0 };\n            localRect.w = extents.x * 2.0f;\n            localRect.h = extents.y * 2.0f;\n            localRect.x = -extents.x;\n            localRect.y = -extents.y;\n\n            return localPoint.x >= localRect.x && localPoint.x <= localRect.x + localRect.w &&\n                localPoint.y >= localRect.y && localPoint.y <= localRect.y + localRect.h;\n        }\n    };\n\n    void Initialize(); \n    void Shutdown();\n\n    void Begin(u32 designWidth, u32 designHeight, f32 designScale, u32 screenWidth, u32 screenHeight);\n    void End(); \n\n    void EnableAlphaBlending();\n    void DisableAlphaBlending();\n\n    void PushClip(f32 x, f32 y, f32 w, f32 h);\n    void PopClip();\n\n    u32 LoadFont(void* memory, u32 bytes, bool autoCleanup = false); // If own is true, DestroyFont will call MemRelease on the memory pointer passed here\n    void DestroyFont(u32 font);\n\n    u32 LoadImage(void* memory, u32 bytes, Interpolation interp); // NOTE: maybe interpolation should be \"bool useNearest\"\n    Size GetImageSize(u32 image);\n    void DestroyImage(u32 image); \n\n    void DrawString(u32 font, u32 pixelHeight, f32 x, f32 y, const char* string, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    void DrawCodePoint(u32 font, u32 pixelHeight, f32 x, f32 y, unsigned char codePoint, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    int FindStringIndex(u32 font, u32 pixelHeight, const char* string, const vec2& relativePoint);\n    Size MeasureString(u32 font, u32 pixelHeight, const char* string);\n    Rect MeasureSubString(u32 font, u32 pixelHeight, const char* string, u32 startIndex, u32 len);\n    OBB DrawImage(u32 image, f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 sourceX, f32 sourceY, f32 sourceW, f32 shourceH, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotation = 0.0f, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    OBB ImageTransform(f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotation = 0.0f);\n    void DrawLine(f32* points, u32 numPoints, f32 thickness = 1.0f, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n    void DrawEllipse(f32 x, f32 y, f32 radiusX, f32 radiusY, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotation = 0.0f);\n    void DrawRect(f32 x, f32 y, f32 w, f32 h, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotation = 0.0f);\n\n    void DrawCircleSlice(f32 cX, f32 cY, float radius, float startAngle, float fillAngle, float red, float green, float blue);\n    void DrawHollowCircle(f32 x, f32 y, f32 innerR, f32 outerR, f32 r, f32 g, f32 b);\n    //void DrawImageWithTransform(u32 image, f32 screenX, f32 screenY, f32 screenW, f32 screenH, f32 sourceX, f32 sourceY, f32 sourceW, f32 shourceH, f32 scaleX = 1.0f, f32 scaleY = 1.0f, f32 pivotX = 0.0f, f32 pivotY = 0.0f, f32 rotationRadians = 0.0f, f32 blendR = 1.0f, f32 blendG = 1.0f, f32 blendB = 1.0f, f32 blendA = 1.0f);\n\n\n    void DrawRect(f32 x, f32 y, f32 w, f32 h,\n        f32 tlR, f32 tlG, f32 tlB,\n        f32 trR, f32 trG, f32 trB,\n        f32 blR, f32 blG, f32 blB,\n        f32 brR, f32 brG, f32 brB);\n\n    void DrawTriangle(f32 x0, f32 y0, f32 x1, f32 y1, f32 x2, f32 y2, f32 r, f32 g, f32 b);\n};\n\n#endif","#ifndef _H_VEC2_\n#define _H_VEC2_\n\n#define VEC2_EPSILON 0.000001f\n\ntemplate<typename T>\nstruct TVec2 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t};\n\t\tT v[2];\n\t};\n\tinline TVec2() : x(T(0)), y(T(0)) { }\n\tinline TVec2(T _x, T _y) :\n\t\tx(_x), y(_y) { }\n\tinline TVec2(T* fv) {\n\t\tif (fv != 0) {\n\t\t\tx = fv[0];\n\t\t\ty = fv[1];\n\t\t}\n\t\telse {\n\t\t\tx = y = 0.0f;\n\t\t}\n\t}\n};\n\ntypedef TVec2<float> vec2;\ntypedef TVec2<int> ivec2;\ntypedef TVec2<unsigned int> uivec2;\n\nvec2 operator-(const vec2& l, const vec2& r);\nvec2 operator+(const vec2& l, const vec2& r);\nvec2 operator*(const vec2& l, const vec2& r);\nvec2 operator/(const vec2& l, const vec2& r);\nvec2 operator/(const vec2& l, float f);\nvec2 operator*(const vec2& l, float f);\n\nvoid normalize(vec2& v);\nvec2 normalized(const vec2& v);\nfloat dot(const vec2& l, const vec2& r);\nfloat lenSq(const vec2& v);\nfloat len(const vec2& v);\nvec2 abs(const vec2& v);\nfloat angle(const vec2& l, const vec2& r);\nvec2 rotate(const vec2& v, float angle);\n\ninline vec2 perp(const vec2& v) {\n\treturn vec2(v.y, -v.x);\n}\n\n#endif","#include \"vec2.h\"\n#include \"../platform/math.h\"\n\nvec2 operator-(const vec2& l, const vec2& r) {\n\treturn vec2(l.x - r.x, l.y - r.y);\n}\n\nvec2 operator+(const vec2& l, const vec2& r) {\n\treturn vec2(l.x + r.x, l.y + r.y);\n}\n\nvec2 operator*(const vec2& l, const vec2& r) {\n\treturn vec2(l.x * r.x, l.y * r.y);\n}\n\nvec2 operator/(const vec2& l, float r) {\n\treturn vec2(l.x / r, l.y / r);\n}\n\nvec2 operator/(const vec2& l, const vec2& r) {\n\treturn vec2(l.x / r.x, l.y / r.y);\n}\n\nvec2 operator*(const vec2& l, float f) {\n\treturn vec2(l.x * f, l.y * f);\n}\n\nvec2 rotate(const vec2& _v, float angle) {\n\tvec2 v = _v;\n\tfloat s = MathSin(angle);\n\tfloat c = MathCos(angle);\n\tfloat x = v.x;\n\tfloat y = v.y;\n\tv.x = x * c - y * s;\n\tv.y = x * s + y * c;\n\treturn v;\n}\n\nfloat angle(const vec2& l, const vec2& r) {\n\tfloat sqMagL = l.x * l.x + l.y * l.y;\n\tfloat sqMagR = r.x * r.x + r.y * r.y;\n\n\tif (sqMagL < VEC2_EPSILON || sqMagR < VEC2_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat dot = l.x * r.x + l.y * r.y;\n\tfloat len = MathSqrt(sqMagL) * MathSqrt(sqMagR);\n\treturn MathACos(dot / len);\n}\n\n\nvoid normalize(vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\tv.x *= invLen;\n\tv.y *= invLen;\n}\n\nvec2 normalized(const vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn v;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\treturn vec2(\n\t\tv.x * invLen,\n\t\tv.y * invLen\n\t);\n}\n\nfloat dot(const vec2& l, const vec2& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\nfloat lenSq(const vec2& v) {\n\treturn v.x * v.x + v.y * v.y ;\n}\n\nfloat len(const vec2& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y;\n\tif (lenSq < VEC2_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn MathSqrt(lenSq);\n}\n\nvec2 abs(const vec2& v) {\n\tvec2 result = v;\n\tif (v.x < 0.0f) {\n\t\tresult.x = -v.x;\n\t}\n\tif (v.y < 0.0f) {\n\t\tresult.y = -v.y;\n\t}\n\treturn result;\n}","#include \"vec3.h\"\n#include \"../platform/math.h\"\n\nvec3 operator+(const vec3& l, const vec3& r) {\n\treturn vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\n\nvec3 operator-(const vec3& l, const vec3& r) {\n\treturn vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\n\nvec3 operator*(const vec3& v, float f) {\n\treturn vec3(v.x * f, v.y * f, v.z * f);\n}\n\nvec3 operator*(const vec3& l, const vec3& r) {\n\treturn vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n}\n\nfloat dot(const vec3& l, const vec3& r) {\n\treturn l.x * r.x + l.y * r.y + l.z * r.z;\n}\n\nfloat lenSq(const vec3& v) {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfloat len(const vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn MathSqrt(lenSq);\n}\n\nvoid normalize(vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\tv.x *= invLen;\n\tv.y *= invLen;\n\tv.z *= invLen;\n}\n\nvec3 normalized(const vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn v;\n\t}\n\tfloat invLen = 1.0f / MathSqrt(lenSq);\n\n\treturn vec3(\n\t\tv.x * invLen,\n\t\tv.y * invLen,\n\t\tv.z * invLen\n\t);\n}\n\nfloat angle(const vec3& l, const vec3& r) {\n\tfloat sqMagL = l.x * l.x + l.y * l.y + l.z * l.z;\n\tfloat sqMagR = r.x * r.x + r.y * r.y + r.z * r.z;\n\n\tif (sqMagL < VEC3_EPSILON || sqMagR < VEC3_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\n\tfloat dot = l.x * r.x + l.y * r.y + l.z * r.z;\n\tfloat len = MathSqrt(sqMagL) * MathSqrt(sqMagR);\n\treturn MathACos(dot / len);\n}\n\nvec3 project(const vec3& a, const vec3& b) {\n\tfloat magBSq = len(b);\n\tif (magBSq < VEC3_EPSILON) {\n\t\treturn vec3();\n\t}\n\tfloat scale = dot(a, b) / magBSq;\n\treturn b * scale;\n}\n\nvec3 reject(const vec3& a, const vec3& b) {\n\tvec3 projection = project(a, b);\n\treturn a - projection;\n}\n\nvec3 reflect(const vec3& a, const vec3& b) {\n\tfloat magBSq = len(b);\n\tif (magBSq < VEC3_EPSILON) {\n\t\treturn vec3();\n\t}\n\tfloat scale = dot(a, b) / magBSq;\n\tvec3 proj2 = b * (scale * 2);\n\treturn a - proj2;\n}\n\nvec3 cross(const vec3& l, const vec3& r) {\n\treturn vec3(\n\t\tl.y * r.z - l.z * r.y,\n\t\tl.z * r.x - l.x * r.z,\n\t\tl.x * r.y - l.y * r.x\n\t);\n}\n\nvec3 lerp(const vec3& s, const vec3& e, float t) {\n\treturn vec3(\n\t\ts.x + (e.x - s.x) * t,\n\t\ts.y + (e.y - s.y) * t,\n\t\ts.z + (e.z - s.z) * t\n\t);\n}\n\nvec3 slerp(const vec3& s, const vec3& e, float t) {\n\tif (t < 0.01f) {\n\t\treturn lerp(s, e, t);\n\t}\n\n\tvec3 from = normalized(s);\n\tvec3 to = normalized(e);\n\n\tfloat theta = angle(from, to);\n\tfloat sin_theta = MathSin(theta);\n\n\tfloat a = MathSin((1.0f - t) * theta) / sin_theta;\n\tfloat b = MathSin(t * theta) / sin_theta;\n\n\treturn from * a + to * b;\n}\n\nvec3 nlerp(const vec3& s, const vec3& e, float t) {\n\tvec3 linear(\n\t\ts.x + (e.x - s.x) * t,\n\t\ts.y + (e.y - s.y) * t,\n\t\ts.z + (e.z - s.z) * t\n\t);\n\treturn normalized(linear);\n}\n\nbool operator==(const vec3& l, const vec3& r) {\n\tvec3 diff(l - r);\n\treturn lenSq(diff) < VEC3_EPSILON;\n}\n\nbool operator!=(const vec3& l, const vec3& r) {\n\treturn !(l == r);\n}","#ifndef _H_VEC3_\n#define _H_VEC3_\n\n#define VEC3_EPSILON 0.000001f\n#include \"vec2.h\"\n\nstruct vec3 {\n\tunion {\n\t\tstruct {\n\t\t\tvec2 asVec2;\n\t\t\tfloat _z;\n\t\t};\n\t\tstruct {\n\t\t\tfloat x;\n\t\t\tfloat y;\n\t\t\tfloat z;\n\t\t};\n\t\tfloat v[3];\n\t};\n\tinline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n\tinline vec3(float _x, float _y, float _z) :\n\t\tx(_x), y(_y), z(_z) { }\n\tinline vec3(float* fv) {\n\t\tif (fv != 0) {\n\t\t\tx = fv[0];\n\t\t\ty = fv[1];\n\t\t\tz = fv[2];\n\t\t}\n\t\telse {\n\t\t\tx = y = z = 0.0f;\n\t\t}\n\t}\n\tinline vec3(const vec2& v2, float _z) : x(v2.x), y(v2.y), z(_z) {}\n};\n\nvec3 operator+(const vec3& l, const vec3& r);\nvec3 operator-(const vec3& l, const vec3& r);\nvec3 operator*(const vec3& v, float f);\nvec3 operator*(const vec3& l, const vec3& r);\nfloat dot(const vec3& l, const vec3& r);\nfloat lenSq(const vec3& v);\nfloat len(const vec3& v);\nvoid normalize(vec3& v);\nvec3 normalized(const vec3& v);\nfloat angle(const vec3& l, const vec3& r);\nvec3 project(const vec3& a, const vec3& b);\nvec3 reject(const vec3& a, const vec3& b);\nvec3 reflect(const vec3& a, const vec3& b);\nvec3 cross(const vec3& l, const vec3& r);\nvec3 lerp(const vec3& s, const vec3& e, float t);\nvec3 slerp(const vec3& s, const vec3& e, float t);\nvec3 nlerp(const vec3& s, const vec3& e, float t);\nbool operator==(const vec3& l, const vec3& r);\nbool operator!=(const vec3& l, const vec3& r);\n\n#endif\n","#include \"Transform.h\"\n#include \"../platform/math.h\"\n\nTransform combine(const Transform& a, const Transform& b) {\n\tTransform out;\n\n\tout.scale = a.scale * b.scale;\n\tout.rotation = b.rotation * a.rotation;\n\n\tout.position = a.rotation * (a.scale * b.position);\n\tout.position = a.position + out.position;\n\n\treturn out;\n}\n\nTransform inverse(const Transform& t) {\n\tTransform inv;\n\n\tinv.rotation = inverse(t.rotation);\n\n\tinv.scale.x = MathAbsF(t.scale.x) < VEC3_EPSILON ? 0.0f : 1.0f / t.scale.x;\n\tinv.scale.y = MathAbsF(t.scale.y) < VEC3_EPSILON ? 0.0f : 1.0f / t.scale.y;\n\tinv.scale.z = MathAbsF(t.scale.z) < VEC3_EPSILON ? 0.0f : 1.0f / t.scale.z;\n\n\tvec3 invTranslation = t.position * -1.0f;\n\tinv.position = inv.rotation * (inv.scale * invTranslation);\n\n\treturn inv;\n}\n\nTransform mix(const Transform& a, const Transform& b, float t) {\n\tquat bRot = b.rotation;\n\tif (dot(a.rotation, bRot) < 0.0f) {\n\t\tbRot = -bRot;\n\t}\n\treturn Transform(\n\t\tlerp(a.position, b.position, t),\n\t\tnlerp(a.rotation, bRot, t),\n\t\tlerp(a.scale, b.scale, t));\n}\n\nmat4 transformToMat4(const Transform& t) {\n\t// First, extract the rotation basis of the transform\n\tvec3 x = t.rotation * vec3(1, 0, 0);\n\tvec3 y = t.rotation * vec3(0, 1, 0);\n\tvec3 z = t.rotation * vec3(0, 0, 1);\n\n\t// Next, scale the basis vectors\n\tx = x * t.scale.x;\n\ty = y * t.scale.y;\n\tz = z * t.scale.z;\n\n\t// Extract the position of the transform\n\tvec3 p = t.position;\n\n\t// Create matrix\n\treturn mat4(\n\t\tx.x, x.y, x.z, 0, // X basis (& Scale)\n\t\ty.x, y.y, y.z, 0, // Y basis (& scale)\n\t\tz.x, z.y, z.z, 0, // Z basis (& scale)\n\t\tp.x, p.y, p.z, 1  // Position\n\t);\n}\n\nTransform mat4ToTransform(const mat4& m) {\n\tTransform out;\n\n\tout.position = vec3(m.v[12], m.v[13], m.v[14]);\n\tout.rotation = mat4ToQuat(m);\n\n\tmat4 rotScaleMat(\n\t\tm.v[0], m.v[1], m.v[2], 0,\n\t\tm.v[4], m.v[5], m.v[6], 0,\n\t\tm.v[8], m.v[9], m.v[10], 0,\n\t\t0, 0, 0, 1\n\t);\n\tmat4 invRotMat = quatToMat4(inverse(out.rotation));\n\tmat4 scaleSkewMat = rotScaleMat * invRotMat;\n\n\tout.scale = vec3(\n\t\tscaleSkewMat.v[0],\n\t\tscaleSkewMat.v[5],\n\t\tscaleSkewMat.v[10]\n\t);\n\n\n\treturn out;\n}\n\nvec3 transformPoint(const Transform& a, const vec3& b) {\n\tvec3 out;\n\n\tout = a.rotation * (a.scale * b);\n\tout = a.position + out;\n\n\treturn out;\n}\n\nvec3 transformVector(const Transform& a, const vec3& b) {\n\tvec3 out;\n\n\tout = a.rotation * (a.scale * b);\n\n\treturn out;\n}\n\nbool operator==(const Transform& a, const Transform& b) {\n\treturn a.position == b.position &&\n\t\ta.rotation == b.rotation &&\n\t\ta.scale == b.scale;\n}\n\nbool operator!=(const Transform& a, const Transform& b) {\n\treturn !(a == b);\n}","#ifndef _H_TRANSFORM_\n#define _H_TRANSFORM_\n\n#include \"vec3.h\"\n#include \"mat4.h\"\n#include \"quat.h\"\n\nstruct Transform {\n\tvec3 position;\n\tquat rotation;\n\tvec3 scale;\n\tTransform() :\n\t\tposition(vec3(0, 0, 0)),\n\t\trotation(quat(0, 0, 0, 1)),\n\t\tscale(vec3(1, 1, 1)) {}\n\tTransform(const vec3& p, const quat& r, const vec3& s) :\n\t\tposition(p), rotation(r), scale(s) {}\n}; // End of transform struct\n\nTransform combine(const Transform& a, const Transform& b);\nTransform inverse(const Transform& t);\nTransform mix(const Transform& a, const Transform& b, float t);\nmat4 transformToMat4(const Transform& t);\nTransform mat4ToTransform(const mat4& m);\nvec3 transformPoint(const Transform& a, const vec3& b);\nvec3 transformVector(const Transform& a, const vec3& b);\n\nbool operator==(const Transform& a, const Transform& b);\nbool operator!=(const Transform& a, const Transform& b);\n\n#endif","#include \"quat.h\"\n#include \"../platform/math.h\"\n\nquat angleAxis(float angle, const vec3& axis) {\n\tvec3 norm = normalized(axis);\n\tfloat s = MathSin(angle * 0.5f);\n\n\treturn quat(\n\t\tnorm.x * s,\n\t\tnorm.y * s,\n\t\tnorm.z * s,\n\t\tMathCos(angle * 0.5f)\n\t);\n}\n\nquat fromTo(const vec3& from, const vec3& to) {\n\tvec3 f = normalized(from);\n\tvec3 t = normalized(to);\n\n\tif (f == t) {\n\t\treturn quat();\n\t}\n\telse if (f == t * -1.0f) {\n\t\tvec3 ortho = vec3(1, 0, 0);\n\t\tif (MathAbsF(f.y) < MathAbsF(f.x)) {\n\t\t\tortho = vec3(0, 1, 0);\n\t\t}\n\t\tif (MathAbsF(f.z) < MathAbsF(f.y) && MathAbsF(f.z) < MathAbsF(f.x)) {\n\t\t\tortho = vec3(0, 0, 1);\n\t\t}\n\n\t\tvec3 axis = normalized(cross(f, ortho));\n\t\treturn quat(axis.x, axis.y, axis.z, 0);\n\t}\n\n\tvec3 half = normalized(f + t);\n\tvec3 axis = cross(f, half);\n\n\treturn quat(\n\t\taxis.x,\n\t\taxis.y,\n\t\taxis.z,\n\t\tdot(f, half)\n\t);\n}\n\nvec3 getAxis(const quat& quat) {\n\treturn normalized(vec3(quat.x, quat.y, quat.z));\n}\n\nfloat getAngle(const quat& quat) {\n\treturn 2.0f * MathACos(quat.w);\n}\n\nquat operator+(const quat& a, const quat& b) {\n\treturn quat(\n\t\ta.x + b.x,\n\t\ta.y + b.y,\n\t\ta.z + b.z,\n\t\ta.w + b.w\n\t);\n}\n\nquat operator-(const quat& a, const quat& b) {\n\treturn quat(\n\t\ta.x - b.x,\n\t\ta.y - b.y,\n\t\ta.z - b.z,\n\t\ta.w - b.w\n\t);\n}\n\nquat operator*(const quat& a, float b) {\n\treturn quat(\n\t\ta.x * b,\n\t\ta.y * b,\n\t\ta.z * b,\n\t\ta.w * b\n\t);\n}\n\nquat operator-(const quat& q) {\n\treturn quat(\n\t\t-q.x,\n\t\t-q.y,\n\t\t-q.z,\n\t\t-q.w\n\t);\n}\n\nbool operator==(const quat& left, const quat& right) {\n\treturn (MathAbsF(left.x - right.x) <= QUAT_EPSILON && \n\t\t    MathAbsF(left.y - right.y) <= QUAT_EPSILON && \n\t\t    MathAbsF(left.z - right.z) <= QUAT_EPSILON && \n\t\t    MathAbsF(left.w - left.w) <= QUAT_EPSILON);\n}\n\nbool operator!=(const quat& a, const quat& b) {\n\treturn !(a == b);\n}\n\nbool sameOrientation(const quat& left, const quat& right) {\n\treturn (MathAbsF(left.x - right.x) <= QUAT_EPSILON && MathAbsF(left.y - right.y) <= QUAT_EPSILON && \n\t\t    MathAbsF(left.z - right.z) <= QUAT_EPSILON && MathAbsF(left.w - left.w) <= QUAT_EPSILON)\n\t\t|| (MathAbsF(left.x + right.x) <= QUAT_EPSILON && MathAbsF(left.y + right.y) <= QUAT_EPSILON && \n\t\t\tMathAbsF(left.z + right.z) <= QUAT_EPSILON && MathAbsF(left.w + left.w) <= QUAT_EPSILON);\n}\n\nfloat dot(const quat& a, const quat& b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\n\nfloat lenSq(const quat& q) {\n\treturn q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n}\n\nfloat len(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn MathSqrt(lenSq);\n}\n\nvoid normalize(quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn;\n\t}\n\tfloat i_len = 1.0f / MathSqrt(lenSq);\n\n\tq.x *= i_len;\n\tq.y *= i_len;\n\tq.z *= i_len;\n\tq.w *= i_len;\n}\n\nquat normalized(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn quat();\n\t}\n\tfloat i_len = 1.0f / MathSqrt(lenSq);\n\n\treturn quat(\n\t\tq.x * i_len,\n\t\tq.y * i_len,\n\t\tq.z * i_len,\n\t\tq.w * i_len\n\t);\n}\n\nquat conjugate(const quat& q) {\n\treturn quat(\n\t\t-q.x,\n\t\t-q.y,\n\t\t-q.z,\n\t\tq.w\n\t);\n}\n\nquat inverse(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn quat();\n\t}\n\tfloat recip = 1.0f / lenSq;\n\n\t// conjugate / norm\n\treturn quat(\n\t\t-q.x * recip,\n\t\t-q.y * recip,\n\t\t-q.z * recip,\n\t\t q.w * recip\n\t);\n}\n\n#if 1\nquat operator*(const quat& Q1, const quat& Q2) {\n\treturn quat(\n\t\tQ2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n\t\t-Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n\t\tQ2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n\t\t-Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n\t);\n}\n#else\nquat operator*(const quat& Q1, const quat& Q2) {\n\tquat result;\n\tresult.scalar = Q2.scalar * Q1.scalar - dot(Q2.vector, Q1.vector);\n\tresult.vector = (Q1.vector * Q2.scalar) + (Q2.vector * Q1.scalar) + cross(Q2.vector, Q1.vector);\n\treturn result;\n}\n#endif\n\nvec3 operator*(const quat& q, const vec3& v) {\n\treturn q.vector * 2.0f * dot(q.vector, v) +\n\t\tv * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n\t\tcross(q.vector, v) * 2.0f * q.scalar;\n}\n\nquat mix(const quat& from, const quat& to, float t) {\n\treturn from * (1.0f - t) + to * t;\n}\n\nquat nlerp(const quat& from, const quat& to, float t) {\n\treturn normalized(from + (to - from) * t);\n}\n\nquat operator^(const quat& q, float f) {\n\tfloat angle = 2.0f * MathACos(q.scalar);\n\tvec3 axis = normalized(q.vector);\n\n\tfloat halfCos = MathCos(f * angle * 0.5f);\n\tfloat halfSin = MathSin(f * angle * 0.5f);\n\n\treturn quat(\n\t\taxis.x * halfSin,\n\t\taxis.y * halfSin,\n\t\taxis.z * halfSin,\n\t\thalfCos\n\t);\n}\n\nquat slerp(const quat& start, const quat& end, float t) {\n\tif (MathAbsF(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n\t\treturn nlerp(start, end, t);\n\t}\n\n\treturn normalized(((inverse(start) * end) ^ t) * start);\n}\n\nquat lookRotation(const vec3& direcion, const vec3& up) {\n\t// Find orthonormal basis vectors\n\tvec3 f = normalized(direcion);\n\tvec3 u = normalized(up);\n\tvec3 r = cross(u, f);\n\tu = cross(f, r);\n\n\t// From world forward to object forward\n\tquat f2d = fromTo(vec3(0, 0, 1), f);\n\n\t// what direction is the new object up?\n\tvec3 objectUp = f2d * vec3(0, 1, 0);\n\t// From object up to desired up\n\tquat u2u = fromTo(objectUp, u);\n\n\t// Rotate to forward direction first, then twist to correct up\n\tquat result = f2d * u2u;\n\t// Don\u00ef\u00bf\u00bdt forget to normalize the result\n\treturn normalized(result);\n}\n\nmat4 quatToMat4(const quat& q) {\n\tvec3 r = q * vec3(1, 0, 0);\n\tvec3 u = q * vec3(0, 1, 0);\n\tvec3 f = q * vec3(0, 0, 1);\n\n\treturn mat4(\n\t\tr.x, r.y, r.z, 0,\n\t\tu.x, u.y, u.z, 0,\n\t\tf.x, f.y, f.z, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nquat mat4ToQuat(const mat4& m) {\n\tvec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n\tvec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\n\treturn lookRotation(forward, up);\n}","#ifndef _H_QUAT_\n#define _H_QUAT_\n\n#define QUAT_EPSILON 0.000001f\n#define QUAT_DEG2RAD 0.0174533f\n#define QUAT_RAD2DEG 57.2958f\n\n#include \"vec3.h\"\n#include \"mat4.h\"\n\nstruct quat {\n\tunion {\n\t\tstruct {\n\t\t\tfloat x;\n\t\t\tfloat y;\n\t\t\tfloat z;\n\t\t\tfloat w;\n\t\t};\n\t\tstruct {\n\t\t\tvec3 vector;\n\t\t\tfloat scalar;\n\t\t};\n\t\tfloat v[4];\n\t};\n\n\tinline quat() :\n\t\tx(0), y(0), z(0), w(1) { }\n\tinline quat(float _x, float _y, float _z, float _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) {}\n};\n\nquat angleAxis(float angle, const vec3& axis);\nquat fromTo(const vec3& from, const vec3& to);\nvec3 getAxis(const quat& quat);\nfloat getAngle(const quat& quat);\nquat operator+(const quat& a, const quat& b);\nquat operator-(const quat& a, const quat& b);\nquat operator*(const quat& a, float b);\nquat operator-(const quat& q);\nbool operator==(const quat& left, const quat& right);\nbool operator!=(const quat& a, const quat& b);\nbool sameOrientation(const quat& left, const quat& right);\nfloat dot(const quat& a, const quat& b);\nfloat lenSq(const quat& q);\nfloat len(const quat& q);\nvoid normalize(quat& q);\nquat normalized(const quat& q);\nquat conjugate(const quat& q);\nquat inverse(const quat& q);\nquat operator*(const quat& Q1, const quat& Q2);\nvec3 operator*(const quat& q, const vec3& v);\nquat mix(const quat& from, const quat& to, float t);\nquat nlerp(const quat& from, const quat& to, float t);\nquat operator^(const quat& q, float f);\nquat operator^(const quat& q, float f);\nquat slerp(const quat& start, const quat& end, float t);\nquat lookRotation(const vec3& direcion, const vec3& up);\nmat4 quatToMat4(const quat& q);\nquat mat4ToQuat(const mat4& m);\n\n#endif","// stb_sprintf - v1.10 - public domain snprintf() implementation\n// originally by Jeff Roberts / RAD Game Tools, 2015/10/20\n// http://github.com/nothings/stb\n//\n// allowed types:  sc uidBboXx p AaGgEef n\n// lengths      :  hh h ll j z t I64 I32 I\n//\n// Contributors:\n//    Fabian \"ryg\" Giesen (reformatting)\n//    github:aganm (attribute format)\n//\n// Contributors (bugfixes):\n//    github:d26435\n//    github:trex78\n//    github:account-login\n//    Jari Komppa (SI suffixes)\n//    Rohit Nirmal\n//    Marcin Wojdyr\n//    Leonard Ritter\n//    Stefano Zanotti\n//    Adam Allison\n//    Arvid Gerstmann\n//    Markus Kolb\n//\n// LICENSE:\n//\n//   See end of file for license information.\n\n#ifndef STB_SPRINTF_H_INCLUDE\n#define STB_SPRINTF_H_INCLUDE\n\n#include \"../platform/memory.h\"\n#if MEM_PLATFORM_WASM\n#include \"../platform/compiler/clang_stdarg.h\"\n#endif\n\n/*\nSingle file sprintf replacement.\n\nOriginally written by Jeff Roberts at RAD Game Tools - 2015/10/20.\nHereby placed in public domain.\n\nThis is a full sprintf replacement that supports everything that\nthe C runtime sprintfs support, including float/double, 64-bit integers,\nhex floats, field parameters (%*.*d stuff), length reads backs, etc.\n\nWhy would you need this if sprintf already exists?  Well, first off,\nit's *much* faster (see below). It's also much smaller than the CRT\nversions code-space-wise. We've also added some simple improvements\nthat are super handy (commas in thousands, callbacks at buffer full,\nfor example). Finally, the format strings for MSVC and GCC differ\nfor 64-bit integers (among other small things), so this lets you use\nthe same format strings in cross platform code.\n\nIt uses the standard single file trick of being both the header file\nand the source itself. If you just include it normally, you just get\nthe header file function definitions. To get the code, you include\nit from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.\n\nIt only uses va_args macros from the C runtime to do it's work. It\ndoes cast doubles to S64s and shifts and divides U64s, which does\ndrag in CRT code on most platforms.\n\nIt compiles to roughly 8K with float support, and 4K without.\nAs a comparison, when using MSVC static libs, calling sprintf drags\nin 16K.\n\nAPI:\n====\nint stbsp_sprintf( char * buf, char const * fmt, ... )\nint stbsp_snprintf( char * buf, int count, char const * fmt, ... )\n  Convert an arg list into a buffer.  stbsp_snprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintf( char * buf, char const * fmt, va_list va )\nint stbsp_vsnprintf( char * buf, int count, char const * fmt, va_list va )\n  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns\n  a zero-terminated string (unlike regular snprintf).\n\nint stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )\n    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );\n  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.\n  Your callback can then copy the chars out, print them or whatever.\n  This function is actually the workhorse for everything else.\n  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.\n    // you return the next buffer to use or 0 to stop converting\n\nvoid stbsp_set_separators( char comma, char period )\n  Set the comma and period characters to use.\n\nFLOATS/DOUBLES:\n===============\nThis code uses a internal float->ascii conversion method that uses\ndoubles with error correction (double-doubles, for ~105 bits of\nprecision).  This conversion is round-trip perfect - that is, an atof\nof the values output here will give you the bit-exact double back.\n\nOne difference is that our insignificant digits will be different than\nwith MSVC or GCC (but they don't match each other either).  We also\ndon't attempt to find the minimum length matching float (pre-MSVC15\ndoesn't either).\n\nIf you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT\nand you'll save 4K of code space.\n\n64-BIT INTS:\n============\nThis library also supports 64-bit integers and you can use MSVC style or\nGCC style indicators (%I64d or %lld).  It supports the C99 specifiers\nfor u32 and ptr_diff_t (%jd %zd) as well.\n\nEXTRAS:\n=======\nLike some GCCs, for integers and floats, you can use a ' (single quote)\nspecifier and commas will be inserted on the thousands: \"%'d\" on 12345\nwould print 12,345.\n\nFor integers and floats, you can use a \"$\" specifier and the number\nwill be converted to float and then divided to get kilo, mega, giga or\ntera and then printed, so \"%$d\" 1000 is \"1.0 k\", \"%$.2d\" 2536000 is\n\"2.53 M\", etc. For byte values, use two $:s, like \"%$$d\" to turn\n2536000 to \"2.42 Mi\". If you prefer JEDEC suffixes to SI ones, use three\n$:s: \"%$$$d\" -> \"2.42 M\". To remove the space between the number and the\nsuffix, add \"_\" specifier: \"%_$d\" -> \"2.53M\".\n\nIn addition to octal and hexadecimal conversions, you can print\nintegers in binary: \"%b\" for 256 would print 100.\n\nPERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):\n===================================================================\n\"%d\" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)\n\"%24d\" across all 32-bit ints (4.5x/4.2x faster)\n\"%x\" across all 32-bit ints (4.5x/3.8x faster)\n\"%08x\" across all 32-bit ints (4.3x/3.8x faster)\n\"%f\" across e-10 to e+10 floats (7.3x/6.0x faster)\n\"%e\" across e-10 to e+10 floats (8.1x/6.0x faster)\n\"%g\" across e-10 to e+10 floats (10.0x/7.1x faster)\n\"%f\" for values near e-300 (7.9x/6.5x faster)\n\"%f\" for values near e+300 (10.0x/9.1x faster)\n\"%e\" for values near e-300 (10.1x/7.0x faster)\n\"%e\" for values near e+300 (9.2x/6.0x faster)\n\"%.320f\" for values near e-300 (12.6x/11.2x faster)\n\"%a\" for random values (8.6x/4.3x faster)\n\"%I64d\" for 64-bits with 32-bit values (4.8x/3.4x faster)\n\"%I64d\" for 64-bits > 32-bit values (4.9x/5.5x faster)\n\"%s%s%s\" for 64 char strings (7.1x/7.3x faster)\n\"...512 char string...\" ( 35.0x/32.5x faster!)\n*/\n\n#if defined(__clang__)\n #if defined(__has_feature) && defined(__has_attribute)\n  #if __has_feature(address_sanitizer)\n   #if __has_attribute(__no_sanitize__)\n    #define STBSP__ASAN __attribute__((__no_sanitize__(\"address\")))\n   #elif __has_attribute(__no_sanitize_address__)\n    #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n   #elif __has_attribute(__no_address_safety_analysis__)\n    #define STBSP__ASAN __attribute__((__no_address_safety_analysis__))\n   #endif\n  #endif\n #endif\n#elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n #if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__\n  #define STBSP__ASAN __attribute__((__no_sanitize_address__))\n #endif\n#endif\n\n#ifndef STBSP__ASAN\n#define STBSP__ASAN\n#endif\n\n#ifdef STB_SPRINTF_STATIC\n#define STBSP__PUBLICDEC static\n#define STBSP__PUBLICDEF static STBSP__ASAN\n#else\n#ifdef __cplusplus\n#define STBSP__PUBLICDEC extern \"C\"\n#define STBSP__PUBLICDEF extern \"C\" STBSP__ASAN\n#else\n#define STBSP__PUBLICDEC extern\n#define STBSP__PUBLICDEF STBSP__ASAN\n#endif\n#endif\n\n#if defined(__has_attribute)\n #if __has_attribute(format)\n   #define STBSP__ATTRIBUTE_FORMAT(fmt,va) __attribute__((format(printf,fmt,va)))\n #endif\n#endif\n\n#ifndef STBSP__ATTRIBUTE_FORMAT\n#define STBSP__ATTRIBUTE_FORMAT(fmt,va)\n#endif\n\n#ifdef _MSC_VER\n#define STBSP__NOTUSED(v)  (void)(v)\n#else\n#define STBSP__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#if MEM_PLATFORM_WINDOWS\n#include <stdarg.h> // for va_arg(), va_list()\n#endif\n\n#ifndef STB_SPRINTF_MIN\n#define STB_SPRINTF_MIN 512 // how many characters per callback\n#endif\ntypedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);\n\n#ifndef STB_SPRINTF_DECORATE\n#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names\n#endif\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, int count, char const *fmt, va_list va);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(2,3);\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(3,4);\n\nSTBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);\nSTBSP__PUBLICDEC void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);\n\n#endif // STB_SPRINTF_H_INCLUDE\n\n#ifdef STB_SPRINTF_IMPLEMENTATION\n\n#define stbsp__uint32 unsigned int\n#define stbsp__int32 signed int\n\n#ifdef _MSC_VER\n#define stbsp__uint64 unsigned __int64\n#define stbsp__int64 signed __int64\n#else\n#define stbsp__uint64 unsigned long long\n#define stbsp__int64 signed long long\n#endif\n#define stbsp__uint16 unsigned short\n\n#ifndef stbsp__uintptr\n#if defined(__ppc64__) || defined(__powerpc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64) || defined(__s390x__)\n#define stbsp__uintptr stbsp__uint64\n#else\n#define stbsp__uintptr stbsp__uint32\n#endif\n#endif\n\n#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define STB_SPRINTF_MSVC_MODE\n#endif\n#endif\n\n#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses\n#define STBSP__UNALIGNED(code)\n#else\n#define STBSP__UNALIGNED(code) code\n#endif\n\n#ifndef STB_SPRINTF_NOFLOAT\n// internal float utility functions\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);\n#define STBSP__SPECIAL 0x7000\n#endif\n\nstatic char stbsp__period = '.';\nstatic char stbsp__comma = ',';\nstatic struct\n{\n   short temp; // force next field to be 2-byte aligned\n   char pair[201];\n} stbsp__digitpair =\n{\n  0,\n   \"00010203040506070809101112131415161718192021222324\"\n   \"25262728293031323334353637383940414243444546474849\"\n   \"50515253545556575859606162636465666768697071727374\"\n   \"75767778798081828384858687888990919293949596979899\"\n};\n\nSTBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)\n{\n   stbsp__period = pperiod;\n   stbsp__comma = pcomma;\n}\n\n#define STBSP__LEFTJUST 1\n#define STBSP__LEADINGPLUS 2\n#define STBSP__LEADINGSPACE 4\n#define STBSP__LEADING_0X 8\n#define STBSP__LEADINGZERO 16\n#define STBSP__INTMAX 32\n#define STBSP__TRIPLET_COMMA 64\n#define STBSP__NEGATIVE 128\n#define STBSP__METRIC_SUFFIX 256\n#define STBSP__HALFWIDTH 512\n#define STBSP__METRIC_NOSPACE 1024\n#define STBSP__METRIC_1024 2048\n#define STBSP__METRIC_JEDEC 4096\n\nstatic void stbsp__lead_sign(stbsp__uint32 fl, char *sign)\n{\n   sign[0] = 0;\n   if (fl & STBSP__NEGATIVE) {\n      sign[0] = 1;\n      sign[1] = '-';\n   } else if (fl & STBSP__LEADINGSPACE) {\n      sign[0] = 1;\n      sign[1] = ' ';\n   } else if (fl & STBSP__LEADINGPLUS) {\n      sign[0] = 1;\n      sign[1] = '+';\n   }\n}\n\nstatic STBSP__ASAN stbsp__uint32 stbsp__strlen_limited(char const *s, stbsp__uint32 limit)\n{\n   char const * sn = s;\n\n   // get up to 4-byte alignment\n   for (;;) {\n      if (((stbsp__uintptr)sn & 3) == 0)\n         break;\n\n      if (!limit || *sn == 0)\n         return (stbsp__uint32)(sn - s);\n\n      ++sn;\n      --limit;\n   }\n\n   // scan over 4 bytes at a time to find terminating 0\n   // this will intentionally scan up to 3 bytes past the end of buffers,\n   // but becase it works 4B aligned, it will never cross page boundaries\n   // (hence the STBSP__ASAN markup; the over-read here is intentional\n   // and harmless)\n   while (limit >= 4) {\n      stbsp__uint32 v = *(stbsp__uint32 *)sn;\n      // bit hack to find if there's a 0 byte in there\n      if ((v - 0x01010101) & (~v) & 0x80808080UL)\n         break;\n\n      sn += 4;\n      limit -= 4;\n   }\n\n   // handle the last few characters to find actual size\n   while (limit && *sn) {\n      ++sn;\n      --limit;\n   }\n\n   return (stbsp__uint32)(sn - s);\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)\n{\n   static char hex[] = \"0123456789abcdefxp\";\n   static char hexu[] = \"0123456789ABCDEFXP\";\n   char *bf;\n   char const *f;\n   int tlen = 0;\n\n   bf = buf;\n   f = fmt;\n   for (;;) {\n      stbsp__int32 fw, pr, tz;\n      stbsp__uint32 fl;\n\n      // macros for the callback buffer stuff\n      #define stbsp__chk_cb_bufL(bytes)                        \\\n         {                                                     \\\n            int len = (int)(bf - buf);                         \\\n            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \\\n               tlen += len;                                    \\\n               if (0 == (bf = buf = callback(buf, user, len))) \\\n                  goto done;                                   \\\n            }                                                  \\\n         }\n      #define stbsp__chk_cb_buf(bytes)    \\\n         {                                \\\n            if (callback) {               \\\n               stbsp__chk_cb_bufL(bytes); \\\n            }                             \\\n         }\n      #define stbsp__flush_cb()                      \\\n         {                                           \\\n            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \\\n         } // flush if there is even one byte in the buffer\n      #define stbsp__cb_buf_clamp(cl, v)                \\\n         cl = v;                                        \\\n         if (callback) {                                \\\n            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \\\n            if (cl > lg)                                \\\n               cl = lg;                                 \\\n         }\n\n      // fast copy everything up to the next % (or end of string)\n      for (;;) {\n         while (((stbsp__uintptr)f) & 3) {\n         schk1:\n            if (f[0] == '%')\n               goto scandd;\n         schk2:\n            if (f[0] == 0)\n               goto endfmt;\n            stbsp__chk_cb_buf(1);\n            *bf++ = f[0];\n            ++f;\n         }\n         for (;;) {\n            // Check if the next 4 bytes contain %(0x25) or end of string.\n            // Using the 'hasless' trick:\n            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord\n            stbsp__uint32 v, c;\n            v = *(stbsp__uint32 *)f;\n            c = (~v) & 0x80808080;\n            if (((v ^ 0x25252525) - 0x01010101) & c)\n               goto schk1;\n            if ((v - 0x01010101) & c)\n               goto schk2;\n            if (callback)\n               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)\n                  goto schk1;\n            #ifdef STB_SPRINTF_NOUNALIGNED\n                if(((stbsp__uintptr)bf) & 3) {\n                    bf[0] = f[0];\n                    bf[1] = f[1];\n                    bf[2] = f[2];\n                    bf[3] = f[3];\n                } else\n            #endif\n            {\n                *(stbsp__uint32 *)bf = v;\n            }\n            bf += 4;\n            f += 4;\n         }\n      }\n   scandd:\n\n      ++f;\n\n      // ok, we have a percent, read the modifiers first\n      fw = 0;\n      pr = -1;\n      fl = 0;\n      tz = 0;\n\n      // flags\n      for (;;) {\n         switch (f[0]) {\n         // if we have left justify\n         case '-':\n            fl |= STBSP__LEFTJUST;\n            ++f;\n            continue;\n         // if we have leading plus\n         case '+':\n            fl |= STBSP__LEADINGPLUS;\n            ++f;\n            continue;\n         // if we have leading space\n         case ' ':\n            fl |= STBSP__LEADINGSPACE;\n            ++f;\n            continue;\n         // if we have leading 0x\n         case '#':\n            fl |= STBSP__LEADING_0X;\n            ++f;\n            continue;\n         // if we have thousand commas\n         case '\\'':\n            fl |= STBSP__TRIPLET_COMMA;\n            ++f;\n            continue;\n         // if we have kilo marker (none->kilo->kibi->jedec)\n         case '$':\n            if (fl & STBSP__METRIC_SUFFIX) {\n               if (fl & STBSP__METRIC_1024) {\n                  fl |= STBSP__METRIC_JEDEC;\n               } else {\n                  fl |= STBSP__METRIC_1024;\n               }\n            } else {\n               fl |= STBSP__METRIC_SUFFIX;\n            }\n            ++f;\n            continue;\n         // if we don't want space between metric suffix and number\n         case '_':\n            fl |= STBSP__METRIC_NOSPACE;\n            ++f;\n            continue;\n         // if we have leading zero\n         case '0':\n            fl |= STBSP__LEADINGZERO;\n            ++f;\n            goto flags_done;\n         default: goto flags_done;\n         }\n      }\n   flags_done:\n\n      // get the field width\n      if (f[0] == '*') {\n         fw = va_arg(va, stbsp__uint32);\n         ++f;\n      } else {\n         while ((f[0] >= '0') && (f[0] <= '9')) {\n            fw = fw * 10 + f[0] - '0';\n            f++;\n         }\n      }\n      // get the precision\n      if (f[0] == '.') {\n         ++f;\n         if (f[0] == '*') {\n            pr = va_arg(va, stbsp__uint32);\n            ++f;\n         } else {\n            pr = 0;\n            while ((f[0] >= '0') && (f[0] <= '9')) {\n               pr = pr * 10 + f[0] - '0';\n               f++;\n            }\n         }\n      }\n\n      // handle integer size overrides\n      switch (f[0]) {\n      // are we halfwidth?\n      case 'h':\n         fl |= STBSP__HALFWIDTH;\n         ++f;\n         if (f[0] == 'h')\n            ++f;  // QUARTERWIDTH\n         break;\n      // are we 64-bit (unix style)\n      case 'l':\n         fl |= ((sizeof(long) == 8) ? STBSP__INTMAX : 0);\n         ++f;\n         if (f[0] == 'l') {\n            fl |= STBSP__INTMAX;\n            ++f;\n         }\n         break;\n      // are we 64-bit on intmax? (c99)\n      case 'j':\n         fl |= (sizeof(u32) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit on u32 or platform_t? (c99)\n      case 'z':\n         fl |= (sizeof(platform_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      case 't':\n         fl |= (sizeof(platform_t) == 8) ? STBSP__INTMAX : 0;\n         ++f;\n         break;\n      // are we 64-bit (msft style)\n      case 'I':\n         if ((f[1] == '6') && (f[2] == '4')) {\n            fl |= STBSP__INTMAX;\n            f += 3;\n         } else if ((f[1] == '3') && (f[2] == '2')) {\n            f += 3;\n         } else {\n            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);\n            ++f;\n         }\n         break;\n      default: break;\n      }\n\n      // handle each replacement\n      switch (f[0]) {\n         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307\n         char num[STBSP__NUMSZ];\n         char lead[8];\n         char tail[8];\n         char *s;\n         char const *h;\n         stbsp__uint32 l, n, cs;\n         stbsp__uint64 n64;\n#ifndef STB_SPRINTF_NOFLOAT\n         double fv;\n#endif\n         stbsp__int32 dp;\n         char const *sn;\n\n      case 's':\n         // get the string\n         s = va_arg(va, char *);\n         if (s == 0)\n            s = (char *)\"null\";\n         // get the length, limited to desired precision\n         // always limit to ~0u chars since our counts are 32b\n         l = stbsp__strlen_limited(s, (pr >= 0) ? pr : ~0u);\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         // copy the string in\n         goto scopy;\n\n      case 'c': // char\n         // get the character\n         s = num + STBSP__NUMSZ - 1;\n         *s = (char)va_arg(va, int);\n         l = 1;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n\n      case 'n': // weird write-bytes specifier\n      {\n         int *d = va_arg(va, int *);\n         *d = tlen + (int)(bf - buf);\n      } break;\n\n#ifdef STB_SPRINTF_NOFLOAT\n      case 'A':              // float\n      case 'a':              // hex float\n      case 'G':              // float\n      case 'g':              // float\n      case 'E':              // float\n      case 'e':              // float\n      case 'f':              // float\n         va_arg(va, double); // eat it\n         s = (char *)\"No float\";\n         l = 8;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         cs = 0;\n         STBSP__NOTUSED(dp);\n         goto scopy;\n#else\n      case 'A': // hex float\n      case 'a': // hex float\n         h = (f[0] == 'A') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))\n            fl |= STBSP__NEGATIVE;\n\n         s = num + 64;\n\n         stbsp__lead_sign(fl, lead);\n\n         if (dp == -1023)\n            dp = (n64) ? -1022 : 0;\n         else\n            n64 |= (((stbsp__uint64)1) << 52);\n         n64 <<= (64 - 56);\n         if (pr < 15)\n            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));\n// add leading chars\n\n#ifdef STB_SPRINTF_MSVC_MODE\n         *s++ = '0';\n         *s++ = 'x';\n#else\n         lead[1 + lead[0]] = '0';\n         lead[2 + lead[0]] = 'x';\n         lead[0] += 2;\n#endif\n         *s++ = h[(n64 >> 60) & 15];\n         n64 <<= 4;\n         if (pr)\n            *s++ = stbsp__period;\n         sn = s;\n\n         // print the bits\n         n = pr;\n         if (n > 13)\n            n = 13;\n         if (pr > (stbsp__int32)n)\n            tz = pr - n;\n         pr = 0;\n         while (n--) {\n            *s++ = h[(n64 >> 60) & 15];\n            n64 <<= 4;\n         }\n\n         // print the expo\n         tail[1] = h[17];\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n\n         dp = (int)(s - sn);\n         l = (int)(s - (num + 64));\n         s = num + 64;\n         cs = 1 + (3 << 24);\n         goto scopy;\n\n      case 'G': // float\n      case 'g': // float\n         h = (f[0] == 'G') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6;\n         else if (pr == 0)\n            pr = 1; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n\n         n = pr;\n         if (l > (stbsp__uint32)pr)\n            l = pr;\n         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {\n            --pr;\n            --l;\n         }\n\n         // should we use %e\n         if ((dp <= -4) || (dp > (stbsp__int32)n)) {\n            if (pr > (stbsp__int32)l)\n               pr = l - 1;\n            else if (pr)\n               --pr; // when using %e, there is one digit before the decimal\n            goto doexpfromg;\n         }\n         // this is the insane action to get the pr to match %g semantics for %f\n         if (dp > 0) {\n            pr = (dp < (stbsp__int32)l) ? l - dp : 0;\n         } else {\n            pr = -dp + ((pr > (stbsp__int32)l) ? (stbsp__int32) l : pr);\n         }\n         goto dofloatfromg;\n\n      case 'E': // float\n      case 'e': // float\n         h = (f[0] == 'E') ? hexu : hex;\n         fv = va_arg(va, double);\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))\n            fl |= STBSP__NEGATIVE;\n      doexpfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n         // handle leading chars\n         *s++ = sn[0];\n\n         if (pr)\n            *s++ = stbsp__period;\n\n         // handle after decimal\n         if ((l - 1) > (stbsp__uint32)pr)\n            l = pr + 1;\n         for (n = 1; n < l; n++)\n            *s++ = sn[n];\n         // trailing zeros\n         tz = pr - (l - 1);\n         pr = 0;\n         // dump expo\n         tail[1] = h[0xe];\n         dp -= 1;\n         if (dp < 0) {\n            tail[2] = '-';\n            dp = -dp;\n         } else\n            tail[2] = '+';\n#ifdef STB_SPRINTF_MSVC_MODE\n         n = 5;\n#else\n         n = (dp >= 100) ? 5 : 4;\n#endif\n         tail[0] = (char)n;\n         for (;;) {\n            tail[n] = '0' + dp % 10;\n            if (n <= 3)\n               break;\n            --n;\n            dp /= 10;\n         }\n         cs = 1 + (3 << 24); // how many tens\n         goto flt_lead;\n\n      case 'f': // float\n         fv = va_arg(va, double);\n      doafloat:\n         // do kilos\n         if (fl & STBSP__METRIC_SUFFIX) {\n            double divisor;\n            divisor = 1000.0f;\n            if (fl & STBSP__METRIC_1024)\n               divisor = 1024.0;\n            while (fl < 0x4000000) {\n               if ((fv < divisor) && (fv > -divisor))\n                  break;\n               fv /= divisor;\n               fl += 0x1000000;\n            }\n         }\n         if (pr == -1)\n            pr = 6; // default is 6\n         // read the double into a string\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))\n            fl |= STBSP__NEGATIVE;\n      dofloatfromg:\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n         if (dp == STBSP__SPECIAL) {\n            s = (char *)sn;\n            cs = 0;\n            pr = 0;\n            goto scopy;\n         }\n         s = num + 64;\n\n         // handle the three decimal varieties\n         if (dp <= 0) {\n            stbsp__int32 i;\n            // handle 0.000*000xxxx\n            *s++ = '0';\n            if (pr)\n               *s++ = stbsp__period;\n            n = -dp;\n            if ((stbsp__int32)n > pr)\n               n = pr;\n            i = n;\n            while (i) {\n               if ((((stbsp__uintptr)s) & 3) == 0)\n                  break;\n               *s++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)s = 0x30303030;\n               s += 4;\n               i -= 4;\n            }\n            while (i) {\n               *s++ = '0';\n               --i;\n            }\n            if ((stbsp__int32)(l + n) > pr)\n               l = pr - n;\n            i = l;\n            while (i) {\n               *s++ = *sn++;\n               --i;\n            }\n            tz = pr - (n + l);\n            cs = 1 + (3 << 24); // how many tens did we write (for commas below)\n         } else {\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;\n            if ((stbsp__uint32)dp >= l) {\n               // handle xxxx000*000.0\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= l)\n                        break;\n                  }\n               }\n               if (n < (stbsp__uint32)dp) {\n                  n = dp - n;\n                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                     while (n) {\n                        if ((((stbsp__uintptr)s) & 3) == 0)\n                           break;\n                        *s++ = '0';\n                        --n;\n                     }\n                     while (n >= 4) {\n                        *(stbsp__uint32 *)s = 0x30303030;\n                        s += 4;\n                        n -= 4;\n                     }\n                  }\n                  while (n) {\n                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                        cs = 0;\n                        *s++ = stbsp__comma;\n                     } else {\n                        *s++ = '0';\n                        --n;\n                     }\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr) {\n                  *s++ = stbsp__period;\n                  tz = pr;\n               }\n            } else {\n               // handle xxxxx.xxxx000*000\n               n = 0;\n               for (;;) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\n                     cs = 0;\n                     *s++ = stbsp__comma;\n                  } else {\n                     *s++ = sn[n];\n                     ++n;\n                     if (n >= (stbsp__uint32)dp)\n                        break;\n                  }\n               }\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\n               if (pr)\n                  *s++ = stbsp__period;\n               if ((l - dp) > (stbsp__uint32)pr)\n                  l = pr + dp;\n               while (n < l) {\n                  *s++ = sn[n];\n                  ++n;\n               }\n               tz = pr - (l - dp);\n            }\n         }\n         pr = 0;\n\n         // handle k,m,g,t\n         if (fl & STBSP__METRIC_SUFFIX) {\n            char idx;\n            idx = 1;\n            if (fl & STBSP__METRIC_NOSPACE)\n               idx = 0;\n            tail[0] = idx;\n            tail[1] = ' ';\n            {\n               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.\n                  if (fl & STBSP__METRIC_1024)\n                     tail[idx + 1] = \"_KMGT\"[fl >> 24];\n                  else\n                     tail[idx + 1] = \"_kMGT\"[fl >> 24];\n                  idx++;\n                  // If printing kibits and not in jedec, add the 'i'.\n                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {\n                     tail[idx + 1] = 'i';\n                     idx++;\n                  }\n                  tail[0] = idx;\n               }\n            }\n         };\n\n      flt_lead:\n         // get the length that we copied\n         l = (stbsp__uint32)(s - (num + 64));\n         s = num + 64;\n         goto scopy;\n#endif\n\n      case 'B': // upper binary\n      case 'b': // lower binary\n         h = (f[0] == 'B') ? hexu : hex;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[0xb];\n         }\n         l = (8 << 4) | (1 << 8);\n         goto radixnum;\n\n      case 'o': // octal\n         h = hexu;\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 1;\n            lead[1] = '0';\n         }\n         l = (3 << 4) | (3 << 8);\n         goto radixnum;\n\n      case 'p': // pointer\n         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;\n         pr = sizeof(void *) * 2;\n         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros\n                                    // fall through - to X\n\n      case 'X': // upper hex\n      case 'x': // lower hex\n         h = (f[0] == 'X') ? hexu : hex;\n         l = (4 << 4) | (4 << 8);\n         lead[0] = 0;\n         if (fl & STBSP__LEADING_0X) {\n            lead[0] = 2;\n            lead[1] = '0';\n            lead[2] = h[16];\n         }\n      radixnum:\n         // get the number\n         if (fl & STBSP__INTMAX)\n            n64 = va_arg(va, stbsp__uint64);\n         else\n            n64 = va_arg(va, stbsp__uint32);\n\n         s = num + STBSP__NUMSZ;\n         dp = 0;\n         // clear tail, and clear leading if value is zero\n         tail[0] = 0;\n         if (n64 == 0) {\n            lead[0] = 0;\n            if (pr == 0) {\n               l = 0;\n               cs = 0;\n               goto scopy;\n            }\n         }\n         // convert to string\n         for (;;) {\n            *--s = h[n64 & ((1 << (l >> 8)) - 1)];\n            n64 >>= (l >> 8);\n            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))\n               break;\n            if (fl & STBSP__TRIPLET_COMMA) {\n               ++l;\n               if ((l & 15) == ((l >> 4) & 15)) {\n                  l &= ~15;\n                  *--s = stbsp__comma;\n               }\n            }\n         };\n         // get the tens and the comma pos\n         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         // copy it\n         goto scopy;\n\n      case 'u': // unsigned\n      case 'i':\n      case 'd': // integer\n         // get the integer and abs it\n         if (fl & STBSP__INTMAX) {\n            stbsp__int64 i64 = va_arg(va, stbsp__int64);\n            n64 = (stbsp__uint64)i64;\n            if ((f[0] != 'u') && (i64 < 0)) {\n               n64 = (stbsp__uint64)-i64;\n               fl |= STBSP__NEGATIVE;\n            }\n         } else {\n            stbsp__int32 i = va_arg(va, stbsp__int32);\n            n64 = (stbsp__uint32)i;\n            if ((f[0] != 'u') && (i < 0)) {\n               n64 = (stbsp__uint32)-i;\n               fl |= STBSP__NEGATIVE;\n            }\n         }\n\n#ifndef STB_SPRINTF_NOFLOAT\n         if (fl & STBSP__METRIC_SUFFIX) {\n            if (n64 < 1024)\n               pr = 0;\n            else if (pr == -1)\n               pr = 1;\n            fv = (double)(stbsp__int64)n64;\n            goto doafloat;\n         }\n#endif\n\n         // convert to string\n         s = num + STBSP__NUMSZ;\n         l = 0;\n\n         for (;;) {\n            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)\n            char *o = s - 8;\n            if (n64 >= 100000000) {\n               n = (stbsp__uint32)(n64 % 100000000);\n               n64 /= 100000000;\n            } else {\n               n = (stbsp__uint32)n64;\n               n64 = 0;\n            }\n            if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n               do {\n                  s -= 2;\n                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n                  n /= 100;\n               } while (n);\n            }\n            while (n) {\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = (char)(n % 10) + '0';\n                  n /= 10;\n               }\n            }\n            if (n64 == 0) {\n               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))\n                  ++s;\n               break;\n            }\n            while (s != o)\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\n                  l = 0;\n                  *--s = stbsp__comma;\n                  --o;\n               } else {\n                  *--s = '0';\n               }\n         }\n\n         tail[0] = 0;\n         stbsp__lead_sign(fl, lead);\n\n         // get the length that we copied\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\n         if (l == 0) {\n            *--s = '0';\n            l = 1;\n         }\n         cs = l + (3 << 24);\n         if (pr < 0)\n            pr = 0;\n\n      scopy:\n         // get fw=leading/trailing space, pr=leading zeros\n         if (pr < (stbsp__int32)l)\n            pr = l;\n         n = pr + lead[0] + tail[0] + tz;\n         if (fw < (stbsp__int32)n)\n            fw = n;\n         fw -= n;\n         pr -= l;\n\n         // handle right justify and leading zeros\n         if ((fl & STBSP__LEFTJUST) == 0) {\n            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr\n            {\n               pr = (fw > pr) ? fw : pr;\n               fw = 0;\n            } else {\n               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas\n            }\n         }\n\n         // copy the spaces and/or zeros\n         if (fw + pr) {\n            stbsp__int32 i;\n            stbsp__uint32 c;\n\n            // copy leading spaces (or when doing %8.4d stuff)\n            if ((fl & STBSP__LEFTJUST) == 0)\n               while (fw > 0) {\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i) {\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  stbsp__chk_cb_buf(1);\n               }\n\n            // copy leader\n            sn = lead + 1;\n            while (lead[0]) {\n               stbsp__cb_buf_clamp(i, lead[0]);\n               lead[0] -= (char)i;\n               while (i) {\n                  *bf++ = *sn++;\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n\n            // copy leading zeros\n            c = cs >> 24;\n            cs &= 0xffffff;\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;\n            while (pr > 0) {\n               stbsp__cb_buf_clamp(i, pr);\n               pr -= i;\n               if ((fl & STBSP__TRIPLET_COMMA) == 0) {\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = '0';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x30303030;\n                     bf += 4;\n                     i -= 4;\n                  }\n               }\n               while (i) {\n                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {\n                     cs = 0;\n                     *bf++ = stbsp__comma;\n                  } else\n                     *bf++ = '0';\n                  --i;\n               }\n               stbsp__chk_cb_buf(1);\n            }\n         }\n\n         // copy leader if there is still one\n         sn = lead + 1;\n         while (lead[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, lead[0]);\n            lead[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy the string\n         n = l;\n         while (n) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, n);\n            n -= i;\n            STBSP__UNALIGNED(while (i >= 4) {\n               *(stbsp__uint32 volatile *)bf = *(stbsp__uint32 volatile *)s;\n               bf += 4;\n               s += 4;\n               i -= 4;\n            })\n            while (i) {\n               *bf++ = *s++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy trailing zeros\n         while (tz) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tz);\n            tz -= i;\n            while (i) {\n               if ((((stbsp__uintptr)bf) & 3) == 0)\n                  break;\n               *bf++ = '0';\n               --i;\n            }\n            while (i >= 4) {\n               *(stbsp__uint32 *)bf = 0x30303030;\n               bf += 4;\n               i -= 4;\n            }\n            while (i) {\n               *bf++ = '0';\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // copy tail if there is one\n         sn = tail + 1;\n         while (tail[0]) {\n            stbsp__int32 i;\n            stbsp__cb_buf_clamp(i, tail[0]);\n            tail[0] -= (char)i;\n            while (i) {\n               *bf++ = *sn++;\n               --i;\n            }\n            stbsp__chk_cb_buf(1);\n         }\n\n         // handle the left justify\n         if (fl & STBSP__LEFTJUST)\n            if (fw > 0) {\n               while (fw) {\n                  stbsp__int32 i;\n                  stbsp__cb_buf_clamp(i, fw);\n                  fw -= i;\n                  while (i) {\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\n                        break;\n                     *bf++ = ' ';\n                     --i;\n                  }\n                  while (i >= 4) {\n                     *(stbsp__uint32 *)bf = 0x20202020;\n                     bf += 4;\n                     i -= 4;\n                  }\n                  while (i--)\n                     *bf++ = ' ';\n                  stbsp__chk_cb_buf(1);\n               }\n            }\n         break;\n\n      default: // unknown, just copy code\n         s = num + STBSP__NUMSZ - 1;\n         *s = f[0];\n         l = 1;\n         fw = fl = 0;\n         lead[0] = 0;\n         tail[0] = 0;\n         pr = 0;\n         dp = 0;\n         cs = 0;\n         goto scopy;\n      }\n      ++f;\n   }\nendfmt:\n\n   if (!callback)\n      *bf = 0;\n   else\n      stbsp__flush_cb();\n\ndone:\n   return tlen + (int)(bf - buf);\n}\n\n// cleanup\n#undef STBSP__LEFTJUST\n#undef STBSP__LEADINGPLUS\n#undef STBSP__LEADINGSPACE\n#undef STBSP__LEADING_0X\n#undef STBSP__LEADINGZERO\n#undef STBSP__INTMAX\n#undef STBSP__TRIPLET_COMMA\n#undef STBSP__NEGATIVE\n#undef STBSP__METRIC_SUFFIX\n#undef STBSP__NUMSZ\n#undef stbsp__chk_cb_bufL\n#undef stbsp__chk_cb_buf\n#undef stbsp__flush_cb\n#undef stbsp__cb_buf_clamp\n\n// ============================================================================\n//   wrapper functions\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n   va_end(va);\n   return result;\n}\n\ntypedef struct stbsp__context {\n   char *buf;\n   int count;\n   int length;\n   char tmp[STB_SPRINTF_MIN];\n} stbsp__context;\n\nstatic char *stbsp__clamp_callback(const char *buf, void *user, int len)\n{\n   stbsp__context *c = (stbsp__context *)user;\n   c->length += len;\n\n   if (len > c->count)\n      len = c->count;\n\n   if (len) {\n      if (buf != c->buf) {\n         const char *s, *se;\n         char *d;\n         d = c->buf;\n         s = buf;\n         se = buf + len;\n         do {\n            *d++ = *s++;\n         } while (s < se);\n      }\n      c->buf += len;\n      c->count -= len;\n   }\n\n   if (c->count <= 0)\n      return c->tmp;\n   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can\n}\n\nstatic char * stbsp__count_clamp_callback( const char * buf, void * user, int len )\n{\n   stbsp__context * c = (stbsp__context*)user;\n   (void) sizeof(buf);\n\n   c->length += len;\n   return c->tmp; // go direct into buffer if you can\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE( vsnprintf )( char * buf, int count, char const * fmt, va_list va )\n{\n   stbsp__context c;\n\n   if ( (count == 0) && !buf )\n   {\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );\n   }\n   else\n   {\n      int l;\n\n      c.buf = buf;\n      c.count = count;\n      c.length = 0;\n\n      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );\n\n      // zero-terminate\n      l = (int)( c.buf - buf );\n      if ( l >= count ) // should never be greater, only equal (or less) than count\n         l = count - 1;\n      buf[l] = 0;\n   }\n\n   return c.length;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...)\n{\n   int result;\n   va_list va;\n   va_start(va, fmt);\n\n   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);\n   va_end(va);\n\n   return result;\n}\n\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)\n{\n   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\n}\n\n// =======================================================================\n//   low level float utility functions\n\n#ifndef STB_SPRINTF_NOFLOAT\n\n// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)\n#define STBSP__COPYFP(dest, src)                   \\\n   {                                               \\\n      int cn;                                      \\\n      for (cn = 0; cn < 8; cn++)                   \\\n         ((char *)&dest)[cn] = ((char *)&src)[cn]; \\\n   }\n\n// get float info\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)\n{\n   double d;\n   stbsp__int64 b = 0;\n\n   // load value and round at the frac_digits\n   d = value;\n\n   STBSP__COPYFP(b, d);\n\n   *bits = b & ((((stbsp__uint64)1) << 52) - 1);\n   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);\n\n   return (stbsp__int32)((stbsp__uint64) b >> 63);\n}\n\nstatic double const stbsp__bot[23] = {\n   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,\n   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022\n};\nstatic double const stbsp__negbot[22] = {\n   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,\n   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022\n};\nstatic double const stbsp__negboterr[22] = {\n   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,\n   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,\n   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,\n   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039\n};\nstatic double const stbsp__top[13] = {\n   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299\n};\nstatic double const stbsp__negtop[13] = {\n   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299\n};\nstatic double const stbsp__toperr[13] = {\n   8388608,\n   6.8601809640529717e+028,\n   -7.253143638152921e+052,\n   -4.3377296974619174e+075,\n   -1.5559416129466825e+098,\n   -3.2841562489204913e+121,\n   -3.7745893248228135e+144,\n   -1.7356668416969134e+167,\n   -3.8893577551088374e+190,\n   -9.9566444326005119e+213,\n   6.3641293062232429e+236,\n   -5.2069140800249813e+259,\n   -5.2504760255204387e+282\n};\nstatic double const stbsp__negtoperr[13] = {\n   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,\n   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,\n   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,\n   8.0970921678014997e-317\n};\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1200)\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000,\n   100000000000,\n   1000000000000,\n   10000000000000,\n   100000000000000,\n   1000000000000000,\n   10000000000000000,\n   100000000000000000,\n   1000000000000000000,\n   10000000000000000000U\n};\n#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)\n#else\nstatic stbsp__uint64 const stbsp__powten[20] = {\n   1,\n   10,\n   100,\n   1000,\n   10000,\n   100000,\n   1000000,\n   10000000,\n   100000000,\n   1000000000,\n   10000000000ULL,\n   100000000000ULL,\n   1000000000000ULL,\n   10000000000000ULL,\n   100000000000000ULL,\n   1000000000000000ULL,\n   10000000000000000ULL,\n   100000000000000000ULL,\n   1000000000000000000ULL,\n   10000000000000000000ULL\n};\n#define stbsp__tento19th (1000000000000000000ULL)\n#endif\n\n#define stbsp__ddmulthi(oh, ol, xh, yh)                            \\\n   {                                                               \\\n      double ahi = 0, alo, bhi = 0, blo;                           \\\n      stbsp__int64 bt;                                             \\\n      oh = xh * yh;                                                \\\n      STBSP__COPYFP(bt, xh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(ahi, bt);                                      \\\n      alo = xh - ahi;                                              \\\n      STBSP__COPYFP(bt, yh);                                       \\\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\n      STBSP__COPYFP(bhi, bt);                                      \\\n      blo = yh - bhi;                                              \\\n      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \\\n   }\n\n#define stbsp__ddtoS64(ob, xh, xl)          \\\n   {                                        \\\n      double ahi = 0, alo, vh, t;           \\\n      ob = (stbsp__int64)xh;                \\\n      vh = (double)ob;                      \\\n      ahi = (xh - vh);                      \\\n      t = (ahi - xh);                       \\\n      alo = (xh - (ahi - t)) - (vh + t);    \\\n      ob += (stbsp__int64)(ahi + alo + xl); \\\n   }\n\n#define stbsp__ddrenorm(oh, ol) \\\n   {                            \\\n      double s;                 \\\n      s = oh + ol;              \\\n      ol = ol - (s - oh);       \\\n      oh = s;                   \\\n   }\n\n#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);\n\n#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);\n\nstatic void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350\n{\n   double ph, pl;\n   if ((power >= 0) && (power <= 22)) {\n      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);\n   } else {\n      stbsp__int32 e, et, eb;\n      double p2h, p2l;\n\n      e = power;\n      if (power < 0)\n         e = -e;\n      et = (e * 0x2c9) >> 14; /* %23 */\n      if (et > 13)\n         et = 13;\n      eb = e - (et * 23);\n\n      ph = d;\n      pl = 0.0;\n      if (power < 0) {\n         if (eb) {\n            --eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);\n            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      } else {\n         if (eb) {\n            e = eb;\n            if (eb > 22)\n               eb = 22;\n            e -= eb;\n            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);\n            if (e) {\n               stbsp__ddrenorm(ph, pl);\n               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);\n               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);\n               ph = p2h;\n               pl = p2l;\n            }\n         }\n         if (et) {\n            stbsp__ddrenorm(ph, pl);\n            --et;\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);\n            ph = p2h;\n            pl = p2l;\n         }\n      }\n   }\n   stbsp__ddrenorm(ph, pl);\n   *ohi = ph;\n   *olo = pl;\n}\n\n// given a float value, returns the significant bits in bits, and the position of the\n//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values\n//   returned in the decimal_pos parameter.\n// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)\n{\n   double d;\n   stbsp__int64 bits = 0;\n   stbsp__int32 expo, e, ng, tens;\n\n   d = value;\n   STBSP__COPYFP(bits, d);\n   expo = (stbsp__int32)((bits >> 52) & 2047);\n   ng = (stbsp__int32)((stbsp__uint64) bits >> 63);\n   if (ng)\n      d = -d;\n\n   if (expo == 2047) // is nan or inf?\n   {\n      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? \"NaN\" : \"Inf\";\n      *decimal_pos = STBSP__SPECIAL;\n      *len = 3;\n      return ng;\n   }\n\n   if (expo == 0) // is zero or denormal\n   {\n      if (((stbsp__uint64) bits << 1) == 0) // do zero\n      {\n         *decimal_pos = 1;\n         *start = out;\n         out[0] = '0';\n         *len = 1;\n         return ng;\n      }\n      // find the right expo for denormals\n      {\n         stbsp__int64 v = ((stbsp__uint64)1) << 51;\n         while ((bits & v) == 0) {\n            --expo;\n            v >>= 1;\n         }\n      }\n   }\n\n   // find the decimal exponent as well as the decimal bits of the value\n   {\n      double ph, pl;\n\n      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046\n      tens = expo - 1023;\n      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);\n\n      // move the significant bits into position and stick them into an int\n      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);\n\n      // get full as much precision from double-double as possible\n      stbsp__ddtoS64(bits, ph, pl);\n\n      // check if we undershot\n      if (((stbsp__uint64)bits) >= stbsp__tento19th)\n         ++tens;\n   }\n\n   // now do the rounding in integer land\n   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);\n   if ((frac_digits < 24)) {\n      stbsp__uint32 dg = 1;\n      if ((stbsp__uint64)bits >= stbsp__powten[9])\n         dg = 10;\n      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {\n         ++dg;\n         if (dg == 20)\n            goto noround;\n      }\n      if (frac_digits < dg) {\n         stbsp__uint64 r;\n         // add 0.5 at the right position and round\n         e = dg - frac_digits;\n         if ((stbsp__uint32)e >= 24)\n            goto noround;\n         r = stbsp__powten[e];\n         bits = bits + (r / 2);\n         if ((stbsp__uint64)bits >= stbsp__powten[dg])\n            ++tens;\n         bits /= r;\n      }\n   noround:;\n   }\n\n   // kill long trailing runs of zeros\n   if (bits) {\n      stbsp__uint32 n;\n      for (;;) {\n         if (bits <= 0xffffffff)\n            break;\n         if (bits % 1000)\n            goto donez;\n         bits /= 1000;\n      }\n      n = (stbsp__uint32)bits;\n      while ((n % 1000) == 0)\n         n /= 1000;\n      bits = n;\n   donez:;\n   }\n\n   // convert to string\n   out += 64;\n   e = 0;\n   for (;;) {\n      stbsp__uint32 n;\n      char *o = out - 8;\n      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)\n      if (bits >= 100000000) {\n         n = (stbsp__uint32)(bits % 100000000);\n         bits /= 100000000;\n      } else {\n         n = (stbsp__uint32)bits;\n         bits = 0;\n      }\n      while (n) {\n         out -= 2;\n         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];\n         n /= 100;\n         e += 2;\n      }\n      if (bits == 0) {\n         if ((e) && (out[0] == '0')) {\n            ++out;\n            --e;\n         }\n         break;\n      }\n      while (out != o) {\n         *--out = '0';\n         ++e;\n      }\n   }\n\n   *decimal_pos = tens;\n   *start = out;\n   *len = e;\n   return ng;\n}\n\n#undef stbsp__ddmulthi\n#undef stbsp__ddrenorm\n#undef stbsp__ddmultlo\n#undef stbsp__ddmultlos\n#undef STBSP__SPECIAL\n#undef STBSP__COPYFP\n\n#endif // STB_SPRINTF_NOFLOAT\n\n// clean up\n#undef stbsp__uint16\n#undef stbsp__uint32\n#undef stbsp__int32\n#undef stbsp__uint64\n#undef stbsp__int64\n#undef STBSP__UNALIGNED\n\n#endif // STB_SPRINTF_IMPLEMENTATION\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n","#include \"AnimLoader.h\"\n#include \"../platform/loader.h\"\n#include \"../platform/assert.h\"\n\nnamespace AnimLoader {\n\tHeader* PatchPointers(Header* header, void* base) {\n\t\theader->firstNodePtr = (ptr)((char*)base + (u64)header->firstNodePtr);\n\t\theader->firstResourcePtr = (ptr)((char*)base + (u64)header->firstResourcePtr);\n\t\theader->firstAnimPtr = (ptr)((char*)base + (u64)header->firstAnimPtr);\n\t\theader->firstTrackPtr = (ptr)((char*)base + (u64)header->firstTrackPtr);\n\t\theader->firstFramePtr = (ptr)((char*)base + (u64)header->firstFramePtr);\n\t\theader->firstFilePtr = (ptr)((char*)base + (u64)header->firstFilePtr);\n\n\t\t{\n\t\t\tNode* iter = header->FirstNode();\n\t\t\tfor (u32 i = 0; i < header->nodeCount; ++i) {\n\t\t\t\tif (iter->name != 0) {\n\t\t\t\t\titer->name = (str)((char*)base + (u64)iter->name);\n\t\t\t\t}\n\t\t\t\titer = iter->Next();\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tAnimation* iter = header->FirstAnimation();\n\t\t\tfor (u32 i = 0; i < header->animationCount; ++i) {\n\t\t\t\tif (iter->trackPtr != 0) {\n\t\t\t\t\titer->trackPtr = (ptr)((char*)base + (u64)iter->trackPtr);\n\t\t\t\t}\n\t\t\t\tif (iter->name != 0) {\n\t\t\t\t\titer->name = (str)((char*)base + (u64)iter->name);\n\t\t\t\t}\n\t\t\t\titer = iter->Next();\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tTrack* iter = header->FirstTrack();\n\t\t\tfor (u32 i = 0; i < header->trackCount; ++i) {\n\t\t\t\tif (iter->framesPtr != 0) {\n\t\t\t\t\titer->framesPtr = (ptr)((char*)base + (u64)iter->framesPtr);\n\t\t\t\t}\n\t\t\t\tif (iter->nextPtr != 0) {\n\t\t\t\t\titer->nextPtr = (ptr)((char*)base + (u64)iter->nextPtr);\n\t\t\t\t}\n\t\t\t\titer = iter->NextInMemory();\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tResource* iter = header->FirstResource();\n\t\t\tfor (u32 i = 0; i < header->resourceCount; ++i) {\n\t\t\t\tif (iter->name != 0) {\n\t\t\t\t\titer->name = (str)((char*)base + (u64)iter->name);\n\t\t\t\t}\n\t\t\t\tif (iter->dataPtr != 0) {\n\t\t\t\t\titer->dataPtr = (str)((char*)base + (u64)iter->dataPtr);\n\t\t\t\t}\n\t\t\t\t//PresentFile(iter->Data(), iter->bytes);\n\t\t\t\titer = iter->Next();\n\t\t\t}\n\t\t}\n\n\n\t\treturn header;\n\t}\n\n\tHeader* Parse(void* data, u32 size) {\n\t\tconst char* expected = \"Keyframe Studio\";\n\t\tconst char* result = (const char*)data;\n\n\t\tbool same = true;\n\t\tfor (const char* e = expected, *r = result; *e != 0; ++e, ++r) {\n\t\t\tif (*e != *r) {\n\t\t\t\tsame = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!same) {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tu32 len = 0;\n\t\tfor (const char* e = expected; *e != 0; ++e, ++len);\n\t\tlen += 1; // Null terminator\n\t\tvoid* reader = (void*)((char*)data + len);\n\t\tHeader* header = (Header*)reader;\n\n\t\tfor (const char* e = expected, *r = ((const char*)data) + (size - len + 1); *e != 0; ++e, ++r) {\n\t\t\tif (*e != *r) {\n\t\t\t\tsame = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!same) {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\treturn 0;\n\t\t}\n\n\t\theader = PatchPointers(header, data);\n\t\treturn header;\n\t}\n}","#define _CRT_SECURE_NO_WARNINGS\n#ifndef  _H_ANIM_LOADER_\n#define _H_ANIM_LOADER_\n\n#include \"../platform/memory.h\"\n\nnamespace AnimLoader {\n\ttypedef u32 b32;\n\ttypedef u64 str;\n\ttypedef u64 ptr;\n\n\tstatic_assert (sizeof(b32) == 4, \"b32 should be defined as a 4 byte type\");\n\tstatic_assert (sizeof(ptr) == 8, \"ptr should be defined as a 8 byte type\");\n\tstatic_assert (sizeof(str) == 8, \"ptr should be defined as a 8 byte type\");\n\n\tstruct Header;\n\tstruct Node;\n\tstruct Resource;\n\tstruct Animation;\n\tstruct Track;\n\tstruct Frame;\n\n#define HEADER_SIZE (8 * 4 + 6 * 8)\n#define NODE_SIZE (22 * 4 + 1 * 8)\n#define RESOURCE_SIZE (4 * 4 + 2 * 8)\n#define ANIMATION_SIZE (6 * 4 + 2 * 8)\n#define TRACK_SIZE (4 * 4 + 2 * 8)\n#define FRAME_SIZE (4 * 4)\n\n\tstruct Header {\n\t\t/*0*/u32 nodeCount;\n\t\t/*1*/u32 resourceCount;\n\t\t/*2*/u32 animationCount;\n\t\t/*3*/u32 trackCount;\n\t\t/*4*/u32 nodeUidGenerator;\n\t\t/*5*/u32 resourceUidGenerator;\n\t\t/*6*/u32 animationUidGenerator;\n\t\t/*7*/u32 padding;\n\t\t/*8*/ptr firstNodePtr;\n\t\t/*10*/ptr firstResourcePtr;\n\t\t/*12*/ptr firstAnimPtr;\n\t\t/*14*/ptr firstTrackPtr;\n\t\t/*16*/ptr firstFramePtr;\n\t\t/*18*/ptr firstFilePtr;\n\n\t\tinline Node* FirstNode() {\n\t\t\treturn (Node*)firstNodePtr;\n\t\t}\n\n\t\tinline Resource* FirstResource() {\n\t\t\treturn (Resource*)firstResourcePtr;\n\t\t}\n\n\t\tinline Animation* FirstAnimation() {\n\t\t\treturn (Animation*)firstAnimPtr;\n\t\t}\n\n\t\tinline Track* FirstTrack() {\n\t\t\treturn (Track*)firstTrackPtr;\n\t\t}\n\n\t\tinline Node* FindNodeByUID(u32 uid) {\n\t\t\tNode* iter = FirstNode();\n\t\t\tchar* step = (char*)iter;\n\t\t\tfor (u32 i = 0; i < nodeCount; ++i) {\n\t\t\t\tu32* nUid = (u32*)iter;\n\t\t\t\tif (*nUid == uid) {\n\t\t\t\t\treturn iter;\n\t\t\t\t}\n\t\t\t\titer = (Node*)(step + NODE_SIZE);\n\t\t\t\tstep = (char*)iter;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tinline Resource* FindResourceByUID(u32 uid) {\n\t\t\tResource* iter = FirstResource();\n\t\t\tchar* step = (char*)iter;\n\n\t\t\tfor (u32 i = 0; i < resourceCount; ++i) {\n\t\t\t\tu32* rUid = (u32*)iter;\n\t\t\t\tif (*rUid == uid) {\n\t\t\t\t\treturn iter;\n\t\t\t\t}\n\n\t\t\t\titer = (Resource*)(step + RESOURCE_SIZE);\n\t\t\t\tstep = (char*)iter;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tinline Animation* FindAnimationByUID(u32 uid) {\n\t\t\tAnimation* iter = FirstAnimation();\n\t\t\tchar* step = (char*)iter;\n\n\t\t\tfor (u32 i = 0; i < animationCount; ++i) {\n\t\t\t\tu32* aUid = (u32*)iter;\n\t\t\t\tif (*aUid == uid) {\n\t\t\t\t\treturn iter;\n\t\t\t\t}\n\n\t\t\t\titer = (Animation*)(step + ANIMATION_SIZE);\n\t\t\t\tstep = (char*)iter;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t};\n\tstatic_assert (sizeof(Header) == HEADER_SIZE, \"Header isn't tightly packed\");\n\n\tstruct Node {\n\t\tu32 nodeUid;\n\t\tu32 parentUid;\n\t\tu32 firstChildUid;\n\t\tu32 nextSiblingUid;\n\t\tstr name;\n\t\tf32 positionX;\n\t\tf32 positionY;\n\t\tf32 rotationAngles;\n\t\tf32 scaleX;\n\t\tf32 scaleY;\n\t\tu32 resourceUid;\n\t\tf32 tintR;\n\t\tf32 tintG;\n\t\tf32 tintB;\n\t\tf32 tintA;\n\t\tu32 visible;\n\t\tf32 sourceX;\n\t\tf32 sourceY;\n\t\tf32 sourceW;\n\t\tf32 sourceH;\n\t\tf32 pivotX;\n\t\tf32 pivotY;\n\t\ti32 sortIndex;\n\n\t\tinline Node* Next() {\n\t\t\treturn this + 1;\n\t\t}\n\n\t\tinline bool IsRoot() {\n\t\t\treturn nodeUid == 0 && parentUid == 0;\n\t\t}\n\t};\n\tstatic_assert (sizeof(Node) == NODE_SIZE, \"Node isn't tightly packed\");\n\n\tstruct Resource {\n\t\tu32 resourceUid;\n\t\tu32 bytes;\n\t\tstr name;\n\t\tu32 width;\n\t\tu32 height;\n\t\tptr dataPtr;\n\n\t\tinline void* Data() {\n\t\t\treturn (void*)dataPtr;\n\t\t}\n\n\t\tinline Resource* Next() {\n\t\t\treturn this + 1;\n\t\t}\n\t};\n\tstatic_assert (sizeof(Resource) == RESOURCE_SIZE, \"Resource isn't tightly packed\");\n\n\tstruct Animation {\n\t\tu32 animUid;\n\t\tb32 looping;\n\t\tu32 frameRate;\n\t\tu32 frameCount;\n\t\tu32 numTracks;\n\t\tu32 padding;\n\t\tstr name;\n\t\tptr trackPtr;\n\n\t\tinline Track* FirstTrack() {\n\t\t\treturn (Track*)trackPtr;\n\t\t}\n\n\t\tinline Animation* Next() {\n\t\t\treturn this + 1;\n\t\t}\n\t};\n\tstatic_assert (sizeof(Animation) == ANIMATION_SIZE, \"Animation isn't tightly packed\");\n\n\tstruct Track {\n\t\tu32 targetAnimUid;\n\t\tu32 targetNodeUid;\n\t\tu32 targetProp;\n\t\tu32 numFrames;\n\t\tptr framesPtr;\n\t\tptr nextPtr;\n\n\t\tinline Frame* FirstFrame() {\n\t\t\treturn (Frame*)framesPtr;\n\t\t}\n\n\t\tinline Track* NextInAnimation() {\n\t\t\treturn (Track*)nextPtr;\n\t\t}\n\n\t\tinline Track* NextInMemory() {\n\t\t\treturn this + 1;\n\t\t}\n\t};\n\tstatic_assert (sizeof(Track) == TRACK_SIZE, \"Track isn't tightly packed\");\n\n\tstruct Frame {\n\t\tu32 index;\n\t\tunion {\n\t\t\tf32 fValue;\n\t\t\tu32 uValue;\n\t\t\ti32 iValue;\n\t\t\tb32 bValue;\n\t\t};\n\t\tu32 padding;\n\t\tu32 interp;\n\n\t\tinline Frame* Next() {\n\t\t\treturn this + 1;\n\t\t}\n\t};\n\n\tstatic_assert (sizeof(Frame) == FRAME_SIZE, \"Frame isn't tightly packed\");\n\n\tHeader* Parse(void* data, u32 size);\n};\n\n#endif // ! _H_ANIM_LOADER_","#include \"imgui.h\"\n#include \"../platform/math.h\"\n#include \"../platform/window.h\"\n#include \"../framework/vector.h\"\n#include \"../framework/draw2d.h\"\n#include \"../debt/stb_sprintf.h\"\n\n#define IMGUI_ACTIVE_INPUT_NONE 0\n#define IMGUI_ACTIVE_INPUT_MOUSE 1\n#define IMGUI_ACTIVE_INPUT_TOUCH1 2\n#define IMGUI_ACTIVE_INPUT_TOUCH2 3\n#define IMGUI_ACTIVE_INPUT_TOUCH3 4\n#define IMGUI_ACTIVE_INPUT_TOUCH4 5\n#define IMGUI_ACTIVE_INPUT_TOUCH5 6\n\n#define IMGUI_WIDGET_BLOCK_SIZE 256\n\nnamespace Imgui {\n\tvoid SetTooltipLabel(const char* label);\n\tnamespace Internal {\n#if PLATFORM_DEBUG\n\t\tstruct RectBlock\n\t\t{\n\t\t\tImgui::Rect rectangles[IMGUI_WIDGET_BLOCK_SIZE];\n\t\t\tRectBlock* next;\n\t\t};\n#endif\n\t\tenum class TextAreaState {\n\t\t\tNone = 0,\n\t\t\tActivated,\n\t\t\tIdle,\n\t\t\tShutdown\n\t\t};\n\n\t\tstruct TextAreaInstance {\n\t\t\ti32 widgetId;\n\t\t\tchar* buffer;\n\t\t\tu32 length;\n\t\t\tu32 capacity;\n\t\t\ti32 karratIndex;\n\t\t\ti32 selection;\n\t\t\tTextAreaState state;\n\n\t\t\tinline void Reserve(u32 cap) {\n\t\t\t\tu32 newCap = capacity;\n\t\t\t\tif (capacity == 0) {\n\t\t\t\t\tnewCap = 16;\n\t\t\t\t}\n\t\t\t\tif (newCap < cap) {\n\t\t\t\t\tnewCap = cap;\n\t\t\t\t}\n\n\t\t\t\tif (capacity != newCap) {\n\t\t\t\t\tbuffer = (char*)MemRealloc(buffer, sizeof(char) * newCap);\n\t\t\t\t\tcapacity = newCap;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinline void Set(const char* newText, u32 newTextLen) {\n\t\t\t\tif (newTextLen + 1 >= capacity) {\n\t\t\t\t\tReserve(newTextLen + 1);\n\t\t\t\t}\n\n\t\t\t\tif (newTextLen == 0) {\n\t\t\t\t\tbuffer[0] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMemCopy(buffer, newText, newTextLen); // This includes the null terminator (i think)\n\t\t\t\t\tbuffer[newTextLen] = 0;\n\t\t\t\t}\n\t\t\t\tlength = newTextLen;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstruct PopupMenuInfo {\n\t\t\ti32 id;\n\t\t\tRect screenPos;\n\t\t\tVector<const char*> items;\n\t\t\tu32 itemCount;\n\t\t\ti32 hot;\n\t\t\tbool reversed;\n\t\t};\n\n\t\tstruct State {\n\t\t\tconst StyleSheet* style;\n\n\t\t\ti32 hotControl;\n\t\t\ti32 activeControl;\n\t\t\ti32 modalControl;\n\t\t\ti32 lastBeingModalPopupContext;\n\t\t\ti32 lastBeingModalPopupActivation;\n\n\t\t\tu32 widgetFont;\n\t\t\tu32 interfaceFont;\n\t\t\tu32 labelFont;\n\n\t\t\tbool ateKeyboard;\n\t\t\tbool virtualKeyPressed;\n\t\t\tbool fakeShift;\n\t\t\tbool fakeCtrl;\n\t\t\tbool fakeCaps;\n\t\t\tbool fakeLeftPressed;\n\t\t\tbool fakeRightPressed;\n\n\t\t\ti32 positiveIdGenerator;\n\t\t\ti32 negativeIdGenerator;\n\n\t\t\ti32 grabKeyboardOnOrAfter;\n\n\t\t\tf32 dpi;\n\n\t\t\ti32 lastHotControl;\n\t\t\tf32 hotControlTimer;\n\n\t\t\ti32 lastActiveControl;\n\t\t\tf32 activeControlTimer;\n\t\t\tf32 lastTextDoubleClickTimer;\n\n\t\t\tf32 pulseTimer;\n\t\t\tbool pulse;\n\n\t\t\tf32 longPulseTimer;\n\t\t\tbool longPulse;\n\n\t\t\tf32 blinkTimer;\n\t\t\tbool blink;\n\n\t\t\ti32 tooltipIcon;\n\t\t\tconst char* tooltipLabel;\n\t\t\ti32 activeInputMethod;\n\n\t\t\tTextAreaInstance textAreaA;\n\t\t\tTextAreaInstance textAreaB;\n\n\t\t\tf32 timeSinceLastRelease;\n\n\t\t\thsv lastSelectedColor;\n\t\t\tbool colorPickerActive;\n\t\t\tRect colorPickerArea;\n\n\t\t\tbool debugOverlayEnabled;\n\n\t\t\tVector<PopupMenuInfo> modalPopups;\n\t\t\tu32 numPopupMenus;\n\t\t\tu32 maxPopupMenus;\n\t\t\ti32 lastModalId;\n#if PLATFORM_DEBUG\n\t\t\tRectBlock positiveWidgets;\n\t\t\tRectBlock negativeWidgets;\n#endif\n\t\tprivate:\n#if PLATFORM_DEBUG\n\n\t\t\tinline i32 _PrivateGetWidgetIndex(i32 widgetId) {\n\t\t\t\ti32 widgetIndex = MathAbsI(widgetId);\n\t\t\t\tu32 widgetBlock = widgetIndex / IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\twidgetIndex -= widgetBlock * IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\tPlatformAssert(widgetIndex >= 0, __LOCATION__);\n\t\t\t\tPlatformAssert(widgetIndex < IMGUI_WIDGET_BLOCK_SIZE, __LOCATION__);\n\t\t\t\treturn widgetIndex;\n\t\t\t}\n\n\t\t\tRectBlock* _PrivateGetWidgetBlock(i32 widgetId) {\n\t\t\t\tRectBlock* block = &positiveWidgets;\n\t\t\t\tif (widgetId < 0) {\n\t\t\t\t\tblock = &negativeWidgets;\n\t\t\t\t}\n\n\t\t\t\ti32 widgetIndex = MathAbsI(widgetId);\n\t\t\t\tu32 widgetBlock = widgetIndex / IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\twidgetIndex -= widgetBlock * IMGUI_WIDGET_BLOCK_SIZE;\n\t\t\t\tPlatformAssert(widgetIndex >= 0, __LOCATION__);\n\t\t\t\tPlatformAssert(widgetIndex < IMGUI_WIDGET_BLOCK_SIZE, __LOCATION__);\n\n\t\t\t\tfor (u32 i = 0; i < widgetBlock; ++i) {\n\t\t\t\t\tif (block->next == 0) {\n\t\t\t\t\t\tblock->next = (RectBlock*)MemAlloc(sizeof(RectBlock));\n\t\t\t\t\t}\n\t\t\t\t\tblock = block->next;\n\t\t\t\t}\n\n\t\t\t\treturn block;\n\t\t\t}\n#endif\n\t\t\tinline i32 _PrivateGenerateWidget(const Rect& widgetRect, i32 widgetId) {\n#if PLATFORM_DEBUG\n\t\t\t\tRectBlock* block = _PrivateGetWidgetBlock(widgetId);\n\t\t\t\ti32 index = _PrivateGetWidgetIndex(widgetId);\n\t\t\t\tblock->rectangles[index] = widgetRect;\n#endif\n\t\t\t\treturn widgetId;\n\t\t\t}\n\t\tpublic:\n\t\t\tinline Rect Debug_GetWidgetRect(i32 widgetId) {\n#if PLATFORM_DEBUG\n\t\t\t\tRectBlock* block = _PrivateGetWidgetBlock(widgetId);\n\t\t\t\ti32 index = _PrivateGetWidgetIndex(widgetId);\n\t\t\t\treturn block->rectangles[index];\n#else\n\t\t\t\treturn Rect(0, 0, 50, 50);\n#endif\n\t\t\t}\n\n\t\t\tinline i32 NegativeId(const Rect& widgetRect) {\n\t\t\t\treturn _PrivateGenerateWidget(widgetRect, --negativeIdGenerator);\n\t\t\t}\n\n\t\t\tinline i32 PositiveId(const Rect& widgetRect) {\n\t\t\t\treturn _PrivateGenerateWidget(widgetRect, ++positiveIdGenerator);\n\t\t\t}\n\n\t\t\t\n\t\t\t// A \"pointer\" in this context is the mouse or a touch. Only one thing can be\n\t\t\t// the active pointer at once. IE, if the active pointer is the mouse, then\n\t\t\t// touch events wont be dispatched. But if the active pointer is a touch,\n\t\t\t// then mouse events wont be dispatched. Only one active touch at a time.\n\t\t\tinline f32 GetPointerX() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetX(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseGetX();\n\t\t\t}\n\n\t\t\tinline f32 GetPrevPointerX() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetPrevX(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MousePrevX();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerY() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetY(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseGetY();\n\t\t\t}\n\n\t\t\tinline f32 GetPrevPointerY() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchGetPrevY(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MousePrevY();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerDeltaX() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchDeltaX(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseDeltaX();\n\t\t\t}\n\n\t\t\tinline f32 GetPointerDeltaY() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchDeltaY(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseDeltaY();\n\t\t\t}\n\n\t\t\tinline bool GetPointerPressed() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchPressed(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MousePressed(MouseButtonLeft);\n\t\t\t}\n\n\t\t\tinline bool GetPointerReleased() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn TouchReleased(touchIndex);\n\t\t\t\t}\n\t\t\t\tbool debug = MouseReleased(MouseButtonLeft);\n\t\t\t\treturn debug;\n\t\t\t}\n\n\t\t\tinline bool GetPointerUp() {\n\t\t\t\tif (activeInputMethod != IMGUI_ACTIVE_INPUT_NONE && activeInputMethod != IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\t\tint touchIndex = activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\t\tPlatformAssert(touchIndex >= 0 && touchIndex <= 4, __LOCATION__);\n\t\t\t\t\treturn !TouchIsActive(touchIndex);\n\n\t\t\t\t}\n\t\t\t\treturn MouseUp(MouseButtonLeft);\n\t\t\t}\n\t\t};\n\n\t\tState* gState;\n\n\t\tinline u32 StrLen(const char* str) {\n\t\t\tif (str == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tu32 len = 0;\n\t\t\tfor (const char* s = str; *s != 0; ++s, ++len);\n\t\t\treturn len;\n\t\t}\n\n\n\t\t// Returns the number of elements shifted\n\t\tinline i32 RemoveRangeFromString(char* stringToModify, u32 stringLen, i32 startIndex, i32 endIndex) {\n\t\t\tif (startIndex > endIndex) {\n\t\t\t\ti32 tmp = startIndex;\n\t\t\t\tstartIndex = endIndex;\n\t\t\t\tendIndex = tmp;\n\t\t\t}\n\n\t\t\tint n = endIndex - startIndex;\n\t\t\tint p = startIndex;\n\t\t\t\n\t\t\tif (p + n >= stringLen + 1) { // +1 to clear the string (it's cool, i own the memory for sure)\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tint cut = 0;\n\t\t\tfor (n += p; stringToModify[n] != 0; cut++) {\n\t\t\t\tstringToModify[p++] = stringToModify[n++];\n\t\t\t}\n\t\t\tstringToModify[p] = 0;\n\t\t\t\n\t\t\treturn cut;\n\t\t}\n\n\t\tinline bool MakeHotOrActive(i32 widgetId, const Rect& screenPos, const vec2& mouse, const char* tooltip) {\n\t\t\t// Make hot\n\t\t\tif (mouse.x >= screenPos.x && mouse.x <= screenPos.x + screenPos.w) {\n\t\t\t\tif (mouse.y >= screenPos.y && mouse.y <= screenPos.y + screenPos.h) {\n\t\t\t\t\tif (Internal::gState->activeControl == widgetId || Internal::gState->activeControl == 0) {\n\t\t\t\t\t\tInternal::gState->hotControl = widgetId;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make active\n\t\t\tif (Internal::gState->hotControl == widgetId && Internal::gState->activeControl == 0) {\n\t\t\t\tif (Internal::gState->GetPointerPressed()) {\n\t\t\t\t\tInternal::gState->activeControl = widgetId;\n\t\t\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (Internal::gState->hotControlTimer > IMGUI_TOOLTIP_MIN && Internal::gState->hotControlTimer < IMGUI_TOOLTIP_MAX) {\n\t\t\t\t\t\tif (tooltip != 0) {\n\t\t\t\t\t\t\tImgui::SetTooltipLabel(tooltip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Activate return\n\t\t\tif (Internal::gState->activeControl == widgetId && Internal::gState->hotControl == widgetId) {\n\t\t\t\tif (Internal::gState->GetPointerReleased()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\n\t\tinline i32 GetStringIndexUnderMouse(const char* string, i32 inputTextLength, const Rect& screenPos, const Draw2D::Size& inputTextSize, const vec2& mouse) {\n\t\t\tint index = -1;\n\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\tfloat string_y = screenPos.y + 2;\n\t\t\tvec2 relativePoint(mouse.x - string_x, 0); // ignore y\n\n\n\t\t\tif (relativePoint.y >= 0 && relativePoint.y <= inputTextSize.h) {\n\t\t\t\tif (relativePoint.x < 0) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t\telse if (relativePoint.x > inputTextSize.w) {\n\t\t\t\t\tindex = inputTextLength;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tindex = Draw2D::FindStringIndex(Internal::gState->interfaceFont, Internal::gState->style->textAreaFontSize, string, relativePoint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index < 0) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\telse if (index >= inputTextLength) {\n\t\t\t\tindex = (i32)inputTextLength;\n\t\t\t}\n\n\t\t\treturn index;\n\t\t}\n\t\n\t\t// You are responsible for calling MemFree here\n\t\tinline char* GetSubString(const char* string, i32 startIndex, i32 endIndex) {\n\t\t\tif (endIndex < startIndex) {\n\t\t\t\ti32 tmp = endIndex;\n\t\t\t\tendIndex = startIndex;\n\t\t\t\tstartIndex = tmp;\n\t\t\t}\n\n\t\t\ti32 len = endIndex - startIndex;\n\t\t\tif (len <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (string == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (startIndex < 0 || endIndex < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tchar* buffer = (char*)MemAlloc(len + 1);\n\t\t\tMemClear(buffer, len + 1);\n\t\t\tfor (i32 i = 0; i < len; ++i) {\n\t\t\t\tbuffer[i] = string[startIndex + i];\n\t\t\t}\n\t\t\tbuffer[len] = '\\0';\n\n\t\t\treturn buffer;\n\t\t}\n\t}\n\n\tvoid VirtualKeyWasPressed() {\n\t\tInternal::gState->virtualKeyPressed = true;\n\t}\n\n\tvoid SetFakeShiftToggle(bool val) {\n\t\tInternal::gState->fakeShift = val;\n\t}\n\n\tbool GetFakeShiftToggle() {\n\t\treturn Internal::gState->fakeShift;\n\t}\n\n\tvoid SetFakeLeftPressed(bool val) {\n\t\tInternal::gState->fakeLeftPressed = val;\n\t}\n\tbool GetFakeLeftPressed() {\n\t\treturn Internal::gState->fakeLeftPressed;\n\t}\n\tvoid SetFakeRightPressed(bool val) {\n\t\tInternal::gState->fakeRightPressed = val;\n\t}\n\tbool GetFakeRightPressed() {\n\t\treturn Internal::gState->fakeRightPressed;\n\t}\n\n\tvoid SetFakeCapsToggle(bool val) {\n\t\tInternal::gState->fakeCaps = val;\n\t}\n\n\tbool GetFakeCapsToggle() {\n\t\treturn Internal::gState->fakeCaps;\n\t}\n\n\tvoid SetFakeControlToggle(bool val) {\n\t\tInternal::gState->fakeCtrl = val;\n\t}\n\n\tbool GetFakeControlToggle() {\n\t\treturn Internal::gState->fakeCtrl;\n\t}\n\t\n\tbool UndoListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tf32 mouseX = Internal::gState->GetPointerX() / dpi;\n\t\tf32 mouseY = Internal::gState->GetPointerY() / dpi;\n\t\tbool activated = false;\n\n\t\tbool mouseInScrollArea = mouseX >= scrollArea.x && mouseX <= scrollArea.x + scrollArea.w && mouseY >= scrollArea.y && mouseY <= scrollArea.y + scrollArea.h;\n\t\tif (mouseInScrollArea) {\n\t\t\tbool mouseInControlArea = mouseX >= screenPos.x && mouseX <= screenPos.x + screenPos.w && mouseY >= screenPos.y && mouseY <= screenPos.y + screenPos.h;\n\t\t\tif (mouseInControlArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tactivated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStyleColor bg = s->hierarchyItemBG_A;\n\t\tStyleColor txt = s->hierarchyLabel;\n\t\tif (evenOrOdd) {\n\t\t\tbg = s->hierarchyItemBG_B;\n\t\t}\n\n\t\tif (top) {\n\t\t\tbg = s->hierarchyItemBG_Selected;\n\t\t}\n\t\telse if (disabled) {\n\t\t\ttxt = s->hierarchyLabelDisabled;\n\t\t\tbg = s->hierarchyItemBGDisabled;\n\t\t}\n\n\t\tif (Intersects(screenPos, scrollArea)) {\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bg.r, bg.g, bg.b);\n\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->hierarchyLabelFontSize,\n\t\t\t\tscreenPos.x + 5, screenPos.y + s->hierarchyLabelFontSize, name, txt.r, txt.g, txt.b);\n\t\t}\n\n\t\treturn activated;\n\t}\n\n\tDeletableListItemResult DeletableListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tRect listItemArea = screenPos;\n\t\tlistItemArea.x += listItemArea.h;\n\t\tlistItemArea.w -= listItemArea.h;\n\t\ti32 widgetId = Internal::gState->NegativeId(listItemArea);\n\n\t\tRect deletedIconArea = screenPos;\n\t\tdeletedIconArea.w = listItemArea.h;\n\t\tRect deletedHitArea = deletedIconArea;\n\t\tdeletedHitArea.x += 3;\n\t\tdeletedHitArea.y += 2;\n\t\tdeletedHitArea.h -= 6;\n\t\tdeletedHitArea.w -= 7;\n\t\ti32 deleteIconID = Internal::gState->NegativeId(deletedIconArea);\n\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tf32 mouseX = Internal::gState->GetPointerX() / dpi;\n\t\tf32 mouseY = Internal::gState->GetPointerY() / dpi;\n\t\tDeletableListItemResult result = { 0 };;\n\n\t\tbool mouseInScrollArea = mouseX >= scrollArea.x && mouseX <= scrollArea.x + scrollArea.w && mouseY >= scrollArea.y && mouseY <= scrollArea.y + scrollArea.h;\n\t\tif (mouseInScrollArea) {\n\t\t\tbool mouseInControlArea = mouseX >= screenPos.x && mouseX <= screenPos.x + screenPos.w && mouseY >= screenPos.y && mouseY <= screenPos.y + screenPos.h;\n\t\t\tif (mouseInControlArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, listItemArea, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tresult.activated = true;\n\t\t\t\t}\n\t\t\t\tif (Internal::MakeHotOrActive(deleteIconID, deletedHitArea, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tresult.deleted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStyleColor bg = s->hierarchyItemBG_A;\n\t\tStyleColor txt = s->hierarchyLabel;\n\t\tif (evenOrOdd) {\n\t\t\tbg = s->hierarchyItemBG_B;\n\t\t}\n\n\t\tif (top) {\n\t\t\tbg = s->hierarchyItemBG_Selected;\n\t\t}\n\t\telse if (disabled) {\n\t\t\ttxt = s->hierarchyLabelDisabled;\n\t\t\tbg = s->hierarchyItemBGDisabled;\n\t\t}\n\n\t\tif (Intersects(screenPos, scrollArea)) {\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bg.r, bg.g, bg.b);\n\n\t\t\tStyleColor iconColor = s->textAreaFont_Normal;\n\t\t\tif (Internal::gState->activeControl == deleteIconID) {\n\t\t\t\ticonColor = s->textAreaFont_Active;\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == deleteIconID) {\n\t\t\t\ticonColor = s->textAreaFont_Hot;\n\t\t\t}\n\n\t\t\t//Draw2D::DrawRect(deletedHitArea.x, deletedHitArea.y, deletedHitArea.w, deletedHitArea.h, 1, 0, 0);\n\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, s->hierarchyLabelFontSize,\n\t\t\t\tdeletedIconArea.x + 2, deletedIconArea.y + s->hierarchyLabelFontSize + 3, \n\t\t\t\tIMGUI_ICON_CODEPOINT_TRASHCAN, iconColor.r, iconColor.g, iconColor.b);\n\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->hierarchyLabelFontSize,\n\t\t\t\tlistItemArea.x, listItemArea.y + s->hierarchyLabelFontSize, name, txt.r, txt.g, txt.b);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tHierarchyListItemResult HierarchyListItem(const Rect& screenPos, const Rect& listARea, const char* name, f32 indent, bool evenOrOdd, bool selected, bool expanded, bool leaf) {\n\t\tHierarchyListItemResult result;\n\t\tresult.expanded = expanded;\n\t\t\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tf32 mouseX = Internal::gState->GetPointerX() / dpi; \n\t\tf32 mouseY = Internal::gState->GetPointerY() / dpi; \n\t\t\n\t\tbool activated = false;\n\t\t\n\t\tf32 toggleX = screenPos.x + indent;\n\t\tf32 toggleY = screenPos.y + s->hierarchyLabelFontSize + 3;\n\t\tRect toggleArea(toggleX, screenPos.y, s->hierarchyLabelFontSize + 3, screenPos.h);\n\t\ti32 toggleId = Internal::gState->NegativeId(toggleArea);\n\n\t\tbool mouseInListArea = mouseX >= listARea.x && mouseX <= listARea.x + listARea.w && mouseY >= listARea.y && mouseY <= listARea.y + listARea.h;\n\t\t\n\t\tif (mouseInListArea) {\n\t\t\tbool mouseInControlArea = mouseX >= screenPos.x && mouseX <= screenPos.x + screenPos.w && mouseY >= screenPos.y && mouseY <= screenPos.y + screenPos.h;\n\t\t\tbool mouseInToggleArea = mouseX >= toggleArea.x && mouseX <= toggleArea.x + toggleArea.w && mouseY >= toggleArea.y && mouseY <= toggleArea.y + toggleArea.h;\n\t\t\t\n\t\t\tbool wasHotOrActive = Internal::gState->activeControl == widgetId || Internal::gState->hotControl == widgetId;\n\n\t\t\tif ((!wasHotOrActive) && mouseInToggleArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(toggleId, toggleArea, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tresult.expanded = !result.expanded;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mouseInControlArea) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, vec2(mouseX, mouseY), 0)) {\n\t\t\t\t\tactivated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStyleColor bg = s->hierarchyItemBG_A;\n\t\tif (evenOrOdd) {\n\t\t\tbg = s->hierarchyItemBG_B;\n\t\t}\n\n\t\tif (selected) {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbg = s->hierarchyItemBG_Movable;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbg = s->hierarchyItemBG_Selected;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbg = s->hierarchyItemBG_Movable;\n\t\t\t}\n\t\t}\n\n\t\tif (Intersects(screenPos, listARea)) {\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bg.r, bg.g, bg.b);\n\t\t\t\n\t\t\t//Draw2D::DrawRect(toggleArea.x, toggleArea.y, toggleArea.w, toggleArea.h, 1, 0, 0);\n\n\t\t\tif (!leaf) {\n\t\t\t\tStyleColor toggleColor = s->hierarchyToggleNormal;\n\t\t\t\tif (Internal::gState->hotControl == toggleId || Internal::gState->activeControl == toggleId) {\n\t\t\t\t\ttoggleColor = s->hierarchyToggleHot;\n\t\t\t\t}\n\n\t\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, s->hierarchyLabelFontSize - 1, toggleX, toggleY,\n\t\t\t\t\texpanded ? IMGUI_ICON_CODEPOINT_EXPANDED : IMGUI_ICON_CODEPOINT_COLLAPSED,\n\t\t\t\t\ttoggleColor.r, toggleColor.g, toggleColor.b);\n\t\t\t}\n\t\t\t\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->hierarchyLabelFontSize,\n\t\t\t\ttoggleX + toggleArea.w, toggleY - 3 + 1, name,\n\t\t\t\ts->hierarchyLabel.r, s->hierarchyLabel.g, s->hierarchyLabel.b);\n\t\t}\n\n\t\tresult.activated = activated;\n\t\tresult.dragging = Internal::gState->activeControl == widgetId;\n\t\treturn result;\n\t}\n\n\tfloat Split(const Rect& screenPos, bool horizontal, float minSplitterSize, float normalizedDivider) {\n\t\tif (normalizedDivider < 0.0f) {\n\t\t\tnormalizedDivider = 0.0f;\n\t\t}\n\t\telse if (normalizedDivider > 1.0f) {\n\t\t\tnormalizedDivider = 1.0f;\n\t\t}\n\n\t\tf32 x = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 y = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouseVector(x / dpi, y / dpi);\n\n\t\tRect grabberArea;\n\t\tif (!horizontal) {\n\t\t\tfloat divider = screenPos.w * normalizedDivider;\n\t\t\tgrabberArea.x = (screenPos.x + divider) - (IMGUI_SPLITTER_GRABBABLE_WIDTH / 2.0f);\n\t\t\tgrabberArea.w = IMGUI_SPLITTER_GRABBABLE_WIDTH;\n\t\t\tgrabberArea.y = screenPos.y;\n\t\t\tgrabberArea.h = screenPos.h;\n\n\t\t}\n\t\telse {\n\t\t\tfloat divider = screenPos.h * normalizedDivider;\n\n\t\t\tgrabberArea.x = screenPos.x;\n\t\t\tgrabberArea.w = screenPos.w;\n\t\t\tgrabberArea.y = (screenPos.y + divider) - (IMGUI_SPLITTER_GRABBABLE_WIDTH / 2.0f);\n\t\t\tgrabberArea.h = IMGUI_SPLITTER_GRABBABLE_WIDTH;\n\t\t}\n\n\t\ti32 widgetId = Internal::gState->NegativeId(grabberArea);\n\t\tInternal::MakeHotOrActive(widgetId, grabberArea, mouseVector, 0);\n\n\t\tif (!horizontal) {\n\t\t\t// Move the splitter to normalizedDivider\n\t\t\tfloat targetX = normalizedDivider * screenPos.w + screenPos.x;\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\ttargetX = x / dpi; // Track the mouse\n\t\t\t}\n\n\t\t\t{ // Constrain splitter to control\n\t\t\t\tif (targetX < screenPos.x) {\n\t\t\t\t\ttargetX = screenPos.x;\n\t\t\t\t}\n\t\t\t\tif (targetX > screenPos.x + screenPos.w) {\n\t\t\t\t\ttargetX = screenPos.x + screenPos.w;\n\t\t\t\t}\n\n\t\t\t\t// Respect min sizes (adjust right first to keep left always visible?\n\t\t\t\tif (screenPos.w - (targetX - screenPos.x) < minSplitterSize) { // Right side is too small\n\t\t\t\t\ttargetX = screenPos.x + screenPos.w - minSplitterSize;\n\t\t\t\t}\n\t\t\t\tif (targetX - screenPos.x < minSplitterSize) { // Left side is too small\n\t\t\t\t\ttargetX = screenPos.x + minSplitterSize;\n\t\t\t\t}\n\n\t\t\t\tfloat normalizedTarget = (targetX - screenPos.x) / screenPos.w;\n\t\t\t\tnormalizedDivider = MathMaxF(MathMinF(normalizedTarget, 1.0f), 0.0f);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Move the splitter to normalizedDivider\n\t\t\tfloat targetY = (normalizedDivider) * screenPos.h + screenPos.y;\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\ttargetY = y / dpi; // Track the mouse\n\t\t\t}\n\n\t\t\t{ // Constrain splitter to control\n\t\t\t\tif (targetY < screenPos.y) {\n\t\t\t\t\ttargetY = screenPos.y;\n\t\t\t\t}\n\t\t\t\tif (targetY > screenPos.y + screenPos.h) {\n\t\t\t\t\ttargetY = screenPos.y + screenPos.h;\n\t\t\t\t}\n\n\t\t\t\t// Respect min sizes (adjust right first to keep left always visible?\n\t\t\t\tif (screenPos.h - (targetY - screenPos.y) < minSplitterSize) { // Top side is too small\n\t\t\t\t\ttargetY = screenPos.y + screenPos.h - minSplitterSize;\n\t\t\t\t}\n\t\t\t\tif (targetY - screenPos.y < minSplitterSize) { // Bottom side is too small\n\t\t\t\t\ttargetY = screenPos.y + minSplitterSize;\n\t\t\t\t}\n\n\t\t\t\tfloat normalizedTarget = (targetY - screenPos.y) / screenPos.h;\n\t\t\t\tnormalizedDivider = MathMaxF(MathMinF(normalizedTarget, 1.0f), 0.0f);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ // Drawing\n\t\t\tfloat colorA[3] = {\n\t\t\t\tInternal::gState->style->dividerAColor.r, Internal::gState->style->dividerAColor.g, Internal::gState->style->dividerAColor.b\n\t\t\t};\n\t\t\tfloat colorB[3] = {\n\t\t\t\tInternal::gState->style->dividerBColor.r, Internal::gState->style->dividerBColor.g, Internal::gState->style->dividerBColor.b\n\t\t\t};\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tcolorA[0] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorA[1] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorA[2] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[0] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[1] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tcolorB[2] *= Internal::gState->style->dividerActiveTint;\n\t\t\t\tSetTooltipIcon(horizontal ? IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL : IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL);\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tcolorA[0] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorA[1] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorA[2] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[0] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[1] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tcolorB[2] *= Internal::gState->style->dividerHotTint;\n\t\t\t\tif (Internal::gState->activeControl == 0) {\n\t\t\t\t\tSetTooltipIcon(horizontal ? IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL : IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRect splitterArea = SplitFirstArea(screenPos, horizontal, normalizedDivider);\n\n\t\t\tRect line(\n\t\t\t\tsplitterArea.x + splitterArea.w, splitterArea.y,\n\t\t\t\t2, splitterArea.h);\n\n\t\t\tif (horizontal) {\n\t\t\t\tline.x = splitterArea.x;\n\t\t\t\tline.y = splitterArea.y + splitterArea.h;\n\t\t\t\tline.w = splitterArea.w;\n\t\t\t\tline.h = 2;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(line.x, line.y, line.w, line.h, colorA[0], colorA[1], colorA[2]);\n\n\t\t\tif (horizontal) {\n\t\t\t\tline.y += 1;\n\t\t\t\tline.h -= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tline.x += 1;\n\t\t\t\tline.w -= 1;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(line.x, line.y, line.w, line.h, colorB[0], colorB[1], colorB[2]);\n\t\t}\n\n\t\treturn normalizedDivider;\n\t}\n\n\tRect SplitFirstArea(const Rect& screenPos, bool horizontal, float splitter) {\n\t\tRect result = screenPos;\n\t\tif (splitter < 0.0f) { splitter = 0.0f; }\n\t\tif (splitter > 1.0f) { splitter = 1.0f; }\n\n\t\tif (!horizontal) {\n\t\t\tresult.x = MathFloor(screenPos.x);\n\t\t\tresult.w = MathFloor(screenPos.w * splitter);\n\t\t\tresult.w -= 1; // Padding for grabber\n\t\t}\n\t\telse {\n\t\t\tresult.y = MathFloor(screenPos.y);\n\t\t\tresult.h = MathFloor(screenPos.h * splitter);\n\t\t\tresult.h -= 1; // Padding for for grabber\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tRect SplitSecondArea(const Rect& screenPos, bool horizontal, float splitter) {\n\t\tRect result = screenPos;\n\t\tif (splitter < 0.0f) { splitter = 0.0f; }\n\t\tif (splitter > 1.0f) { splitter = 1.0f; }\n\t\tRect firstArea = SplitFirstArea(screenPos, horizontal, splitter);\n\n\t\tif (!horizontal) {\n\t\t\tresult.x = firstArea.x + firstArea.w;\n\t\t\tresult.w = MathMaxF(screenPos.w - firstArea.w, 0.0f);\n\n\t\t\t// For grabber\n\t\t\tresult.x += 2;\n\t\t\tresult.w -= 2;\n\t\t}\n\t\telse {\n\t\t\tresult.y = firstArea.y + firstArea.h;\n\t\t\tresult.h = MathMaxF(screenPos.h - firstArea.h, 0.0f);\n\n\t\t\t// For grabber\n\t\t\tresult.y += 2;\n\t\t\tresult.h -= 2;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tPoint GetPointerDelta() {\n\t\treturn Point(Internal::gState->GetPointerDeltaX() / Internal::gState->dpi, Internal::gState->GetPointerDeltaY() / Internal::gState->dpi);\n\t}\n\n\tPoint GetPointer() {\n\t\treturn Point(Internal::gState->GetPointerX() / Internal::gState->dpi, Internal::gState->GetPointerY() / Internal::gState->dpi);\n\t}\n\n\tPoint GetPrevPointer() {\n\t\treturn Point(Internal::gState->GetPrevPointerX() / Internal::gState->dpi, Internal::gState->GetPrevPointerY() / Internal::gState->dpi);\n\t}\n\n\tbool PointerReleased() {\n\t\treturn Internal::gState->GetPointerReleased();\n\t}\n\n\tbool PointerPressed() {\n\t\treturn Internal::gState->GetPointerPressed();\n\t}\n\n\tbool GetPulse() {\n\t\treturn Internal::gState->pulse;\n\t}\n\n\tvec3 ImageBlock(const Rect& screenPos, const char* caption, u32 image, const Rect& sourceRect, bool disabled) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tStyleColor outline = s->imageBlockOutlineColor;\n\t\tStyleColor background = s->imageBlockBackgroundColor;\n\t\tif (disabled) {\n\t\t\toutline = s->toggleButtonDisabledBorder;\n\t\t\tbackground = s->toggleButtonDisabled;\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outline.r, outline.g, outline.b);\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, background.r, background.g, background.b);\n\n\t\tif (caption != 0) {\n\t\t\tDraw2D::DrawString(Internal::gState->labelFont, s->textAreaLabelSize, screenPos.x + 3, screenPos.y, caption, s->imageBlockLabelColor.r, s->imageBlockLabelColor.g, s->imageBlockLabelColor.b);\n\t\t}\n\n\t\tfloat scale = 0.0f;\n\t\tfloat x_offset = 0.0f;\n\t\tfloat y_offset = 0.0f;\n\t\tif (image != 0) {\n\t\t\tif (sourceRect.w > sourceRect.h) {\n\t\t\t\tscale = (screenPos.w - 4) / sourceRect.w;\n\t\t\t\tfloat h = (screenPos.h - 4) - (sourceRect.h * scale);\n\t\t\t\ty_offset += h / 2.0f;\n\t\t\t}\n\t\t\telse if (sourceRect.h > sourceRect.w) {\n\t\t\t\tscale = (screenPos.h - 4) / sourceRect.h;\n\t\t\t\tfloat w = (screenPos.w - 4) - (sourceRect.w * scale);\n\t\t\t\tx_offset += w / 2.0f;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscale = (screenPos.h - 4) / sourceRect.h;\n\t\t\t}\n\n\t\t\tfloat x = screenPos.x + 2;\n\t\t\tfloat y = screenPos.y + 2;\n\t\t\tfloat w = sourceRect.w * scale;\n\t\t\tfloat h = sourceRect.h * scale;\n\n\t\t\tDraw2D::DrawImage(image, x + x_offset, y + y_offset, w, h, sourceRect.x, sourceRect.y, sourceRect.w, sourceRect.h);\n\t\t}\n\t\telse {\n\t\t\tDraw2D::DrawString(Internal::gState->labelFont, s->textAreaLabelSize, \n\t\t\t\tscreenPos.x + (screenPos.w / 2.0f) - (48.0f / 2.0f), \n\t\t\t\tscreenPos.y + (screenPos.h / 2.0f) , \n\t\t\t\t\"No image\", s->imageBlockLabelColor.r, s->imageBlockLabelColor.g, s->imageBlockLabelColor.b\n\t\t\t);\n\t\t}\n\n\t\treturn vec3(x_offset, y_offset, scale);\n\t}\n\n\tDraw2D::Size MeasureLabel(const Rect& screenPos, const char* text, bool samll) {\n\t\treturn Draw2D::MeasureString(samll ? Internal::gState->labelFont : Internal::gState->interfaceFont, screenPos.h, text);\n\t}\n\n\tDraw2D::Size Label(const Rect& screenPos, const char* text, bool disabled, bool measure, bool samll, StyleColor* _c) {\n\t\tDraw2D::Size result(0, 0);\n\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 fontSize = screenPos.h;\n\n\t\tStyleColor c = s->labelFontColorNormal;\n\t\tif (disabled) {\n\t\t\tc = s->labelFontColorDisabled;\n\t\t}\n\t\tif (_c != 0) {\n\t\t\tc = *_c;\n\t\t}\n\n\t\tu32 pixelHeight = screenPos.h;\n\t\t\n\t\tDraw2D::DrawString(samll? Internal::gState->labelFont : Internal::gState->interfaceFont, pixelHeight, screenPos.x, screenPos.y + screenPos.h, text, c.r, c.g, c.b);\n\t\n\t\tif (measure) {\n\t\t\tresult =  Draw2D::MeasureString(samll ? Internal::gState->labelFont : Internal::gState->interfaceFont, pixelHeight, text);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tbool IsModal(i32 id) {\n\t\treturn Internal::gState->modalControl;\n\t}\n\n\ti32 FileMenu(const Rect& screenPos, const char** options, u32 numOptions, i32 selection, Imgui::Rect* outRects) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tPlatformAssert(numOptions <= 8, __LOCATION__);\n\t\ti32 widgetIds[8] = { 0 };\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, s->menuBarBg.r, s->menuBarBg.g, s->menuBarBg.b);\n\t\tDraw2D::DrawRect(screenPos.x, i32(screenPos.y + screenPos.h) - 2, screenPos.w, 1, s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n\t\tfloat mouseX = Internal::gState->GetPointerX() / Internal::gState->dpi;\n\t\tfloat mouseY = Internal::gState->GetPointerY() / Internal::gState->dpi;\n\t\tvec2 mouse(mouseX, mouseY);\n\n\t\tRect Buttons[8] = { 0 };\n\t\tRect karrat = screenPos;\n\t\tkarrat.x += 10;\n\t\tkarrat.y += 5;\n\t\tkarrat.h -= 10;\n\n\t\tStyleColor fontColor = s->textAreaFont_Active;\n\t\tStyleColor hotBg = s->textAreaBg_Hot;\n\t\tu32 height = 14;\n\n\t\tint hotIndex = -1;\n\n\t\tfor (u32 i = 0; i < numOptions; ++i) {\n\t\t\tkarrat.w = Draw2D::MeasureString(Internal::gState->interfaceFont, height, options[i]).w + 5;\n\t\t\twidgetIds[i] = Internal::gState->NegativeId(karrat);\n\t\t\tif (outRects != 0) {\n\t\t\t\toutRects[i] = karrat;\n\t\t\t}\n\n\t\t\tInternal::MakeHotOrActive(widgetIds[i], karrat, mouse, 0);\n\t\t\tif (widgetIds[i] == Internal::gState->hotControl || widgetIds[i] == Internal::gState->activeControl || selection == i) {\n\t\t\t\tif (Imgui::PointerPressed() && karrat.Contains(Imgui::Point(mouseX, mouseY))) {\n\t\t\t\t\tif (widgetIds[i] == Internal::gState->hotControl || widgetIds[i] == Internal::gState->activeControl) {\n\t\t\t\t\t\thotIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDraw2D::DrawRect(karrat.x, karrat.y, karrat.w, karrat.h, hotBg.r, hotBg.g, hotBg.b);\n\t\t\t}\n\n\t\t\tkarrat.w += 10;\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, height, karrat.x + 3, karrat.y + height , options[i], fontColor.r, fontColor.g, fontColor.b);\n\t\t\tkarrat.x += karrat.w;\n\t\t}\n\n\t\treturn hotIndex;\n\t}\n\n\tu32 Header(const Rect& screenPos, const char** options, u32 numOptions, u32 selectedOption) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, s->headerBgColor.r, s->headerBgColor.g, s->headerBgColor.b);\n\t\tDraw2D::DrawRect(screenPos.x, i32(screenPos.y + screenPos.h) - 2, screenPos.w, 1, s->dividerBColor.r, s->dividerBColor.g, s->dividerBColor.b);\n\n\t\tfloat carrat = screenPos.x;\n\t\tImgui::Point mousePos(Internal::gState->GetPointerX() / Internal::gState->dpi,\n\t\t\tInternal::gState->GetPointerY() / Internal::gState->dpi);\n\n\t\tfloat colorA[3] = {\n\t\t\t\tInternal::gState->style->dividerAColor.r, Internal::gState->style->dividerAColor.g, Internal::gState->style->dividerAColor.b\n\t\t};\n\t\tfloat colorB[3] = {\n\t\t\tInternal::gState->style->dividerBColor.r, Internal::gState->style->dividerBColor.g, Internal::gState->style->dividerBColor.b\n\t\t};\n\n\t\tu32 result = selectedOption;\n\n\t\tfor (u32 i = 0; i < numOptions; ++i) {\n\t\t\tif (options[i] == 0) {\n\t\t\t\tif (result == i) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tDraw2D::Size stringSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->headerFontSize, options[i]);\n\t\t\tstringSize.w += 10;\n\n\t\t\tRect clickArea(carrat, screenPos.y, stringSize.w, screenPos.h);\n\t\t\ti32 widgetId = Internal::gState->NegativeId(clickArea);\n\n\t\t\tif (Contains(clickArea, mousePos)) {\n\t\t\t\tif (Internal::MakeHotOrActive(widgetId, clickArea, vec2(mousePos.x, mousePos.y), 0)) {\n\t\t\t\t\tresult = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGActiveColor.r, s->HeaderBGActiveColor.g, s->HeaderBGActiveColor.b);\n\t\t\t}\n\t\t\telse  if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGHotColor.r, s->HeaderBGHotColor.g, s->HeaderBGHotColor.b);\n\t\t\t}\n\t\t\telse if (result == i) {\n\t\t\t\tDraw2D::DrawRect(clickArea.x, clickArea.y, clickArea.w, clickArea.h, s->HeaderBGActiveColor.r, s->HeaderBGActiveColor.g, s->HeaderBGActiveColor.b);\n\t\t\t}\n\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->headerFontSize,\n\t\t\t\tcarrat + 5, screenPos.y + 3 + s->headerFontSize, options[i],\n\t\t\t\ts->headerFontColor.r, s->headerFontColor.g, s->headerFontColor.b);\n\t\t\t\n\t\t\tcarrat += stringSize.w;\n\n\t\t\tif (i + 1 < numOptions) {\n\t\t\t\tRect divider = screenPos;\n\t\t\t\tdivider.x = carrat;\n\t\t\t\tdivider.w = 2;\n\t\t\t\tDraw2D::DrawRect(divider.x, divider.y, divider.w, divider.h, colorA[0], colorA[1], colorA[2]);\n\t\t\t\tdivider.x = carrat + 1;\n\t\t\t\tdivider.w = 1;\n\t\t\t\tDraw2D::DrawRect(divider.x, divider.y, divider.w, divider.h, colorB[0], colorB[1], colorB[2]);\n\t\t\t\tcarrat += 2;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid SetTooltipIcon(int codePoint) {\n\t\tInternal::gState->tooltipIcon = codePoint;\n\t}\n\n\tvoid SetTooltipLabel(const char* label) {\n\t\tInternal::gState->tooltipLabel = label;\n\t}\n\n\tPoint GetPointer(float dpi) {\n\t\treturn Point(Internal::gState->GetPointerX() / dpi, Internal::gState->GetPointerY() / dpi);\n\t}\n\n\tvoid Icon(const Rect& screenPos, u32 iconSize, u32 codePoint, float r, float g, float b, float a) {\n\t\tInternal::gState->NegativeId(screenPos);\n\t\tDraw2D::DrawCodePoint(\n\t\t\tInternal::gState->widgetFont, iconSize,\n\t\t\tscreenPos.x,\n\t\t\tscreenPos.y + iconSize,\n\t\t\tcodePoint,\n\t\t\tr, g, b, a\n\t\t);\n\t}\n\n\tbool HandleScroll(const Rect& scrollArea) {\n\t\tfloat dpi = Internal::gState->dpi;\n\t\tfloat mouseX = Internal::gState->GetPointerX() / dpi;\n\t\tfloat mouseY = Internal::gState->GetPointerY() / dpi;\n\t\treturn Contains(scrollArea, Point(mouseX, mouseY));\n\t}\n\n\tfloat FloatSlider(const Rect& screeenPos, float value) {\n\t\tif (screeenPos.w <= 1.0f) {\n\t\t\treturn 0.0f;\n\t\t}\n\n\t\ti32 scrollTrackId = Internal::gState->NegativeId(screeenPos);\n\n\t\tfloat dpi = Internal::gState->dpi;\n\t\tPoint mousePos((float)Internal::gState->GetPointerX() / dpi, (float)Internal::gState->GetPointerY() / dpi);\n\t\tPoint mouseDelta((float)Internal::gState->GetPointerDeltaX() / dpi, (float)Internal::gState->GetPointerDeltaY() / dpi);\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tif (mousePos.x < screeenPos.x || mousePos.x > screeenPos.x + screeenPos.w || mousePos.y < screeenPos.y || mousePos.y > screeenPos.y + screeenPos.h) {\n\t\t\t\tmouseDelta = Point(0, 0);\n\t\t}\n\n\t\tDraw2D::DrawRect(screeenPos.x, screeenPos.y, screeenPos.w, screeenPos.h,\n\t\t\ts->scrollBarTrackBG.r, s->scrollBarTrackBG.g, s->scrollBarTrackBG.b);\n\n\t\tfloat v = value;\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\tRect track = screeenPos;\n\t\tRect grabHandle = screeenPos;\n\t\t\n\t\tbool horizontal = true;\n\n\t\tf32 grabberSize = 4.0f;\n\t\tif (horizontal) {\n\t\t\tif (grabberSize > track.w - track.w / 4.0f) {\n\t\t\t\tgrabberSize = track.w - track.w / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.x += grabberSize / 2.0f;\n\t\t\ttrack.w -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.h -= 6;\n\t\t\t\tgrabHandle.y += 3;\n\t\t\t\tgrabHandle.w = grabberSize;\n\n\t\t\t\tfloat handlePos = track.w * v + track.x;\n\t\t\t\tgrabHandle.x = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (grabberSize > track.h - track.h / 4.0f) {\n\t\t\t\tgrabberSize = track.h - track.h / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.y += grabberSize / 2.0f;\n\t\t\ttrack.h -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.w -= 6;\n\t\t\t\tgrabHandle.x += 3;\n\t\t\t\tgrabHandle.h = grabberSize;\n\n\t\t\t\tfloat handlePos = track.h * v + track.y;\n\t\t\t\tgrabHandle.y = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\n\t\ti32 scrollHandleId = Internal::gState->NegativeId(grabHandle);\n\n\t\tInternal::MakeHotOrActive(scrollHandleId, grabHandle, vec2(mousePos.x, mousePos.y), 0);\n\n\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\tfloat scroll_v = 0.0f;\n\t\t\tif (horizontal) {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.x / track.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.y / track.h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv += scroll_v;\n\t\t}\n\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\t{ // Handle\n\t\t\tif ((Internal::gState->hotControl == scrollHandleId && Internal::gState->activeControl == 0) ||\n\t\t\t\tInternal::gState->activeControl == scrollHandleId) {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberHot.r, s->scrollGrabberHot.g, s->scrollGrabberHot.b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberNormal.r, s->scrollGrabberNormal.g, s->scrollGrabberNormal.b);\n\t\t\t}\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tfloat ScrollBar(const Rect& screenPos, float value, bool horizontal, float grabberSize, bool handleScroll) {\n\t\ti32 scrollTrackId = Internal::gState->NegativeId(screenPos);\n\n\t\tfloat dpi = Internal::gState->dpi;\n\t\tPoint mousePos((float)Internal::gState->GetPointerX() / dpi, (float)Internal::gState->GetPointerY() / dpi);\n\t\tPoint mouseDelta((float)Internal::gState->GetPointerDeltaX() / dpi, (float)Internal::gState->GetPointerDeltaY() / dpi);\n\t\t\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tif (grabberSize < 0.0f) {\n\t\t\tgrabberSize = 0.0f;\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\ts->scrollBarTrackBG.r, s->scrollBarTrackBG.g, s->scrollBarTrackBG.b);\n\n\t\tu32 arrowAIcon = 0;\n\t\tu32 arrowBIcon = 0;\n\n\t\tfloat v = value;\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\tRect arrowAArea = screenPos;\n\t\tRect arrowBArea = screenPos;\n\t\tRect track = screenPos;\n\t\tRect grabHandle = screenPos;\n\n\t\tStyleColor iconAColor = s->scrollBarIconNormal;\n\t\tStyleColor iconBColor = s->scrollBarIconNormal;\n\n\t\tif (horizontal) {\n\t\t\tarrowAIcon = IMGUI_ICON_CODEPOINT_ARROW_LEFT;\n\t\t\tarrowBIcon = IMGUI_ICON_CODEPOINT_ARROW_RIGHT;\n\t\t\tarrowAArea.w = arrowAArea.h;\n\t\t\tarrowBArea.w = arrowBArea.h;\n\t\t\tarrowBArea.x = screenPos.x + screenPos.w - arrowBArea.w;\n\n\t\t\t// Set track between arrows\n\t\t\ttrack.x += arrowAArea.w;\n\t\t\ttrack.w -= arrowAArea.w * 2.0f;\n\n\t\t\t// Add 1px gab before / after arrows\n\t\t\ttrack.x += 1;\n\t\t\ttrack.w -= 2;\n\n\t\t\tif (grabberSize > track.w - track.w / 4.0f) {\n\t\t\t\tgrabberSize = track.w - track.w / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.x += grabberSize / 2.0f;\n\t\t\ttrack.w -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.h -= 6;\n\t\t\t\tgrabHandle.y += 3;\n\t\t\t\tgrabHandle.w = grabberSize;\n\n\t\t\t\tfloat handlePos = track.w * v + track.x;\n\t\t\t\tgrabHandle.x = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tarrowAIcon = IMGUI_ICON_CODEPOINT_ARROW_UP;\n\t\t\tarrowBIcon = IMGUI_ICON_CODEPOINT_ARROW_DOWN;\n\t\t\tarrowAArea.h = arrowAArea.w;\n\t\t\tarrowBArea.h = arrowBArea.w;\n\t\t\tarrowBArea.y = screenPos.y + screenPos.h - arrowBArea.h;\n\n\t\t\t// Set track between arrows\n\t\t\ttrack.y += arrowBArea.h;\n\t\t\ttrack.h -= arrowBArea.h * 2.0f;\n\n\t\t\t// Add 1px gab before / after arrows\n\t\t\ttrack.y += 1;\n\t\t\ttrack.h -= 2;\n\n\t\t\tif (grabberSize > track.h - track.h / 4.0f) {\n\t\t\t\tgrabberSize = track.h - track.h / 4.0f;\n\t\t\t}\n\n\t\t\t// Adjust track area for grabber\n\t\t\ttrack.y += grabberSize / 2.0f;\n\t\t\ttrack.h -= grabberSize;\n\n\t\t\tif (grabberSize > 0.0f) {\n\t\t\t\tgrabHandle.w -= 6;\n\t\t\t\tgrabHandle.x += 3;\n\t\t\t\tgrabHandle.h = grabberSize;\n\n\t\t\t\tfloat handlePos = track.h * v + track.y;\n\t\t\t\tgrabHandle.y = handlePos - grabberSize / 2;\n\t\t\t}\n\t\t}\n\n\t\ti32 scrollUpId = Internal::gState->NegativeId(arrowAArea); \n\t\ti32 scrollDownId = Internal::gState->NegativeId(arrowBArea);\n\t\ti32 scrollHandleId = Internal::gState->NegativeId(grabHandle);\n\n\t\tif (grabberSize > 0.0f) {\n\t\t\tInternal::MakeHotOrActive(scrollUpId, arrowAArea, vec2(mousePos.x, mousePos.y), 0);\n\t\t\tInternal::MakeHotOrActive(scrollDownId, arrowBArea, vec2(mousePos.x, mousePos.y), 0);\n\t\t\tInternal::MakeHotOrActive(scrollHandleId, grabHandle, vec2(mousePos.x, mousePos.y), 0);\n\t\t}\n\n\t\tif (Internal::gState->activeControl == scrollUpId) {\n\t\t\tif (Internal::gState->pulse) {\n\t\t\t\tv -= 0.1f;\n\t\t\t}\n\t\t}\n\t\telse if (Internal::gState->activeControl == scrollDownId) {\n\t\t\tif (Internal::gState->pulse) {\n\t\t\t\tv += 0.1f;\n\t\t\t}\n\t\t}\n\t\telse if (Internal::gState->activeControl == scrollHandleId) {\n\t\t\tfloat scroll_v = 0.0f;\n\t\t\tif (horizontal) {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.x / track.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\t\tscroll_v = mouseDelta.y / track.h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv += scroll_v;\n\t\t}\n\t\telse if (handleScroll) { // This is the scroll wheel here\n\t\t\ti32 scroll = MouseGetScroll();\n\t\t\ti32 prev = MousePrevScroll();\n\t\t\tif (scroll != prev) {\n\t\t\t\tif (scroll > 0) {\n\t\t\t\t\tv -= 0.1f;\n\t\t\t\t}\n\t\t\t\telse if (scroll < 0) {\n\t\t\t\t\tv += 0.1f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v < 0.0f) {\n\t\t\tv = 0.0f;\n\t\t}\n\t\telse if (v > 1.0f) {\n\t\t\tv = 1.0f;\n\t\t}\n\n\t\tif ((Internal::gState->hotControl == scrollUpId && Internal::gState->activeControl == 0)|| Internal::gState->activeControl == scrollUpId) {\n\t\t\ticonAColor = s->scrollBarIconHot;\n\t\t\tDraw2D::DrawRect(arrowAArea.x, arrowAArea.y, arrowAArea.w, arrowAArea.h,\n\t\t\t\ts->scrollBarHotButtonBg.r, s->scrollBarHotButtonBg.g, s->scrollBarHotButtonBg.b);\n\t\t}\n\t\telse if ((Internal::gState->hotControl == scrollDownId && Internal::gState->activeControl == 0) || Internal::gState->activeControl == scrollDownId) {\n\t\t\ticonBColor = s->scrollBarIconHot;\n\t\t\tDraw2D::DrawRect(arrowBArea.x, arrowBArea.y, arrowBArea.w, arrowBArea.h,\n\t\t\t\ts->scrollBarHotButtonBg.r, s->scrollBarHotButtonBg.g, s->scrollBarHotButtonBg.b);\n\t\t}\n\t\t\n\t\tif (grabberSize > 0.0f) {\n\t\t\tImgui::Icon(arrowAArea, s->scrollIconSize, arrowAIcon, iconAColor.r, iconAColor.g, iconAColor.b);\n\t\t\tImgui::Icon(arrowBArea, s->scrollIconSize, arrowBIcon, iconBColor.r, iconBColor.g, iconBColor.b);\n\t\t}\n\n\t\tif (grabberSize > 0.0f) { // Handle\n\t\t\tif ((Internal::gState->hotControl == scrollHandleId && Internal::gState->activeControl == 0) || Internal::gState->activeControl == scrollHandleId) {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberHot.r, s->scrollGrabberHot.g, s->scrollGrabberHot.b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDraw2D::DrawRect(grabHandle.x, grabHandle.y, grabHandle.w, grabHandle.h,\n\t\t\t\t\ts->scrollGrabberNormal.r, s->scrollGrabberNormal.g, s->scrollGrabberNormal.b);\n\t\t\t}\n\t\t}\n\n\t\tif (grabberSize <= 0.0f) {\n\t\t\treturn 0.0f;\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tbool HoldArea(const Rect& screenPos, HoldAreaDetails* details, float* roc, const vec2* rocV) {\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool wasActive = Internal::gState->activeControl == widgetId;\n\t\tbool activated = Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0);\n\t\tbool active = Internal::gState->activeControl == widgetId;\n\n\t\tif (details != 0) {\n\t\t\tdetails->wasActive = wasActive;\n\t\t\tdetails->activated = activated;\n\t\t\tdetails->active = active;\n\t\t\tif (!details->wasActive && details->active) {\n\t\t\t\tdetails->mouseDown = mouse;\n\t\t\t\tif (roc != 0) {\n\t\t\t\t\tdetails->rememberF32OnClick = *roc;\n\t\t\t\t}\n\t\t\t\tif (rocV != 0) {\n\t\t\t\t\tdetails->rememberVec2OnClick = *rocV;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn activated || active;\n\t}\n\n\tbool ClickArea(const Rect& screenPos) {\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\t\treturn Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0);\n\t}\n\n\tbool SidebarButton(const Rect& screenPos, u32 codePoint, const char* caption, bool isActive, vec3* iconOverride) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = Internal::MakeHotOrActive(widgetId, screenPos, mouse, caption);\n\n\t\tStyleColor bgColor = s->toolBarBg;\n\t\tif (Internal::gState->hotControl == widgetId) {\n\t\t\tbgColor = s->dividerAColor;\n\t\t}\n\t\tif (Internal::gState->activeControl == widgetId || isActive) {\n\t\t\tbgColor = s->headerBgColor;\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, bgColor.r, bgColor.g, bgColor.b);\n\n\t\tStyleColor color = s->labelFontColorNormal;\n\t\tf32 height = screenPos.h - 8.0f;\n\n\t\tfloat x_off = 0.0f;\n\t\tfloat y_off = 0.0f;\n\t\tif (iconOverride != 0) {\n\t\t\tx_off = iconOverride->x;\n\t\t\ty_off = iconOverride->y;\n\t\t}\n\n\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, iconOverride != 0? iconOverride->z : height, screenPos.x + 3.0 + x_off, y_off + screenPos.y + height + 4.0f, codePoint,\n\t\t\tcolor.r, color.g, color.b);\n\n\t\treturn result;\n\t}\n\n\tbool FooterButton(const Rect& screenPos, u32 codePoint, const char* caption, const StyleColor& color) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tu32 iconSize = u32(s->hierarchyFooterButtonSize) - 4;\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = Internal::MakeHotOrActive(widgetId, screenPos, mouse, caption);\n\n\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\tStyleColor border = s->hierarchyFooterButtonBorder_Active;\n\t\t\tStyleColor button = s->hierarchyFooterButtonBG_Active;\n\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\t\tborder.r, border.g, border.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2,\n\t\t\t\tbutton.r, button.g, button.b);\n\t\t}\n\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\tStyleColor border = s->hierarchyFooterButtonBorder_Hot;\n\t\t\tStyleColor button = s->hierarchyFooterButtonBG_Hot;\n\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\t\tborder.r, border.g, border.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2,\n\t\t\t\tbutton.r, button.g, button.b);\n\t\t}\n#if 0\n\t\telse { // Debugging for normal state\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, 1, 0, 0);\n\t\t}\n#endif\n\n\t\tDraw2D::DrawCodePoint(\n\t\t\tInternal::gState->widgetFont, iconSize,\n\t\t\tscreenPos.x + 2,\n\t\t\tscreenPos.y + iconSize + 3,\n\t\t\tcodePoint,\n\t\t\tcolor.r, color.g, color.b, 1.0f\n\t\t);\n\n\t\treturn result;\n\t}\n\n\ti32 Dummy() {\n\t\tRect screenPos = { 0 };\n\t\tscreenPos.w = screenPos.h = 5;\n\t\tscreenPos.x = screenPos.y = -10;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\treturn widgetId;\n\t}\n\n\tbool ToggleIcon(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, const char* label) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tu32 iconSize = u32(screenPos.h) - 6;\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = state;\n\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, label)) {\n\t\t\tresult = !result;\n\t\t}\n\n\t\tStyleColor iconColor = s->textAreaFont_Normal;\n\n\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, screenPos.h - 6, screenPos.x + 3, screenPos.y + 3 + (screenPos.h - 6),\n\t\t\tstate ? trueIcon : falseIcon, iconColor.r, iconColor.g, iconColor.b);\n\n\t\treturn result;\n\t}\n\n\tbool ToggleButton(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, bool disabled, const char* label, const StyleColor& tint, StyleColor* iconTint) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tu32 iconSize = u32(screenPos.h) - 6;\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tbool result = state;\n\t\tif (!disabled && Internal::MakeHotOrActive(widgetId, screenPos, mouse, label)) {\n\t\t\tresult = !result;\n\t\t}\n\n\t\tStyleColor borderColor = s->toggleButtonBorder;\n\t\tStyleColor bgColor = s->toggleButtonNormal;\n\t\t\n\t\tif (disabled) {\n\t\t\tborderColor = s->toggleButtonDisabledBorder;\n\t\t\tbgColor = s->toggleButtonDisabled;\n\t\t}\n\t\telse if (state) {\n\t\t\tbgColor = s->toggleButtonActive;\n\t\t\tif (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonHot;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->activeControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonActive;\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->toggleButtonHot;\n\t\t\t}\n\t\t}\n\n\t\t// Adjustments\n\t\tborderColor.r += tint.r;\n\t\tborderColor.g += tint.g;\n\t\tborderColor.b += tint.b;\n\t\tbgColor.r += tint.r;\n\t\tbgColor.g += tint.g;\n\t\tbgColor.b += tint.b;\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, borderColor.r, borderColor.g, borderColor.b);\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, bgColor.r, bgColor.g, bgColor.b);\n\n\t\tStyleColor iconColor = s->textAreaFont_Normal;\n\t\tif (disabled) {\n\t\t\ticonColor = s->textAreaFont_Disabled;\n\t\t}\n\n\t\tif (iconTint != 0) {\n\t\t\ticonColor.r += iconTint->r;\n\t\t\ticonColor.g += iconTint->g;\n\t\t\ticonColor.b += iconTint->b;\n\t\t}\n\n\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, screenPos.h - 6, screenPos.x + 3, screenPos.y + 3 + (screenPos.h - 6), \n\t\t\tstate ? trueIcon : falseIcon, iconColor.r, iconColor.g, iconColor.b);\n\n\t\treturn result;\n\t}\n\n\tnamespace Internal {\n\t\ti32 PopupMenuBegin(i32 id, const Point& screenPos, f32 width, u32 numOptions, bool reversed) {\n\t\t\ti32 result = -1;\n\t\t\tconst StyleSheet* s = Internal::gState->style;\n\t\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\t\tf32 dpi = Internal::gState->dpi;\n\t\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\t\tRect screenArea(screenPos.x, screenPos.y, width, numOptions * s->listBoxItemHeight);\n\t\t\tif (reversed) {\n\t\t\t\tscreenArea.y -= numOptions * s->listBoxItemHeight;\n\t\t\t\tscreenArea.y -= s->listBoxItemHeight;\n\t\t\t}\n\n\t\t\tif (MakeHotOrActive(id, screenArea, mouse, \"Display Sprite\")) {\n\t\t\t\tfloat relative_y = mouse.y - screenArea.y;\n\t\t\t\tif (relative_y >= 0.0f && relative_y <= screenArea.h) {\n\t\t\t\t\ti32 index = relative_y / s->listBoxItemHeight;\n\t\t\t\t\tif (index >= 0 && index < numOptions) {\n\t\t\t\t\t\tresult = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti32 hot = -1;\n\n\t\t\tfloat relative_y = mouse.y - screenArea.y;\n\t\t\tif (mouse.x >= screenPos.x && mouse.x <= screenPos.x + width) {\n\t\t\t\tif (relative_y >= 0.0f && relative_y <= screenArea.h) {\n\t\t\t\t\ti32 index = relative_y / s->listBoxItemHeight;\n\t\t\t\t\tif (index >= 0 && index < numOptions) {\n\t\t\t\t\t\thot = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Internal::gState->numPopupMenus >= Internal::gState->modalPopups.Count()) {\n\t\t\t\tInternal::gState->modalPopups.Resize(Internal::gState->numPopupMenus + 1);\n\t\t\t\tnew (&Internal::gState->modalPopups[Internal::gState->numPopupMenus].items) Vector< Internal::PopupMenuInfo>();\n\t\t\t\tInternal::gState->maxPopupMenus += 1;\n\t\t\t}\n\n\t\t\tInternal::PopupMenuInfo& reuse = Internal::gState->modalPopups[Internal::gState->numPopupMenus];\n\t\t\treuse.id = id;\n\t\t\treuse.reversed = reversed;\n\t\t\treuse.screenPos = screenArea;\n\t\t\treuse.hot = hot;\n\t\t\treuse.itemCount = 0;\n\t\t\treuse.items.Resize(numOptions);\n\t\t\t\n\t\t\tInternal::gState->lastModalId = id;\n\t\t\tInternal::gState->numPopupMenus += 1;\n\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid PopupMenuRender(PopupMenuInfo& info) {\n\t\t\tconst StyleSheet* s = Internal::gState->style;\n\t\t\tStyleColor bg = s->textAreaBg_Normal;\n\t\t\tStyleColor outline = s->textAreaOutline_Normal;\n\t\t\tStyleColor txtN = s->textAreaFont_Normal;\n\t\t\tStyleColor txtH = s->textAreaFont_Hot;\n\t\t\tStyleColor hover = s->hierarchyItemBG_Selected;\n\n\t\t\tDraw2D::DrawRect(info.screenPos.x, info.screenPos.y, info.screenPos.w, info.screenPos.h, outline.r, outline.g, outline.b);\n\t\t\tDraw2D::DrawRect(info.screenPos.x + 1, info.screenPos.y + 1, info.screenPos.w - 2, info.screenPos.h - 2, bg.r, bg.g, bg.b);\n\n\t\t\tDraw2D::PushClip(info.screenPos.x + 1, info.screenPos.y + 1, info.screenPos.w - 2, info.screenPos.h - 2);\n\t\t\tf32 item_x = info.screenPos.x + 3;\n\t\t\tf32 item_y = info.screenPos.y + 2;\n\n\t\t\tfor (i32 i = 0; i < info.itemCount; ++i) {\n\t\t\t\tconst char* item = info.items[i];\n\t\t\t\tPlatformAssert(item != 0, __LOCATION__);\n\n\t\t\t\tif (i == info.hot) {\n\t\t\t\t\tDraw2D::DrawRect(info.screenPos.x + 1,\n\t\t\t\t\t\tinfo.screenPos.y + 1 + (i * s->listBoxItemHeight),\n\t\t\t\t\t\tinfo.screenPos.w - 2, s->listBoxItemHeight, hover.r, hover.g, hover.b);\n\t\t\t\t}\n\n\t\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->textAreaFontSize, item_x, item_y + s->textAreaFontSize, item, txtN.r, txtN.g, txtN.b);\n\t\t\t\titem_y += s->listBoxItemHeight;\n\t\t\t}\n\t\t\tDraw2D::PopClip();\n\t\t}\n\n\t\tvoid PopupMenuEnd() {\n\t\t\tInternal::gState->lastModalId = 0;\n\t\t}\n\t}\n\n\t// If endModalPopup returned the i32 instead, then we could\n\t// infer width. And the height is already given. This function\n\t// would become (Point screen, u32 count)\n\ti32 BeginModalPopup(const Rect& screenPos, const Rect& activation, u32 numOptions, bool reversed) {\n\t\ti32 activationId = Internal::gState->NegativeId(screenPos);\n\t\ti32 contextId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tif (Internal::MakeHotOrActive(activationId, activation, mouse, 0)) {\n\t\t\tInternal::gState->modalControl = contextId;\n\t\t}\n\n\t\tInternal::gState->lastBeingModalPopupContext = contextId;\n\t\tInternal::gState->lastBeingModalPopupActivation = activationId;\n\n\t\tif (Internal::gState->activeControl == contextId) {\n\t\t\treturn Internal::PopupMenuBegin(contextId, Point(screenPos.x, screenPos.y + screenPos.h), screenPos.w, numOptions, reversed);\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid PushModalPopupItem(const char* item) {\n\t\tif (Internal::gState->lastModalId != 0 && Internal::gState->numPopupMenus > 0) {\n\t\t\tInternal::PopupMenuInfo* menu = 0;\n\t\t\tfor (u32 i = 0; i < Internal::gState->numPopupMenus; ++i) {\n\t\t\t\tif (Internal::gState->modalPopups[i].id == Internal::gState->lastModalId) {\n\t\t\t\t\tmenu = &Internal::gState->modalPopups[i];\n\t\t\t\t\tPlatformAssert(menu->itemCount <= menu->items.Count(), __LOCATION__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPlatformAssert(menu != 0, __LOCATION__);\n\t\t\tmenu->items[menu->itemCount++] = item;\n\t\t}\n\t}\n\n\tbool EndModalPopup() {\n\t\tInternal::PopupMenuEnd();\n\t\treturn Internal::gState->activeControl == Internal::gState->lastBeingModalPopupContext ||\n\t\t\tInternal::gState->modalControl == Internal::gState->lastBeingModalPopupContext ||\n\t\t\tInternal::gState->modalControl == Internal::gState->lastBeingModalPopupActivation ||\n\t\t\t//Internal::gState->lastActiveControl == Internal::gState->lastBeingModalPopupContext ||\n\t\t\t//Internal::gState->lastActiveControl == Internal::gState->lastBeingModalPopupActivation ||\n\t\t\tInternal::gState->activeControl ==  Internal::gState->lastBeingModalPopupActivation;\n\t}\n\n\ti32 Timeline(const Rect& screenPos, u32 numFrames, i32 selectedFrame, float scroll) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\tStyleColor highlight = s->hierarchyItemBG_Selected;\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tfloat scrollableWidth = numFrames * s->animationFrameWidth;\n\n\t\tfloat x_offset = 0.0f;\n\t\tif (screenPos.w < scrollableWidth) {\n\t\t\tfloat delta = scrollableWidth - screenPos.w;\n\t\t\tx_offset = scroll * delta;\n\t\t}\n\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0) || Internal::gState->activeControl == widgetId) {\n\t\t\tfloat x_delta = (mouse.x + x_offset) - screenPos.x;\n\t\t\tif (mouse.x >= screenPos.x && mouse.x <= screenPos.x + screenPos.w) {\n\t\t\t\tu32 index = x_delta / s->animationFrameWidth;\n\t\t\t\tif (index < numFrames) {\n\t\t\t\t\tselectedFrame = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tImgui::Rect frameRect = screenPos;\n\t\tframeRect.x -= x_offset;\n\n\t\tframeRect.w = s->animationFrameWidth;\n\t\tchar printBuff[8] = { 0 };\n\n\t\tfor (u32 i = 0; i < numFrames; ++i) {\n\t\t\tif (Imgui::Intersects(screenPos, frameRect)) {\n\t\t\t\tStyleColor frameColor = (i % 2 == 0) ? s->frameEven : s->frameOdd;\n\t\t\t\tDraw2D::DrawRect(frameRect.x, frameRect.y, frameRect.w, frameRect.h, frameColor.r, frameColor.g, frameColor.b);\n\n\t\t\t\tif (selectedFrame >= 0 && selectedFrame == i) {\n\t\t\t\t\tDraw2D::DrawRect(frameRect.x, frameRect.y, frameRect.w, frameRect.h, highlight.r, highlight.g, highlight.b);\n\n\t\t\t\t\tif (!((i + 1) % 5 == 0 || i == 0)) {\n\t\t\t\t\t\tImgui::Rect labelRect = frameRect;\n\t\t\t\t\t\tlabelRect.x += 1;\n\t\t\t\t\t\tlabelRect.h = 6;\n\t\t\t\t\t\tlabelRect.y = frameRect.y + frameRect.h - labelRect.h - 2;\n\t\t\t\t\t\tstbsp_snprintf(printBuff, 8, \"%d\", i + 1);\n\t\t\t\t\t\tImgui::Label(labelRect, printBuff, false, false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((i + 1) % 5 == 0 || i == 0) {\n\t\t\t\t\tImgui::Rect labelRect = frameRect;\n\t\t\t\t\tlabelRect.x += 1;\n\t\t\t\t\tlabelRect.h = 6;\n\t\t\t\t\tlabelRect.y = frameRect.y + frameRect.h - labelRect.h - 2;\n\t\t\t\t\tstbsp_snprintf(printBuff, 8, \"%d\", i + 1);\n\t\t\t\t\tImgui::Label(labelRect, printBuff, false, false, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (frameRect.x > screenPos.x + screenPos.w) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframeRect.x += frameRect.w;\n\t\t}\n\n\t\treturn selectedFrame;\n\t}\n\n\tvoid EndComboBox() {\n\t\tInternal::PopupMenuEnd();\n\t}\n\n\tvoid PushComboBoxItem(const char* item) {\n\t\tif (Internal::gState->lastModalId != 0 && Internal::gState->numPopupMenus > 0) {\n\t\t\tInternal::PopupMenuInfo* menu = 0;\n\t\t\tfor (u32 i = 0; i < Internal::gState->numPopupMenus; ++i) {\n\t\t\t\tif (Internal::gState->modalPopups[i].id == Internal::gState->lastModalId) {\n\t\t\t\t\tmenu = &Internal::gState->modalPopups[i];\n\t\t\t\t\tPlatformAssert(menu->itemCount <= menu->items.Count(), __LOCATION__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPlatformAssert(menu != 0, __LOCATION__);\n\t\t\tmenu->items[menu->itemCount++] = item;\n\t\t}\n\t}\n\n\ti32 BeginComboBox(const Rect& screenPos, const char* name, u32 numOptions, i32 selectedOption, const char* label, bool reversed, bool disabled) {\n\t\tif (numOptions == 0) {\n\t\t\tdisabled = true;\n\t\t}\n\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->NegativeId(screenPos);\n\t\ti32 contextId = Internal::gState->NegativeId(screenPos);\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tif (selectedOption >= numOptions || selectedOption < 0) {\n\t\t\tselectedOption = -1;\n\t\t}\n\n\t\tif (!disabled) {\n\t\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0)) {\n\t\t\t\tInternal::gState->modalControl = contextId;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->hotControl == widgetId || Internal::gState->hotControl == contextId) {\n\t\t\t\tInternal::gState->hotControl = 0;\n\t\t\t}\n\t\t\tif (Internal::gState->activeControl == widgetId || Internal::gState->activeControl == contextId) {\n\t\t\t\tInternal::gState->activeControl = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStyleColor outline = s->textAreaOutline_Normal;\n\t\tStyleColor background = s->textAreaBg_Normal;\n\t\tStyleColor lbl = s->textAreaLabel_Normal;\n\t\tStyleColor text = s->textAreaFont_Normal;\n\n\t\tif (disabled) {\n\t\t\toutline = s->textAreaOutline_Disabled;\n\t\t\tbackground = s->textAreaBg_Disabled;\n\t\t\tlbl = s->textAreaLabel_Disabled;\n\t\t\ttext = s->textAreaFont_Disabled;\n\t\t}\n\t\telse if (Internal::gState->hotControl == widgetId || Internal::gState->hotControl == contextId) {\n\t\t\toutline = s->textAreaOutline_Hot;\n\t\t\tbackground = s->textAreaBg_Hot;\n\t\t\tlbl = s->textAreaLabel_Hot;\n\t\t\ttext = s->textAreaFont_Hot;\n\t\t}\n\t\telse if (Internal::gState->activeControl == widgetId || Internal::gState->activeControl == contextId) {\n\t\t\toutline = s->textAreaOutline_Active;\n\t\t\tbackground = s->textAreaBg_Active;\n\t\t\tlbl = s->textAreaLabel_Active;\n\t\t\ttext = s->textAreaFont_Active;\n\t\t}\n\n\t\tconst char* selected = name;\n\t\tif (selected == 0) {\n\t\t\tselected = \"None\";\n\t\t}\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outline.r, outline.g, outline.b);\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, background.r, background.g, background.b);\n\t\tif (label != 0) {\n\t\t\tDraw2D::DrawString(Internal::gState->labelFont, s->textAreaLabelSize, screenPos.x + 3, screenPos.y, label, lbl.r, lbl.g, lbl.b);\n\t\t}\n\n\t\tDraw2D::Size stringSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, selected);\n\t\t\n\t\tfloat max_w = screenPos.w - 2;\n\t\tmax_w -= s->txtAreaHeight;\n\n\t\tif (stringSize.w > max_w) {\n\t\t\tDraw2D::PushClip(screenPos.x + 1, screenPos.y + 1, screenPos.w - 3 - s->textAreaFontSize, screenPos.h - 2);\n\t\t}\n\n\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->textAreaFontSize, screenPos.x + 3, screenPos.y + 1 + s->textAreaFontSize, selected, text.r, text.g, text.b);\n\t\t\n\t\tif (stringSize.w > max_w) {\n\t\t\tDraw2D::PopClip();\n\t\t}\n\n\t\tfloat rect_x = screenPos.x + screenPos.w - 3 - s->textAreaFontSize;\n\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, s->textAreaFontSize, rect_x, screenPos.y + 3 + s->textAreaFontSize, \n\t\t\tIMGUI_ICON_CODEPOINT_ARROW_DOWN, text.r, text.g, text.b);\n\n\t\tif (Internal::gState->activeControl == contextId) {\n\t\t\ti32 selection = Internal::PopupMenuBegin(contextId, Point(screenPos.x, screenPos.y + screenPos.h), screenPos.w, numOptions, reversed);\n\t\t\t\n\t\t\tif (selection >= 0) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\n\t\treturn selectedOption;\n\t}\n\n\tvoid DrawColorPicker(const Rect& screenPos, const hsv& color) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\trgb selectedRgb = hsv2rgb(color);\n\n\t\tRect colorArea(screenPos.x + 2, screenPos.y + 2, screenPos.w - 4, screenPos.h - 4);\n\t\tcolorArea.w -= 24;\n\t\tcolorArea.h -= 20;\n\n\t\tRect hueueArea = colorArea;\n\t\thueueArea.x = colorArea.x + colorArea.w + 10;\n\t\thueueArea.w = 13;\n\n\t\thsv topLeft;\n\t\ttopLeft.h = color.h; // h = hueue slider\n\t\ttopLeft.s = 0.0f;      // s = x axis\n\t\ttopLeft.v = 1.0f;      // v = y axis\n\t\trgb tl = hsv2rgb(topLeft);\n\n\t\thsv topRight;\n\t\ttopRight.h = color.h; // h = hueue slider\n\t\ttopRight.s = 1.0f;      // s = x axis\n\t\ttopRight.v = 1.0f;      // v = y axis\n\t\trgb tr = hsv2rgb(topRight);\n\n\t\thsv bottomLeft;\n\t\tbottomLeft.h = color.h; // h = hueue slider\n\t\tbottomLeft.s = 0.0f;      // s = x axis\n\t\tbottomLeft.v = 0.0f;      // v = y axis\n\t\trgb bl = hsv2rgb(bottomLeft);\n\n\t\thsv bottomRight;\n\t\tbottomRight.h = color.h; // h = hueue slider\n\t\tbottomRight.s = 1.0f;      // s = x axis\n\t\tbottomRight.v = 0.0f;      // v = y axis\n\t\trgb br = hsv2rgb(bottomRight);\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h,\n\t\t\ts->textAreaOutline_Normal.r, s->textAreaOutline_Normal.g, s->textAreaOutline_Normal.b);\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2,\n\t\t\ts->textAreaBg_Normal.r, s->textAreaBg_Normal.g, s->textAreaBg_Normal.b);\n\n\t\t{ // RGB label\n\t\t\tfloat fontSize = 14.0f;\n\t\t\tchar buffer[24] = { 0 };\n\t\t\tint r = MathMaxI(MathMinI(selectedRgb.r * 255.0f, 255), 0);\n\t\t\tint g = MathMaxI(MathMinI(selectedRgb.g * 255.0f, 255), 0);\n\t\t\tint b = MathMaxI(MathMinI(selectedRgb.b * 255.0f, 255), 0);\n\t\t\tstbsp_snprintf(buffer, 24, \"R: %d, G: %d, B: %d\", r, g, b);\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, fontSize, colorArea.x + 22, colorArea.y + colorArea.h + fontSize + 2,\n\t\t\t\tbuffer, s->textAreaFont_Normal.r, s->textAreaFont_Normal.g, s->textAreaFont_Normal.b);\n\n\t\t\tDraw2D::DrawRect(colorArea.x + 1, colorArea.y + colorArea.h + 3, 15, 15, selectedRgb.r, selectedRgb.g, selectedRgb.b);\n\t\t}\n\n\t\t{ // Hueue block\n\t\t\thsv hsvTop;\n\t\t\thsvTop.h = 359.0f;\n\t\t\thsvTop.s = hsvTop.v = 1.0f;\n\t\t\thsv hsvBottom = hsvTop;\n\t\t\thsvBottom.h = 0.0f;\n\t\t\tRect hueueSlice = hueueArea;\n\t\t\tfloat step = hueueArea.h / 10.0f;\n\t\t\thueueSlice.h = step;\n\n\t\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\t\tfloat t0 = (float)(i) / 10.0f;\n\t\t\t\tfloat t1 = (float)(i + 1) / 10.0f;\n\n\t\t\t\thsvTop.h = 359.0f * t0;\n\t\t\t\thsvBottom.h = 359.0f * t1;\n\n\t\t\t\trgb rgbTop = hsv2rgb(hsvTop);\n\t\t\t\trgb rgbBottom = hsv2rgb(hsvBottom);\n\n\t\t\t\tDraw2D::DrawRect(hueueSlice.x, hueueSlice.y, hueueSlice.w, hueueSlice.h,\n\t\t\t\t\trgbTop.r, rgbTop.g, rgbTop.b,\n\t\t\t\t\trgbTop.r, rgbTop.g, rgbTop.b,\n\t\t\t\t\trgbBottom.r, rgbBottom.g, rgbBottom.b,\n\t\t\t\t\trgbBottom.r, rgbBottom.g, rgbBottom.b);\n\n\t\t\t\thueueSlice.y += step;\n\t\t\t}\n\t\t}\n\n\t\t{ // Hueue indicator\n\t\t\tfloat ht = color.h / 359.0f;\n\t\t\tfloat y_pos = ht * hueueArea.h + hueueArea.y;\n\n\t\t\tDraw2D::DrawRect(hueueArea.x, y_pos, hueueArea.w, 2, 0.0f, 0.0f, 0.0f);\n\t\t\tDraw2D::DrawRect(hueueArea.x, y_pos + 1, hueueArea.w, 1, 1.0f, 1.0f, 1.0f);\n\t\t}\n\n\t\t// Main color block\n#if 1\n\t\tfloat slice_w = colorArea.w / 5.0f;\n\t\tfloat slice_h = colorArea.h / 5.0f;\n\n\t\tfor (int x = 0; x < 5; ++x) {\n\t\t\tfloat x0 = (float)(x) / 5.0f;\n\t\t\tfloat x1 = (float)(x + 1) / 5.0f;\n\n\t\t\tfor (int y = 0; y < 5; ++y) {\n\t\t\t\tfloat y0 = (float)(y) / 5.0f;\n\t\t\t\tfloat y1 = (float)(y + 1) / 5.0f;\n\n\t\t\t\tfloat slice_x = colorArea.x + (float)x * slice_w;\n\t\t\t\tfloat slice_y = colorArea.y + (float)y * slice_h;\n\n\t\t\t\trgb _tl = hsv2rgb(lerp(lerp(topLeft, topRight, x0), lerp(bottomLeft, bottomRight, x0), y0));\n\t\t\t\trgb _tr = hsv2rgb(lerp(lerp(topLeft, topRight, x1), lerp(bottomLeft, bottomRight, x1), y0));\n\n\t\t\t\trgb _bl = hsv2rgb(lerp(lerp(topLeft, topRight, x0), lerp(bottomLeft, bottomRight, x0), y1));\n\t\t\t\trgb _br = hsv2rgb(lerp(lerp(topLeft, topRight, x1), lerp(bottomLeft, bottomRight, x1), y1));\n\n\t\t\t\tDraw2D::DrawRect(slice_x, slice_y, slice_w, slice_h,\n\t\t\t\t\t_tl.r, _tl.g, _tl.b,\n\t\t\t\t\t_tr.r, _tr.g, _tr.b,\n\t\t\t\t\t_br.r, _br.g, _br.b,\n\t\t\t\t\t_bl.r, _bl.g, _bl.b);\n\t\t\t}\n\t\t}\n#else\n\t\tDraw2D::DrawRect(colorArea.x, colorArea.y, colorArea.w, colorArea.h,\n\t\t\ttl.r, tl.g, tl.b,\n\t\t\ttr.r, tr.g, tr.b,\n\t\t\tbl.r, bl.g, bl.b,\n\t\t\tbr.r, br.g, br.b);\n#endif\n\n\t\t{ // Color indicator\n\t\t\tfloat yt = 1.0f - color.v;\n\t\t\tfloat xt = color.s;\n\t\t\tfloat x_pos = xt * colorArea.w + colorArea.x;\n\t\t\tfloat y_pos = yt * colorArea.h + colorArea.y;\n\n\t\t\tDraw2D::DrawRect(x_pos - 4, y_pos - 1, 8, 2, 0.0f, 0.0f, 0.0f);\n\t\t\tDraw2D::DrawRect(x_pos - 4, y_pos, 8, 1, 1.0f, 1.0f, 1.0f);\n\n\t\t\tDraw2D::DrawRect(x_pos - 1, y_pos - 4, 2, 8, 0.0f, 0.0f, 0.0f);\n\t\t\tDraw2D::DrawRect(x_pos, y_pos - 4, 1, 8, 1.0f, 1.0f, 1.0f);\n\t\t}\n\n\t}\n\n\thsv ColorPicker(i32 widgetId, const Rect& screenPos, const hsv& inColor) {\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\t\tPoint m(mouse.x, mouse.y);\n\n\t\tRect colorArea(screenPos.x + 2, screenPos.y + 2, screenPos.w - 4, screenPos.h - 4);\n\t\tcolorArea.w -= 24;\n\t\tcolorArea.h -= 20;\n\n\t\tRect hueueArea = colorArea;\n\t\thueueArea.x = colorArea.x + colorArea.w + 10;\n\t\thueueArea.w = 13;\n\n\t\thsv selectedHsv = inColor;\n\n\t\tif (Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0)) {\n\n\t\t}\n\t\telse if (Internal::gState->activeControl == widgetId) {\n\t\t\tbool down = MouseDown(MouseButtonRight);\n\t\t\tif (!Internal::gState->GetPointerUp() || down) {\n\t\t\t\tif (Contains(hueueArea, m)) {\n\t\t\t\t\tfloat t = (mouse.y - hueueArea.y) / hueueArea.h;\n\t\t\t\t\tif (t < 0.0f) {\n\t\t\t\t\t\tt = 0.0f;\n\t\t\t\t\t}\n\t\t\t\t\tif (t > 1.0f) {\n\t\t\t\t\t\tt = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tselectedHsv.h = t * 359.0f;\n\t\t\t\t}\n\t\t\t\telse if (Contains(colorArea, m)) {\n\t\t\t\t\tfloat tx = (mouse.x - colorArea.x) / colorArea.w;\n\t\t\t\t\tfloat ty = (mouse.y - colorArea.y) / colorArea.h;\n\t\t\t\t\tif (tx < 0.0f) {\n\t\t\t\t\t\ttx = 0.0f;\n\t\t\t\t\t}\n\t\t\t\t\tif (tx > 1.0f) {\n\t\t\t\t\t\ttx = 1.0f;\n\t\t\t\t\t}\n\t\t\t\t\tif (ty < 0.0f) {\n\t\t\t\t\t\tty = 0.0f;\n\t\t\t\t\t}\n\t\t\t\t\tif (ty > 1.0f) {\n\t\t\t\t\t\tty = 1.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tselectedHsv.s = tx;\n\t\t\t\t\tselectedHsv.v = (1.0f - ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!Internal::gState->colorPickerActive) {\n\t\t\tDrawColorPicker(screenPos, selectedHsv);\n\t\t}\n\n\t\treturn selectedHsv;\n\t}\n\n\thsv ColorPicker(const Rect& screenPos, const hsv& inColor) {\n\t\tint widgetId = Internal::gState->NegativeId(screenPos);\n\t\treturn ColorPicker(widgetId, screenPos, inColor);\n\t}\n\n\thsv ColorPickerButton(const Rect& screenPos, const hsv& inColor, bool disabled, const StyleColor& tint) {\n\t\tRect colorBox = screenPos;\n\t\tcolorBox.y += screenPos.h;\n\t\tcolorBox.x -= 200;\n\t\tcolorBox.x += screenPos.w;\n\n\t\tcolorBox.w = 200;\n\t\tcolorBox.h = 200;\n\n\t\tint buttonId = Internal::gState->NegativeId(screenPos);\n\t\tint colorPicker = Internal::gState->NegativeId(colorBox);\n\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\thsv displayColor = inColor;\n\t\tif (!disabled && Internal::MakeHotOrActive(buttonId, screenPos, mouse, 0)) {\n\t\t\tInternal::gState->modalControl = colorPicker;\n\t\t\tInternal::gState->lastSelectedColor = inColor;\n\t\t}\n\n\t\tStyleColor outline = s->textAreaOutline_Normal;\n\t\tStyleColor background = s->textAreaBg_Normal;\n\n\t\tif (disabled) {\n\t\t\toutline = s->textAreaOutline_Disabled;\n\t\t\tbackground = s->textAreaBg_Disabled;\n\t\t}\n\t\telse if (Internal::gState->hotControl == buttonId || Internal::gState->hotControl == colorPicker) {\n\t\t\toutline = s->textAreaOutline_Hot;\n\t\t\tbackground = s->textAreaBg_Hot;\n\t\t}\n\t\telse if (Internal::gState->activeControl == buttonId || Internal::gState->activeControl == colorPicker) {\n\t\t\toutline = s->textAreaOutline_Active;\n\t\t\tbackground = s->textAreaBg_Active;\n\t\t}\n\n\t\tif (Internal::gState->activeControl == colorPicker && Internal::gState->lastActiveControl != colorPicker) {\n\t\t\tdisplayColor = Internal::gState->lastSelectedColor;\n\t\t}\n\t\t\n\t\tif (Internal::gState->activeControl == colorPicker) {\n\t\t\tInternal::gState->colorPickerActive = true;\n\t\t\tInternal::gState->colorPickerArea = colorBox;\n\n\t\t\tdisplayColor = Internal::gState->lastSelectedColor;\n\t\t\tdisplayColor = ColorPicker(colorPicker, colorBox, displayColor);\n\n\t\t\tInternal::gState->lastSelectedColor = displayColor;\n\t\t}\n\t\t\n\t\toutline.r += tint.r;\n\t\toutline.g += tint.g;\n\t\toutline.b += tint.b;\n\t\tbackground.r += tint.r;\n\t\tbackground.g += tint.g;\n\t\tbackground.b += tint.b;\n\n\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outline.r, outline.g, outline.b);\n\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, background.r, background.g, background.b);\n\t\t\n\t\tif (!disabled) {\n\t\t\trgb inColorRgb = hsv2rgb(displayColor);\n\t\t\tDraw2D::DrawRect(screenPos.x + 3, screenPos.y + 3, screenPos.w - 6, screenPos.h - 6, inColorRgb.r, inColorRgb.g, inColorRgb.b);\n\t\t}\n\n\t\tif (Internal::gState->lastActiveControl == colorPicker && Internal::gState->activeControl != colorPicker) {\n\t\t\treturn Internal::gState->lastSelectedColor;\n\t\t}\n\t\treturn inColor;\n\t}\n\n\tvoid ClearActiveTextAreas() {\n\t\tInternal::gState->grabKeyboardOnOrAfter = 0;\n\t}\n\t\n\tconst char* TextArea(const Rect& screenPos, const char* inputText, const char* label,\n\t\tbool disabled, bool fraction, bool integer, bool animated, bool interpolated, bool dirty) {\n\t\tPlatformAssert(inputText != 0, __LOCATION__);\n\n\t\tconst StyleSheet* s = Internal::gState->style;\n\t\ti32 widgetId = Internal::gState->PositiveId(screenPos);\n\n\t\tbool kbdActivate = false;\n\t\tif (Internal::gState->grabKeyboardOnOrAfter > 0) {\n\t\t\tif (widgetId == Internal::gState->grabKeyboardOnOrAfter) {\n\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = 0;\n\t\t\t\tkbdActivate = true;\n\t\t\t}\n\t\t}\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tvec2 mouse = vec2(_mouseX / dpi, _mouseY / dpi);\n\n\t\tconst char* string = inputText;\n\t\tu32 inputTextLength = Internal::StrLen(string);\n\t\tDraw2D::Size inputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\tbool return_hit = false;\n\n\t\tInternal::TextAreaInstance* textArea = 0;\n\t\tif (!disabled &&(Internal::MakeHotOrActive(widgetId, screenPos, mouse, 0) || kbdActivate)) {\n\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId || Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t// Claim text area (guaranteed to exist at this point)\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\t\t\t\t}\n\t\t\t\telse if (Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\t\t\t\tPlatformAssert(textArea != 0, __LOCATION__);\n\n\t\t\t\t// Select which text to work with\n\t\t\t\tif (textArea != 0) {\n\t\t\t\t\tstring = textArea->buffer;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring = inputText;\n\t\t\t\t}\n\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\t\t// Select everything on double click\n\t\t\t\tif (Internal::gState->lastTextDoubleClickTimer < IMGUI_DOUBLECLICK_SECOND) {\n\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInternal::gState->lastTextDoubleClickTimer = 0.0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == 0) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\n\t\t\t\t\tif (Internal::gState->textAreaB.widgetId != 0) {\n\t\t\t\t\t\tInternal::gState->textAreaB.state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInternal::gState->textAreaA.state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\tPlatformAssert(Internal::gState->textAreaB.widgetId == 0, __LOCATION__);\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\n\t\t\t\ttextArea->widgetId = widgetId;\n\t\t\t\ttextArea->state = Internal::TextAreaState::Activated;\n\t\t\t\ttextArea->karratIndex = 0;// stringLength > 0 ? stringLength - 1 : 0;\n\t\t\t\ttextArea->selection = Internal::StrLen(inputText); // 0 to string length is select everything\n\t\t\t\ttextArea->Reserve(inputTextLength);\n\t\t\t\ttextArea->Set(inputText, textArea->selection);\n\n\t\t\t\t// Select which text to work with\n\t\t\t\tif (textArea != 0) {\n\t\t\t\t\tstring = textArea->buffer;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring = inputText;\n\t\t\t\t}\n\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId || Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\tif (Internal::gState->textAreaA.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaA;\n\t\t\t\t}\n\t\t\t\telse if (Internal::gState->textAreaB.widgetId == widgetId) {\n\t\t\t\t\ttextArea = &Internal::gState->textAreaB;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Select which text to work with\n\t\t\tif (textArea != 0) {\n\t\t\t\tstring = textArea->buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstring = inputText;\n\t\t\t}\n\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\tif (textArea != 0) {\n\t\t\t\ttextArea->state = Internal::TextAreaState::Idle;\n\t\t\t\tif (Internal::gState->GetPointerPressed()) {\n\t\t\t\t\t// Shutdown if mouse clicked outside\n\t\t\t\t\tif (!Internal::gState->virtualKeyPressed) {\n\t\t\t\t\t\tif (!Contains(screenPos, Imgui::Point(mouse.x, mouse.y))) {\n\t\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Move karrat if mouse clicked inside\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvec2 adjustedMouse = mouse;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (inputTextSize.w >= screenPos.w - 6) { // To keep karrat on screen :(\n\t\t\t\t\t\t\t\tDraw2D::Rect distanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\t\t\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\t\t\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\t\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\t\t\t\t\tadjustedMouse.x -= delta;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti32 index = Internal::GetStringIndexUnderMouse(string, inputTextLength, screenPos, inputTextSize, adjustedMouse);\n\t\t\t\t\t\t\ttextArea->karratIndex = index;\n\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the mouse is being dragged\n\t\t\t\telse if (!Internal::gState->GetPointerUp()) {\n\t\t\t\t\tif (!Internal::gState->virtualKeyPressed) {\n\t\t\t\t\t\tvec2 fakeMouse = mouse;\n\t\t\t\t\t\tfakeMouse.y = screenPos.y;\n\t\t\t\t\t\tif (inputTextSize.w >= screenPos.w - 6) { // To keep karrat on screen :(\n\t\t\t\t\t\t\tDraw2D::Rect distanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\t\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\t\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\t\t\t\tfakeMouse.x -= delta;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti32 index = Internal::GetStringIndexUnderMouse(string, inputTextLength, screenPos, inputTextSize, fakeMouse);\n\t\t\t\t\t\ttextArea->selection = index - textArea->karratIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Handle text input. Text area, karrat and selection are all done by now\n\t\tbool shift = KeyboardDown(KeyboardCodeShift);\n\t\tif (Internal::gState->fakeShift || Imgui::GetFakeCapsToggle()) {\n\t\t\tshift = true;\n\t\t}\n\t\tbool control = KeyboardDown(KeyboardCodeControl);\n\t\tif (Internal::gState->fakeCtrl) {\n\t\t\tcontrol = true;\n\t\t}\n\n\t\tif (textArea != 0) {\n\t\t\tif (textArea->state == Internal::TextAreaState::Activated) {\n\t\t\t}\n\t\t\telse if (textArea->state == Internal::TextAreaState::Idle) {\n\t\t\t\t{ // Process text input\n\t\t\t\t\tu32 keyCode = ConsumeKeyQueue();\n\t\t\t\t\tbool processed_key = false;\n\t\t\t\t\twhile (keyCode != KeyboardCodeLeftMouse) {\n\t\t\t\t\t\tInternal::gState->ateKeyboard = true;\n\t\t\t\t\t\tprocessed_key = true;\n\t\t\t\t\t\tchar ascii = ScanCodeToAscii(keyCode, shift);\n\n\t\t\t\t\t\tbool skipCharacter = false;\n\t\t\t\t\t\tif (fraction || integer) {\n\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\tif (ascii >= '0' && ascii <= '9') {\n\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == '.') {\n\t\t\t\t\t\t\t\tif (integer) {\n\t\t\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t\tfor (i32 i = 0; i < textArea->length; ++i) {\n\t\t\t\t\t\t\t\t\t\tif (textArea->buffer[i] == '.') {\n\t\t\t\t\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == '-') {\n\t\t\t\t\t\t\t\t/*if (integer) {\n\t\t\t\t\t\t\t\t\tskipCharacter = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse */if (textArea->length == 0) {\n\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (textArea->selection != 0) {\n\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (textArea->karratIndex == 0) {\n\t\t\t\t\t\t\t\t\tif (textArea->length > 0) {\n\t\t\t\t\t\t\t\t\t\tif (textArea->buffer[0] != '-') {\n\t\t\t\t\t\t\t\t\t\t\tskipCharacter = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure the text areas buffer has enough room\n\t\t\t\t\t\tif (textArea->length + 2 >= textArea->capacity) {\n\t\t\t\t\t\t\tif (textArea->capacity < 16) {\n\t\t\t\t\t\t\t\ttextArea->capacity = 16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextArea->capacity *= 2;\n\t\t\t\t\t\t\ttextArea->buffer = (char*)MemRealloc(textArea->buffer, textArea->capacity);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (control) {\n\t\t\t\t\t\t\tif (ascii == 'c' || ascii == 'C') {\n\t\t\t\t\t\t\t\tchar* toCopy = Internal::GetSubString(textArea->buffer, textArea->karratIndex, textArea->karratIndex + textArea->selection);\n\t\t\t\t\t\t\t\tif (toCopy != 0) {\n\t\t\t\t\t\t\t\t\tWriteClipboard(toCopy);\n\t\t\t\t\t\t\t\t\tMemRelease(toCopy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'v' || ascii == 'V') {\n\t\t\t\t\t\t\t\tchar* toPaste = ReadClipboard();\n\t\t\t\t\t\t\t\tif (toPaste != 0) {\n\t\t\t\t\t\t\t\t\ti32 len = Internal::StrLen(toPaste);\n\n\t\t\t\t\t\t\t\t\t// Make sure text area has enough room\n\t\t\t\t\t\t\t\t\tif (textArea->capacity <= len) {\n\t\t\t\t\t\t\t\t\t\ttextArea->capacity = len + (len / 2);\n\t\t\t\t\t\t\t\t\t\ttextArea->buffer = (char*)MemRealloc(textArea->buffer, textArea->capacity);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Copy text\n\t\t\t\t\t\t\t\t\tfor (i32 i = 0; i < len; ++i) {\n\t\t\t\t\t\t\t\t\t\ttextArea->buffer[i] = toPaste[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttextArea->buffer[len] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->length = len;\n\n\t\t\t\t\t\t\t\t\t// Update internal numbers\n\t\t\t\t\t\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\t\t\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\n\t\t\t\t\t\t\t\t\t// Move karrat to end\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'x' || ascii == 'X') {\n\t\t\t\t\t\t\t\tchar* toCopy = Internal::GetSubString(textArea->buffer, textArea->karratIndex, textArea->karratIndex + textArea->selection);\n\t\t\t\t\t\t\t\tif (toCopy != 0) {\n\t\t\t\t\t\t\t\t\tWriteClipboard(toCopy);\n\t\t\t\t\t\t\t\t\tMemRelease(toCopy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ascii == 'a' || ascii == 'A') {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle text clear if there is any text selected\n\t\t\t\t\t\tbool clearedText = false;\n\t\t\t\t\t\tif (textArea->selection != 0 && ascii != '\\t' && ascii != '\\n' && ascii != 0) {\n\t\t\t\t\t\t\tif (!control || (control && (ascii == 'X' || ascii == 'x'))) {\n\t\t\t\t\t\t\t\tif ((fraction || integer) && skipCharacter) {\n\t\t\t\t\t\t\t\t\t// Ignore key. I think that's the right call here\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ti32 startIndex = textArea->karratIndex;\n\t\t\t\t\t\t\t\t\ti32 endIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\tif (endIndex < startIndex) {\n\t\t\t\t\t\t\t\t\t\ti32 tmp = endIndex;\n\t\t\t\t\t\t\t\t\t\tendIndex = startIndex;\n\t\t\t\t\t\t\t\t\t\tstartIndex = tmp;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tPlatformAssert(endIndex != startIndex, __LOCATION__);\n\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, startIndex, endIndex);\n\t\t\t\t\t\t\t\t\ti32 lengthRemoved = endIndex - startIndex;\n\t\t\t\t\t\t\t\t\ttextArea->length -= lengthRemoved;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = startIndex;\n\t\t\t\t\t\t\t\t\tclearedText = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Append character after karrat\n\t\t\t\t\t\tif (control) {\n\t\t\t\t\t\t\t// Already handled\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\n') {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\n\t\t\t\t\t\t\treturn_hit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\t') {\n\t\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = widgetId - 1; // Let the next box grab it\n\t\t\t\t\t\t\t\tif (Internal::gState->grabKeyboardOnOrAfter <= 0) {\n\t\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown; // Shut us down\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = widgetId + 1; // Let the next box grab it\n\t\t\t\t\t\t\t\ttextArea->state = Internal::TextAreaState::Shutdown; // Shut us down\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\b') {\n\t\t\t\t\t\t\tif (!clearedText) {\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > 0) {\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, textArea->karratIndex - 1, textArea->karratIndex);\n\t\t\t\t\t\t\t\t\ttextArea->buffer[--textArea->length] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex -= 1;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii == '\\a') {\n\t\t\t\t\t\t\tif (!clearedText) {\n\t\t\t\t\t\t\t\tif (textArea->length > 0) {\n\t\t\t\t\t\t\t\t\tInternal::RemoveRangeFromString(textArea->buffer, textArea->length, textArea->karratIndex, textArea->karratIndex + 1);\n\t\t\t\t\t\t\t\t\ttextArea->buffer[--textArea->length] = 0;\n\t\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > textArea->length - 1) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->length - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ascii != 0) {\n\t\t\t\t\t\t\tif (!skipCharacter) {\n\t\t\t\t\t\t\t\t// Shift string to make room for the new character\n\t\t\t\t\t\t\t\tif (textArea->karratIndex < textArea->length && textArea->karratIndex >= 0) {\n\t\t\t\t\t\t\t\t\t// Selection here is alweays 0, so we can just use karratINdex\n\t\t\t\t\t\t\t\t\t// Length + 1 so it overrides null?\n\t\t\t\t\t\t\t\t\tfor (int i = textArea->length; i >= textArea->karratIndex; --i) {\n\t\t\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\t\t\ttextArea->buffer[i] = textArea->buffer[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set karrat to current character\n\t\t\t\t\t\t\t\ttextArea->buffer[textArea->karratIndex++] = ascii;\n\t\t\t\t\t\t\t\ttextArea->buffer[++textArea->length] = 0;\n\n\t\t\t\t\t\t\t\t// Show karrat if a character was inserted\n\t\t\t\t\t\t\t\tInternal::gState->blink = true;\n\t\t\t\t\t\t\t\tInternal::gState->blinkTimer = 0.0f;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkeyCode = ConsumeKeyQueue();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (processed_key) {\n\t\t\t\t\t\tinputTextLength = Internal::StrLen(string);\n\t\t\t\t\t\tinputTextSize = Draw2D::MeasureString(Internal::gState->interfaceFont, s->textAreaFontSize, string);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{ // Process arrow nagivation\n\t\t\t\t\ti32 arrowStartIndex = textArea->karratIndex;\n\t\t\t\t\ti32 arrowEndIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\n\t\t\t\t\tbool leftArrowPressed = KeyboardPressed(KeyboardCodeLeft);\n\t\t\t\t\tif (Internal::gState->fakeLeftPressed) {\n\t\t\t\t\t\tleftArrowPressed = true;\n\t\t\t\t\t}\n\t\t\t\t\tbool leftArrowDown = KeyboardDown(KeyboardCodeLeft);\n\t\t\t\t\t\n\t\t\t\t\tbool rightArrowPressed = KeyboardPressed(KeyboardCodeRight);\n\t\t\t\t\tif (Internal::gState->fakeRightPressed) {\n\t\t\t\t\t\trightArrowPressed = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbool rightArrowDown = KeyboardDown(KeyboardCodeRight);\n\n\t\t\t\t\tif (leftArrowPressed || rightArrowPressed) {\n\t\t\t\t\t\tInternal::gState->pulseTimer = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftArrowDown || rightArrowDown) {\n\t\t\t\t\t\tInternal::gState->blink = true;\n\t\t\t\t\t\tInternal::gState->blinkTimer = 0.0f;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (leftArrowPressed || leftArrowDown) {\n\t\t\t\t\t\tif (Internal::gState->pulse || leftArrowPressed) {\n\t\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\ttextArea->selection *= -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tPlatformAssert(textArea->selection >= 0, __LOCATION__);\n\t\t\t\t\t\t\t\tif (textArea->karratIndex > 0) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex -= 1;\n\t\t\t\t\t\t\t\t\ttextArea->selection += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection == 0 && inputTextLength > 0) {\n\t\t\t\t\t\t\t\tif (--textArea->karratIndex < 0) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection != 0) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (rightArrowPressed || rightArrowDown) {\n\t\t\t\t\t\t if (Internal::gState->pulse || rightArrowPressed) {\n\t\t\t\t\t\t\t if (shift) {\n\t\t\t\t\t\t\t\t if (arrowEndIndex < arrowStartIndex) {\n\t\t\t\t\t\t\t\t\t textArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t\t textArea->selection *= -1;\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t PlatformAssert(textArea->selection >= 0, __LOCATION__);\n\t\t\t\t\t\t\t\t if (textArea->karratIndex + textArea->selection < inputTextLength) {\n\t\t\t\t\t\t\t\t\t textArea->selection += 1;\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t else if (textArea->selection == 0 && inputTextLength > 0) {\n\t\t\t\t\t\t\t\tif (++textArea->karratIndex >= inputTextLength) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (textArea->selection != 0) {\n\t\t\t\t\t\t\t\tif (arrowEndIndex > arrowStartIndex) {\n\t\t\t\t\t\t\t\t\ttextArea->karratIndex = textArea->karratIndex + textArea->selection;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (KeyboardPressed(KeyboardCodeUp)) {\n\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (KeyboardPressed(KeyboardCodeDown)) {\n\t\t\t\t\t\tif (shift) {\n\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\ttextArea->selection = inputTextLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (inputTextLength > 0) {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = inputTextLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttextArea->karratIndex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextArea->selection = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (textArea->state == Internal::TextAreaState::Shutdown) {\n\t\t\t}\n\t\t}\n\n\t\t{ // Drawing\n\t\t\tStyleColor bgColor = s->textAreaBg_Normal;\n\t\t\tStyleColor txtColor = s->textAreaFont_Normal;\n\t\t\tStyleColor outlinColor = s->textAreaOutline_Normal;\n\t\t\tStyleColor labelColor = s->textAreaLabel_Normal;\n\n\t\t\tif (disabled) {\n\t\t\t\tbgColor = s->textAreaBg_Disabled;\n\t\t\t\ttxtColor = s->textAreaFont_Disabled;\n\t\t\t\toutlinColor = s->textAreaOutline_Disabled;\n\t\t\t\tlabelColor = s->textAreaLabel_Disabled;\n\t\t\t}\n\t\t\telse if (Internal::gState->activeControl == widgetId || textArea != 0) {\n\t\t\t\tbgColor = s->textAreaBg_Active;\n\t\t\t\ttxtColor = s->textAreaFont_Active;\n\t\t\t\toutlinColor = s->textAreaOutline_Active;\n\t\t\t\tlabelColor = s->textAreaLabel_Active;\n\t\t\t}\n\t\t\telse if (Internal::gState->hotControl == widgetId) {\n\t\t\t\tbgColor = s->textAreaBg_Hot;\n\t\t\t\ttxtColor = s->textAreaFont_Hot;\n\t\t\t\toutlinColor = s->textAreaOutline_Hot;\n\t\t\t\tlabelColor = s->textAreaLabel_Hot;\n\t\t\t}\n\n\t\t\tif (animated && dirty) {\n\t\t\t\tbgColor.r += s->textAreaBg_DirtyTint.r;\n\t\t\t\tbgColor.g += s->textAreaBg_DirtyTint.g;\n\t\t\t\tbgColor.b += s->textAreaBg_DirtyTint.b;\n\t\t\t\toutlinColor.r += s->textAreaOutline_DirtyTint.r;\n\t\t\t\toutlinColor.g += s->textAreaOutline_DirtyTint.g;\n\t\t\t\toutlinColor.b += s->textAreaOutline_DirtyTint.b;\n\t\t\t\ttxtColor.r += s->textAreaFont_DirtyTint.r;\n\t\t\t\ttxtColor.g += s->textAreaFont_DirtyTint.g;\n\t\t\t\ttxtColor.b += s->textAreaFont_DirtyTint.b;\n\t\t\t}\n\t\t\telse if (animated && interpolated) {\n\t\t\t\tbgColor.r += s->textAreaBg_InterpolatedTint.r;\n\t\t\t\tbgColor.g += s->textAreaBg_InterpolatedTint.g;\n\t\t\t\tbgColor.b += s->textAreaBg_InterpolatedTint.b;\n\t\t\t\toutlinColor.r += s->textAreaOutline_InterpolatedTint.r;\n\t\t\t\toutlinColor.g += s->textAreaOutline_InterpolatedTint.g;\n\t\t\t\toutlinColor.b += s->textAreaOutline_InterpolatedTint.b;\n\t\t\t\ttxtColor.r += s->textAreaFont_InterpolatedTint.r;\n\t\t\t\ttxtColor.g += s->textAreaFont_InterpolatedTint.g;\n\t\t\t\ttxtColor.b += s->textAreaFont_InterpolatedTint.b;\n\t\t\t}\n\t\t\telse if (animated) {\n\t\t\t\tbgColor.r += s->textAreaBg_AnimatedTint.r;\n\t\t\t\tbgColor.g += s->textAreaBg_AnimatedTint.g;\n\t\t\t\tbgColor.b += s->textAreaBg_AnimatedTint.b;\n\t\t\t\toutlinColor.r += s->textAreaOutline_AnimatedTint.r;\n\t\t\t\toutlinColor.g += s->textAreaOutline_AnimatedTint.g;\n\t\t\t\toutlinColor.b += s->textAreaOutline_AnimatedTint.b;\n\t\t\t\ttxtColor.r+= s->textAreaFont_AnimatedTint.r;\n\t\t\t\ttxtColor.g+= s->textAreaFont_AnimatedTint.g;\n\t\t\t\ttxtColor.b+= s->textAreaFont_AnimatedTint.b;\n\t\t\t}\n\n\t\t\t// Draw bg\n\t\t\tDraw2D::DrawRect(screenPos.x, screenPos.y, screenPos.w, screenPos.h, outlinColor.r, outlinColor.g, outlinColor.b);\n\t\t\tDraw2D::DrawRect(screenPos.x + 1, screenPos.y + 1, screenPos.w - 2, screenPos.h - 2, bgColor.r, bgColor.g, bgColor.b);\n\t\t\tif (label != 0) {\n\t\t\t\tDraw2D::DrawString(Internal::gState->labelFont, s->textAreaLabelSize, screenPos.x + 3, screenPos.y, label, labelColor.r, labelColor.g, labelColor.b);\n\t\t\t}\n\n\t\t\tfloat string_x = screenPos.x + screenPos.w - 5 - inputTextSize.w;\n\t\t\tfloat string_y = screenPos.y + 2;\n\n\t\t\tbool clip = false;\n\t\t\tif (inputTextSize.w > screenPos.w - 6) {\n\t\t\t\tclip = true;\n\t\t\t\tDraw2D::PushClip(screenPos.x + 3, screenPos.y, screenPos.w - 6, screenPos.h);\n\t\t\t}\n\n\t\t\t// Adjust string position so karrat is visible\n\t\t\tDraw2D::Rect distanceToKarrat(0, 0, 0, 0);\n\t\t\tif (textArea != 0) {\n\t\t\t\tdistanceToKarrat = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\t\t\t\tfloat karrat_x = string_x + distanceToKarrat.w;\n\n\t\t\t\tif (karrat_x < screenPos.x) {\n\t\t\t\t\tfloat delta = screenPos.x - karrat_x;\n\t\t\t\t\tdelta += 5; // Arbitrary\n\t\t\t\t\tstring_x += delta;\n\t\t\t\t}\n\t\t\t\telse if (karrat_x > screenPos.x + screenPos.w) {\n\t\t\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Draw selection\n\t\t\tif (textArea != 0 && textArea->selection != 0) {\n\t\t\t\ti32 selectionStart = textArea->karratIndex;\n\t\t\t\ti32 selectionEnd = selectionStart + textArea->selection;\n\t\t\t\tif (selectionEnd < selectionStart) {\n\t\t\t\t\ti32 tmp = selectionEnd;\n\t\t\t\t\tselectionEnd = selectionStart;\n\t\t\t\t\tselectionStart = tmp;\n\t\t\t\t}\n\t\t\t\tif (selectionStart >= 0) {\n\t\t\t\t\tDraw2D::Rect substring = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, selectionStart, selectionEnd - selectionStart);\n\t\t\t\t\tDraw2D::DrawRect(string_x + substring.x, string_y + substring.y, substring.w, substring.h, s->textAreaSelectionColor.r, s->textAreaSelectionColor.g, s->textAreaSelectionColor.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Draw string\n\t\t\tstring_y += s->textAreaFontSize;\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, s->textAreaFontSize, string_x, string_y, string, txtColor.r, txtColor.g, txtColor.b);\n\t\t\tstring_y -= s->textAreaFontSize;\n\n\t\t\t// Draw karrat\n\t\t\tif (textArea != 0 && textArea->karratIndex >= 0 && textArea->selection == 0) {\n\t\t\t\tDraw2D::Rect substring = Draw2D::MeasureSubString(Internal::gState->interfaceFont, s->textAreaFontSize, string, 0, textArea->karratIndex);\n\n\t\t\t\tf32 karratPosX = string_x + substring.x + substring.w - 1;\n\t\t\t\tf32 karratPosY = string_y + 1;\n\t\t\t\tf32 karratHeight = substring.h - 4;\n\n\t\t\t\tif (Internal::gState->blink) {\n\t\t\t\t\tDraw2D::DrawRect(karratPosX - 3, karratPosY - 1, 3 + 1 + 3, 1, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t\tDraw2D::DrawRect(karratPosX, karratPosY, 1, karratHeight, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t\tDraw2D::DrawRect(karratPosX - 3, karratPosY + karratHeight, 3 + 1 + 3, 1, s->karratColor.r, s->karratColor.g, s->karratColor.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (clip) {\n\t\t\t\tDraw2D::PopClip();\n\t\t\t}\n\t\t}\n\n\t\tif (textArea != 0 && textArea->state == Internal::TextAreaState::Shutdown) {\n\t\t\ttextArea->widgetId = 0;\n\t\t\treturn textArea->buffer;\n\t\t}\n\n\t\tif (textArea != 0 && return_hit) {\n\t\t\treturn textArea->buffer;\n\t\t}\n\n\t\treturn inputText;\n\t}\n\n\tvoid Initialize(u32 interfaceFont, u32 widgetFont, u32 labelFont) {\n\t\tInternal::gState = (Internal::State*)MemAlloc(sizeof(Internal::State));\n\t\tMemClear(Internal::gState, sizeof(Internal::State));\n\t\tInternal::gState->widgetFont = widgetFont;\n\t\tInternal::gState->interfaceFont = interfaceFont;\n\t\tInternal::gState->labelFont = labelFont;\n\t\tnew (&Internal::gState->modalPopups) Vector<Internal::PopupMenuInfo>();\n\t}\n\n\tvoid Shutdown() {\n\t\tif (Internal::gState->maxPopupMenus != 0) {\n\t\t\tfor (u32 i = 0; i < Internal::gState->maxPopupMenus; ++i) {\n\t\t\t\tInternal::gState->modalPopups[i].items.~Vector();\n\t\t\t}\n\t\t}\n\t\tInternal::gState->modalPopups.~Vector();\n\n\t\tif (Internal::gState->textAreaA.buffer != 0) {\n\t\t\tMemRelease(Internal::gState->textAreaA.buffer);\n\t\t}\n\t\tif (Internal::gState->textAreaB.buffer != 0) {\n\t\t\tMemRelease(Internal::gState->textAreaB.buffer);\n\t\t}\n#if PLATFORM_DEBUG\n\t\tInternal::RectBlock* iter = Internal::gState->positiveWidgets.next;\n\t\twhile (iter != 0) {\n\t\t\tInternal::RectBlock* del = iter;\n\t\t\titer = iter->next;\n\t\t\tMemRelease(del);\n\t\t}\n\t\titer = Internal::gState->negativeWidgets.next;\n\t\twhile (iter != 0) {\n\t\t\tInternal::RectBlock* del = iter;\n\t\t\titer = iter->next;\n\t\t\tMemRelease(del);\n\t\t}\n#endif\n\t\tMemRelease(Internal::gState);\n\t}\n\n\tvoid BeginFrame(float dpi, const struct StyleSheet& style) {\n\t\tInternal::gState->dpi = dpi;\n\t\tInternal::gState->tooltipIcon = -1;\n\t\tInternal::gState->tooltipLabel = 0;\n\t\tInternal::gState->style = &style;\n\t\tInternal::gState->positiveIdGenerator = 0;\n\t\tInternal::gState->negativeIdGenerator = 0;\n\t\tif (Internal::gState->lastHotControl != Internal::gState->hotControl) {\n\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t}\n\t\tInternal::gState->lastHotControl = Internal::gState->hotControl;\n\t\tInternal::gState->hotControl = 0;\n\n\t\t// Update pointer state\n\t\tif (Internal::gState->activeInputMethod == IMGUI_ACTIVE_INPUT_NONE) {\n\t\t\tif (MousePressed(MouseButtonLeft)) {\n\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_MOUSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (u32 i = 0; i < 5; ++i) {\n\t\t\t\t\tif (TouchPressed(i)) {\n\t\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_TOUCH1 + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool EndFrame(u32 screenWidth, u32 screenHeight) {\n\t\tconst StyleSheet* s = Internal::gState->style;\n\n\t\tf32 _mouseX = Internal::gState->GetPointerX(); // In screen space, needs to be divided \n\t\tf32 _mouseY = Internal::gState->GetPointerY(); // by dpi to move into design space.\n\t\tf32 dpi = Internal::gState->dpi;\n\t\tPoint mouse(_mouseX / dpi, _mouseY / dpi);\n\t\t\n\t\tInternal::gState->lastBeingModalPopupContext = 0;\n\t\tInternal::gState->lastBeingModalPopupActivation = 0;\n\t\tInternal::gState->lastModalId = 0;\n\n\t\tInternal::gState->fakeLeftPressed = false;\n\t\tInternal::gState->fakeRightPressed = false;\n\n\t\twhile (Internal::gState->numPopupMenus > 0) {\n\t\t\tInternal::PopupMenuRender(Internal::gState->modalPopups[Internal::gState->numPopupMenus - 1]);\n\t\t\tInternal::gState->numPopupMenus -= 1;\n\t\t}\n\n\t\tif (Internal::gState->tooltipIcon >= 0 && Internal::gState->tooltipIcon < 256) {\n\t\t\tf32 x = Internal::gState->GetPointerX();\n\t\t\tf32 y = Internal::gState->GetPointerY();\n\t\t\tf32 dpi = Internal::gState->dpi;\n\t\t\t\n\t\t\tconst StyleColor& back = s->tooltipIconBGColor;\n\t\t\tconst StyleColor& fore = s->tooltipIconFGColor;\n\t\t\tfloat offset = MathMaxF(1.0f, MathFloor(dpi));\n\t\t\t\n\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, IMGUI_TOOLTIP_SIZE, (x + (3 * dpi)) / dpi, (y + (3 * dpi)) / dpi, Internal::gState->tooltipIcon, back.r, back.g, back.b, 1.0f);\n\t\t\tDraw2D::DrawCodePoint(Internal::gState->widgetFont, IMGUI_TOOLTIP_SIZE, (x + (3 * dpi) + offset) / dpi, (y + (3 * dpi) + offset) / dpi, Internal::gState->tooltipIcon, fore.r, fore.g, fore.b, 1.0f);\n\t\t}\n\n\t\tif (Internal::gState->tooltipLabel != 0) {\n\t\t\tf32 dpi = Internal::gState->dpi;\n\n\t\t\tf32 x = Internal::gState->GetPointerX() / dpi;\n\t\t\tf32 y = Internal::gState->GetPointerY() / dpi;\n\n\t\t\tDraw2D::Size stringSize = Draw2D::MeasureString(Internal::gState->interfaceFont, IMGUI_TOOLTIP_SIZE - 2, Internal::gState->tooltipLabel);\n\t\t\tstringSize.w += 2;\n\t\t\tif (x + stringSize.w > (f32)screenWidth / dpi) {\n\t\t\t\tx -= stringSize.w;\n\t\t\t}\n\n\t\t\tDraw2D::DrawRect(x - 1, y - IMGUI_TOOLTIP_SIZE - 1, stringSize.w + 2, IMGUI_TOOLTIP_SIZE + 2, s->tooltipIconBGColor.r, s->tooltipIconBGColor.g, s->tooltipIconBGColor.b);\n\t\t\tDraw2D::DrawRect(x, y - IMGUI_TOOLTIP_SIZE, stringSize.w, IMGUI_TOOLTIP_SIZE, s->tooltipTextBGColor.r, s->tooltipTextBGColor.g, s->tooltipTextBGColor.b);\n\t\t\tDraw2D::DrawString(Internal::gState->interfaceFont, IMGUI_TOOLTIP_SIZE - 2, x + 2, y - 2, Internal::gState->tooltipLabel, s->tooltipTextColor.r, s->tooltipTextColor.g, s->tooltipTextColor.b);\n\t\t}\n\n\t\tif (Internal::gState->lastActiveControl != Internal::gState->activeControl) {\n\t\t\tInternal::gState->activeControlTimer = 0.0f;\n\t\t}\n\t\tInternal::gState->lastActiveControl = Internal::gState->activeControl;\n\n\t\ti32 _active = Internal::gState->activeControl;\n\n\t\tif (Internal::gState->grabKeyboardOnOrAfter >= Internal::gState->positiveIdGenerator) {\n\t\t\tInternal::gState->grabKeyboardOnOrAfter = 1;\n\t\t}\n\t\telse if (Internal::gState->grabKeyboardOnOrAfter < 0) {\n\t\t\tInternal::gState->grabKeyboardOnOrAfter = Internal::gState->positiveIdGenerator;\n\t\t\tif (Internal::gState->grabKeyboardOnOrAfter < 0) {\n\t\t\t\tInternal::gState->grabKeyboardOnOrAfter = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (Internal::gState->GetPointerReleased()) {\n\t\t\tif (Internal::gState->modalControl != 0) {\n\t\t\t\tInternal::gState->activeControl = Internal::gState->modalControl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Internal::gState->colorPickerActive) {\n\t\t\t\t\tif (!Contains(Internal::gState->colorPickerArea, mouse)) {\n\t\t\t\t\t\tInternal::gState->activeControl = 0;\n\t\t\t\t\t} // else keep the color picker active\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInternal::gState->activeControl = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInternal::gState->modalControl = 0;\n\t\t}\n\n\t\tif (Internal::gState->colorPickerActive) {\n\t\t\tDrawColorPicker(Internal::gState->colorPickerArea, Internal::gState->lastSelectedColor);\n\t\t\tInternal::gState->colorPickerActive = false;\n\t\t}\n\n\t\t// THIS HAS TO HAPPEN LAST!\n\n\t\tif (Internal::gState->activeInputMethod != IMGUI_ACTIVE_INPUT_NONE) {\n\t\t\tif (Internal::gState->activeInputMethod == IMGUI_ACTIVE_INPUT_MOUSE) {\n\t\t\t\tif (MouseReleased(MouseButtonLeft)) {\n\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint touchIndex = Internal::gState->activeInputMethod - IMGUI_ACTIVE_INPUT_TOUCH1;\n\t\t\t\tif (TouchReleased(touchIndex)) {\n\t\t\t\t\tInternal::gState->activeInputMethod = IMGUI_ACTIVE_INPUT_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if PLATFORM_DEBUG\n\t\tif (Internal::gState->debugOverlayEnabled) {\n\t\t\tif (Internal::gState->hotControl != 0) {\n\t\t\t\tRect hotRect = Internal::gState->Debug_GetWidgetRect(Internal::gState->hotControl);\n\t\t\t\tDraw2D::DrawRect(hotRect.x, hotRect.y, hotRect.w, hotRect.h, 1.0f, 0.0f, 0.0f, 0.3f);\n\t\t\t}\n\n\t\t\tif (_active != 0) {\n\t\t\t\tRect activeRect = Internal::gState->Debug_GetWidgetRect(_active);\n\t\t\t\tDraw2D::DrawRect(activeRect.x, activeRect.y, activeRect.w, activeRect.h, 0.0f, 1.0f, 0.0f, 0.3f);\n\t\t\t}\n\t\t}\n#endif\n\n\t\tbool result = Internal::gState->ateKeyboard;\n\t\tInternal::gState->ateKeyboard = false;\n\t\tClearKeyQueue();\n\t\treturn result;\n\t}\n\n\tvoid TickFrame(float deltaTime) {\n\t\tInternal::gState->pulse = false;\n\t\tInternal::gState->pulseTimer += deltaTime;\n\t\tInternal::gState->lastTextDoubleClickTimer += deltaTime;\n\t\tInternal::gState->longPulse = false;\n\t\tInternal::gState->longPulseTimer += deltaTime;\n\n\t\tif (Internal::gState->activeControl != 0) {\n\t\t\tInternal::gState->activeControlTimer += deltaTime;\n\t\t}\n\t\telse {\n\t\t\tInternal::gState->activeControlTimer = 0.0f;\n\t\t}\n\n\t\tif (Internal::gState->hotControl != 0) {\n\t\t\tInternal::gState->hotControlTimer += deltaTime;\n\t\t}\n\t\telse {\n\t\t\tInternal::gState->hotControlTimer = 0.0f;\n\t\t}\n\n\t\tif (Internal::gState->pulseTimer > float(IMGUI_PULSE_MS) / 1000.0f) {\n\t\t\tInternal::gState->pulseTimer = 0;\n\t\t\tInternal::gState->pulse = true;\n\t\t}\n\n\t\tif (Internal::gState->longPulseTimer > float(IMGUI_LONG_PULSE_MS) / 1000.0f) {\n\t\t\tInternal::gState->longPulseTimer = 0;\n\t\t\tInternal::gState->longPulse = true;\n\t\t}\n\n\t\tfloat blinkLimit = float(IMGUI_BLINK_MS) / 1000.0f;\n\t\tif (Internal::gState->blink) {\n\t\t\tInternal::gState->blinkTimer += deltaTime;\n\t\t\tif (Internal::gState->blinkTimer > blinkLimit) {\n\t\t\t\tInternal::gState->blinkTimer = 0;\n\t\t\t\tInternal::gState->blink = !Internal::gState->blink;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tblinkLimit *= -1.0f;\n\t\t\tInternal::gState->blinkTimer -= deltaTime;\n\t\t\tif (Internal::gState->blinkTimer < blinkLimit) {\n\t\t\t\tInternal::gState->blinkTimer = 0;\n\t\t\t\tInternal::gState->blink = !Internal::gState->blink;\n\t\t\t}\n\t\t}\n\n\t\tif (KeyboardPressed(KeyboardCodeTilde)) {\n\t\t\tInternal::gState->debugOverlayEnabled = !Internal::gState->debugOverlayEnabled;\n\t\t}\n\t\tInternal::gState->virtualKeyPressed = false;\n\t}\n}","#ifndef _H_IMGUI_\n#define _H_IMGUI_\n\n#include \"../platform/memory.h\"\n#include \"../framework/vec3.h\"\n#include \"color.h\"\n#include \"Node2D.h\"\n#include \"../framework/draw2d.h\"\n\n#define IMGUI_ICON_CODEPOINT_RESIZE_HORIZONTAL 'A'\n#define IMGUI_ICON_CODEPOINT_RESIZE_VERTICAL 'B'\n#define IMGUI_ICON_CODEPOINT_TRASHCAN 'C'\n#define IMGUI_ICON_CODEPOINT_NEWLAYER 'D'\n#define IMGUI_ICON_CODEPOINT_NEWCHAIN 'E'\n#define IMGUI_ICON_CODEPOINT_NEWSPRITE 'F'\n#define IMGUI_ICON_CODEPOINT_REMOVECHAIN 'G'\n#define IMGUI_ICON_CODEPOINT_REMOVESPRITE 'H'\n#define IMGUI_ICON_CODEPOINT_CHAIN 'I'\n#define IMGUI_ICON_CODEPOINT_KEY 'J'\n#define IMGUI_ICON_CODEPOINT_NOKEY 'K'\n#define IMGUI_ICON_CODEPOINT_DESELECT 'L'\n#define IMGUI_ICON_CODEPOINT_UNDO 'M'\n#define IMGUI_ICON_CODEPOINT_REDO 'N'\n#define IMGUI_ICON_CODEPOINT_CLEAR_UNDO 'O'\n#define IMGUI_ICON_CODEPOINT_ARROW_DOWN 'P'\n#define IMGUI_ICON_CODEPOINT_ARROW_UP 'Q'\n#define IMGUI_ICON_CODEPOINT_ARROW_LEFT 'R'\n#define IMGUI_ICON_CODEPOINT_ARROW_RIGHT 'S'\n#define IMGUI_ICON_CODEPOINT_VISIBLE 'T'\n#define IMGUI_ICON_CODEPOINT_INVISIBLE 'U'\n#define IMGUI_ICON_CODEPOINT_DEBUGOFF 'V'\n#define IMGUI_ICON_CODEPOINT_DEBUGON 'W'\n#define IMGUI_ICON_CODEPOINT_COLLAPSED 'X'\n#define IMGUI_ICON_CODEPOINT_EXPANDED 'Y'\n#define IMGUI_ICON_CODEPOINT_KEYBOARD_OUTLINED 'Z'\n#define IMGUI_ICON_CODEPOINT_KEYBOARD_FILLED 'a'\n#define IMGUI_ICON_CODEPOINT_LOCK_CLOSED 'b'\n#define IMGUI_ICON_CODEPOINT_LOCK_OPEN 'c'\n#define IMGUI_ICON_CODEPOINT_ADD_FILE 'd'\n#define IMGUI_ICON_APPICON 'e'\n#define IMGUI_ICON_ADDTRACK 'f'\n#define IMGUI_ICON_PLAY 'g'\n#define IMGUI_ICON_PAUSE 'h'\n#define IMGUI_ICON_RECORD 'i'\n#define IMGUI_ICON_SYNC_ENABLED 'j'\n#define IMGUI_ICON_SYNC_DISABLED 'k'\n#define IMGUI_ICON_DIAMOND 'l'\n#define IMGUI_ICON_TIMELINEKEY 'm'\n#define IMGUI_ICON_CLEARKEY 'n'\n#define IMGUI_ICON_STOP 'p'\n#define IMGUI_ICON_MOVETOOL 'q'\n#define IMGUI_ICON_ZOOM_IN 'r'\n#define IMGUI_ICON_ZOOM_OUT 's'\n#define IMGUI_ICON_ROTATE 'o'\n#define IMGUI_ICON_SCALE 't'\n#define IMGUI_ICON_MOVE 'u'\n#define IMGUI_ICON_PIVOT 'v'\n#define IMGUI_ICON_UNCHECKED 'w'\n#define IMGUI_ICON_CHECKED 'x'\n#define IMGUI_ICON_GRID 'y'\n#define IMGUI_ICON_Left '!'\n#define IMGUI_ICON_Right '\"'\n#define IMGUI_ICON_Up '#'\n#define IMGUI_ICON_Down '$'\n\n#define IMGUI_TOOLTIP_SIZE 18\n#define IMGUI_SPLITTER_GRABBABLE_WIDTH 4.0f\n#define IMGUI_PULSE_MS 250\n#define IMGUI_LONG_PULSE_MS 500\n#define IMGUI_BLINK_MS 800\n#define IMGUI_TOOLTIP_MIN 1.5f\n#define IMGUI_TOOLTIP_MAX 12.0f\n#define IMGUI_TRANSFORM_HEIGHT 110.0f\n#define IMGUI_PREVIEW_HEIGHT 110.0f\n#define IMGUI_ANIMDETAIL_HEIGHT 75.0f\n#define IMGUI_SPRITE_HEIGHT 150.0f\n#define IMGUI_DOUBLECLICK_SECOND 0.4f\n\nstruct StyleColor {\n\tunion {\n\t\tstruct {\n\t\t\tfloat r;\n\t\t\tfloat g;\n\t\t\tfloat b;\n\t\t\tfloat a;\n\t\t};\n\t\tfloat rgba[4];\n\t};\n\n\tinline StyleColor(float _r = 0.0f, float _g = 0.0f, float _b = 0.0f, float _a = 1.0f) :\n\t\tr(_r), g(_g), b(_b), a(_a) {}\n};\n\ninline StyleColor ColorRGB8(u8 r, u8 g, u8 b) {\n\tfloat _r = (float)r / 255.0f;\n\tfloat _g = (float)g / 255.0f;\n\tfloat _b = (float)b / 255.0f;\n\treturn StyleColor(_r, _g, _b, 1.0f);\n}\n\ninline StyleColor ColorRGB8(u8 c) {\n\tfloat _r = (float)c / 255.0f;\n\tfloat _g = (float)c / 255.0f;\n\tfloat _b = (float)c / 255.0f;\n\treturn StyleColor(_r, _g, _b, 1.0f);\n}\n\nstruct StyleSheet {\n\tfloat animationFrameWidth;\n\tfloat animationFrameHeight;\n\tStyleColor frameEven;\n\tStyleColor frameOdd;\n\n\tStyleColor gizmoR;\n\tStyleColor gizmoG;\n\tStyleColor gizmoB;\n\tStyleColor gizmoY;\n\tStyleColor gizmoR_Hover;\n\tStyleColor gizmoG_Hover;\n\tStyleColor gizmoB_Hover;\n\tStyleColor gizmoY_Hover;\n\n\tStyleColor menuBarBg;\n\tfloat menuBarHeight;\n\n\tStyleColor toolBarBg;\n\tfloat toolbarWidth;\n\n\tStyleColor footerBg;\n\tfloat footerHeight;\n\n\tfloat inspectorMinWidth;\n\tfloat timelineMinWidth;\n\tfloat animatorMinHeight;\n\n\tu32 menuTextLineHeight;\n\n\tStyleColor tooltipIconBGColor;\n\tStyleColor tooltipIconFGColor;\n\tStyleColor tooltipTextColor;\n\tStyleColor tooltipTextBGColor;\n\n\tStyleColor documentBGColor;\n\tStyleColor panelBgColor;\n\tStyleColor keyframeDiamond;\n\n\tStyleColor dividerAColor;\n\tStyleColor dividerBColor;\n\tfloat dividerHotTint;\n\tfloat dividerActiveTint;\n\n\tfloat headerHeight;\n\tu32 headerFontSize;\n\tStyleColor headerBgColor;\n\tStyleColor headerFontColor;\n\tStyleColor HeaderBGHotColor;\n\tStyleColor HeaderBGActiveColor;\n\n\tStyleColor imageBlockOutlineColor;\n\tStyleColor imageBlockBackgroundColor;\n\tStyleColor imageBlockLabelColor;\n\n\tStyleColor gridA;\n\tStyleColor gridB;\n\n\tStyleColor hierarchyFooterBg;\n\tfloat hierarchyFooterHeight;\n\tfloat hierarchyFooterButtonSize;\n\tStyleColor hierarchyFooterButtonBG_Hot;\n\tStyleColor hierarchyFooterButtonBG_Active;\n\tStyleColor hierarchyFooterButtonBorder_Hot;\n\tStyleColor hierarchyFooterButtonBorder_Active;\n\tStyleColor hierarchyFooterButtonIcon;\n\tStyleColor hierarchyFooterRemoveIcon;\n\tStyleColor hierarchyFooterDisabledIconColor;\n\tStyleColor hierarchyLabelDisabled;\n\tStyleColor hierarchyItemBGDisabled;\n\n\tfloat listBoxItemHeight;\n\tu32 hierarchyLabelFontSize;\n\tStyleColor hierarchyItemBG_A;\n\tStyleColor hierarchyItemBG_B;\n\tStyleColor hierarchyItemBG_Selected;\n\tStyleColor hierarchyItemBG_Movable;\n\tStyleColor hierarchyLabel;\n\tStyleColor hierarchyToggleNormal;\n\tStyleColor hierarchyToggleHot;\n\n\tStyleColor scrollBarTrackBG;\n\tStyleColor scrollBarIconNormal;\n\tStyleColor scrollBarIconHot;\n\tStyleColor scrollBarHotButtonBg;\n\tStyleColor scrollGrabberNormal;\n\tStyleColor scrollGrabberHot;\n\tfloat scrollBarSize;\n\tfloat scrollIconSize;\n\tfloat scrollBarHandleSize;\n\n\tStyleColor fps1;\n\tStyleColor fps2;\n\tStyleColor fps3;\n\n\tStyleColor toggleButtonBorder;\n\tStyleColor toggleButtonDisabledBorder;\n\tStyleColor toggleButtonNormal;\n\tStyleColor toggleButtonHot;\n\tStyleColor toggleButtonActive;\n\tStyleColor toggleButtonDisabled;\n\n\tStyleColor textAreaBg_Normal;\n\tStyleColor textAreaBg_Hot;\n\tStyleColor textAreaBg_Active;\n\tStyleColor textAreaBg_Disabled;\n\tStyleColor textAreaBg_AnimatedTint;\n\tStyleColor textAreaBg_InterpolatedTint;\n\tStyleColor textAreaBg_DirtyTint;\n\n\tStyleColor textAreaFont_Normal;\n\tStyleColor textAreaFont_Hot;\n\tStyleColor textAreaFont_Active;\n\tStyleColor textAreaFont_Disabled;\n\tStyleColor textAreaFont_AnimatedTint;\n\tStyleColor textAreaFont_InterpolatedTint;\n\tStyleColor textAreaFont_DirtyTint;\n\n\tStyleColor textAreaOutline_Normal;\n\tStyleColor textAreaOutline_Hot;\n\tStyleColor textAreaOutline_Active;\n\tStyleColor textAreaOutline_Disabled;\n\tStyleColor textAreaOutline_AnimatedTint;\n\tStyleColor textAreaOutline_InterpolatedTint;\n\tStyleColor textAreaOutline_DirtyTint;\n\n\tStyleColor memoryPageInUse;\n\tStyleColor memoryFreePage;\n\n\tStyleColor textAreaLabel_Normal;\n\tStyleColor textAreaLabel_Hot;\n\tStyleColor textAreaLabel_Active;\n\tStyleColor textAreaLabel_Disabled;\n\n\tStyleColor labelFontColorNormal;\n\tStyleColor labelFontColorDisabled;\n\n\tStyleColor textAreaSelectionColor;\n\tStyleColor karratColor;\n\n\tf32 txtAreaHeight;\n\tu32 textAreaFontSize;\n\tu32 textAreaLabelSize;\n};\n\nnamespace Imgui {\n\tstruct Point {\n\t\tfloat x;\n\t\tfloat y;\n\n\t\tinline Point(float _x = 0.0f, float _y = 0.0f) : x(_x), y(_y) { }\n\t};\n\n\tstruct Rect {\n\t\tf32 x;\n\t\tf32 y;\n\t\tf32 w;\n\t\tf32 h;\n\n\t\tinline Rect(f32 _x = 0.0f, f32 _y = 0.0f, f32 _w = 0.0f, f32 _h = 0.0f) :\n\t\t\tx(_x), y(_y), w(_w), h(_h) {}\n\n\t\tinline bool Contains(const Point& point) {\n\t\t\tif (point.x >= x && point.x <= x + w) {\n\t\t\t\tif (point.y >= y && point.y <= y + h) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tinline bool Contains(const Rect& rect, const Point& point) {\n\t\tif (point.x >= rect.x && point.x <= rect.x + rect.w) {\n\t\t\tif (point.y >= rect.y && point.y <= rect.y + rect.h) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tinline bool Intersects(const Rect& r1, const Rect& r2) {\n\t\treturn !(r1.x + r1.w < r2.x || r1.y + r1.h < r2.y || r1.x > r2.x + r2.w || r1.y > r2.y + r2.h);\n\t}\n\n\tvoid Initialize(u32 interfaceFont, u32 widgetFont, u32 labelFont);\n\tvoid Shutdown();\n\tvoid BeginFrame(float dpi, const struct StyleSheet& style);\n\tbool EndFrame(u32 screenWidth, u32 screenHeight); // Returns true if processed kbd this frame\n\tvoid TickFrame(float deltaTime);\n\n\tvoid VirtualKeyWasPressed();\n\tvoid SetFakeShiftToggle(bool val);\n\tbool GetFakeShiftToggle();\n\tvoid SetFakeCapsToggle(bool val);\n\tbool GetFakeCapsToggle();\n\tvoid SetFakeControlToggle(bool val);\n\tbool GetFakeControlToggle();\n\n\tvoid SetFakeLeftPressed(bool val);\n\tbool GetFakeLeftPressed();\n\tvoid SetFakeRightPressed(bool val);\n\tbool GetFakeRightPressed();\n\n\tfloat Split(const Rect& screenPos, bool horizontal, float minSplitterHeight, float normalizedDivider);\n\tRect SplitFirstArea(const Rect& screenPos, bool horizontal, float splitter);\n\tRect SplitSecondArea(const Rect& screenPos, bool horizontal, float splitter);\n\t\n\tinline float HSplit(const Rect& screenPos, float minSplitterHeight, float normalizedDivider) {\n\t\treturn Split(screenPos, true, minSplitterHeight, normalizedDivider);\n\t}\n\tinline Rect HSplitFirstArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitFirstArea(screenPos, true, splitter);\n\t}\n\tinline Rect HSplitSecondArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitSecondArea(screenPos, true, splitter);\n\t}\n\n\tinline float VSplit(const Rect& screenPos, float minSplitterWidth, float normalizedDivider) {\n\t\treturn Split(screenPos, false, minSplitterWidth, normalizedDivider);\n\t}\n\tinline Rect VSplitFirstArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitFirstArea(screenPos, false, splitter);\n\t}\n\tinline Rect VSplitSecondArea(const Rect& screenPos, float splitter) {\n\t\treturn SplitSecondArea(screenPos, false, splitter);\n\t}\n\n\tstruct HierarchyListItemResult { // Note: should be a bitmask\n\t\tbool activated;\n\t\tbool dragging;\n\t\tbool expanded;\n\t};\n\n\tstruct DeletableListItemResult {\n\t\tbool activated;\n\t\tbool deleted;\n\t};\n\n\tHierarchyListItemResult HierarchyListItem(const Rect& screenPos, const Rect& listARea, const char* name, f32 indent, bool evenOrOdd, bool selected, bool expanded, bool leaf);\n\tDeletableListItemResult DeletableListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top);\n\tbool UndoListItem(const Rect& screenPos, const Rect& scrollArea, const char* name, bool evenOrOdd, bool disabled, bool top);\n\tu32 Header(const Rect& screenPos, const char** options, u32 numOptions, u32 selectedOption);\n\t\n\ti32 FileMenu(const Rect& screenPos, const char** options, u32 numOptions, i32 selection, Imgui::Rect* outRect);\n\n\t// Will show an overlay next to the pointer. Drawn in EndFrame.\n\tvoid SetTooltipIcon(int codePoint);\n\n\tbool ToggleIcon(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, const char* hoverLabel);\n\n\tbool ToggleButton(const Rect& screenPos, u32 trueIcon, u32 falseIcon, bool state, bool disabled, const char* hoverLabel, const StyleColor& tint, StyleColor* iconTint = 0);\n\tbool FooterButton(const Rect& screenPos, u32 codePoint, const char* caption, const StyleColor& color);\n\tbool ClickArea(const Rect& screenPos);\n\t\n\tstruct HoldAreaDetails {\n\t\tbool wasActive;\n\t\tbool active;\n\t\tbool activated;\n\t\tvec2 mouseDown;\n\t\tfloat rememberF32OnClick;\n\t\tvec2 rememberVec2OnClick;\n\t};\n\tbool HoldArea(const Rect& screenPos, HoldAreaDetails* optDetails = 0, float* rememberOnClick = 0, const vec2* rememberVecOnClick = 0);\n\tbool SidebarButton(const Rect& screenPos, u32 codePoint, const char* caption, bool isActive, vec3* iconOverride = 0);\n\n\tvoid Icon(const Rect& screenPos, u32 iconSize, u32 codePoint, float r = 1.0f, float g = 1.0f, float b = 1.0f, float a = 1.0f);\n\ti32 Dummy();\n\n\tfloat FloatSlider(const Rect& screeenPos, float value);\n\n\tfloat ScrollBar(const Rect& screeenPos, float value, bool horizontal, float grabberHeight = 15.0f, bool handleScroll = false);\n\tbool HandleScroll(const Rect& scrollArea);\n\n\tinline float Slider(const Rect& screenPos, float value) {\n\t\treturn ScrollBar(screenPos, value, true, 3.0f, false);\n\t}\n\n\tinline float HScroll(const Rect& screenPos, float value, float grabberHeight = 15.0f, bool handleScroll = false) {\n\t\treturn ScrollBar(screenPos, value, true, grabberHeight, handleScroll);\n\t}\n\tinline float VScroll(const Rect& screenPos, float value, float grabberHeight = 15.0f, bool handleScroll = false) {\n\t\treturn ScrollBar(screenPos, value, false, grabberHeight, handleScroll);\n\t}\n\n\tDraw2D::Size Label(const Rect& screenPos, const char* text, bool disabled, bool measure = false, bool small = false, StyleColor* c = 0);\n\tDraw2D::Size MeasureLabel(const Rect& screenPos, const char* text, bool small = false);\n\n\tvec3 ImageBlock(const Rect& screenPos, const char* caption, u32 image, const Rect& sourceRectPixels, bool disabled);\n\n\tvoid ClearActiveTextAreas();\n\n\ti32 BeginComboBox(const Rect& screenPos, const char* name, u32 numOptions, i32 selectedOption, const char* label, bool reversed_like_backwards, bool disabled);\n\tvoid PushComboBoxItem(const char* itemName);\n\tvoid EndComboBox();\n\n\ti32 Timeline(const Rect& screenPos, u32 numFrames, i32 selectedFrame, float scroll);\n\n\ti32 BeginModalPopup(const Rect& screenPos, const Rect& activationArea, u32 numItems, bool reversed = false);\n\tvoid PushModalPopupItem(const char* item);\n\tbool EndModalPopup();\n\n\t// hsv ColorPicker(i32 id, const Rect& screenPos, const hsv& inColor); // This is private\n\thsv ColorPicker(const Rect& screenPos, const hsv& inColor); // Not modal\n\thsv ColorPickerButton(const Rect& screenPos, const hsv& inColor, bool disabled, const StyleColor& tint); // Picker is modal\n\n\tPoint GetPointer();\n\tPoint GetPrevPointer();\n\tPoint GetPointerDelta();\n\tbool GetPulse();\n\tbool PointerReleased();\n\tbool PointerPressed();\n\n\t// Returns the same pointer as the second argument (inputText) when the control is inactive or the text is being edited\n\t// returns a pointer to a new string when the edited text is commited. The returned string is valid until Imgui::EndFrame\n\tconst char* TextArea(const Rect& screenPos, const char* inputText, const char* label, \n\t\tbool disabled, bool fraction, bool integer, bool animated, bool interpolated, bool dirty);\n\n}\n\n#endif","#ifndef _H_WINDOW_\n#define _H_WINDOW_\n\n#ifndef WINDOW_HEAP_SIZE\n#define WINDOW_HEAP_SIZE (128 * 1024 * 1024)\n#endif\n\n#ifndef WINDOW_MAX_TOUCHES\n#define WINDOW_MAX_TOUCHES 5\n#endif\n\ntypedef unsigned int u32;\ntypedef int i32;\nstatic_assert (sizeof(u32) == 4, \"u32 should be a 4 byte type\");\nstatic_assert (sizeof(i32) == 4, \"i32 should be a 4 byte type\");\n\n#define KeyboardCodeLeftMouse         1  //  \n#define KeyboardCodeRightMouse        2  //  \n#define KeyboardCodeBackspace         3  //  Backspace\n#define KeyboardCodeMiddleMouse       4  //  \n#define KeyboardCodeReturn            5  //  Enter\n#define KeyboardCodeShift             6  //  Shift \n#define KeyboardCodeControl           7  //  Control key\n#define KeyboardCodeAlt               8  //  Alt key\n#define KeyboardCodeCapslock          9  //  Capslock\n#define KeyboardCodeEscape           10  //  Escape\n#define KeyboardCodeSpace            11  //  Spacebar\n#define KeyboardCodeLeft             12  //  Left arrow\n#define KeyboardCodeUp               13  //  Up arrow\n#define KeyboardCodeRight            14  //  Right arrow\n#define KeyboardCodeDown             15  //  Down arrow\n#define KeyboardCodeDelete           16  //  Delete key\n#define KeyboardCode0                17  //  Key 0\n#define KeyboardCode1                18  //  Key 1\n#define KeyboardCode2                19  //  Key 2\n#define KeyboardCode3                20  //  Key 3\n#define KeyboardCode4                21  //  Key 4\n#define KeyboardCode5                22  //  Key 5\n#define KeyboardCode6                23  //  Key 6\n#define KeyboardCode7                24  //  Key 7\n#define KeyboardCode8                25  //  Key 8\n#define KeyboardCode9                26  //  Key 9\n#define KeyboardCodeA                27  //  Key A\n#define KeyboardCodeB                28  //  Key B\n#define KeyboardCodeC                29  //  Key C\n#define KeyboardCodeD                30  //  Key D\n#define KeyboardCodeE                31  //  Key E\n#define KeyboardCodeF                32  //  Key F\n#define KeyboardCodeG                33  //  Key G\n#define KeyboardCodeH                34  //  Key H\n#define KeyboardCodeI                35  //  Key I\n#define KeyboardCodeJ                36  //  Key J\n#define KeyboardCodeK                37  //  Key K\n#define KeyboardCodeL                38  //  Key L\n#define KeyboardCodeM                39  //  Key M\n#define KeyboardCodeN                40  //  Key N\n#define KeyboardCodeO                41  //  Key O\n#define KeyboardCodeP                42  //  Key P\n#define KeyboardCodeQ                43  //  Key Q\n#define KeyboardCodeR                44  //  Key R\n#define KeyboardCodeS                45  //  Key S\n#define KeyboardCodeT                46  //  Key T\n#define KeyboardCodeU                47  //  Key U\n#define KeyboardCodeV                48  //  Key V\n#define KeyboardCodeW                49  //  Key W\n#define KeyboardCodeX                50  //  Key X\n#define KeyboardCodeY                51  //  Key Y\n#define KeyboardCodeZ                52  //  Key Z\n#define KeyboardCodeSemicolon        53  //  ;:\n#define KeyboardCodeColon            53  //  ;:\n#define KeyboardCodePlus             54  //  +=\n#define KeyboardCodeEquals           54  //  +=\n#define KeyboardCodeComma            55  //  ,<\n#define KeyboardCodeLess             55  //  ,<\n#define KeyboardCodeMinus            56  //  -_\n#define KeyboardCodeUnderscore       56  //  -_\n#define KeyboardCodePeriod           57  //  .>\n#define KeyboardCodeGreater          57  //  .>\n#define KeyboardCodeSlash            58  //  /?\n#define KeyboardCodeQuestionmark     58  //  /?\n#define KeyboardCodeTilde            59  //  ~`\n#define KeyboardCodeTick             59  //  ~`\n#define KeyboardCodeLBracket         60  //  [{\n#define KeyboardCodeLBrace           60  //  [{\n#define KeyboardCodeBackslash        61  //  \\|\n#define KeyboardCodeCarray           61  //  \\|\n#define KeyboardCodeRbracket         62  //  ]}\n#define KeyboardCodeRBrace           62  //  ]}\n#define KeyboardCodeQoute            63  //  \"'\n#define KeyboardCodeTab              64  //  Tab\n\nextern \"C\" u32 AsciiToScancode(char val);\nextern \"C\" char ScanCodeToAscii(u32 scanCode, bool shift);\n\nextern \"C\" bool KeyboardDown(u32 scanCode);\nextern \"C\" bool KeyboardPrevDown(u32 scanCode);\n\n\n// Queued keyboard input is hacked together (at best)\n// ConsumeKeyQueue will return a key code as long as there is queued input\n// ConsumeKeyQueue will return KeyboardCodeLeftMouse if there is no more input\n// ClearKeyQueue must be called once a frame to reset the internal queue pointer\nextern \"C\" void PushKey(u32 scanCode);\nextern \"C\" u32 ConsumeKeyQueue();\nextern \"C\" void ClearKeyQueue();\n\nextern \"C\" void WriteClipboard(const char* string); \nextern \"C\" char* ReadClipboard(); \n\ninline bool KeyboardUp(u32 scanCode) {\n    return !KeyboardDown(scanCode);\n}\n\ninline bool KeyboardPrevUp(u32 scanCode) {\n    return !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardPressed(u32 scanCode) {\n    return KeyboardDown(scanCode) && !KeyboardPrevDown(scanCode);\n}\n\ninline bool KeyboardReleased(u32 scanCode) {\n    return !KeyboardDown(scanCode) && KeyboardPrevDown(scanCode);\n}\n\n// Mouse API\n#define MouseButtonLeft         KeyboardCodeLeftMouse\n#define MouseButtonMiddle       KeyboardCodeMiddleMouse\n#define MouseButtonRight        KeyboardCodeRightMouse\n\nextern \"C\" u32 MouseGetX();\nextern \"C\" u32 MouseGetY();\nextern \"C\" i32 MouseGetScroll();\nextern \"C\" bool MouseDown(u32 button);\n\nextern \"C\" u32 MousePrevX();\nextern \"C\" u32 MousePrevY();\nextern \"C\" i32 MousePrevScroll();\nextern \"C\" bool MousePrevDown(u32 button);\n\ninline bool MouseUp(u32 button) {\n    return !MouseDown(button);\n}\n\ninline bool MousePrevUp(u32 button) {\n    return !MousePrevDown(button);\n}\n\ninline bool MousePressed(u32 button) {\n    return MouseDown(button) && !MousePrevDown(button);\n}\n\ninline bool MouseReleased(u32 button) {\n    bool debug_1 = !MouseDown(button);\n    bool debug_2 = MousePrevDown(button);\n    return debug_1 && debug_2;\n}\n\ninline i32 MouseDeltaX() {\n    i32 thisX = MouseGetX();\n    i32 lastX = MousePrevX();\n    return thisX - lastX;\n}\n\ninline i32 MouseDeltaY() {\n    i32 thisY = MouseGetY();\n    i32 lastY = MousePrevY();\n    return thisY - lastY;\n}\n\n// Touch API\nextern \"C\" u32 TouchGetMaxContacts();\nextern \"C\" u32 TouchGetNumContacts(); // Misleading, touch array is sparse. Always loop to max.\n\nextern \"C\" u32 TouchGetX(u32 touchIndex);\nextern \"C\" u32 TouchGetY(u32 touchIndex);\nextern \"C\" bool TouchIsActive(u32 touchIndex);\n\nextern \"C\" u32 TouchGetPrevX(u32 touchIndex);\nextern \"C\" u32 TouchGetPrevY(u32 touchIndex);\nextern \"C\" bool TouchWasActive(u32 touchIndex);\n\ninline bool TouchPressed(u32 touchIndex) {\n    return TouchIsActive(touchIndex) && !TouchWasActive(touchIndex);\n}\n\ninline bool TouchReleased(u32 touchIndex) {\n    return !TouchIsActive(touchIndex) && TouchWasActive(touchIndex);\n}\n\ninline i32 TouchDeltaX(u32 touchIndex) {\n    if (!TouchIsActive(touchIndex) || !TouchWasActive(touchIndex)) {\n        return 0;\n    }\n    i32 thisX = TouchGetX(touchIndex);\n    i32 lastX = TouchGetPrevX(touchIndex);\n    return thisX - lastX;\n}\n\ninline i32 TouchDeltaY(u32 touchIndex) {\n    if (!TouchIsActive(touchIndex) || !TouchWasActive(touchIndex)) {\n        return 0;\n    }\n    i32 thisY = TouchGetY(touchIndex);\n    i32 lastY = TouchGetPrevY(touchIndex);\n    return thisY - lastY;\n}\n\nextern \"C\" void WindowOpenURL(const char* url);\n\n// Window API\n// The following functions need to be declared. Initialize returns the userdata pointer that is passed to the other functions.\n/*#define WasmExport __attribute__ (( visibility( \"default\" ) )) extern \"C\"\nWasmExport void* Initialize();\nWasmExport void Update(float dt, void* userData);\nWasmExport void Render(unsigned int x, unsigned int y, unsigned int w, unsigned int h, float dpi, void* userData);\nWasmExport void Shutdown(void* userData);*/\n\n// NOTE: Needs a \"Get Pointer\" API, similar to what i build in the animator imgui sample\n// a pointer is either a touch or a mouse, whatever happened first.\n\nextern \"C\" void WindowUpdateTitle(const char* newTitle);\n\n#endif","#ifndef _H_COLOR_\n#define _H_COLOR_\n\ntypedef struct {\n    double r;       // a fraction between 0 and 1\n    double g;       // a fraction between 0 and 1\n    double b;       // a fraction between 0 and 1\n} rgb;\n\ntypedef struct {\n    double h;       // angle in degrees\n    double s;       // a fraction between 0 and 1\n    double v;       // a fraction between 0 and 1\n} hsv;\n\ninline bool compare(const rgb& a, const rgb& b) {\n    unsigned char ar = a.r * 255.0f;\n    unsigned char ag = a.g * 255.0f;\n    unsigned char ab = a.b * 255.0f;\n\n    unsigned char br = b.r * 255.0f;\n    unsigned char bg = b.g * 255.0f;\n    unsigned char bb = b.b * 255.0f;\n\n    return ar == br && ab == bb && ag == bg;\n}\n\ninline rgb lerp(const rgb& a, const rgb& b, const float t) {\n    rgb result;\n    result.r = a.r + (b.r - a.r) * t;\n    result.g = a.g + (b.g - a.g) * t;\n    result.b = a.b + (b.b - a.b) * t;\n    if (result.r < 0.0f) {\n        result.r = 0.0f;\n    }\n    if (result.g < 0.0f) {\n        result.g = 0.0f;\n    }\n    if (result.r > 1.0f) {\n        result.r = 1.0f;\n    }\n    if (result.g > 1.0f) {\n        result.g = 1.0f;\n    }\n    if (result.b < 0.0f) {\n        result.b = 0.0f;\n    }\n    if (result.b > 1.0f) {\n        result.b = 1.0f;\n    }\n    return result;\n}\n\ninline hsv lerp(const hsv& a, const hsv& b, const float t) {\n    hsv result;\n    result.h = a.h + (b.h - a.h) * t;\n    result.s = a.s + (b.s - a.s) * t;\n    result.v = a.v + (b.v - a.v) * t;\n    if (result.s < 0.0f) {\n        result.s = 0.0f;\n    }\n    if (result.v < 0.0f) {\n        result.v = 0.0f;\n    }\n    if (result.s > 1.0f) {\n        result.s = 1.0f;\n    }\n    if (result.v > 1.0f) {\n        result.v = 1.0f;\n    }\n    if (result.h < 0.0f) {\n        result.h = 0.0f;\n    }\n    if (result.h > 360.0f) {\n        result.h = 360.0f;\n    }\n    return result;\n}\n\ninline hsv rgb2hsv(const rgb& in)\n{\n    hsv         out;\n    double      min, max, delta;\n\n    min = in.r < in.g ? in.r : in.g;\n    min = min < in.b ? min : in.b;\n\n    max = in.r > in.g ? in.r : in.g;\n    max = max > in.b ? max : in.b;\n\n    out.v = max;                                // v\n    delta = max - min;\n    if (delta < 0.00001)\n    {\n        out.s = 0;\n        out.h = 0; // undefined, maybe nan?\n        return out;\n    }\n    if (max > 0.0) { // NOTE: if Max is == 0, this divide would cause a crash\n        out.s = (delta / max);                  // s\n    }\n    else {\n        // if max is 0, then r = g = b = 0              \n        // s = 0, h is undefined\n        out.s = 0.0;\n        out.h = 0.0f;                            // its now undefined\n        return out;\n    }\n    if (in.r >= max)                           // > is bogus, just keeps compilor happy\n        out.h = (in.g - in.b) / delta;        // between yellow & magenta\n    else\n        if (in.g >= max)\n            out.h = 2.0 + (in.b - in.r) / delta;  // between cyan & yellow\n        else\n            out.h = 4.0 + (in.r - in.g) / delta;  // between magenta & cyan\n\n    out.h *= 60.0;                              // degrees\n\n    if (out.h < 0.0)\n        out.h += 360.0;\n\n    return out;\n}\n\n\ninline rgb hsv2rgb(const hsv& in)\n{\n    double      hh, p, q, t, ff;\n    long        i;\n    rgb         out;\n\n    if (in.s <= 0.0) {       // < is bogus, just shuts up warnings\n        out.r = in.v;\n        out.g = in.v;\n        out.b = in.v;\n        return out;\n    }\n    hh = in.h;\n    if (hh >= 360.0) hh = 0.0;\n    hh /= 60.0;\n    i = (long)hh;\n    ff = hh - i;\n    p = in.v * (1.0 - in.s);\n    q = in.v * (1.0 - (in.s * ff));\n    t = in.v * (1.0 - (in.s * (1.0 - ff)));\n\n    switch (i) {\n    case 0:\n        out.r = in.v;\n        out.g = t;\n        out.b = p;\n        break;\n    case 1:\n        out.r = q;\n        out.g = in.v;\n        out.b = p;\n        break;\n    case 2:\n        out.r = p;\n        out.g = in.v;\n        out.b = t;\n        break;\n\n    case 3:\n        out.r = p;\n        out.g = q;\n        out.b = in.v;\n        break;\n    case 4:\n        out.r = t;\n        out.g = p;\n        out.b = in.v;\n        break;\n    case 5:\n    default:\n        out.r = in.v;\n        out.g = p;\n        out.b = q;\n        break;\n    }\n    return out;\n}\n\n#endif","#include \"Node2D.h\"\n\nvoid Animation::ReleaseMemory() {\n\tif (name != 0) {\n\t\tMemRelease(name);\n\t\tname = 0;\n\t}\n\n\tif (tracks != 0) {\n\t\tTrack* track = tracks;\n\t\twhile (track != 0) {\n\t\t\tTrack* to_delete_track = track;\n\t\t\tif (to_delete_track->frames != 0) {\n\t\t\t\tMemRelease(to_delete_track->frames);\n\t\t\t\tto_delete_track->frames = 0;\n\t\t\t\tto_delete_track->frameCount = 0;\n\t\t\t}\n\t\t\tMemRelease(to_delete_track);\n\t\t\ttrack = track->next;\n\t\t}\n\t\ttracks = 0;\n\t\tnumTracks = 0;\n\t}\n}\n\nu32 CountDescendants(Node2D* node) {\n\tif (node == 0) {\n\t\treturn 0;\n\t}\n\n\tu32 result = 0;\n\n\tNode2D* itr = node;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tif (itr != node) { // Process\n\t\t\tresult += 1;\n\t\t}\n\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\twhile (itr->next == 0) {\n\t\t\t\tif (itr == node) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr = itr->parent;\n\t\t\t}\n\t\t\tif (itr == node) {\n\t\t\t\ttraversing = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titr = itr->next;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvoid ForEachNode(Node2D* root, NodeVisitor callback, void* userData) {\n\tNode2D* itr = root;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tcallback(itr, userData);\n\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\twhile (itr->next == 0) {\n\t\t\t\tif (itr == root) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titr = itr->parent;\n\t\t\t}\n\t\t\tif (itr == root) { \n\t\t\t\ttraversing = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titr = itr->next;\n\t\t}\n\t}\n}\n\nvoid RecursivleyDestroyNode(Node2D* node) {\n\t// Unhook from hierarchy\n\tif (node->parent != 0) {\n\t\tRemoveChild(*node->parent, *node);\n\t}\n\n\t// Iterate subtree and release all resources\n\n\tNode2D* itr = node;\n\tbool traversing = true;\n\twhile (traversing) {\n\t\tif (itr->firstChild) {\n\t\t\titr = itr->firstChild;\n\t\t}\n\t\telse {\n\t\t\t// At the bottom of the tree. This node has no children. \n\t\t\tNode2D* parent = itr->parent;\n\t\t\tNode2D* next = itr->next;\n\n\t\t\tif (parent != 0) {\n\t\t\t\tRemoveChild(*parent, *itr);\n\t\t\t}\n\t\t\tPlatformAssert(itr->parent == 0, __LOCATION__);\n\t\t\tPlatformAssert(itr->firstChild == 0, __LOCATION__);\n\n\t\t\t{ // Release memory\n\t\t\t\tif (itr->name != 0) {\n\t\t\t\t\tMemRelease(itr->name);\n\t\t\t\t\titr->name = 0;\n\t\t\t\t}\n\n\t\t\t\tif (itr == node) {\n\t\t\t\t\ttraversing = false;\n\t\t\t\t}\n\t\t\t\tMemRelease(itr);\n\t\t\t}\n\n\t\t\tif (next != 0) {\n\t\t\t\titr = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\titr = parent;\n\t\t\t}\n\t\t}\n\t}\n}\n\nNode2D* GetLastChild(Node2D& node) {\n\tif (node.firstChild == 0) {\n\t\treturn 0;\n\t}\n\tNode2D* iter = node.firstChild;\n\twhile (iter->next != 0) {\n\t\titer = iter->next;\n\t}\n\treturn iter;\n}\n\nNode2D* GetChildById(Node2D& node, u32 uid) {\n\tif (node.firstChild == 0 || uid == 0) {\n\t\treturn 0;\n\t}\n\n\tNode2D* iter = node.firstChild;\n\twhile (iter->next != 0) {\n\t\tif (iter->uid == uid) {\n\t\t\tbreak;\n\t\t}\n\t\titer = iter->next;\n\t}\n\n\treturn iter;\n}\n\nbool RemoveChild(Node2D& parent, Node2D& child) {\n\tif (parent.firstChild == 0) {\n\t\treturn false;\n\t}\n\n\tNode2D* iter = parent.firstChild;\n\tNode2D* prev = 0;\n\twhile (iter != 0) {\n\t\tif (iter == &child) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = iter;\n\t\titer = iter->next;\n\t}\n\n\tif (iter == 0) {\n\t\treturn false;\n\t}\n\n\tif (prev != 0) {\n\t\tprev->next = iter->next;\n\t}\n\telse {\n\t\tparent.firstChild = iter->next;\n\t}\n\n\tchild.parent = 0;\n\tchild.depth = 0;\n\tchild.next = 0;\n\n\treturn true;\n}\n\nbool AddChild(Node2D& parent, Node2D& child) {\n\tNode2D* lastChild = GetLastChild(parent);\n\n\tif (lastChild != 0) {\n\t\tlastChild->next = &child;\n\t\tchild.next = 0;\n\t}\n\telse {\n\t\tchild.next = parent.firstChild;\n\t\tparent.firstChild = &child;\n\t}\n\tchild.parent = &parent;\n\tchild.depth = parent.depth + 1;\n\n\treturn true;\n}\n\nbool AddChild(Node2D& parent, Node2D& child, u32 lastSibling) {\n\tNode2D* prevNode = GetChildById(parent, lastSibling);\n\n\tif (prevNode != 0) {\n\t\tchild.next = prevNode->next;\n\t\tprevNode->next = &child;\n\t}\n\telse {\n\t\tchild.next = parent.firstChild;\n\t\tparent.firstChild = &child;\n\t}\n\tchild.parent = &parent;\n\tchild.depth = parent.depth + 1;\n\n\treturn true;\n}\n\nvoid SetParent(Node2D* parent, Node2D& child) {\n\tif (child.parent != 0) {\n\t\tbool removed = RemoveChild(*child.parent, child);\n\t\tPlatformAssert(removed, __LOCATION__);\n\t}\n\n\tchild.parent = parent;\n\tchild.depth = 0;\n\tif (parent != 0) {\n\t\tchild.depth = parent->depth + 1;\n\t}\n\n\tif (parent != 0) {\n\t\tAddChild(*child.parent, child);\n\n\t\tu32 parentDepth = 0;\n\t\tNode2D* iter = parent;\n\t\twhile (iter != 0) {\n\t\t\tparentDepth += 1;\n\t\t\titer = iter->parent;\n\t\t}\n\t\tparent->depth = parentDepth == 0? 0 : parentDepth - 1;\n\t\tForEachNode(parent, [](Node2D* node, void* userData) {\n\t\t\tif (node != userData) {\n\t\t\t\tnode->depth = node->parent->depth + 1;\n\t\t\t}\n\t\t}, parent);\n\t}\n}\n\nvoid SetParent(Node2D* parent, Node2D& child, u32 lastSibling) {\n\tif (child.parent != 0) {\n\t\tbool removed = RemoveChild(*child.parent, child);\n\t\tPlatformAssert(removed, __LOCATION__);\n\t}\n\n\tchild.parent = parent;\n\tchild.depth = 0;\n\n\tif (parent != 0) {\n\t\tAddChild(*child.parent, child, lastSibling);\n\t\tchild.depth = parent->depth + 1;\n\n\t\tu32 parentDepth = 0;\n\t\tNode2D* iter = parent;\n\t\twhile (iter != 0) {\n\t\t\tparentDepth += 1;\n\t\t\titer = iter->parent;\n\t\t}\n\t\tparent->depth = parentDepth == 0 ? 0 : parentDepth - 1;\n\t\tForEachNode(parent, [](Node2D* node, void* userData) {\n\t\t\tif (node != userData) {\n\t\t\t\tnode->depth = node->parent->depth + 1;\n\t\t\t}\n\t\t}, parent);\n\t}\n}\n\nvoid SetName(Node2D& node, const char* name) {\n\tu32 len = 0;\n\tif (name != 0) {\n\t\tfor (len = 0; name[len] != 0; ++len);\n\t}\n\n\tif (len > node.nameCapacity) {\n\t\twhile (len > node.nameCapacity) {\n\t\t\tnode.nameCapacity = node.nameCapacity * 2;\n\t\t}\n\t\tMemRelease(node.name);\n\t\tnode.name = (char*)MemAlloc(node.nameCapacity + 1);\n\t\tMemClear(node.name, node.nameCapacity + 1);\n\t\tnode.nameLength = 0;\n\t}\n\n\tfor (u32 i = 0; i < len; ++i) {\n\t\tnode.name[i] = name[i];\n\t}\n\tnode.name[len] = 0;\n\tnode.nameLength = len;\n}","#include \"Document.h\"\n#include \"../debt/stb_sprintf.h\"\n#include \"../platform/memory.h\"\n#include \"../platform/loader.h\"\n#include \"../framework/draw2d.h\"\n\n#define NODE_TRANSFORM_DELTA 0.00001f\n\nNode2D* Document::Sorted(Node2D* iter) {\n    if (iter == 0) {\n        Node2D* sortedList = DepthFirst(0);\n        sortedList->sortedNext = 0;\n        sortedList->sortedPrev = 0;\n        \n        sortedList = DepthFirst(sortedList); // Skip the root node\n        if (sortedList != 0) {\n            sortedList->sortedNext = 0;\n            sortedList->sortedPrev = 0;\n        }\n\n        for (Node2D* iter = sortedList; iter != 0; iter = DepthFirst(iter)) {\n            for (Node2D* insertPtr = sortedList; insertPtr != 0; insertPtr = insertPtr->sortedNext) {\n                if (iter == insertPtr) {\n                    continue;\n                }\n                if (insertPtr->sortIndex > iter->sortIndex) { // Add on left\n                    if (insertPtr->sortedPrev != 0) {\n                        insertPtr->sortedPrev->sortedNext = iter;\n                    }\n                    iter->sortedPrev = insertPtr->sortedPrev;\n\n                    iter->sortedNext = insertPtr;\n                    insertPtr->sortedPrev = iter;\n                    break;\n                }\n                if (insertPtr->sortedNext == 0) { // Looking at tail\n                    insertPtr->sortedNext = iter;\n                    iter->sortedNext = 0;\n                    iter->sortedPrev = insertPtr;\n                    break;\n                }\n            }\n            while (sortedList->sortedPrev != 0) {\n                sortedList = sortedList->sortedPrev;\n            }\n        }\n\n        return sortedList;\n    }\n\n    return iter->sortedNext;\n}\n\nNode2D* Document::SortedVisibleOnly(Node2D* iter) {\n    if (iter == 0) {\n        Node2D* rootIter = DepthFirst(0);\n        rootIter->sortedNext = 0;\n        rootIter->sortedPrev = 0;\n\n        Node2D* sortedList = 0;\n\n        while (rootIter != 0) {\n            rootIter = DepthFirst(rootIter); \n            if (rootIter == 0) {\n                break;\n            }\n            \n            rootIter->sortedNext = 0;\n            rootIter->sortedPrev = 0;\n\n            if (rootIter->sprite.resourceUID != 0 && rootIter->sprite.visible) {\n                sortedList = rootIter;\n                break;\n            }\n        }\n\n        for (Node2D* iter = sortedList; iter != 0; iter = DepthFirst(iter)) {\n            for (Node2D* insertPtr = sortedList; insertPtr != 0; insertPtr = insertPtr->sortedNext) {\n                if (iter == insertPtr) {\n                    continue;\n                }\n                if (iter->sprite.resourceUID == 0 || !iter->sprite.visible) {\n                    continue;\n                }\n                if (insertPtr->sortIndex > iter->sortIndex) { // Add on left\n                    if (insertPtr->sortedPrev != 0) {\n                        insertPtr->sortedPrev->sortedNext = iter;\n                    }\n                    iter->sortedPrev = insertPtr->sortedPrev;\n\n                    iter->sortedNext = insertPtr;\n                    insertPtr->sortedPrev = iter;\n                    break;\n                }\n                if (insertPtr->sortedNext == 0) { // Looking at tail\n                    insertPtr->sortedNext = iter;\n                    iter->sortedNext = 0;\n                    iter->sortedPrev = insertPtr;\n                    break;\n                }\n            }\n            while (sortedList->sortedPrev != 0) {\n                sortedList = sortedList->sortedPrev;\n            }\n        }\n\n        return sortedList;\n    }\n\n    return iter->sortedNext;\n}\n\n\nNode2D* Document::DepthFirst(Node2D* iter) {\n    if (iter == 0) {\n        return rootNode;\n    }\n\n    if (iter->firstChild) {\n        iter = iter->firstChild;\n    }\n    else {\n        while (iter->next == 0) {\n            if (iter == rootNode) { // This should be iteration root, not document root\n                return 0;\n            }\n            iter = iter->parent;\n        }\n        // This isn't 100% accurate, should stop if iter == root, but i don't have the iteration root\n        iter = iter->next;\n    }\n\n    return iter;\n}\n\nNode2D* Document::DepthFirstExpandedOnly(Node2D* iter) {\n    if (iter == 0) {\n        return rootNode;\n    }\n\n    bool shouldDescend = iter->firstChild && iter->uiExpanded;\n    if (iter == rootNode) {\n        shouldDescend = true;\n    }\n\n    if (shouldDescend) {\n        iter = iter->firstChild;\n    }\n    else {\n        while (iter->next == 0) {\n            if (iter == rootNode) { // This should be iteration root, not document root\n                return 0;\n            }\n            iter = iter->parent;\n        }\n        // This isn't 100% accurate, should stop if iter == root, but i don't have the iteration root\n        iter = iter->next;\n    }\n\n    return iter;\n}\n\nAnimation* Document::FindAnimationById(u32 animId) {\n    if (animId == 0) {\n        return 0;\n    }\n\n    Animation* iter = allAnimations;\n    while (iter != 0) {\n        if (iter->uid == animId) {\n            return iter;\n        }\n        iter = iter->next;\n    }\n\n    return 0;\n}\n\nResource* Document::FindResourceById(u32 resourceId) {\n    if (resourceId == 0) {\n        return 0;\n    }\n\n    Resource* iter = resources;\n    while (iter != 0) {\n        if (iter->uid == resourceId) {\n            return iter;\n        }\n        iter = iter->next;\n    }\n\n    return 0;\n}\n\n\nNode2D* Document::FindNodeById(u32 nodeId) { // Non intrusive, non extra memory DFS: https://stackoverflow.com/questions/5278580/non-recursive-depth-first-search-algorithm\n    if (nodeId == 0) {\n        return 0;\n    }\n    \n    Node2D* itr = rootNode;\n    bool traversing = true;\n    while (traversing) {\n        if (itr != rootNode) { // Process\n            if (itr->uid == nodeId) {\n                return itr;\n            }\n        }\n\n        if (itr->firstChild) {\n            itr = itr->firstChild;\n        }\n        else {\n            while (itr->next == 0) {\n                if (itr == rootNode) {\n                    traversing = false;\n                    break;\n                }\n                itr = itr->parent;\n            }\n            if (itr == rootNode) {\n                traversing = false;\n                break;\n            }\n            itr = itr->next;\n        }\n    }\n\n    return 0;\n}\n\nstatic void _RecursivleyDestroyNodeIfItHasNoReferences(Node2D* node) {\n    while (node->firstChild != 0) {\n        Node2D* lastChild = GetLastChild(*node);\n        PlatformAssert(lastChild->next == 0, __LOCATION__);\n        _RecursivleyDestroyNodeIfItHasNoReferences(lastChild);\n    }\n\n    SetParent(0, *node);\n    if (node->name != 0) {\n        MemRelease(node->name);\n        node->name = 0;\n    }\n\n    MemRelease(node);\n}\n\nbool RecursivleyDestroyNodeIfItHasNoReferences(Node2D* node) {\n    if (node == 0) {\n        return false;\n    }\n\n    if (node->refCount == 0) {\n        ForEachNode(node, [](Node2D* childNode, void* userData) {\n            PlatformAssert(childNode->refCount == 0, __LOCATION__);\n            }, 0);\n\n        _RecursivleyDestroyNodeIfItHasNoReferences(node);\n\n        return true;\n    }\n\n    return false;\n}\n\nu32 WriteNode(Node2D* node, void* data, u32 writer) {\n    u32* pu = (u32*)data;\n    i32* ps = (i32*)data;\n    f32* pf = (f32*)data;\n\n    pu[writer++] = node->uid;\n    pu[writer++] = node->parent != 0? node->parent->uid : 0;\n    pu[writer++] = node->firstChild == 0 ? 0 : node->firstChild->uid;\n    pu[writer++] = node->next == 0 ? 0 : node->next->uid;\n    pu[writer++] = 0; // name offset\n    pu[writer++] = 0; // name offset\n    pf[writer++] = node->position.x;\n    pf[writer++] = node->position.y;\n    pf[writer++] = node->rotationAngles;\n    pf[writer++] = node->scale.x;\n    pf[writer++] = node->scale.y;\n    pu[writer++] = node->sprite.resourceUID;\n    pf[writer++] = node->sprite.tintR;\n    pf[writer++] = node->sprite.tintG;\n    pf[writer++] = node->sprite.tintB;\n    pf[writer++] = node->sprite.tintA;\n    pu[writer++] = node->sprite.visible;\n    pf[writer++] = node->sprite.sourceX;\n    pf[writer++] = node->sprite.sourceY;\n    pf[writer++] = node->sprite.sourceW;\n    pf[writer++] = node->sprite.sourceH;\n    pf[writer++] = node->sprite.pivotX;\n    pf[writer++] = node->sprite.pivotY;\n    ps[writer++] = node->sortIndex;\n\n    return writer;\n}\n\nu32 WriteResource(Resource* r, void* data, u32 writer) {\n    u32* pu = (u32*)data;\n    i32* ps = (i32*)data;\n    f32* pf = (f32*)data;\n\n    pu[writer++] = r->uid;\n    pu[writer++] = r->size;\n    pu[writer++] = 0; // name\n    pu[writer++] = 0; // name\n    pu[writer++] = r->width;\n    pu[writer++] = r->height;\n    pu[writer++] = 0; // data\n    pu[writer++] = 0; // data\n\n    return writer;\n}\n\nu32 WriteAnimation(Animation* a, void* data, u32 writer) {\n    u32* pu = (u32*)data;\n    i32* ps = (i32*)data;\n    f32* pf = (f32*)data;\n\n    u32 numTracks = 0;\n    for (Track* t = a->tracks; t != 0; t = t->next) {\n        if (t->avtive) {\n            numTracks++;\n        }\n    }\n\n    pu[writer++] = a->uid;\n    pu[writer++] = (u32)(a->loop == AnimationLoopMode::Looping ? 1 : 0);\n    pu[writer++] = a->frameRate;\n    pu[writer++] = a->frameCount; \n    pu[writer++] = numTracks;\n    pu[writer++] = 1234; // Padding\n    pu[writer++] = 0; // name\n    pu[writer++] = 0; // name\n    pu[writer++] = 0; // first track\n    pu[writer++] = 0; // first track\n\n    return writer;\n}\n\nu32 WriteTrack(Track* t, void* data, u32 writer, u32 animUid) {\n    u32* pu = (u32*)data;\n    pu[writer++] = animUid;\n    pu[writer++] = t->targetNode == 0 ? 0 : t->targetNode;\n    pu[writer++] = (u32)t->targetProp;\n    pu[writer++] = t->numKeyFrames;\n    pu[writer++] = 0; // Frame offset\n    pu[writer++] = 0; // It's a pointer\n    pu[writer++] = 0; // Track offset\n    pu[writer++] = 0; // It's a pointer\n    return writer;\n}\n\nu32 WriteFrame(Frame* f, void* data, u32 writer, u32 index) {\n    u32* pu = (u32*)data;\n    pu[writer++] = index;\n    pu[writer++] = f->uValue;\n    pu[writer++] = 1234;\n    pu[writer++] = (u32)f->interp;\n    return writer;\n}\n\nu32 WriteString(void* data, const char* str, u32 writer) {\n    u8* pu = (u8*)data;\n    u32 char_writer = writer * 4;\n    for (const char* iter = str; *iter != 0; ++iter) {\n        pu[char_writer++] = *iter;\n    }\n    while (char_writer % 4 != 0) {\n        pu[char_writer++] = 0;\n    }\n    return char_writer / 4;\n}\n\nu32 WriteTerminatedString(void* data, const char* str, u32 writer) {\n    u8* pu = (u8*)data;\n    u32 char_writer = writer * 4;\n    for (const char* iter = str; *iter != 0; ++iter) {\n        pu[char_writer++] = *iter;\n    }\n\n    // Write a null char\n    pu[char_writer++] = 0;\n    while (char_writer % 4 != 0) {\n        pu[char_writer++] = 0;\n    }\n\n    return char_writer / 4;\n}\n\nu32 WriteNonPaddedString(void* data, const char* str, u32 writer) {\n    u8* pu = (u8*)data;\n    u32 char_writer = writer * 4;\n    for (const char* iter = str; *iter != 0; ++iter) {\n        pu[char_writer++] = *iter;\n    }\n    return char_writer - (writer * 4);\n}\n\nu32 WriteBlob(void* data, void* blob, u32 blobBytes, u32 writer) {\n    u8* pu = (u8*)data;\n    u32 char_writer = writer * 4;\n\n    u8* blobIter = (u8*)blob;\n    for (u32 i = 0; i < blobBytes; ++i) {\n        pu[char_writer++] = *blobIter;\n        blobIter += 1;\n    }\n\n    while (char_writer % 4 != 0) {\n        pu[char_writer++] = 0;\n    }\n\n    return char_writer / 4;\n}\n\nu32 Document::SaveInto(void* dest) {\n    u32 totalTracks = 0;\n    u32 totalFrames = 0;\n    u32 totalAnimations = 0;\n    for (Animation* anim = allAnimations; anim != 0; anim = anim->next) {\n        totalAnimations += 1;\n        for (Track* track = anim->tracks; track != 0; track = track->next) {\n            if (track->avtive) {\n                totalTracks += 1;\n                totalFrames += track->numKeyFrames;\n            }\n        }\n    }\n\n    u32* pu = (u32*)dest;\n    i32* ps = (i32*)dest;\n\n    u32 writer = 0;\n\n    writer = WriteTerminatedString(dest, \"Keyframe Studio\", writer);\n\n    pu[writer++] = numNodes + 1;\n    pu[writer++] = numResources;\n    pu[writer++] = totalAnimations;\n    pu[writer++] = totalTracks;\n    pu[writer++] = nodeUidGenerator;\n    pu[writer++] = resourceUidGenerator;\n    pu[writer++] = animationUidGenerator;\n    pu[writer++] = 1234; // Padding\n\n    u32 offsets = writer;\n    writer += 2; // first node\n    writer += 2; // first resource\n    writer += 2; // first anim\n    writer += 2; // first track\n    writer += 2; // first frame\n    writer += 2; // first resourceData\n\n    pu[offsets++] = writer * 4; // Record first node offset\n    pu[offsets++] = 0; // It's a pointer\n\n    u32 first_node_name_offset = writer + 4;\n    for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n        writer = WriteNode(iter, dest, writer);\n    }\n\n    pu[offsets++] = writer * 4; // Record first resource offset\n    pu[offsets++] = 0; // It's a pointer\n\n    u32 first_resource_data_offset = writer + 6;\n    u32 first_resource_name_offset = writer + 2;\n    for (Resource* iter = resources; iter != 0; iter = iter->next) {\n        writer = WriteResource(iter, dest, writer);\n    }\n\n    pu[offsets++] = writer * 4; // Record first animation offset\n    pu[offsets++] = 0; // It's a pointer\n\n    u32 anim_track_offset = writer + 8;\n    u32 first_anim_name_offset = writer + 6;\n    for (Animation* iter = allAnimations; iter != 0; iter = iter->next) {\n        writer = WriteAnimation(iter, dest, writer);\n    }\n    u32 animTrackStride = (6 * 4 + 2 * 8); // Sizeof anim, not track\n\n    pu[offsets++] = writer * 4; // Record first track offset\n    pu[offsets++] = 0; // It's a pointer\n\n    u32 first_track_for_frames = 0;\n    for (Animation* anim = allAnimations; anim != 0; anim = anim->next) {\n        if (first_track_for_frames == 0) {\n            first_track_for_frames = (writer + 4);\n        }\n\n        pu[anim_track_offset] = writer * 4;\n        anim_track_offset += animTrackStride / 4;\n\n        for (Track* track = anim->tracks; track != 0; track = track->next) {\n            if (!track->avtive) {\n                continue;\n            }\n            writer = WriteTrack(track, dest, writer, anim->uid);\n            if (track->next != 0 && track->next->avtive) {\n                pu[writer - 2] = writer * 4;\n            }\n            else{\n                pu[writer - 2] = 0;\n            }\n        }\n    }\n\n    bool first_frame_written = false;\n    u32 trackFrameStride = 4 + 4 + 4 + 4 + 8 + 8;\n    for (Animation* anim = allAnimations; anim != 0; anim = anim->next) {\n        for (Track* track = anim->tracks; track != 0; track = track->next) {\n            if (!track->avtive) {\n                continue;\n            }\n\n            pu[first_track_for_frames] = writer * 4;\n            for (int i = 0; i < track->frameCount; ++i) {\n                if (track->frames[i].key) {\n                    if (!first_frame_written) {\n                        pu[offsets++] = writer * 4; // Record first frame offset\n                        pu[offsets++] = 0; // It's a pointer\n                        first_frame_written = true;\n                    }\n                    writer = WriteFrame(&track->frames[i], dest, writer, i);\n                }\n            }\n            \n            first_track_for_frames += trackFrameStride / 4;\n        }\n    }\n\n    if (!first_frame_written) {\n        pu[offsets++] = 0;\n        pu[offsets++] = 0;\n    }\n\n    // Write node names\n    u32 node_name_stride = (22 * 4 + 1 * 8) / 4;\n    for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n        pu[first_node_name_offset] = writer * 4;\n        if (iter->name == 0) {\n            pu[first_node_name_offset] = 0;\n        }\n        else {\n            writer = WriteTerminatedString(dest, iter->name, writer);\n        }\n\n        first_node_name_offset += node_name_stride;\n    }\n\n    // Write resource names\n    u32 resource_name_stride = (4 * 4 + 2 * 8) / 4;\n    for (Resource* iter = resources; iter != 0; iter = iter->next) {\n        if (iter->name != 0) {\n            pu[first_resource_name_offset] = writer * 4;\n            writer = WriteTerminatedString(dest, iter->name, writer);\n            //PresentFile(iter->data, iter->size);\n        }\n        first_resource_name_offset += resource_name_stride;\n    }\n\n    // Write animation names\n    u32 anim_name_stride = (6 * 4 + 2 * 8) / 4;\n    for (Animation* iter = allAnimations; iter != 0; iter = iter->next) {\n        if (iter->name != 0) {\n            pu[first_anim_name_offset] = writer * 4;\n            writer = WriteTerminatedString(dest, iter->name, writer);\n        }\n        first_anim_name_offset += anim_name_stride;\n    }\n\n    // Embed png data\n    pu[offsets++] = writer * 4; // Record first file offset\n    pu[offsets++] = 0; // It's a pointer\n    u32 resource_data_stride = (4 * 4 + 2 * 8) / 4;\n    for (Resource* iter = resources; iter != 0; iter = iter->next) {\n        if (iter->data != 0) {\n            pu[first_resource_data_offset] = writer * 4;\n            writer = WriteBlob(dest, iter->data, iter->size, writer);\n        }\n        else {\n            pu[first_resource_data_offset] = 0;\n        }\n        first_resource_data_offset += resource_data_stride;\n    }\n\n    u32 lastBytes = WriteNonPaddedString(dest, \"\\nKeyframe Studio\", writer);\n\n    return writer * 4 + lastBytes;\n}\n\n\nstruct DocumentAction {\n    virtual void Undo() = 0;\n    virtual void Redo() = 0;\n    virtual ~DocumentAction() = 0;\n    virtual const char* Name() = 0;\n};\n\nDocumentAction::~DocumentAction() {  }\n\nstruct HierarchySelectAction : DocumentAction {\n    Document* owner;\n    u32 selectedId;\n    u32 lastSelectedId;\n\n    HierarchySelectAction(Document* doc, u32 newSelection, u32 oldSelection) {\n        owner = doc;\n        selectedId = newSelection;\n        lastSelectedId = oldSelection;\n    }\n\n    ~HierarchySelectAction() {\n    }\n\n    void Redo() {\n        Node2D* selection = owner->FindNodeById(selectedId);\n        owner->selectedNode = selection;\n    }\n\n    void Undo() {\n        Node2D* selection = owner->FindNodeById(lastSelectedId);\n        owner->selectedNode = selection;\n    }\n\n    const char* Name()  {\n        if (selectedId == 0) {\n            return \"Hierarchy deselect\";\n        }\n        return \"Hierarchy select\";\n    }\n};\n\nstruct NullAction : DocumentAction {\n    NullAction() { }\n\n    void Redo() { }\n\n    void Undo() { }\n\n    ~NullAction() {\n        PlatformAssert(false, __LOCATION__);\n    }\n\n    const char* Name() {\n        return \"Null action\";\n    }\n};\n\nstruct SetFrameAction : DocumentAction {\n    const char* actionName;\n    Track* _track;\n    u32 _frame;\n    bool _wasKeyFrame;\n    u32 _oldValue;\n    u32 _newValue;\n\n    InterpolationType oldInterp;\n    InterpolationType newInterp;\n\n    SetFrameAction(Document* d, Track* t, u32 f, InterpolationType interp, bool looping, const Frame& frm) {\n        PlatformAssert(f < t->frameCount, __LOCATION__);\n        _track = t;\n        _frame = f;\n        _wasKeyFrame = t->frames[f].key;\n        _oldValue = t->frames[f].uValue;\n        _newValue = frm.uValue;\n        oldInterp = frm.interp;\n        newInterp = interp;\n\n        actionName = _wasKeyFrame ? \"Update key frame\" : \"Create key frame\";\n    }\n\n    void Redo() {\n        Frame* frame = &_track->frames[_frame];\n        if (!_wasKeyFrame) {\n            frame->key = true;\n            _track->numKeyFrames += 1;\n        }\n        frame->uValue = _newValue;\n        frame->interp = newInterp;\n    }\n\n    void Undo() {\n        Frame* frame = &_track->frames[_frame];\n        if (!_wasKeyFrame) {\n            frame->key = false;\n            _track->numKeyFrames -= 1;\n        }\n        frame->uValue = _oldValue;\n        frame->interp = oldInterp;\n    }\n\n    ~SetFrameAction() {\n    }\n\n    const char* Name() {\n        return actionName;\n    }\n};\n\nstruct AutoKeyFrameAction : DocumentAction {\n    const char* actionName;\n    Track* _track;\n    u32 _frame;\n    bool _wasKeyFrame;\n    u32 _oldValue;\n    u32 _newValue;\n\n    InterpolationType oldInterp;\n    InterpolationType newInterp;\n\n    AutoKeyFrameAction(Document* d, Track* t, u32 f, InterpolationType interp, const Frame& frm, u32 new_value_as_u32) {\n        PlatformAssert(f < t->frameCount, __LOCATION__);\n        _track = t;\n        _frame = f;\n        _wasKeyFrame = t->frames[f].key;\n        _oldValue = t->frames[f].uValue;\n        _newValue = new_value_as_u32;\n        oldInterp = frm.interp;\n        newInterp = interp;\n    }\n\n    void Redo() {\n        Frame* frame = &_track->frames[_frame];\n        if (!_wasKeyFrame) {\n            frame->key = true;\n            _track->numKeyFrames += 1;\n        }\n        frame->uValue = _newValue;\n        frame->interp = newInterp;\n    }\n\n    void Undo() {\n        Frame* frame = &_track->frames[_frame];\n        if (!_wasKeyFrame) {\n            frame->key = false;\n            _track->numKeyFrames -= 1;\n        }\n        frame->uValue = _oldValue;\n        frame->interp = oldInterp;\n    }\n\n    ~AutoKeyFrameAction() {\n    }\n\n    const char* Name() {\n        return \"Auto key frame\";\n    }\n};\n\nstruct ClearFrameAction : DocumentAction {\n    Document* owner;\n    Track* track;\n    u32 frame;\n\n    ClearFrameAction(Document* d, Track* t, u32 f) { \n        track = t;\n        owner = d;\n        frame = f;\n        PlatformAssert(track->frames[frame].key, __LOCATION__);\n    }\n\n    void Redo() { \n        track->frames[frame].key = false;\n        track->numKeyFrames -= 1;\n    }\n\n    void Undo() { \n        track->frames[frame].key = true;\n        track->numKeyFrames += 1;\n    }\n\n    ~ClearFrameAction() {\n    }\n\n    const char* Name() {\n        return \"Remove Keyframe\";\n    }\n};\n\nstruct DeleteTrackAction : DocumentAction {\n    Document* owner;\n    Track* track;\n\n    DeleteTrackAction(Document* doc, Track* t) {\n        PlatformAssert(t->avtive, __LOCATION__);\n        track = t;\n        owner = doc;\n    }\n\n    void Redo() {\n        track->avtive = false;\n        for (i32 i = 0; i < track->frameCapacity; ++i) {\n            track->frames[i].key = false;\n        }\n    }\n\n    void Undo() {\n        track->avtive = true;\n    }\n\n    ~DeleteTrackAction() {\n    }\n\n    const char* Name() {\n        return \"Remove track\";\n    }\n};\n\nstruct ActivateTrackAction : DocumentAction {\n    Document* owner;\n    Track* track;\n\n    ActivateTrackAction(Document* doc, Track* t) {\n        track = t;\n        owner = doc;\n    }\n\n    void Redo() {\n        track->avtive = true;\n        for (u32 i = 0; i < track->frameCount; ++i) {\n            track->frames[i].key = false;\n            track->frames[i].uValue = 0;\n        }\n    }\n\n    void Undo() {\n        track->avtive = false;\n    }\n\n    ~ActivateTrackAction() {\n    }\n\n    const char* Name() {\n        return \"Create track\";\n    }\n};\n\nstruct CreateTrackAction : DocumentAction {\n    Document* owner;\n    Animation* animation;\n    Node2D* node;\n    TrackType trackType;\n\n    Track* result;\n\n    CreateTrackAction(Document* doc, Animation* anim, Node2D* target, TrackType type) {\n        owner = doc;\n        animation = anim;\n        node = target;\n        trackType = type;\n        \n        PlatformAssert(anim != 0, __LOCATION__);\n        PlatformAssert(target != 0, __LOCATION__);\n\n        u32 nodeId = target->uid;\n        Track* tail = anim->tracks;\n        if (tail != 0) {\n            while (tail->next != 0) {\n                if (tail->targetNode == nodeId && tail->targetProp == type) {\n                    result = tail;\n                    return;\n                }\n                tail = tail->next;\n            }\n            PlatformAssert(tail != 0, __LOCATION__);\n            PlatformAssert(tail->next == 0, __LOCATION__);\n            if (tail->targetNode == nodeId && tail->targetProp == type) {\n                result = tail;\n                return;\n            }\n        }\n\n        result = (Track*)MemAlloc(sizeof(Track));\n        result->targetNode = target->uid;\n        result->targetProp = type;\n        result->avtive = true;\n        result->frameCapacity = result->frameCount = anim->frameCount;\n        result->numKeyFrames = 0;\n        result->prev = result->next = 0;\n\n        result->frames = (Frame*)MemAlloc(sizeof(Frame) * anim->frameCount);\n        MemClear(result->frames, sizeof(Frame) * anim->frameCount);\n        \n        Frame* prev = 0;\n        for (u32 i = 0; i < anim->frameCount; ++i) {\n            result->frames[i].key = false;\n            result->frames[i].uValue = false;\n            result->frames[i].interp = InterpolationType::Linear;\n            if (type == TrackType::SpriteVisibility || type == TrackType::SortIndex) {\n                result->frames[i].interp = InterpolationType::Step;\n            }\n        }\n\n        if (tail == 0) {\n            anim->tracks = result;\n        }\n        else {\n            tail->next = result;\n            result->prev = tail;\n        }\n    }\n\n    void Redo() { \n        animation->numTracks += 1;\n        result->avtive = true;\n    }\n\n    void Undo() {\n        animation->numTracks -= 1;\n        result->avtive = false;\n    }\n\n    ~CreateTrackAction() {\n        // Nothing to clean up, when an animation is destroyed, it will\n        // take all of its frames and tracks with it\n    }\n\n    const char* Name() {\n        return \"Create new track\";\n    }\n};\n\nstruct UpdateSpriteTintAction : DocumentAction {\n    Document* doc;\n    u32 nodeID;\n\n    float newR;\n    float newG;\n    float newB;\n    float newA;\n\n    float oldR;\n    float oldG;\n    float oldB;\n    float oldA;\n\n    UpdateSpriteTintAction(Document* owner, Node2D* node, float r, float g, float b, float a) {\n        doc = owner;\n        nodeID = node->uid;\n\n        oldR = node->sprite.tintR;\n        oldG = node->sprite.tintG;\n        oldB = node->sprite.tintB;\n        oldA = node->sprite.tintA;\n\n        newR = r;\n        newG = g;\n        newB = b;\n        newA = a;\n    }\n\n    void Redo() { \n        Node2D* node = doc->FindNodeById(nodeID);\n        PlatformAssert(node != 0, __LOCATION__);\n        node->sprite.tintR = newR;\n        node->sprite.tintG = newG;\n        node->sprite.tintB = newB;\n        node->sprite.tintA = newA;\n    }\n\n    void Undo() { \n        Node2D* node = doc->FindNodeById(nodeID);\n        PlatformAssert(node != 0, __LOCATION__);\n        node->sprite.tintR = oldR;\n        node->sprite.tintG = oldG;\n        node->sprite.tintB = oldB;\n        node->sprite.tintA = oldA;\n    }\n\n    ~UpdateSpriteTintAction() {\n    }\n\n    const char* Name() {\n        return \"Update sprite tint\";\n    }\n};\n\nstruct ChangeNodeVisibilityAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n    bool visible;\n\n    i32 oldSort;\n    i32 newSort;\n\n    ChangeNodeVisibilityAction(Document* doc, Node2D* node, bool vis, i32 sortIndex) { \n        owner = doc;\n        nodeId = node->uid;\n        visible = vis;\n        oldSort = node->sortIndex;\n        newSort = sortIndex;\n    }\n\n    void Redo() { \n        Node2D* node = owner->FindNodeById(nodeId);\n        node->sprite.visible = visible;\n        node->sortIndex = newSort;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        node->sprite.visible = !visible;\n        node->sortIndex = oldSort;\n    }\n\n    ~ChangeNodeVisibilityAction() {\n    }\n\n    const char* Name() {\n        return \"Toggle node visibility\";\n    }\n};\n\nstruct UpdateResourceRectAction : DocumentAction {\n    u32 nodeId;\n    Document* owner;\n\n    i32 sourceX;\n    i32 oldSourceX;\n\n    i32 sourceY;\n    i32 oldSourceY;\n\n    i32 sourceW;\n    i32 oldSourceW;\n\n    i32 sourceH;\n    i32 oldSourceH;\n\n    f32 pivotX;\n    f32 oldPivotX;\n\n    f32 pivotY;\n    f32 oldPivotY;\n\n    UpdateResourceRectAction(Document* doc, Node2D* node, i32 sx, i32 sy, i32 sw, i32 sh, f32 px, f32 py) { \n        owner = doc;\n        nodeId = node->uid;\n\n        oldSourceX = node->sprite.sourceX;\n        oldSourceY = node->sprite.sourceY;\n        oldSourceW = node->sprite.sourceW;\n        oldSourceH = node->sprite.sourceH;\n        oldPivotX = node->sprite.pivotX;\n        oldPivotY = node->sprite.pivotY;\n\n        sourceX = sx;\n        sourceY = sy;\n        sourceW = sw;\n        sourceH = sh;\n        pivotX = px;\n        pivotY = py;\n    }\n\n    void Redo() { \n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->sprite.sourceX = sourceX;\n        node->sprite.sourceY = sourceY;\n        node->sprite.sourceW = sourceW;\n        node->sprite.sourceH = sourceH;\n        node->sprite.pivotX = pivotX;\n        node->sprite.pivotY = pivotY;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->sprite.sourceX = oldSourceX;\n        node->sprite.sourceY = oldSourceY;\n        node->sprite.sourceW = oldSourceW;\n        node->sprite.sourceH = oldSourceH;\n        node->sprite.pivotX = oldPivotX;\n        node->sprite.pivotY = oldPivotY;\n    }\n\n    ~UpdateResourceRectAction() {\n    }\n\n    const char* Name() {\n        return \"Update resource view\";\n    }\n};\n\nstruct SetNodeResourceAction : DocumentAction {\n    u32 nodeId;\n    u32 resourceId;\n    u32 oldResourceId;\n    Document* owner;\n\n    SetNodeResourceAction(Document* d, Node2D* n, Resource* r) { \n        if (r == 0) {\n            resourceId = 0;\n        }\n        else {\n            resourceId = r->uid;\n        }\n\n        if (n == 0) {\n            nodeId = 0;\n        }\n        else {\n            nodeId = n->uid;\n        }\n        oldResourceId = n->sprite.resourceUID;\n        owner = d;\n    }\n\n    void Redo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        Resource* resource = owner->FindResourceById(resourceId);\n\n        PlatformAssert(node != 0, __LOCATION__);\n        if (node != 0) {\n            if (resource != 0) {\n                node->sprite.resourceUID = resource->uid;\n            }\n            else {\n                node->sprite.resourceUID = 0;\n            }\n        }\n    }\n\n    void Undo() { \n        Node2D* node = owner->FindNodeById(nodeId);\n        Resource* resource = owner->FindResourceById(oldResourceId);\n    \n        PlatformAssert(node != 0, __LOCATION__);\n        if (node != 0) {\n            if (resource != 0) {\n                node->sprite.resourceUID = resource->uid;\n            }\n            else {\n                node->sprite.resourceUID = 0;\n            }\n        }\n    }\n\n    ~SetNodeResourceAction() {\n    }\n\n    const char* Name() {\n        return \"Update node resource\";\n    }\n};\n\nstruct RearrangeNodeAction : DocumentAction {\n    Document* doc;\n    \n    u32 targetId;\n\n    u32 newParentId;\n    u32 newPrevId;\n\n    u32 oldParentId;\n    u32 oldPrevId;\n\n    RearrangeNodeAction(Document* d, Node2D* target, Node2D* parent, Node2D* prevNode) {\n        PlatformAssert(target != 0, __LOCATION__);\n        PlatformAssert(parent != 0, __LOCATION__);\n\n        doc = d;\n        targetId = target->uid;\n        oldParentId = 0;\n        oldPrevId = 0;\n        if (target->parent != 0) {\n            oldParentId = target->parent->uid;\n\n            Node2D* iter = target->parent->firstChild;\n            Node2D* prev = 0;\n            while (iter != 0) {\n                if (iter == target) {\n                    break;\n                }\n                prev = iter;\n                iter = iter->next;\n            }\n\n            if (prev != 0) {\n                oldPrevId = prev->uid;\n            }\n        }\n\n        newParentId = parent->uid;\n        newPrevId = 0;\n        if (prevNode != 0) {\n            newPrevId = prevNode->uid;\n            PlatformAssert(prevNode->parent = parent, __LOCATION__);\n        }\n    }\n\n    void Redo() {\n        Node2D* newParent = doc->FindNodeById(newParentId);\n        if (newParent == 0) {\n            newParent = doc->rootNode;\n        }\n        Node2D* target = doc->FindNodeById(targetId);\n        SetParent(newParent, *target, newPrevId);\n    }\n\n    void Undo() {\n        Node2D* oldParent = doc->FindNodeById(oldParentId);\n        if (oldParent == 0) {\n            oldParent = doc->rootNode;\n        }\n        Node2D* target = doc->FindNodeById(targetId);\n        SetParent(oldParent, *target, oldPrevId);\n    }\n\n    ~RearrangeNodeAction() {  }\n\n    const char* Name() {\n        return \"Hierarchy Reorder\";\n    }\n};\n\nstruct CreateNodeAction : DocumentAction {\n    Document* owner;\n    u32 parentUID;\n    Node2D* createdInstance;\n    bool undone;\n\n    CreateNodeAction(Document* doc, u32 parent) {\n        owner = doc;\n        parentUID = parent;\n        undone = false;\n\n        Node2D* _parent = owner->FindNodeById(parentUID);\n        if (_parent == 0) {\n            _parent = owner->rootNode;\n        }\n\n        createdInstance = (Node2D*)MemAlloc(sizeof(Node2D));\n        MemClear(createdInstance, sizeof(Node2D));\n        createdInstance->uid = ++owner->nodeUidGenerator;\n        createdInstance->sprite.visible = true;\n        createdInstance->sprite.tintR = 1.0f;\n        createdInstance->sprite.tintG = 1.0f;\n        createdInstance->sprite.tintB = 1.0f;\n        createdInstance->sprite.tintA = 1.0f;\n\n        createdInstance->name = (char*)MemAlloc(NODE2D_DEFAULT_NAME_CAPACITY + 1);\n        MemClear(createdInstance->name, NODE2D_DEFAULT_NAME_CAPACITY + 1);\n        createdInstance->nameCapacity = NODE2D_DEFAULT_NAME_CAPACITY;\n        stbsp_snprintf(createdInstance->name, createdInstance->nameCapacity, \"Node %d\", createdInstance->uid);\n\n        createdInstance->refCount += 1;  // +1 for the create node action\n        createdInstance->scale = vec2(1, 1);\n        createdInstance->uiVisible = true;\n        createdInstance->uiExpanded = true;\n\n        SetParent(_parent, *createdInstance);\n        SetName(*createdInstance, createdInstance->name);\n    }\n\n    ~CreateNodeAction() {\n        createdInstance->refCount -= 1;\n        if (undone) {\n            PlatformAssert(createdInstance->firstChild == 0, __LOCATION__);\n        }\n        RecursivleyDestroyNodeIfItHasNoReferences(createdInstance);\n\n        owner = 0;\n    }\n\n    void Undo() {\n        undone = true;\n        owner->numNodes -= 1;\n        createdInstance->refCount -= 1;  // -1 since it's deleted\n        PlatformAssert(createdInstance->refCount != 0, __LOCATION__); // This struct has to have +1 ref!\n\n        if (createdInstance->parent != 0) {\n            RemoveChild(*createdInstance->parent, *createdInstance);\n        }\n\n        PlatformAssert(createdInstance->firstChild == 0, __LOCATION__);\n    }\n\n    void Redo() {\n        undone = false;\n        owner->numNodes += 1;\n        Node2D* parent = owner->FindNodeById(parentUID);\n        if (parent == 0) {\n            parent = owner->rootNode;\n        }\n        createdInstance->refCount += 1;  // +1 since it's in document\n\n        SetParent(parent, *createdInstance);\n    }\n\n    const char* Name() {\n        return \"Hierarchy create node\";\n    }\n\n    Node2D* RedoResult() {\n        return createdInstance;\n    }\n};\n\nstruct DeleteNodeAction : DocumentAction {\n    Document* owner;\n    Node2D* deletedNode;\n    u32 parentId;\n    u32 lastSibling;\n\n    DeleteNodeAction(Document* doc, Node2D* target) {\n        PlatformAssert(target != 0, __LOCATION__);\n        owner = doc;\n        parentId = 0;\n        deletedNode = target;\n\n\n        // Increase the reference cound for every node that the delete action touches\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) { // Not sure if i should do this just to the root, or all nodes\n            node->refCount += 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, 0);\n\n        lastSibling = 0;\n        if (target->parent != 0) {\n            parentId = target->parent->uid;\n            Node2D* iter = target->parent->firstChild;\n            while (iter != 0) {\n                if (iter->uid == target->uid) {\n                    break;\n                }\n                lastSibling = iter->uid;\n                iter = iter->next;\n            }\n        }\n    }\n\n    ~DeleteNodeAction() {\n        // Decrease the reference count, since the delete action is gone\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            node->refCount -= 1;\n        }, 0);\n\n        RecursivleyDestroyNodeIfItHasNoReferences(deletedNode);\n    }\n\n    void Undo() {\n        Node2D* parent = owner->FindNodeById(parentId);\n        if (parent == 0) {\n            parent = owner->rootNode;\n        }\n        SetParent(parent, *deletedNode, lastSibling);\n        owner->selectedNode = deletedNode;\n\n        // Increase the reference cound for every node when it is added to the hierarchy\n        u32 nodesToRemove = 0;\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            u32* nodesToRemove = (u32*)userData;\n            *nodesToRemove += 1;\n            node->refCount += 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, &nodesToRemove);\n        owner->numNodes += nodesToRemove;\n\n    }\n\n    void Redo() {\n        PlatformAssert (owner->selectedNode->uid == deletedNode->uid, __LOCATION__);\n        SetParent(0, *deletedNode);\n        owner->selectedNode = 0;\n\n        // Decrease the reference cound for every node when it is removed from the hierarchy\n        u32 nodesToRemove = 0;\n        ForEachNode(deletedNode, [](Node2D* node, void* userData) {\n            u32* nodesToRemove = (u32*)userData;\n            *nodesToRemove += 1; \n            node->refCount -= 1;\n            PlatformAssert(node->refCount > 0, __LOCATION__);\n        }, & nodesToRemove);\n        owner->numNodes -= nodesToRemove;\n    }\n\n    const char* Name() {\n        return \"Hierarchy delete node\";\n    }\n};\n\nstruct RenameAnimationAction : DocumentAction {\n    Document* owner;\n    u32 animID;\n    char* oldName;\n    u32 oldNameLen;\n    char* newName;\n    u32 newNameLen;\n\n    RenameAnimationAction(Document* doc, Animation* anim, const char* name, u32 nameLen) { \n        PlatformAssert(anim != 0, __LOCATION__);\n        PlatformAssert(name != 0, __LOCATION__);\n\n        owner = doc;\n        animID = anim->uid;\n\n        oldName = 0;\n        oldNameLen = 0;\n        if (anim->name != 0) {\n            oldNameLen = nameLen;\n            oldName = (char*)MemAlloc(oldNameLen + 1);\n            for (u32 i = 0; i < oldNameLen; ++i) {\n                oldName[i] = anim->name[i];\n            }\n            oldName[oldNameLen] = 0;\n        }\n\n        newName = 0;\n        newNameLen = 0;\n        if (name) {\n            u32 len = 0;\n            const char* iter = name;\n            while (*iter != 0) {\n                len++;\n                iter++;\n            }\n\n            newNameLen = len;\n            newName = (char*)MemAlloc(newNameLen + 1);\n            for (u32 i = 0; i < newNameLen; ++i) {\n                newName[i] = name[i];\n            }\n            newName[newNameLen] = 0;\n        }\n    }\n\n    void Redo() {\n        Animation* anim = owner->FindAnimationById(animID);\n        PlatformAssert(anim != 0, __LOCATION__);\n\n        anim->name = (char*)MemRealloc(anim->name, newNameLen + 1);\n        for (u32 i = 0; i < newNameLen; ++i) {\n            anim->name[i] = newName[i];\n        }\n        anim->name[newNameLen] = 0;\n    }\n\n    void Undo() { \n        Animation* anim = owner->FindAnimationById(animID);\n        PlatformAssert(anim != 0, __LOCATION__);\n\n        anim->name = (char*)MemRealloc(anim->name, oldNameLen + 1);\n        for (u32 i = 0; i < oldNameLen; ++i) {\n            anim->name[i] = oldName[i];\n        }\n        anim->name[oldNameLen] = 0;\n    }\n\n    ~RenameAnimationAction() {\n        if (oldName != 0) {\n            MemRelease(oldName);\n        }\n        if (newName != 0) {\n            MemRelease(newName);\n        }\n    }\n\n    const char* Name() {\n        return \"Rename animation\";\n    }\n};\n\nstruct RenameNodeAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n    char* oldName;\n    u32 oldNameLen;\n    char* newName;\n    u32 newNameLen;\n\n    RenameNodeAction(Document* doc, Node2D* node, const char* name) {\n        PlatformAssert(node != 0, __LOCATION__);\n        PlatformAssert(name != 0, __LOCATION__);\n\n        owner = doc;\n        nodeId = node->uid;\n\n        oldName = 0;\n        oldNameLen = 0;\n        if (node->name != 0) {\n            oldNameLen = node->nameLength;\n            oldName = (char*)MemAlloc(oldNameLen + 1);\n            for (u32 i = 0; i < oldNameLen; ++i) {\n                oldName[i] = node->name[i];\n            }\n            oldName[oldNameLen] = 0;\n        }\n\n        newName = 0;\n        newNameLen = 0;\n        if (name) {\n            u32 len = 0;\n            const char* iter = name;\n            while (*iter != 0) {\n                len++;\n                iter++;\n            }\n\n            newNameLen = len;\n            newName = (char*)MemAlloc(newNameLen + 1);\n            for (u32 i = 0; i < newNameLen; ++i) {\n                newName[i] = name[i];\n            }\n            newName[newNameLen] = 0;\n        }\n    }\n\n    void Redo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        if (node->nameCapacity < newNameLen + 1) {\n            node->nameCapacity = newNameLen + 1;\n            node->name = (char*)MemRealloc(node->name, newNameLen + 1);\n        }\n\n        node->nameLength = newNameLen;\n        for (u32 i = 0; i < newNameLen; ++i) {\n            node->name[i] = newName[i];\n        }\n        node->name[newNameLen] = 0;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        if (node->nameCapacity < oldNameLen + 1) {\n            node->nameCapacity = oldNameLen + 1;\n            node->name = (char*)MemRealloc(node->name, oldNameLen + 1);\n        }\n\n        node->nameLength = oldNameLen;\n        for (u32 i = 0; i < oldNameLen; ++i) {\n            node->name[i] = oldName[i];\n        }\n        node->name[oldNameLen] = 0;\n    }\n\n    ~RenameNodeAction() {\n        if (oldName != 0) {\n            MemRelease(oldName);\n        }\n        if (newName != 0) {\n            MemRelease(newName);\n        }\n    }\n\n    const char* Name() {\n        return \"Rename node\";\n    }\n};\n\nstruct EditTransformAction : DocumentAction {\n    Document* owner;\n    u32 nodeId;\n\n    vec2 olsPos;\n    vec2 newPos;\n\n    float oldRot;\n    float newRot;\n\n    vec2 oldScale;\n    vec2 newScale;\n\n    EditTransformAction(Document* doc, Node2D* node, const vec2& nPos, float nRot, const vec2& nScale) {\n        owner = doc;\n        nodeId = node->uid;\n\n        olsPos = node->position;\n        oldRot = node->rotationAngles;\n        oldScale = node->scale;\n\n        newPos = nPos;\n        newRot = nRot;\n        newScale = nScale;\n    }\n\n    void Redo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->position = newPos;\n        node->rotationAngles = newRot;\n        node->scale = newScale;\n    }\n\n    void Undo() {\n        Node2D* node = owner->FindNodeById(nodeId);\n        PlatformAssert(node != 0, __LOCATION__);\n\n        node->position = olsPos;\n        node->rotationAngles = oldRot;\n        node->scale = oldScale;\n    }\n\n    ~EditTransformAction() {\n        // Nothing to do\n    }\n\n    const char* Name() {\n        return \"Edit node transform\";\n    }\n};\n\nstruct CreateAnimationAction : DocumentAction {\n    Document* owner;\n    Animation* anim;\n    u32 animID;\n\n    inline Animation* RedoResult() {\n        return anim;\n    }\n\n    inline CreateAnimationAction(Document* doc, const char* optionalName) { \n        owner = doc;\n        anim = (Animation*)MemAlloc(sizeof(Animation));\n        MemClear(anim, sizeof(Animation));\n\n        doc->numAnimations += 1;\n\n        anim->uid = animID = ++doc->animationUidGenerator;\n        anim->frameRate = 30; // 2 second default \n        anim->frameCount = 60;\n        anim->loop = AnimationLoopMode::Looping;\n\n        // Name the animation\n        if (optionalName == 0) {\n            anim->name = (char*)MemAlloc(20);\n            stbsp_snprintf(anim->name, 20, \"Animation %d\", anim->uid);\n        }\n        else {\n            u32 len = 0; // strlen(name)\n            for (const char* n = optionalName; *n != 0; ++n, ++len);\n\n            anim->name = (char*)MemAlloc(len + 1);\n            MemCopy(anim->name, optionalName, len);\n            anim->name[len] = 0;\n        }\n\n        \n        anim->refCount = 1; // Because the action is holding onto it\n\n    }\n\n    void Redo() {\n        // Add to document\n        if (owner->allAnimations == 0) {\n            owner->allAnimations = anim;\n            anim->prev = anim->next = 0;\n        }\n        else {\n            Animation* tail = owner->allAnimations;\n            while (tail->next != 0) {\n                tail = tail->next;\n            }\n\n            PlatformAssert(tail->next == 0, __LOCATION__);\n            tail->next = anim;\n            anim->prev = tail;\n            anim->next = 0;\n        }\n\n        anim->refCount += 1; // Because it's in the document now\n    }\n\n    void Undo() {\n        if (owner->allAnimations == anim) {\n            PlatformAssert(anim->prev == 0, __LOCATION__);\n            PlatformAssert(owner->allAnimations->prev == 0, __LOCATION__);\n\n            if (owner->allAnimations->next != 0) {\n                owner->allAnimations->next->prev = 0;\n            }\n            owner->allAnimations = owner->allAnimations->next;\n        }\n        else {\n            if (anim->next != 0) {\n                anim->next->prev = anim->prev;\n            }\n            if (anim->prev != 0) {\n                anim->prev->next = anim->next;\n            }\n        }\n        anim->prev = anim->next = 0;\n\n\n        anim->refCount -= 1; // Because it's no longer in the document\n        // ref count here can never be 0 because the constructor added 1\n    }\n\n    ~CreateAnimationAction() {\n        anim->refCount -= 1; // Because it's no longer in the document\n        if (anim->refCount <= 0) {\n            anim->ReleaseMemory();\n            MemRelease(anim);\n            anim = 0;\n        }\n    }\n\n    const char* Name() {\n        return \"Create Animation\";\n    }\n};\n\nstruct DeleteAnimationAction : DocumentAction {\n    Document* owner;\n    Animation* anim;\n    u32 animID;\n\n    DeleteAnimationAction(Document* doc, Animation* animation) { \n        owner = doc;\n        anim = animation;\n        animID = animation->uid;\n\n        anim->refCount += 1; // Because the action is holding onto it\n    }\n\n    void Redo() { \n        PlatformAssert(anim != 0, __LOCATION__);\n\n        if (owner->allAnimations == anim) {\n            PlatformAssert(anim->prev == 0, __LOCATION__);\n            PlatformAssert(owner->allAnimations->prev == 0, __LOCATION__);\n\n            if (owner->allAnimations->next != 0) {\n                owner->allAnimations->next->prev = 0;\n            }\n            owner->allAnimations = owner->allAnimations->next;\n        }\n        else {\n            if (anim->next != 0) {\n                anim->next->prev = anim->prev;\n            }\n            if (anim->prev != 0) {\n                anim->prev->next = anim->next;\n            }\n        }\n        anim->prev = anim->next = 0;\n\n        anim->refCount -= 1; // Since it's no longer in the documnet\n    }\n\n    void Undo() {\n        if (owner->allAnimations == 0) {\n            owner->allAnimations = anim;\n            anim->prev = anim->next = 0;\n        }\n        else {\n            Animation* tail = owner->allAnimations;\n            while (tail->next != 0) {\n                tail = tail->next;\n            }\n\n            PlatformAssert(tail->next == 0, __LOCATION__);\n            tail->next = anim;\n            anim->prev = tail;\n            anim->next = 0;\n        }\n\n        anim->refCount += 1; // Because it's in the document now\n    }\n\n    ~DeleteAnimationAction() {\n        anim->refCount -= 1; // Because it's no longer in the document\n        if (anim->refCount <= 0) {\n            anim->ReleaseMemory();\n            MemRelease(anim);\n            anim = 0;\n        }\n    }\n\n    const char* Name() {\n        return \"Delete animation\";\n    }\n};\n\nstruct UpdateAnimationAction : DocumentAction {\n    Document* owner;\n    u32 animId;\n\n    u32 oldFrameCount;\n    u32 oldFrameRate;\n    AnimationLoopMode oldLoopMode;\n\n    u32 newFrameCount;\n    u32 newFrameRate;\n    AnimationLoopMode newLoopMode;\n\n    inline void MakeSureAnimationHasEnoughFrames(Animation* anim) {\n        u32 frameCount = newFrameCount;\n        if (oldFrameCount > newFrameCount) {\n            frameCount = oldFrameCount;\n        }\n\n        for (Track* iter = anim->tracks; iter != 0; iter = iter->next) {\n            iter->Resize(frameCount);\n        }\n    }\n\n    UpdateAnimationAction(Document* doc, Animation* anim, u32 frameCount, u32 frameRAte, AnimationLoopMode loopMode) { \n        owner = doc;\n        animId = anim->uid;\n\n        newFrameCount = frameCount;\n        newFrameRate = frameRAte;\n        newLoopMode = loopMode;\n\n        oldFrameCount = anim->frameCount;\n        oldFrameRate = anim->frameRate;\n        oldLoopMode = anim->loop;\n    }\n\n    void Redo() { \n        Animation* anim = owner->FindAnimationById(animId);\n        PlatformAssert(anim != 0, __LOCATION__);\n\n        MakeSureAnimationHasEnoughFrames(anim);\n        anim->frameCount = newFrameCount;\n        anim->frameRate = newFrameRate;\n        anim->loop = newLoopMode;\n    }\n\n    void Undo() {\n        Animation* anim = owner->FindAnimationById(animId);\n        PlatformAssert(anim != 0, __LOCATION__);\n\n        MakeSureAnimationHasEnoughFrames(anim);\n        anim->frameCount = oldFrameCount;\n        anim->frameRate = oldFrameRate;\n        anim->loop = oldLoopMode;\n    }\n\n    ~UpdateAnimationAction() { }\n\n    const char* Name() {\n        return \"Update animation\";\n    }\n};\n\nstruct StaticActionSize {\n    union {\n        NullAction nullAction;\n        HierarchySelectAction hierarchySelection;\n        CreateNodeAction createNode;\n        DeleteNodeAction deleteNode;\n        RearrangeNodeAction arrangeNode;\n        RenameNodeAction renameNode;\n        EditTransformAction editTransform;\n        SetNodeResourceAction setNodeResource;\n        UpdateResourceRectAction updateResource;\n        ChangeNodeVisibilityAction changeNodeVisibility;\n        UpdateSpriteTintAction updateSpriteTint;\n        CreateAnimationAction createAnimation;\n        DeleteAnimationAction deleteAnimation;\n        RenameAnimationAction renameAnimation;\n        UpdateAnimationAction updateAnimations;\n        CreateTrackAction createTrack;\n        ClearFrameAction clearFrame;\n        SetFrameAction setFrame;\n        DeleteTrackAction deleteTrack;\n        ActivateTrackAction activateTrack;\n        AutoKeyFrameAction autoKeyAction;\n    };\n};\n\nStaticActionSize* GrabNextUndoSlot(Document* d);\n\nvoid Document::DeleteNode(Node2D* node) {\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    DeleteNodeAction* dAction = new (action)DeleteNodeAction(this, node);\n    dAction->Redo();\n}\n\nvoid Document::DeleteAnimation(Animation* anim) {\n    if (selectedAnimation == anim) {\n        selectedAnimation = 0;\n    }\n    if (timelineAnimation == anim) {\n        timelineAnimation = 0;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    DeleteAnimationAction* dAction = new (action)DeleteAnimationAction(this, anim);\n    dAction->Redo();\n}\n\nvoid Document::SelectAnimation(Animation* anim) {\n    selectedAnimation = anim;\n    timelineSelectedFrame = -1;\n}\n\nAnimation* Document::CreateAnimation(const char* name) {\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    CreateAnimationAction* cAction = new (action)CreateAnimationAction(this, name);\n    cAction->Redo();\n    return cAction->RedoResult();\n}\n\nNode2D* Document::CreateNode(Node2D* parent) {\n    if (parent == 0) {\n        parent = rootNode;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    CreateNodeAction* cAction = new (action)CreateNodeAction(this, parent->uid);\n    cAction->Redo();\n    return cAction->RedoResult();\n}\n\nnamespace Document_Internal {\n    struct RequestResourceUserData {\n        Document* owner;\n        void* userData;\n        OnResourceLoaded callback;\n    };\n}\n\nu32 Document::GetReferenceCount(Resource* resource) {\n    u32 count = 0;\n    for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n        if (iter->sprite.resourceUID == resource->uid) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nvoid Document::DestroyResource(Resource* resource) {\n    PlatformAssert(numResources != 0, __LOCATION__);\n\n    if (resource != 0) {\n        for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n            if (iter->sprite.resourceUID == resource->uid) {\n                iter->sprite.resourceUID = 0;\n            }\n        }\n\n        if (resource->name != 0) {\n            MemRelease(resource->name);\n            resource->name = 0;\n        }\n        if (resource->data != 0) {\n            MemRelease(resource->data);\n        }\n        Draw2D::DestroyImage(resource->image);\n        resource->image = 0;\n        MemRelease(resource);\n\n        if (selectedResource == resource) {\n            selectedResource = 0;\n        }\n        if (resources == resource) {\n            resources = resources->next;\n        }\n        if (resource->prev) {\n            resource->prev->next = resource->next;\n        }\n        if (resource->next) {\n            resource->next->prev = resource->prev;\n        }\n\n        numResources -= 1;\n    }\n}\n\nResource* Document::LoadResource(const char* path, void* data, u32 bytes) {\n    if (data == 0 || bytes == 0) {\n        return 0;\n    }\n    \n    Resource* result = (Resource*)MemAlloc(sizeof(Resource));\n   \n    {\n        if (path != 0) {\n            const char* lastSlash = path;\n            const char* iter = path;\n            u32 pathLen = 0;\n            while (*iter != '\\0') {\n                pathLen += 1;\n                if (*iter == '/' || *iter == '\\\\') {\n                    lastSlash = ++iter;\n                    pathLen = 0;\n                }\n                else {\n                    ++iter;\n                }\n            }\n\n            result->name = (char*)MemAlloc(pathLen + 1);\n            int i = 0;\n            for (iter = lastSlash; *iter != '\\0'; ++iter) {\n                result->name[i++] = *iter;\n            }\n            result->name[i] = 0;\n            result->nameLen = pathLen;\n        }\n        else {\n            int uid = resourceUidGenerator + 1;\n            result->name = (char*)MemAlloc(16);\n            stbsp_snprintf(result->name, 16, \"Image %d\", uid);\n            result->nameLen = 16;\n        }\n\n        result->data = MemAlloc(bytes); \n        MemCopy(result->data, data, bytes);\n        result->size = bytes;\n        result->image = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n        result->filter = Draw2D::Interpolation::Linear;\n        result->width = Draw2D::GetImageSize(result->image).w;\n        result->height = Draw2D::GetImageSize(result->image).h;\n\n        result->prev = result->next = 0;\n        if (resources == 0) {\n            result->prev = result->next = 0;\n            resources = result;\n        }\n        else {\n            Resource* tail = resources;\n            while (tail->next != 0) {\n                tail = tail->next;\n            }\n            PlatformAssert(tail->next == 0, __LOCATION__);\n            tail->next = result;\n            result->prev = tail;\n        }\n        numResources += 1;\n        result->uid = ++resourceUidGenerator;\n    }\n\n    return result;\n}\n\n\nvoid Document::RequestResource(OnResourceLoaded onLoad, void* userData) {\n    Document_Internal::RequestResourceUserData* userPointer = (Document_Internal::RequestResourceUserData *)MemAlloc(sizeof(Document_Internal::RequestResourceUserData));\n    userPointer->owner = this;\n    userPointer->userData = userData;\n    userPointer->callback = onLoad;\n\n    RequestFileAsynch([](const char* path, void* data, unsigned int bytes, void* userData) {\n        Document_Internal::RequestResourceUserData* userPointer = (Document_Internal::RequestResourceUserData*)userData;\n        Resource* result = (Resource*)MemAlloc(sizeof(Resource));\n\n        if (data == 0 || bytes == 0) {\n            result->name = 0;\n            result->data = 0;\n            result->size = 0;\n            result->image = 0;\n            result->filter = Draw2D::Interpolation::Linear;\n            result->width = 0;\n            result->height = 0;\n            result->prev = 0;\n            result->next = 0;\n\n            if (userPointer->callback != 0) {\n                userPointer->callback(path, *result, userPointer->userData);\n            }\n\n            MemRelease(result);\n            result = 0;\n        }\n        else {\n            if (path != 0) {\n                const char* lastSlash = path;\n                const char* iter = path;\n                u32 pathLen = 0;\n                while (*iter != '\\0') {\n                    pathLen += 1;\n                    if (*iter == '/' || *iter == '\\\\') {\n                        lastSlash = ++iter;\n                        pathLen = 0;\n                    }\n                    else {\n                        ++iter;\n                    }\n                }\n\n                result->name = (char*)MemAlloc(pathLen + 1);\n                int i = 0;\n                for (iter = lastSlash; *iter != '\\0'; ++iter) {\n                    result->name[i++] = *iter;\n                }\n                result->name[i] = 0;\n                result->nameLen = pathLen;\n            }\n            else {\n                int uid = userPointer->owner->resourceUidGenerator + 1;\n                result->name = (char*)MemAlloc(16);\n                stbsp_snprintf(result->name, 16, \"Image %d\", uid);\n                result->nameLen = 16;\n            }\n\n            result->data = data;\n            result->size = bytes;\n            result->image = Draw2D::LoadImage(data, bytes, Draw2D::Interpolation::Linear);\n            result->filter = Draw2D::Interpolation::Linear;\n            result->width = Draw2D::GetImageSize(result->image).w;\n            result->height = Draw2D::GetImageSize(result->image).h;\n\n            result->prev = result->next = 0;\n            if (userPointer->owner->resources == 0) {\n                result->prev = result->next = 0;\n                userPointer->owner->resources = result;\n            }\n            else {\n                Resource* tail = userPointer->owner->resources;\n                while (tail->next != 0) {\n                    tail = tail->next;\n                }\n                PlatformAssert(tail->next == 0, __LOCATION__);\n                tail->next = result;\n                result->prev = tail;\n            }\n            userPointer->owner->numResources += 1;\n            result->uid = ++userPointer->owner->resourceUidGenerator;\n\n            if (userPointer->callback != 0) {\n                userPointer->callback(path, *result, userPointer->userData);\n            }\n        }\n\n        MemRelease(userPointer);\n    }, userPointer);\n}\n\n\nvoid Document::RearrangeNode(Node2D& nodeToInsert, Node2D& parent, Node2D* prevSibling) {\n    PlatformAssert(nodeToInsert.parent != 0, __LOCATION__);\n\n    Node2D* iter = &parent;\n    while (iter != 0) {\n        if (iter == &nodeToInsert) {\n            return; // Early out if causing a problem\n        }\n        iter = iter->parent;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    RearrangeNodeAction* rAction = new (action)RearrangeNodeAction(this, &nodeToInsert, &parent, prevSibling);\n    rAction->Redo();\n}\n\nvoid Document::UpdateAnimation(Animation* anim, u32 frameCount, u32 frameRate, AnimationLoopMode loop) {\n    if (anim->frameCount == frameCount && anim->frameRate == frameRate && anim->loop == loop) {\n        return;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    UpdateAnimationAction* rAction = new (action)UpdateAnimationAction(this, anim, frameCount, frameRate, loop);\n    rAction->Redo();\n}\n\nvoid Document::ClearFrame(Track* t, u32 f) {\n    if (t == 0 || f >= t->frameCount) {\n        return;\n    }\n    if (!t->frames[f].key) {\n        return;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    ClearFrameAction* rAction = new (action)ClearFrameAction(this, t, f);\n    rAction->Redo();\n}\n\nfloat Document::GetLocalProp(Node2D* node, TrackType trackType) {\n    Animation* timelineAnimation = GetTimelineAnimation();\n    i32 selectedFrame = GetSelectedFrame();\n   \n    Track* animatedTrack = 0;\n    if (timelineAnimation != 0 && node != 0) {\n        animatedTrack = timelineAnimation->Contains(node, trackType);\n    }\n    bool contained = animatedTrack != 0 && animatedTrack->numKeyFrames > 0;\n\n    if (contained) {\n        PlatformAssert(timelineAnimation != 0, __LOCATION__); // Safe if contained\n\n        if (node->IsPropertyDirty(trackType)) {\n            return node->GetPropertyBuffer<f32>(trackType);\n        }\n        else {\n            if (selectedFrame == -1) { // No frame selected, show frame 0\n                if (animatedTrack->frames[0].key) { // Frame 0 was a key, show it's value\n                    return animatedTrack->frames[0].fValue;\n                }\n                else { // Nothing is keyed for frame 0, show hierarchy value\n                    return node->GetProperty<f32>(trackType);\n                }\n            }\n            else {\n                PlatformAssert(selectedFrame < animatedTrack->frameCount, __LOCATION__);\n\n                if (animatedTrack->frames[selectedFrame].key) { // Frame 0 was a key, show it's value\n                    return animatedTrack->frames[selectedFrame].fValue;\n                }\n                else {\n                    float interpolated_value = animatedTrack->InterpolateF(selectedFrame, node->GetProperty<f32>(trackType), timelineAnimation->loop);\n                    return interpolated_value;\n                }\n            }\n        }\n    }\n    // Else\n    return node->GetProperty<f32>(trackType);\n}\n\nTransform Document::GetLocalTransform(Node2D* node) {\n    Transform result;\n    result.scale = vec3(1, 1, 1);\n    \n    if (node != 0) {\n        if (node->transformToolActive) {\n            result.position = vec3(node->position.x, node->position.y, 0.0f);\n            result.rotation = angleAxis(node->rotationAngles * MATH_DEG2RAD, vec3(0, 0, 1));\n            result.scale = vec3(node->scale.x, node->scale.y, 1.0f);\n        }\n        else {\n            result.position.x = GetLocalProp(node, TrackType::TransformPositionX);\n            result.position.y = GetLocalProp(node, TrackType::TransformPositionY);\n            float rotationAngles = GetLocalProp(node, TrackType::TransformRotation);\n            result.rotation = angleAxis(rotationAngles * MATH_DEG2RAD, vec3(0, 0, 1));\n            result.scale.x = GetLocalProp(node, TrackType::TransformScaleX);\n            result.scale.y = GetLocalProp(node, TrackType::TransformScaleY);\n        }\n    }\n    return result;\n}\n\nTransform Document::GetWorldTransform(Node2D* node) {\n    Transform result = GetLocalTransform(node);\n    Node2D* iter = node->parent;\n\n    while (iter != 0) {\n        Transform p = GetLocalTransform(iter);\n        result = combine(p, result);\n        iter = iter->parent;\n    }\n    \n    return result;\n}\n\nvoid Document::NewDocument() {\n    ClearUndoHistory();\n    nodeUidGenerator = 0;\n    resourceUidGenerator = 0;\n    animationUidGenerator = 0;\n    selectedNode = 0;\n    timelineSelectedFrame = -1;\n    timelineLastSelectedFrame = -1;\n    selectedTrack = 0;\n    timelineAnimation = 0;\n    needsEndOfFrameUpdate = 0;\n    selectedInterpolationType = 0;\n    numNodes = 0;\n    selectedResource = 0;\n\n    // Release the hierarchy\n    ForEachNode(rootNode, [](Node2D* node, void* userData) {\n        PlatformAssert(node->refCount == 1, __LOCATION__);\n        node->refCount -= 1;\n        }, 0);\n    RecursivleyDestroyNodeIfItHasNoReferences(rootNode);\n    rootNode = 0;\n\n    // Release any resources\n    if (resources != 0) {\n        Resource* iter = resources;\n        while (iter != 0) {\n            Resource* release = iter;\n            iter = iter->next;\n            DestroyResource(release);\n        }\n    }\n    resources = 0;\n    numResources = 0;\n\n    rootNode = (Node2D*)MemAlloc(sizeof(Node2D));\n    MemClear(rootNode, sizeof(Node2D));\n    rootNode->scale = vec2(1, 1);\n    rootNode->refCount += 1;\n\n    {\n        Animation* anim = allAnimations;\n        while (anim != 0) {\n            Animation* to_delete = anim;\n            if (to_delete->numTracks > 0) {\n                Track* track = to_delete->tracks;\n                while (track != 0) {\n                    Track* to_delete_track = track;\n                    if (to_delete_track->frames != 0) {\n                        MemRelease(to_delete_track->frames);\n                    }\n                    MemRelease(to_delete_track);\n                    track = track->next;\n                }\n            }\n            if (to_delete->name != 0) {\n                MemRelease(to_delete->name);\n            }\n            MemRelease(to_delete);\n            anim = anim->next;\n        }\n    }\n    allAnimations = 0;\n    numAnimations = 0;\n    selectedAnimation = 0;\n}\n\nvoid Document::EndOfFrame(bool autoKey) {\n    if (needsEndOfFrameUpdate >= 0) {\n        i32 frame = GetSelectedFrame();\n        Animation* timelineAnimation = GetTimelineAnimation();\n\n        for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n            // Default to whatever the hierarchy representation is\n            iter->anim_position.x = iter->position.x;\n            iter->anim_position.y = iter->position.y;\n            iter->anim_rotationAngles = iter->rotationAngles;\n            iter->anim_scale.x = iter->scale.x;\n            iter->anim_scale.y = iter->scale.y;\n            MemCopy(&iter->anim_sprite, &iter->sprite, sizeof(SpriteComponent));\n\n            if (timelineAnimation != 0 && frame >= 0 && frame <= timelineAnimation->frameCount) {\n                Track* currentTrack = timelineAnimation->tracks;\n                while (currentTrack != 0) {\n                    if (iter->uid == currentTrack->targetNode) {\n                        if (currentTrack->targetProp == TrackType::TransformPositionX) {\n                            iter->anim_position.x = currentTrack->InterpolateF(frame, iter->position.x, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::TransformPositionY) {\n                            iter->anim_position.y = currentTrack->InterpolateF(frame, iter->position.y, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::TransformRotation) {\n                            iter->anim_rotationAngles = currentTrack->InterpolateF(frame, iter->rotationAngles, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::TransformScaleX) {\n                            iter->anim_scale.x = currentTrack->InterpolateF(frame, iter->scale.x, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::TransformScaleY) {\n                            iter->anim_scale.y = currentTrack->InterpolateF(frame, iter->scale.y, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteTintR) {\n                            iter->anim_sprite.tintR = currentTrack->InterpolateF(frame, iter->sprite.tintR, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteTintG) {\n                            iter->anim_sprite.tintG = currentTrack->InterpolateF(frame, iter->sprite.tintG, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteTintB) {\n                            iter->anim_sprite.tintB = currentTrack->InterpolateF(frame, iter->sprite.tintB, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteVisibility) {\n                            iter->anim_sprite.visible = currentTrack->InterpolateB(frame, iter->sprite.visible, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteSourceX) {\n                            iter->anim_sprite.sourceX = currentTrack->InterpolateI(frame, iter->sprite.sourceX, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteSourceY) {\n                            iter->anim_sprite.sourceY = currentTrack->InterpolateI(frame, iter->sprite.sourceY, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteSourceW) {\n                            iter->anim_sprite.sourceW = currentTrack->InterpolateI(frame, iter->sprite.sourceW, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SpriteSourceH) {\n                            iter->anim_sprite.sourceH = currentTrack->InterpolateI(frame, iter->sprite.sourceH, timelineAnimation->loop);\n                        }\n                        else if (currentTrack->targetProp == TrackType::SortIndex) {\n                            iter->anim_sortIndex = currentTrack->InterpolateI(frame, iter->sortIndex, timelineAnimation->loop);\n                        }\n                    }\n                    currentTrack = currentTrack->next;\n                }\n            }\n\n            iter->anim_positionX_dirty = false;\n            iter->anim_positionY_dirty = false;\n            iter->anim_rotation_dirty = false;\n            iter->anim_scaleX_dirty = false;\n            iter->anim_scaleY_dirty = false;\n            iter->anim_sourceX_dirty = false;\n            iter->anim_sourceY_dirty = false;\n            iter->anim_sourceW_dirty = false;\n            iter->anim_sourceH_dirty = false;\n            iter->anim_tintR_dirty = false;\n            iter->anim_tintG_dirty = false;\n            iter->anim_tintB_dirty = false;\n            iter->anim_tintA_dirty = false;\n            iter->anim_visible_dirty = false;\n        }\n    }\n    needsEndOfFrameUpdate = -1;\n    timelineLastSelectedFrame = timelineSelectedFrame;\n}\n\nvoid Document::SetSelectedFrame(i32 frame) {\n    if (timelineSelectedFrame != frame) {\n        needsEndOfFrameUpdate = timelineSelectedFrame;\n    }\n    timelineSelectedFrame = frame;\n}\n\nvoid Document::AutoKeyFrameValue(Track* t, u32 frame, InterpolationType interp, u32 frameVal_as_u32) {\n    PlatformAssert(frame < t->frameCount, __LOCATION__);\n\n    Animation* timeline = GetTimelineAnimation();\n    if (timeline == 0) {\n        return;\n    }\n    bool looping = timeline->loop == AnimationLoopMode::Looping;\n\n    Node2D* node = FindNodeById(t->targetNode);\n    PlatformAssert(node != 0, __LOCATION__);\n    Frame fr = node->GetIneterpolatedFrame(t, frame, looping);\n\n    if (t->targetProp == TrackType::SpriteVisibility) {\n        interp = InterpolationType::Step;\n    }\n\n    if (t->frames[frame].key && t->frames[frame].uValue == fr.uValue) {\n        if (t->frames[frame].interp == interp) {\n            return;\n        }\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    AutoKeyFrameAction* rAction = new (action)AutoKeyFrameAction(this, t, frame, interp, fr, frameVal_as_u32);\n    rAction->Redo();\n}\n\nvoid Document::SetFrame(Track* t, u32 f, InterpolationType interp) {\n    PlatformAssert(f < t->frameCount, __LOCATION__);\n    \n    Animation* timeline = GetTimelineAnimation();\n    if (timeline == 0) {\n        return;\n    }\n    bool looping = timeline->loop == AnimationLoopMode::Looping;\n\n    Node2D* node = FindNodeById(t->targetNode);\n    PlatformAssert(node != 0, __LOCATION__);\n    Frame fr = node->GetIneterpolatedFrame(t, f, looping);\n\n    if (t->targetProp == TrackType::SpriteVisibility) {\n        interp = InterpolationType::Step;\n    }\n\n    if (t->frames[f].key && t->frames[f].uValue == fr.uValue) {\n        if (t->frames[f].interp == interp) {\n            return;\n        }\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    SetFrameAction* rAction = new (action)SetFrameAction(this, t, f, interp, looping, fr);\n    rAction->Redo();\n}\n\nvoid Document::RemoveTrack(Track* track) {\n    if (!track->avtive) {\n        return;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    DeleteTrackAction* rAction = new (action)DeleteTrackAction(this, track);\n    rAction->Redo();\n}\n\nTrack* Document::AddTrack(Animation* anim, Node2D* target, TrackType type) {\n    Track* iter = anim->tracks;\n    while (iter != 0) {\n        if (target->uid == iter->targetNode) {\n            if (type == iter->targetProp) {\n                if (!iter->avtive) {\n                    StaticActionSize* action = GrabNextUndoSlot(this);\n                    ActivateTrackAction* rAction = new (action)ActivateTrackAction(this, iter);\n                    rAction->Redo();\n                }\n\n                return iter;\n            }\n        }\n        iter = iter->next;\n    }\n\n    StaticActionSize* action = GrabNextUndoSlot(this);\n    CreateTrackAction* rAction = new (action)CreateTrackAction(this, anim, target, type);\n    rAction->Redo();\n\n    return rAction->result;\n}\n\nvoid Document::RenameAnimation(Animation* anim, const char* newName) {\n    PlatformAssert(anim != 0, __LOCATION__);\n    PlatformAssert(newName != 0, __LOCATION__);\n\n    bool same = true;\n    const char* oldName = anim->name;\n\n    u32 newLen = 0;\n    for (; newName[newLen] != '\\0'; ++newLen);\n    u32 oldLen = 0;\n\n    for (; oldName[oldLen] != '\\0'; ++oldLen);\n\n    if (newLen != oldLen) {\n        same = false;\n    }\n    else {\n        for (u32 i = 0; i < newLen; ++i) {\n            if (newName[i] != oldName[i]) {\n                same = false;\n                break;\n            }\n        }\n    }\n\n    if (!same) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        RenameAnimationAction* rAction = new (action)RenameAnimationAction(this, anim, newName, newLen);\n        rAction->Redo();\n    }\n}\n\nvoid Document::RenameNode(Node2D* node, const char* newName) {\n    PlatformAssert(node != 0, __LOCATION__);\n    PlatformAssert(newName != 0, __LOCATION__);\n\n    const char* oldName = node->name;\n\n    bool same = true;\n\n    u32 newLen = 0;\n    for (; newName[newLen] != '\\0'; ++newLen);\n    u32 oldLen = 0;\n    for (; oldName[oldLen] != '\\0'; ++oldLen);\n\n    if (newLen != oldLen) {\n        same = false;\n    }\n    else {\n        for (u32 i = 0; i < newLen; ++i) {\n            if (newName[i] != oldName[i]) {\n                same = false;\n                break;\n            }\n        }\n    }\n\n    if (!same) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        RenameNodeAction* rAction = new (action)RenameNodeAction(this, node, newName);\n        rAction->Redo();\n    }\n}\n\nbool Document::UpdateSpriteTint(Node2D* node, float r, float g, float b, float a) {\n    bool exec = false;\n\n    float rDelta = MathAbsF(r - node->sprite.tintR);\n    float gDelta = MathAbsF(g - node->sprite.tintR);\n    float bDelta = MathAbsF(b - node->sprite.tintR);\n    float aDelta = MathAbsF(a - node->sprite.tintR);\n\n    if (rDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n\n    if (gDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n\n    if (bDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n\n    if (aDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n    if (exec) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        UpdateSpriteTintAction* rAction = new (action)UpdateSpriteTintAction(this, node, r, g, b, a);\n        rAction->Redo();\n    }\n\n    return exec;\n}\n\nbool Document::UpdateSpriteVisibility(Node2D* node, bool visible, i32 sortIndex) {\n    if (node->sprite.visible != visible || node->sortIndex != sortIndex) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        ChangeNodeVisibilityAction* rAction = new (action)ChangeNodeVisibilityAction(this, node, visible, sortIndex);\n        rAction->Redo();\n        return true;\n    }\n    return false;\n}\n\nbool Document::UpdateSprite(Node2D* node, i32 sX, i32 sY, i32 sW, i32 sH, f32 pX, f32 pY) {\n    PlatformAssert(node != 0, __LOCATION__);\n    \n    bool exec = false;\n\n    i32 _sx = node->sprite.sourceX;\n    i32 _sy = node->sprite.sourceY;\n    i32 _sw = node->sprite.sourceW;\n    i32 _sh = node->sprite.sourceH;\n\n    if (_sx != sX) {\n        exec = true;\n    }\n\n    if (_sy != sY) {\n        exec = true;\n    }\n\n    if (_sw != sW) {\n        exec = true;\n    }\n\n    if (_sh != sH) {\n        exec = true;\n    }\n\n    f32 xDelta = MathAbsF(node->sprite.pivotX - pX);\n    f32 yDelta = MathAbsF(node->sprite.pivotY - pY);\n\n    if (xDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n\n    if (yDelta > NODE_TRANSFORM_DELTA) {\n        exec = true;\n    }\n\n    if (exec) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        UpdateResourceRectAction* rAction = new (action)UpdateResourceRectAction(this, node, sX, sY, sW, sH, pX, pY);\n        rAction->Redo();\n    }\n\n    return exec;\n}\n\nvoid Document::UpdateSprite(Node2D* node, struct Resource* resource) {\n    PlatformAssert(node != 0, __LOCATION__);\n\n    bool exec = false;\n    if (resource != 0) {\n        if (resource->uid != node->sprite.resourceUID) {\n            exec = true;\n        }\n    }\n    else {\n        if (0 != node->sprite.resourceUID) {\n            exec = true;\n        }\n    }\n\n    if (exec) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        SetNodeResourceAction* rAction = new (action)SetNodeResourceAction(this, node, resource);\n        rAction->Redo();\n    }\n}\n\nbool Document::UpdateNodeTransformSingleF(Node2D* node, float val, TrackType type) {\n    vec2 pos = node->position;\n    vec2 scl = node->scale;\n    float rot = node->rotationAngles;\n    vec2 pivot(node->sprite.pivotX, node->sprite.pivotY);\n    i32 sort = node->sortIndex;\n\n    bool update_transform = false;\n    bool update_sprite = false;\n    bool update_sort = false;\n\n    if (type == TrackType::TransformPositionX) {\n        pos.x = val;\n        update_transform = true;\n    }\n    else if (type == TrackType::TransformPositionY) {\n        update_transform = true;\n        pos.y = val;\n    }\n    else if (type == TrackType::TransformRotation) {\n\n        rot = val;\n        update_transform = true;\n    }\n    else if (type == TrackType::TransformScaleX) {\n        scl.x = val;\n        update_transform = true;\n    }\n    else if (type == TrackType::TransformScaleY) {\n        scl.y = val;\n        update_transform = true;\n    }\n    else if (type == TrackType::SortIndex) {\n        sort = val;\n        update_sort = true;\n    }\n    else {\n        PlatformAssert(false, __LOCATION__);\n    }\n\n    i32 selectedFrame = GetSelectedFrame();\n    if (update_transform) {\n        return UpdateNodeTransform(node, pos, rot, scl);\n    }\n    if (update_sprite) {\n        return UpdateSprite(node,\n            (i32)node->sprite.sourceX,\n            (i32)node->sprite.sourceY,\n            (i32)node->sprite.sourceW,\n            (i32)node->sprite.sourceH,\n            pivot.x, pivot.y);\n    }\n    if (update_sort) {\n        return UpdateSpriteVisibility(node, node->sprite.visible, sort);\n    }\n    return false;\n}\n\nbool Document::UpdateNodeTransformSingleI(Node2D* node, i32 val, TrackType type) {\n    i32 sX = node->sprite.sourceX;\n    i32 sY = node->sprite.sourceY;\n    i32 sW = node->sprite.sourceW;\n    i32 sH = node->sprite.sourceH;\n    i32 sort = node->sortIndex;\n\n    bool updateSprite = false;\n    bool updateSort = false;\n\n    if (type == TrackType::SpriteSourceX) {\n        sX = val;\n        updateSprite = true;\n    }\n    else if (type == TrackType::SpriteSourceY) {\n        sY = val;\n        updateSprite = true;\n    }\n    else if (type == TrackType::SpriteSourceW) {\n        sW = val;\n        updateSprite = true;\n    }\n    else if (type == TrackType::SpriteSourceH) {\n        sH = val;\n        updateSprite = true;\n    }\n    else if (type == TrackType::SortIndex) {\n        sort = val;\n        updateSort = true;\n    }\n    else {\n        PlatformAssert(false, __LOCATION__);\n    }\n\n    if (updateSprite) {\n        return UpdateSprite(node, sX, sY, sW, sH, node->sprite.pivotX, node->sprite.pivotY);\n    }\n    PlatformAssert(updateSort, __LOCATION__);\n    return UpdateSpriteVisibility(node, node->sprite.visible, sort);\n}\n\nbool Document::UpdateNodeTransform(Node2D* node, const vec2& pos, float rot, const vec2& scl) {\n    PlatformAssert(node != 0, __LOCATION__);\n\n    vec2 posDelta = abs(node->position - pos);\n    float rotDelta = MathAbsF(node->rotationAngles - rot);\n    vec2 scaleDelta = abs(node->scale - scl);\n\n    bool same = true;\n    if (posDelta.x > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (posDelta.y > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (rotDelta > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (scaleDelta.x > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n    if (scaleDelta.y > NODE_TRANSFORM_DELTA) {\n        same = false;\n    }\n\n    if (!same) {\n        StaticActionSize* action = GrabNextUndoSlot(this);\n        EditTransformAction* eAction = new (action)EditTransformAction(this, node, pos, rot, scl);\n        eAction->Redo();\n        return true;\n    }\n    return false;\n}\n\nNode2D* Document::SelectNode(Node2D* node) {\n    u32 prevSelectionId = 0;\n    Node2D* prevSelect = 0;\n    if (selectedNode != 0) {\n        prevSelectionId = selectedNode->uid;\n        prevSelect = selectedNode;\n    }\n\n    u32 nodeSelectionID = 0;\n    if (selectedNode != 0 && node != 0 && selectedNode->uid == node->uid) {\n        return selectedNode;\n    }\n    else if (node != 0) {\n        nodeSelectionID = node->uid;\n    }\n    \n    StaticActionSize* action = GrabNextUndoSlot(this);\n    HierarchySelectAction* hAction = new (action) HierarchySelectAction(this, nodeSelectionID, prevSelectionId);\n    hAction->Redo();\n    return prevSelect;\n}\n\nDocument::Document(u32 numUndoSteps) :\n     numNodes(0), selectedNode(0),\n    nodeUidGenerator(0), undoStackCurrent(0),\n    timelineSelectedFrame(-1) {\n\n    if (numUndoSteps < 10) {\n        numUndoSteps = 10;\n    }\n\n    if (numUndoSteps % 2 != 0) {\n        numUndoSteps += 1;\n    }\n    u32 undoStackSize = numUndoSteps * 2 * sizeof(StaticActionSize);\n\n    rootNode = (Node2D*)MemAlloc(sizeof(Node2D));\n    MemClear(rootNode, sizeof(Node2D));\n    rootNode->scale = vec2(1, 1);\n    rootNode->refCount += 1;\n\n    undoNumSteps = numUndoSteps;\n    undoStack = (StaticActionSize*)MemAlloc(undoStackSize);\n    MemClear(undoStack, undoStackSize);\n    undoStackTop = undoStackCurrent;\n\n    // Initialize all undo actions to be null actions\n    for (u32 i = 0; i < numUndoSteps * 2; ++i) {\n        NullAction* action = new (&undoStack[i])NullAction();\n    }\n}\n\nvoid Document::ClearUndoHistory(u32 firstIndex, u32 lastIndex) {\n    if (lastIndex > undoStackTop) {\n        lastIndex = undoStackTop;\n    }\n    if (lastIndex == 0 && undoStackTop == 0) {\n        return;\n    }\n\n    PlatformAssert(firstIndex < lastIndex, __LOCATION__);\n    PlatformAssert(lastIndex >= 1, __LOCATION__);\n\n    i32 _lastIndex = lastIndex;\n    i32 _firstIndex = firstIndex;\n\n    SelectTrack(0);\n    SetSelectedFrame(-1);\n    SelectTimeline(0);\n\n    if (lastIndex >= 1) {\n        //for (i32 i = _lastIndex - 1; i >= _firstIndex; i--) {\n        // I'm sure this will come back to bite me in the ass\n        // loop forward, because if looping backward, i can\n        // get at a destroy call, without ever having seen it's \n        // create call in the stack, leaking one reference.\n        // If it's a problem later, remove the reference assert 1\n        // from the destroy action? I'm not sure if that's a good solution.\n        for (i32 i = _firstIndex; i < _lastIndex; ++i) {\n            DocumentAction* actionToUndo = (DocumentAction*)&undoStack[i];\n            actionToUndo->~DocumentAction();\n            new (actionToUndo)NullAction();\n        }\n    }\n}\n\nDocument::~Document() {\n    ClearUndoHistory(0, undoStackTop);\n    PlatformAssert(rootNode->refCount == 1, __LOCATION__);\n\n    selectedAnimation = 0;\n    timelineSelectedFrame = -1;\n    timelineLastSelectedFrame = -1;\n    timelineAnimation = 0;\n\n    {\n        Animation* anim = allAnimations; \n        while (anim != 0) {\n            Animation* to_delete = anim;\n            if (to_delete->numTracks > 0) {\n                Track* track = to_delete->tracks;\n                while (track != 0) {\n                    Track* to_delete_track = track;\n                    if (to_delete_track->frames != 0) {\n                        MemRelease(to_delete_track->frames);\n                    }\n                    MemRelease(to_delete_track);\n                    track = track->next;\n                }\n            }\n            if (to_delete->name != 0) {\n                MemRelease(to_delete->name);\n            }\n            MemRelease(to_delete);\n            anim = anim->next;\n        }\n    }\n\n    // Release the hierarchy\n    ForEachNode(rootNode, [](Node2D* node, void* userData) {\n        PlatformAssert(node->refCount == 1, __LOCATION__);\n        node->refCount -= 1;\n    }, 0);\n    RecursivleyDestroyNodeIfItHasNoReferences(rootNode);\n    rootNode = 0;\n\n    // Release any resources\n    if (resources != 0) {\n        Resource* iter = resources;\n        while (iter != 0) {\n            Resource* release = iter;\n            iter = iter->next;\n            DestroyResource(release);\n        }\n        resources = 0;\n        numResources = 0;\n    }\n\n    // Release the undo stack\n    MemRelease(undoStack);\n}\n\nStaticActionSize* GrabNextUndoSlot(Document* d) {\n    // Ran out of steps. Remove the first half of the undo stack\n    // and use the second half. I doubled the requested undo\n    // stack size to avoid having to use a doubly linked list\n    if (d->undoStackCurrent == d->undoNumSteps * 2) {\n        void* target = d->undoStack;\n        void* source = &d->undoStack[d->undoNumSteps];\n        d->ClearUndoHistory(0, d->undoNumSteps);\n        \n        MemCopy(target, source, d->undoNumSteps * sizeof(StaticActionSize));\n        d->undoStackTop -= d->undoNumSteps;\n        d->undoStackCurrent -= d->undoNumSteps;\n\n        for (i32 i = d->undoNumSteps * 2 - 1; i >= d->undoNumSteps; i--) {\n            DocumentAction* actionToUndo = (DocumentAction*)&d->undoStack[i];\n            // Destructor does not need to be called, we're just transferring ownership\n            // with that memcpy\n            new (actionToUndo)NullAction();\n        }\n    }\n    else {\n        // Abandoning old undo stack with new action, need to clean up memory\n        if (d->undoStackTop != d->undoStackCurrent) {\n            d->ClearUndoHistory(d->undoStackCurrent, d->undoStackTop);\n            d->undoStackTop = d->undoStackCurrent;\n        }\n    }\n\n    StaticActionSize* result = &d->undoStack[d->undoStackCurrent++];\n    d->undoStackTop = d->undoStackCurrent;\n\n    return result;\n}\n\nvoid Document::Undo() {\n    if (undoStackCurrent == 0) {\n        return;\n    }\n\n    StaticActionSize* genericAction = &undoStack[--undoStackCurrent];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    action->Undo();\n}\n\nvoid Document::Redo() {\n    if (undoStackCurrent >= undoStackTop) {\n        return;\n    }\n\n    StaticActionSize* genericAction = &undoStack[undoStackCurrent++];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    action->Redo();\n}\n\nconst char* Document::GetUndoStepName(u32 index) {\n    PlatformAssert(undoStackTop >= GetNumUndoSteps(), __LOCATION__);\n    u32 base = undoStackTop - GetNumUndoSteps();\n    StaticActionSize* genericAction = &undoStack[base + index];\n    DocumentAction* action = (DocumentAction*)genericAction;\n    return action->Name();\n}","#ifndef _H_DOCUMENT_\n#define _H_DOCUMENT_\n\n#include \"Node2D.h\"\n#include \"../framework/draw2d.h\"\n#include \"../framework/Transform.h\"\n\nstruct Resource {\n    u32 uid;\n\n    char* name;\n    u32 nameLen;\n    void* data;\n    u32 size;\n    u32 image;\n    Draw2D::Interpolation filter;\n    u32 width;\n    u32 height;\n\n    Resource* next;\n    Resource* prev;\n};\n\ntypedef void (*OnResourceLoaded)(const char* path, const Resource& resource, void* userData);\n\n\n\ninline const char* TrackTypeToString(TrackType trackType) {\n    if (trackType == TrackType::TransformPositionX) {\n        return \".Position.X\";\n    }\n    else if (trackType == TrackType::TransformPositionY) {\n        return \".Position.Y\";\n    }\n    else if (trackType == TrackType::TransformRotation) {\n        return \".Rotation\";\n    }\n    else if (trackType == TrackType::TransformScaleX) {\n        return \".ScaleX\";\n    }\n    else if (trackType == TrackType::TransformScaleY) {\n        return \".ScaleY\";\n    }\n    else if (trackType == TrackType::SpriteTintR) {\n        return \".Tint.R\";\n    }\n    else if (trackType == TrackType::SpriteTintG) {\n        return \".Tint.G\";\n    }\n    else if (trackType == TrackType::SpriteTintB) {\n        return \".Tint.B\";\n    }\n    else if (trackType == TrackType::SpriteVisibility) {\n        return \".Visibility\";\n    }\n    else if (trackType == TrackType::SpriteSourceX) {\n        return \".Sprite.X\";\n    }\n    else if (trackType == TrackType::SpriteSourceY) {\n        return \".Sprite.Y\";\n    }\n    else if (trackType == TrackType::SpriteSourceW) {\n        return \".Sprite.W\";\n    }\n    else if (trackType == TrackType::SpriteSourceH) {\n        return \".Sprite.H\";\n    }\n    else if (trackType == TrackType::SortIndex) {\n        return \".SortIndex\";\n    }\n    \n    return \"[NULL]\";\n}\n\n\nstruct Document {\n    friend struct CreateNodeAction;\n    friend struct DeleteNodeAction;\n    friend struct HierarchySelectAction;\n    friend struct RearrangeNodeAction;\n    friend struct CreateAnimationAction;\n    friend struct DeleteAnimationAction;\n    friend struct StaticActionSize* GrabNextUndoSlot(Document*);\npublic:\n    u32 nodeUidGenerator;\n    u32 resourceUidGenerator;\n    u32 animationUidGenerator;\n\n    Node2D* rootNode;\n    u32 numNodes;\n    Node2D* selectedNode;\n\n    Resource* resources;\n    u32 numResources;\n    Resource* selectedResource;\n\n    struct StaticActionSize* undoStack;\n    u32 undoNumSteps;\n    u32 undoStackTop;\n    u32 undoStackCurrent; // 1 past the last undo\n    void ClearUndoHistory(u32 firstIndex, u32 lastIndex);\n\n    Animation* allAnimations;\n    Animation* selectedAnimation;\n    u32 numAnimations;\n\n    Animation* timelineAnimation;\n    Track* selectedTrack;\n    i32 timelineSelectedFrame;\n    i32 timelineLastSelectedFrame;\n\n    i32 needsEndOfFrameUpdate;\n    i32 selectedInterpolationType;\n\n    float GetLocalProp(Node2D* node, TrackType trackType);\npublic:\n    Document(u32 numUndoSteps);\n    ~Document();\n\n    Node2D* FindNodeById(u32 nodeId);\n    Resource* FindResourceById(u32 resourceId);\n    Animation* FindAnimationById(u32 animId);\n\n    void Undo();\n    void Redo();\n    const char* GetUndoStepName(u32 index);\n\n    Node2D* CreateNode(Node2D* parent);\n    void DeleteNode(Node2D* node); // \n    Node2D* SelectNode(Node2D* node); // Returns previous selection\n    void RenameNode(Node2D* node, const char* newName);\n    bool UpdateNodeTransform(Node2D* node, const vec2& pos, float rot, const vec2& scl);\n    bool UpdateNodeTransformSingleF(Node2D* node, float val, TrackType type);\n    bool UpdateNodeTransformSingleI(Node2D* node, i32 val, TrackType type);\n\n    Animation* CreateAnimation(const char* optName = 0);\n    void SelectAnimation(Animation* anim);\n    void DeleteAnimation(Animation* anim);\n    void RenameAnimation(Animation* anim, const char* name);\n    void UpdateAnimation(Animation* anim, u32 frameCount, u32 frameRate, AnimationLoopMode loop);\n    Track* AddTrack(Animation* anim, Node2D* target, TrackType type);\n    void RemoveTrack(Track* track);\n    void SetFrame(Track* t, u32 frame, InterpolationType interp);\n    void AutoKeyFrameValue(Track* t, u32 frame, InterpolationType interp, u32 frame_value_as_u32);\n    void ClearFrame(Track* t, u32 frame);\n    void SetSelectedFrame(i32 frame);\n\n    void RearrangeNode(Node2D& nodeToInsert, Node2D& parent, Node2D* prevSibling);\n\n    //void UpdateSprite(Node2D* node, struct Resource* resource, float sourceX, float sourceY, float sourceW, float sourceH, float pivotX, float pivotY, float tintR, float tintG, float tintB, float tintA);\n    void UpdateSprite(Node2D* node, struct Resource* resource);\n    bool UpdateSprite(Node2D* node, i32 sX, i32 sY, i32 sW, i32 sH, f32 pX, f32 pY);\n    bool UpdateSpriteVisibility(Node2D* node, bool visible, i32 sortIndex);\n    bool UpdateSpriteTint(Node2D* node, float r, float g, float b, float a);\n\n    void RequestResource(OnResourceLoaded onLoad, void* userData);\n    Resource* LoadResource(const char* displayPath, void* resourceData, u32 bytes);\n    void DestroyResource(Resource* resource);\n    u32 GetReferenceCount(Resource* resource);\n\n    Node2D* DepthFirst(Node2D* iter);\n    Node2D* DepthFirstExpandedOnly(Node2D* iter);\n    Node2D* Sorted(Node2D* iter);\n    Node2D* SortedVisibleOnly(Node2D* iter);\n\n    void EndOfFrame(bool autoKey);\n    void NewDocument();\n\n    Transform GetLocalTransform(Node2D* node);\n    Transform GetWorldTransform(Node2D* node);\npublic:\n    inline Track* GetSelectedTrack() {\n        return selectedTrack;\n    }\n\n    void SelectTrack(Track* track) {\n        if (track != 0) {\n            PlatformAssert(timelineAnimation != 0, __LOCATION__);\n        }\n        selectedTrack = track;\n    }\n\n    inline int GetInterpolationIndex() {\n        return selectedInterpolationType;\n    }\n\n    inline void SetInterpolationIndex(i32 val) {\n        selectedInterpolationType = val;\n        PlatformAssert(val >= 0, __LOCATION__);\n        PlatformAssert(val <= 4, __LOCATION__);\n    }\n\n    inline InterpolationType GetSelectedInterpolationType() {\n        if (selectedInterpolationType == 0) {\n            return InterpolationType::Linear;\n        }\n        else if (selectedInterpolationType == 1) {\n            return InterpolationType::Step;\n        }\n        else if (selectedInterpolationType == 2) {\n            return InterpolationType::EaseIn;\n        }\n        else if (selectedInterpolationType == 3) {\n            return InterpolationType::EaseOut;\n        }\n        else if (selectedInterpolationType == 4) {\n            return InterpolationType::EaseInOut;\n        }\n        PlatformAssert(false, __LOCATION__);\n        return InterpolationType::Linear;\n    }\n\n    inline Animation* GetTimelineAnimation() { return timelineAnimation; }\n\n    inline void SelectTimeline(Animation* anim) {\n        if (anim != timelineAnimation) {\n            selectedTrack = 0;\n        }\n        timelineAnimation = anim;\n    }\n\n    inline Node2D* GetSelectedNode() {\n        return selectedNode;\n    }\n\n    inline u32 GetNodeCount() {\n        return numNodes;\n    }\n\n    inline i32 GetSelectedFrame() {\n        return timelineSelectedFrame;\n    }\n\n    inline i32 GetLastSelectedFrame() {\n        return timelineLastSelectedFrame;\n    }\n\n    inline u32 GetVisibleNodeCount() {\n        u32 count = 0;\n        Node2D* iter = DepthFirstExpandedOnly(0);\n        iter = DepthFirstExpandedOnly(iter);\n        while (iter != 0) {\n            count += 1;\n            iter = DepthFirstExpandedOnly(iter);\n        }\n        return count;\n    }\n\n    inline bool CanRedo() {\n        return undoStackCurrent < undoStackTop;\n    }\n\n    inline bool CanUndo() {\n        u32 undoStackBottom = undoStackTop < undoNumSteps ? 0 : undoStackTop - undoNumSteps;\n        PlatformAssert(undoStackCurrent >= undoStackBottom, __LOCATION__);\n        u32 current = undoStackCurrent - undoStackBottom;\n        return current != 0;\n    }\n\n    inline u32 GetNumUndoSteps() {\n        return (undoStackTop > undoNumSteps) ? undoNumSteps : undoStackTop;\n    }\n\n    inline u32 GetUndoStackCurrent()  {\n        u32 undoStackBottom = undoStackTop < undoNumSteps? 0 : undoStackTop - undoNumSteps;\n        PlatformAssert(undoStackCurrent >= undoStackBottom, __LOCATION__);\n        return undoStackCurrent - undoStackBottom;\n    }\n\n    inline u32 GetMaxUndoSteps() {\n        return undoNumSteps;\n    }\n\n    inline u32 GetNumResources() {\n        return numResources;\n    }\n\n    inline Resource* GetSelectedResource() {\n        return selectedResource;\n    }\n\n    inline Animation* GetSelectedAnimation() {\n        return selectedAnimation;\n    }\n\n    inline Resource* ResourceIterator(Resource* iter) {\n        if (iter == 0) {\n            return resources;\n        }\n\n        return iter->next;\n    }\n\n    inline Track* TrackIterator(Track* iter) {\n        if (iter == 0) {\n            return selectedTrack;\n        }\n\n        return iter->next;\n    }\n\n    inline Track* TrackIterator(Animation* iter) {\n        return iter->tracks;\n    }\n\n    inline Animation* AnimationIterator(Animation* anim) {\n        if (anim == 0) {\n            return allAnimations;\n        }\n\n        return anim->next;\n    }\n\n    inline u32 GetNumAnimations() {\n        return numAnimations;\n    }\n\n    \n\n    inline void SelectResource(Resource* resource) {\n        selectedResource = resource;\n    }\n\n    inline void ClearUndoHistory() {\n        ClearUndoHistory(0, undoStackTop);\n        undoStackTop = 0;\n        undoStackCurrent = 0;\n    }\n\n    u32 SaveInto(void* dest);\n    inline u32 GetSaveSizeBytes() {\n        u32 HEADER_SIZE = (8 * 4 + 6 * 8);\n        u32 NODE_SIZE = (22 * 4 + 1 * 8);\n        u32 RESOURCE_SIZE = (4 * 4 + 2 * 8);\n        u32 ANIMATION_SIZE = (6 * 4 + 2 * 8);\n        u32 TRACK_SIZE = (4 * 4 + 2 * 8);\n        u32 FRAME_SIZE = (4 * 4);\n\n\n        u32 totalTracks = 0;\n        u32 totalFrames = 0;\n        for (Animation* anim = allAnimations; anim != 0; anim = anim->next) {\n            for (Track* track = anim->tracks; track != 0; track = track->next) {\n                if (track->avtive) {\n                    totalTracks += 1;\n                    totalFrames += track->numKeyFrames;\n                }\n            }\n        }\n\n        u32 stringBytes = 0;\n        for (Node2D* iter = DepthFirst(0); iter != 0; iter = DepthFirst(iter)) {\n            stringBytes = iter->nameLength + 1;\n            stringBytes += 5; // Potential padding\n        }\n        for (Resource* iter = resources; iter != 0; iter = iter->next) {\n            PlatformAssert(iter->name != 0, __LOCATION__);\n            u32 len = 0;\n            for (; iter->name[len] != '\\0'; ++len);\n            stringBytes += len;\n            stringBytes += 5; // Potential padding\n        }\n        for (Animation* iter = allAnimations; iter != 0; iter = iter->next) {\n            PlatformAssert(iter->name != 0, __LOCATION__);\n            u32 len = 0;\n            for (; iter->name[len] != '\\0'; ++len);\n            stringBytes += len;\n            stringBytes += 5; // Potential padding\n        }\n\n        u32 resourceDataBytes = 0;\n        for (Resource* iter = resources; iter != 0; iter = iter->next) {\n            resourceDataBytes += iter->size;\n        }\n\n        u32 stampSize = 16;\n\n        return stampSize + HEADER_SIZE +\n            (numNodes + 1) * NODE_SIZE +\n            RESOURCE_SIZE * numResources +\n            ANIMATION_SIZE * numAnimations +\n            TRACK_SIZE * totalTracks +\n            FRAME_SIZE * totalFrames +\n            stringBytes + resourceDataBytes + stampSize + 128;\n    }\n};\n\n#endif","#ifndef _H_TRANSFORM2D_\n#define _H_TRANSFORM2D_\n\n#include \"../platform/memory.h\"\n#include \"../platform/assert.h\"\n#include \"../platform/math.h\"\n#include \"../framework/vec2.h\"\n\n#define NODE2D_DEFAULT_NAME_CAPACITY 36\n\nenum class TrackType {\n\tTransformPositionX = 0,\n\tTransformPositionY = 1,\n\tTransformRotation = 2,\n\tTransformScaleX = 3,\n\tTransformScaleY = 4,\n\tSpriteTintR = 5,\n\tSpriteTintG = 6,\n\tSpriteTintB = 7,\n\tSpriteVisibility = 8,\n\tSpriteSourceX = 9,\n\tSpriteSourceY = 10,\n\tSpriteSourceW = 11,\n\tSpriteSourceH = 12,\n\tSortIndex = 13,\n};\n\nenum class InterpolationType {\n\tLinear = 0,\n\tStep = 1,\n\tEaseIn = 2,\n\tEaseOut = 3,\n\tEaseInOut = 4\n};\n\nenum class AnimationLoopMode {\n\tNone = 0,\n\tLooping = 1\n};\n\nstruct Frame {\n\tunion {\n\t\tf32 fValue;\n\t\tu32 uValue;\n\t\ti32 iValue;\n\t\tbool bValue;\n\t};\n\n\tbool key;\n\tInterpolationType interp;\n};\n\nstruct TrackKarrat {\n\tstruct {\n\t\tunion {\n\t\t\tf32 prevF;\n\t\t\ti32 prevI;\n\t\t\tu32 prevU;\n\t\t\tbool prevB;\n\t\t};\n\t};\n\ti32 prev_frame;\n\tstruct {\n\t\tunion {\n\t\t\tf32 nextF;\n\t\t\ti32 nextI;\n\t\t\tu32 nextU;\n\t\t\tbool nextB;\n\t\t};\n\t};\n\ti32 next_frame;\n\tfloat t;\n};\n\nstruct Track {\n\tu32 targetNode;\n\tTrackType targetProp;\n\tbool avtive; // Deleting does not clear memory\n\n\tFrame* frames;\n\tu32 frameCount;\n\tu32 frameCapacity;\n\n\tu32 numKeyFrames;\n\n\tTrack* prev;\n\tTrack* next;\n\nprivate:\n\tTrackKarrat Seek(i32 _frame, u32 valueAt0, AnimationLoopMode looping) {\n\t\tTrackKarrat result = { 0 };\n\t\t// Initialize prev to the value of the last key frame. Then search.\n\t\t\t\t\t\t\t// If search finds a last keyframe, replace frame 0.\n\t\tresult.prevU = valueAt0;\n\t\tif (frames[0].key) {\n\t\t\tresult.prevU = frames[0].uValue;\n\t\t}\n\n\t\tif (frames[_frame].key) {\n\t\t\tresult.prev_frame = _frame;\n\t\t\tresult.prevU = frames[_frame].uValue;\n\t\t}\n\t\telse {\n\t\t\tresult.prev_frame = 0;\n\t\t\tfor (i32 f = _frame - 1; f >= 0; --f) {\n\t\t\t\tif (frames[f].key) {\n\t\t\t\t\tresult.prevU = frames[f].uValue;\n\t\t\t\t\tresult.prev_frame = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// next is a bit different. We start by setting the else case as the default\n\t\t// then replacing the value if either of the if cases are true\n\t\t// if (the animation is looping && frame 0 is a keyframe)\n\t\t//     Initial value is the keyframe\n\t\t// else if (the animation is looping && frame 0 is not a keyframe)\n\t\t//     Initial value is the hierarchy value\n\t\t// else (the animation is not looping)\n\t\t//     Initial value is the same as the previous frame\n\t\t// But, that triage of if statements is just the INITIAL VALUE. After that,\n\t\t// we search every frame, and if there is a real next one, override all that work\n\t\tresult.nextU = result.prevU;\n\t\tif (looping == AnimationLoopMode::Looping) {\n\t\t\tif (frames[0].key) {\n\t\t\t\tresult.nextU = frames[0].uValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.nextU = valueAt0;\n\t\t\t}\n\t\t}\n\t\tresult.next_frame = frameCount - 1;\n\t\tfor (i32 f = _frame + 1; f < frameCount; ++f) {\n\t\t\tif (frames[f].key) {\n\t\t\t\tresult.nextU = frames[f].uValue;\n\t\t\t\tresult.next_frame = f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult.t = 0.0f;\n\t\tif (result.next_frame != result.prev_frame) {\n\t\t\tresult.t = (float)(_frame - result.prev_frame) / (float)(result.next_frame - result.prev_frame);\n\t\t}\n\n\t\treturn result;\n\t}\npublic:\n\tinline bool InterpolateB(i32 _frame, bool valueAt0, AnimationLoopMode looping) {\n\t\tFrame tmp = { 0 };\n\t\ttmp.bValue = valueAt0;\n\t\tTrackKarrat playhead = Seek(_frame, tmp.uValue, looping);\n\t\tPlatformAssert(playhead.t >= 0.0f && playhead.t <= 1.0f, __LOCATION__);\n\t\treturn playhead.prevB;\n\t}\n\n\tinline i32 InterpolateI(i32 _frame, i32 valueAt0, AnimationLoopMode looping) {\n\t\tFrame tmp = { 0 };\n\t\ttmp.iValue = valueAt0;\n\t\tTrackKarrat playhead = Seek(_frame, tmp.uValue, looping);\n\n\t\tPlatformAssert(playhead.t >= 0.0f && playhead.t <= 1.0f, __LOCATION__);\n\n\t\tInterpolationType interp = InterpolationType::Linear;\n\t\tif (frames[playhead.prev_frame].key) {\n\t\t\tinterp = frames[playhead.prev_frame].interp;\n\t\t}\n\t\tif (targetProp == TrackType::SpriteVisibility || targetProp == TrackType::SortIndex) {\n\t\t\tinterp = InterpolationType::Step;\n\t\t}\n\n\t\tfloat t = playhead.t;\n\t\tif (interp == InterpolationType::Step) {\n\t\t\tt = 0.0f;\n\t\t}\n\t\telse if (interp == InterpolationType::EaseIn) {\n\t\t\tt = playhead.t * playhead.t * playhead.t;\n\t\t}\n\t\telse if (interp == InterpolationType::EaseOut) {\n\t\t\tt = 1.0f - MathPow(1.0f - playhead.t, 3.0f);\n\t\t}\n\t\telse if (interp == InterpolationType::EaseInOut) {\n\t\t\tt = playhead.t < 0.5 ?\n\t\t\t\t4.0f * playhead.t * playhead.t * playhead.t :\n\t\t\t\t1.0f - MathPow(-2.0f * playhead.t + 2.0f, 3.0f) / 2.0f;\n\t\t}\n\t\telse if (interp != InterpolationType::Linear) {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\n\t\tfloat interpolated_value = (float)playhead.prevI + (float)(playhead.nextI - playhead.prevI) * t;\n\n\t\treturn interpolated_value + 0.5f;\n\t}\n\n\t// valueAt0 = selectedNode->position.x\n\tinline float InterpolateF(i32 _frame, float valueAt0, AnimationLoopMode looping) {\n\t\tFrame tmp = { 0 };\n\t\ttmp.fValue = valueAt0;\n\t\tTrackKarrat playhead = Seek(_frame, tmp.uValue, looping);\n\t\t\n\t\tPlatformAssert(playhead.t >= 0.0f && playhead.t <= 1.0f, __LOCATION__);\n\n\t\tInterpolationType interp = InterpolationType::Linear;\n\t\tif (frames[playhead.prev_frame].key) {\n\t\t\tinterp = frames[playhead.prev_frame].interp;\n\t\t}\n\t\tif (targetProp == TrackType::SpriteVisibility || targetProp == TrackType::SortIndex) {\n\t\t\tinterp = InterpolationType::Step;\n\t\t}\n\n\t\tfloat t = playhead.t;\n\t\tif (interp == InterpolationType::Step) {\n\t\t\tt = 0.0f;\n\t\t}\n\t\telse if (interp == InterpolationType::EaseIn) {\n\t\t\tt = playhead.t * playhead.t * playhead.t;\n\t\t}\n\t\telse if (interp == InterpolationType::EaseOut) {\n\t\t\tt = 1.0f - MathPow(1.0f - playhead.t, 3.0f);\n\t\t}\n\t\telse if (interp == InterpolationType::EaseInOut) {\n\t\t\tt = playhead.t < 0.5 ? \n\t\t\t\t4.0f * playhead.t * playhead.t * playhead.t : \n\t\t\t\t1.0f - MathPow(-2.0f * playhead.t + 2.0f, 3.0f) / 2.0f;\n\t\t}\n\t\telse if (interp != InterpolationType::Linear) {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\n\t\t// Linear\n\t\tfloat interpolated_value = playhead.prevF + (playhead.nextF - playhead.prevF) * t;\n\n\t\treturn interpolated_value;\n\t}\n\nprotected:\n\tinline void ReserveFrames(u32 cap) {\n\t\tif (cap == 0) {\n\t\t\tcap = 1;\n\t\t}\n\t\tif (cap > frameCapacity) {\n\t\t\tframes = (Frame*)MemRealloc(frames, sizeof(Frame) * cap);\n\t\t\tframeCapacity = cap;\n\t\t}\n\t}\npublic:\n\tinline void Resize(u32 size) {\n\t\tReserveFrames(size);\n\n\t\tif (size > frameCapacity) {\n\t\t\tfor (u32 i = frameCount; i < size; ++i) {\n\t\t\t\tframes[i].key = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint iSize = size;\n\t\t\tint iCount = frameCount;\n\t\t\tfor (int i = iSize; i >= iCount; --i) {\n\t\t\t\t//frames[i].Deactivate();\n\t\t\t}\n\t\t}\n\t\tframeCount = size;\n\t}\n};\n\nstruct SpriteComponent {\n\tfloat sourceX;\n\tfloat sourceY;\n\tfloat sourceW;\n\tfloat sourceH;\n\tfloat pivotX;\n\tfloat pivotY;\n\tfloat tintR;\n\tfloat tintG;\n\tfloat tintB;\n\tfloat tintA;\n\tbool  visible;\n\tu32   resourceUID;\n};\n\nclass Document;\ntypedef  int (Document::* SetFramePtrBecauseIDidntThinkThisTrough)(Track* t, u32 frame, InterpolationType interp);  // Please do this!\n\nstruct Node2D {\n\tu32 uid;\n\n\tchar* name;\n\tu32 nameLength;\n\tu32 nameCapacity;\n\n\tNode2D* parent;\n\tNode2D* firstChild;\n\tNode2D* next;\n\tu32 depth;\n\n\tu32 refCount;\n\n\ti32 sortIndex;\n\ti32 anim_sortIndex;\n\tbool anim_sortIndex_dirty;\n\tNode2D* sortedPrev;\n\tNode2D* sortedNext;\n\n\tvec2 position;\n\tfloat rotationAngles;\n\tvec2 scale;\n\n\tfloat minRotation;\n\tfloat maxRotation;\n\n\tvec2 anim_position;\n\tfloat anim_rotationAngles;\n\tvec2 anim_scale;\n\n\tbool anim_positionX_dirty;\n\tbool anim_positionY_dirty;\n\tbool anim_rotation_dirty;\n\tbool anim_scaleX_dirty;\n\tbool anim_scaleY_dirty;\n\n\tSpriteComponent sprite;\n\tSpriteComponent anim_sprite;\n\n\tbool anim_sourceX_dirty;\n\tbool anim_sourceY_dirty;\n\tbool anim_sourceW_dirty;\n\tbool anim_sourceH_dirty;\n\tbool anim_tintR_dirty;\n\tbool anim_tintG_dirty;\n\tbool anim_tintB_dirty;\n\tbool anim_tintA_dirty;\n\tbool anim_visible_dirty;\n\n\tbool transformToolActive;\n\tbool uiVisible;\n\tbool uiExpanded;\n\n\ttemplate<typename T>\n\tinline void SetBuffered(TrackType type, T v) {\n\t\tif (type == TrackType::TransformPositionX) {\n\t\t\tanim_position.x = v;\n\t\t\tanim_positionX_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::TransformPositionY) {\n\t\t\tanim_position.y = v;\n\t\t\tanim_positionY_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::TransformRotation) {\n\t\t\t\n\t\t\tanim_rotationAngles = v;\n\t\t\tanim_rotation_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleX) {\n\t\t\tanim_scale.x = v;\n\t\t\tanim_scaleX_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleY) {\n\t\t\tanim_scale.y = v;\n\t\t\tanim_scaleY_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintR) {\n\t\t\tanim_sprite.tintR = v;\n\t\t\tanim_tintR_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintG) {\n\t\t\tanim_sprite.tintG = v;\n\t\t\tanim_tintG_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintB) {\n\t\t\tanim_sprite.tintB = v;\n\t\t\tanim_tintB_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteVisibility) {\n\t\t\tanim_sprite.visible = v;\n\t\t\tanim_visible_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceX) {\n\t\t\tanim_sprite.sourceX = v;\n\t\t\tanim_sourceX_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceY) {\n\t\t\tanim_sprite.sourceY = v;\n\t\t\tanim_sourceY_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceW) {\n\t\t\tanim_sprite.sourceW = v;\n\t\t\tanim_sourceW_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceH) {\n\t\t\tanim_sprite.sourceH = v;\n\t\t\tanim_sourceH_dirty = true;\n\t\t}\n\t\telse if (type == TrackType::SortIndex) {\n\t\t\tanim_sortIndex = v;\n\t\t\tanim_sortIndex_dirty = true;\n\t\t}\n\t\telse {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline T GetPropertyBuffer(TrackType type) {\n\t\tif (type == TrackType::TransformPositionX) {\n\t\t\treturn anim_position.x;\n\t\t}\n\t\telse if (type == TrackType::TransformPositionY) {\n\t\t\treturn anim_position.y;\n\t\t}\n\t\telse if (type == TrackType::TransformRotation) {\n\t\t\treturn anim_rotationAngles;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleX) {\n\t\t\treturn anim_scale.x;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleY) {\n\t\t\treturn anim_scale.y;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintG) {\n\t\t\treturn anim_sprite.tintG;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintR) {\n\t\t\treturn anim_sprite.tintR;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintB) {\n\t\t\treturn anim_sprite.tintB;\n\t\t}\n\t\telse if (type == TrackType::SpriteVisibility) {\n\t\t\treturn anim_sprite.visible;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceX) {\n\t\t\treturn anim_sprite.sourceX;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceY) {\n\t\t\treturn anim_sprite.sourceY;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceW) {\n\t\t\treturn anim_sprite.sourceW;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceH) {\n\t\t\treturn anim_sprite.sourceH;\n\t\t}\n\t\telse if (type == TrackType::SortIndex) {\n\t\t\treturn anim_sortIndex;\n\t\t}\n\t\telse {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\t\t\n\t\treturn (T)0;\n\t}\n\n\ttemplate<typename T>\n\tinline float GetProperty(TrackType type) {\n\t\tif (type == TrackType::TransformPositionX) {\n\t\t\treturn position.x;\n\t\t}\n\t\telse if (type == TrackType::TransformPositionY) {\n\t\t\treturn position.y;\n\t\t}\n\t\telse if (type == TrackType::TransformRotation) {\n\t\t\treturn rotationAngles;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleX) {\n\t\t\treturn scale.x;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleY) {\n\t\t\treturn scale.y;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintR) {\n\t\t\treturn sprite.tintR;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintG) {\n\t\t\treturn sprite.tintG;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintB) {\n\t\t\treturn sprite.tintB;\n\t\t}\n\t\telse if (type == TrackType::SpriteVisibility) {\n\t\t\treturn sprite.visible;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceX) {\n\t\t\treturn sprite.sourceX;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceY) {\n\t\t\treturn sprite.sourceY;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceW) {\n\t\t\treturn sprite.sourceW;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceH) {\n\t\t\treturn sprite.sourceH;\n\t\t}\n\t\telse if (type == TrackType::SortIndex) {\n\t\t\treturn sortIndex;\n\t\t}\n\t\telse {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\n\t\treturn (T)0;\n\t}\n\n\t// Resets cached flag, call only once!\n\tinline Frame GetIneterpolatedFrame(Track* t, u32 f, bool _looping) {\n\t\tAnimationLoopMode looping = _looping? AnimationLoopMode::Looping : AnimationLoopMode::None;\n\t\tFrame unionFrame = { 0 };\n\t\tTrackType trackType = t->targetProp;\n\n\t\tif (trackType == TrackType::TransformPositionX) {\n\t\t\tif (anim_positionX_dirty) {\n\t\t\t\tunionFrame.fValue = anim_position.x;\n\t\t\t\tanim_positionX_dirty = false;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, position.x, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::TransformPositionY) {\n\t\t\tif (anim_positionY_dirty) {\n\t\t\t\tunionFrame.fValue = anim_position.y;\n\t\t\t\tanim_positionY_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, position.y, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::TransformRotation) {\n\t\t\tif (anim_rotation_dirty) {\n\t\t\t\tunionFrame.fValue = anim_rotationAngles;\n\t\t\t\tanim_rotation_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, rotationAngles, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::TransformScaleX) {\n\t\t\tif (anim_scaleX_dirty) {\n\t\t\t\tunionFrame.fValue = anim_scale.x;\n\t\t\t\tanim_scaleX_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, scale.x, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::TransformScaleY) {\n\t\t\tif (anim_scaleY_dirty) {\n\t\t\t\tunionFrame.fValue = anim_scale.y;\n\t\t\t\tanim_scaleY_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, scale.y, looping);\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if (trackType == TrackType::SpriteTintR) {\n\t\t\tif (anim_tintR_dirty) {\n\t\t\t\tunionFrame.fValue = anim_sprite.tintR;\n\t\t\t\tanim_tintR_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, sprite.tintR, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteTintG) {\n\t\t\tif (anim_tintG_dirty) {\n\t\t\t\tunionFrame.fValue = anim_sprite.tintG;\n\t\t\t\tanim_tintG_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, sprite.tintG, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteTintB) {\n\t\t\tif (anim_tintB_dirty) {\n\t\t\t\tunionFrame.fValue = anim_sprite.tintB;\n\t\t\t\tanim_tintB_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.fValue = t->InterpolateF(f, sprite.tintB, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteVisibility) {\n\t\t\tif (anim_visible_dirty) {\n\t\t\t\tunionFrame.bValue = anim_sprite.visible;\n\t\t\t\tanim_visible_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.bValue = t->InterpolateB(f, sprite.visible, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteSourceX) {\n\t\t\tif (anim_sourceX_dirty) {\n\t\t\t\tunionFrame.iValue = anim_sprite.sourceX;\n\t\t\t\tanim_sourceX_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.iValue = t->InterpolateI(f, sprite.sourceX, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteSourceY) {\n\t\t\tif (anim_sourceY_dirty) {\n\t\t\t\tunionFrame.iValue = anim_sprite.sourceY;\n\t\t\t\tanim_sourceY_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.iValue = t->InterpolateI(f, sprite.sourceY, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteSourceW) {\n\t\t\tif (anim_sourceW_dirty) {\n\t\t\t\tunionFrame.iValue = anim_sprite.sourceW;\n\t\t\t\tanim_sourceW_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.iValue = t->InterpolateI(f, sprite.sourceW, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SpriteSourceH) {\n\t\t\tif (anim_sourceH_dirty) {\n\t\t\t\tunionFrame.iValue = anim_sprite.sourceH;\n\t\t\t\tanim_sourceH_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.iValue = t->InterpolateI(f, sprite.sourceH, looping);\n\t\t\t}\n\t\t}\n\t\telse if (trackType == TrackType::SortIndex) {\n\t\t\tif (anim_sortIndex_dirty) {\n\t\t\t\tunionFrame.iValue = anim_sortIndex;\n\t\t\t\tanim_sortIndex_dirty = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionFrame.iValue = t->InterpolateI(f, sortIndex, looping);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\n\t\treturn unionFrame;\n\t}\n\n\tinline bool IsPropertyDirty(TrackType type) {\n\t\tif (type == TrackType::TransformPositionX) {\n\t\t\treturn anim_positionX_dirty;\n\t\t}\n\t\telse if (type == TrackType::TransformPositionY) {\n\t\t\treturn anim_positionY_dirty;\n\t\t}\n\t\telse if (type == TrackType::TransformRotation) {\n\t\t\treturn anim_rotation_dirty;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleX) {\n\t\t\treturn anim_scaleX_dirty;\n\t\t}\n\t\telse if (type == TrackType::TransformScaleY) {\n\t\t\treturn anim_scaleY_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintR) {\n\t\t\treturn anim_tintR_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintG) {\n\t\t\treturn anim_tintG_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteTintB) {\n\t\t\treturn anim_tintB_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteVisibility) {\n\t\t\treturn anim_visible_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceX) {\n\t\t\treturn anim_sourceX_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceY) {\n\t\t\treturn anim_sourceY_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceW) {\n\t\t\treturn anim_sourceW_dirty;\n\t\t}\n\t\telse if (type == TrackType::SpriteSourceH) {\n\t\t\treturn anim_sourceH_dirty;\n\t\t}\n\t\telse if (type == TrackType::SortIndex) {\n\t\t\treturn anim_sortIndex_dirty;\n\t\t}\n\t\telse {\n\t\t\tPlatformAssert(false, __LOCATION__);\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstruct Animation {\n\tu32 uid;\n\tchar* name;\n\ti32 refCount;\n\n\tu32 frameCount;\n\tu32 frameRate;\n\n\tAnimationLoopMode loop;\n\n\tTrack* tracks;\n\tu32 numTracks;\n\n\tAnimation* prev;\n\tAnimation* next;\n\n\tinline f32 GetDuration() {\n\t\treturn (f32)frameCount / (f32)frameRate;\n\t}\n\n\tinline f32 FrameDuration() {\n\t\treturn 1.0f / (f32)frameRate;\n\t}\n\n\tinline f32 FrameDurationMs() {\n\t\treturn 1000.0f / (f32)frameRate;\n\t}\n\n\tvoid ReleaseMemory();\n\n\tinline Track* Contains(Node2D* node, TrackType type) {\n\t\tif (node == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tu32 nodeId = node->uid;\n\t\tfor (Track* i = tracks; i != 0; i = i->next) {\n\t\t\tif (i->targetNode == nodeId && i->avtive && i->targetProp == type) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nstruct SerializedHierarchy {\n\tNode2D* root;\n\tvoid* data;\n};\n\n#if 0\nSerializedHierarchy Serialize(Node2D* node);\nNode2D* Deserialize(SerializedHierarchy* data);\n#endif\n\ntypedef void (NodeVisitor)(Node2D* node, void* userData);\nvoid RecursivleyDestroyNode(Node2D* node); // Unhook & delete. Recursive in name only.\nvoid ForEachNode(Node2D* node, NodeVisitor callback, void* userData);\n\nNode2D* GetLastChild(Node2D& node);\nNode2D* GetChildById(Node2D& node, u32 uid);\nbool RemoveChild(Node2D& parent, Node2D& child);\n// Made these into private APIs\n//bool AddChild(Node2D& parent, Node2D& child);\n//bool AddChild(Node2D& parent, Node2D& child, u32 lastSibling);\nvoid SetParent(Node2D* parent, Node2D& child);\nvoid SetParent(Node2D* parent, Node2D& child, u32 lastSibling);\nvoid SetName(Node2D& node, const char* name);\n\nu32 CountDescendants(Node2D* node);\n\n// Returns true if released\nbool RecursivleyDestroyNodeIfItHasNoReferences(Node2D* node);\n\n#endif // !_H_TRANSFORM2D_\n"],"mappings":"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"}