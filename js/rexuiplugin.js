(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexuiplugin = factory());
  })(this, (function () { 'use strict';
  
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      } catch (t) {}
      return (_isNativeReflectConstruct = function () {
        return !!t;
      })();
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e,
          n,
          i,
          u,
          a = [],
          f = !0,
          o = !1;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = !1;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
          o = !0, n = r;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function (r) {
          return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
          _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
      }
      return e;
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function () {
        return e;
      };
      var t,
        e = {},
        r = Object.prototype,
        n = r.hasOwnProperty,
        o = Object.defineProperty || function (t, e, r) {
          t[e] = r.value;
        },
        i = "function" == typeof Symbol ? Symbol : {},
        a = i.iterator || "@@iterator",
        c = i.asyncIterator || "@@asyncIterator",
        u = i.toStringTag || "@@toStringTag";
      function define(t, e, r) {
        return Object.defineProperty(t, e, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), t[e];
      }
      try {
        define({}, "");
      } catch (t) {
        define = function (t, e, r) {
          return t[e] = r;
        };
      }
      function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator,
          a = Object.create(i.prototype),
          c = new Context(n || []);
        return o(a, "_invoke", {
          value: makeInvokeMethod(t, r, c)
        }), a;
      }
      function tryCatch(t, e, r) {
        try {
          return {
            type: "normal",
            arg: t.call(e, r)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart",
        l = "suspendedYield",
        f = "executing",
        s = "completed",
        y = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var p = {};
      define(p, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf,
        v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (e) {
          define(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
          var c = tryCatch(t[r], t, o);
          if ("throw" !== c.type) {
            var u = c.arg,
              h = u.value;
            return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
              invoke("next", t, i, a);
            }, function (t) {
              invoke("throw", t, i, a);
            }) : e.resolve(h).then(function (t) {
              u.value = t, i(u);
            }, function (t) {
              return invoke("throw", t, i, a);
            });
          }
          a(c.arg);
        }
        var r;
        o(this, "_invoke", {
          value: function (t, n) {
            function callInvokeWithMethodAndArg() {
              return new e(function (e, r) {
                invoke(t, n, e, r);
              });
            }
            return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e, r, n) {
        var o = h;
        return function (i, a) {
          if (o === f) throw new Error("Generator is already running");
          if (o === s) {
            if ("throw" === i) throw a;
            return {
              value: t,
              done: !0
            };
          }
          for (n.method = i, n.arg = a;;) {
            var c = n.delegate;
            if (c) {
              var u = maybeInvokeDelegate(c, n);
              if (u) {
                if (u === y) continue;
                return u;
              }
            }
            if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
              if (o === h) throw o = s, n.arg;
              n.dispatchException(n.arg);
            } else "return" === n.method && n.abrupt("return", n.arg);
            o = f;
            var p = tryCatch(e, r, n);
            if ("normal" === p.type) {
              if (o = n.done ? s : l, p.arg === y) continue;
              return {
                value: p.arg,
                done: n.done
              };
            }
            "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
          }
        };
      }
      function maybeInvokeDelegate(e, r) {
        var n = r.method,
          o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
      }
      function pushTryEntry(t) {
        var e = {
          tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
      }
      function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
      }
      function Context(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(e) {
        if (e || "" === e) {
          var r = e[a];
          if (r) return r.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var o = -1,
              i = function next() {
                for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                return next.value = t, next.done = !0, next;
              };
            return i.next = i;
          }
        }
        throw new TypeError(typeof e + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
      }, e.mark = function (t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
      }, e.awrap = function (t) {
        return {
          __await: t
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
          return t.done ? t.value : a.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
        return this;
      }), define(g, "toString", function () {
        return "[object Generator]";
      }), e.keys = function (t) {
        var e = Object(t),
          r = [];
        for (var n in e) r.push(n);
        return r.reverse(), function next() {
          for (; r.length;) {
            var t = r.pop();
            if (t in e) return next.value = t, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function (e) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function () {
          this.done = !0;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval;
        },
        dispatchException: function (e) {
          if (this.done) throw e;
          var r = this;
          function handle(n, o) {
            return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
          }
          for (var o = this.tryEntries.length - 1; o >= 0; --o) {
            var i = this.tryEntries[o],
              a = i.completion;
            if ("root" === i.tryLoc) return handle("end");
            if (i.tryLoc <= this.prev) {
              var c = n.call(i, "catchLoc"),
                u = n.call(i, "finallyLoc");
              if (c && u) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              } else if (c) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              } else {
                if (!u) throw new Error("try statement without catch or finally");
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              }
            }
          }
        },
        abrupt: function (t, e) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var o = this.tryEntries[r];
            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
              var i = o;
              break;
            }
          }
          i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
          var a = i ? i.completion : {};
          return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function (t, e) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function (t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
          }
        },
        catch: function (t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.tryLoc === t) {
              var n = r.completion;
              if ("throw" === n.type) {
                var o = n.arg;
                resetTryEntry(r);
              }
              return o;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function (e, r, n) {
          return this.delegate = {
            iterator: values(e),
            resultName: r,
            nextLoc: n
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    function _toPrimitive(t, r) {
      if ("object" != typeof t || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == typeof i ? i : String(i);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
  
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, _typeof(o);
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
          args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(undefined);
        });
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }
      return object;
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get.bind();
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function set(target, property, value, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
      } else {
        set = function set(target, property, value, receiver) {
          var base = _superPropBase(target, property);
          var desc;
          if (base) {
            desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.set) {
              desc.set.call(receiver, value);
              return true;
            } else if (!desc.writable) {
              return false;
            }
          }
          desc = Object.getOwnPropertyDescriptor(receiver, property);
          if (desc) {
            if (!desc.writable) {
              return false;
            }
            desc.value = value;
            Object.defineProperty(receiver, property, desc);
          } else {
            _defineProperty(receiver, property, value);
          }
          return true;
        };
      }
      return set(target, property, value, receiver);
    }
    function _set(target, property, value, receiver, isStrict) {
      var s = set(target, property, value, receiver || target);
      if (!s && isStrict) {
        throw new TypeError('failed to set property');
      }
      return value;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
  
    var ObjectFactory = /*#__PURE__*/function () {
      function ObjectFactory(scene) {
        _classCallCheck(this, ObjectFactory);
        this.scene = scene;
        this.displayList = scene.sys.displayList;
        this.updateList = scene.sys.updateList;
        scene.events.once('destroy', this.destroy, this);
      }
      _createClass(ObjectFactory, [{
        key: "destroy",
        value: function destroy() {
          this.scene = null;
          this.displayList = null;
          this.updateList = null;
        }
      }], [{
        key: "register",
        value: function register(type, callback) {
          ObjectFactory.prototype[type] = callback;
        }
      }]);
      return ObjectFactory;
    }();
  
    var SetGetFrameNameCallback = function SetGetFrameNameCallback(callback) {
      if (callback === undefined) {
        callback = DefaultGetFrameNameCallback;
      }
      this.getFrameNameCallback = callback;
      return this;
    };
    var DefaultGetFrameNameCallback = function DefaultGetFrameNameCallback(colIndex, rowIndex, baseFrameName) {
      if (baseFrameName === '__BASE') {
        return "".concat(colIndex, ",").concat(rowIndex);
      } else {
        return "".concat(baseFrameName, ":").concat(colIndex, ",").concat(rowIndex);
      }
    };
  
    function DeepClone(obj) {
      if (obj === null || _typeof(obj) !== 'object') {
        // If obj is a primitive value or null, return it directly
        return obj;
      }
      if (Array.isArray(obj)) {
        // If obj is an array, create a new array and clone each element
        return obj.map(function (item) {
          return DeepClone(item);
        });
      }
      if (obj instanceof Date) {
        // If obj is a Date object, create a new Date object with the same value
        return new Date(obj);
      }
      if (obj instanceof RegExp) {
        // If obj is a RegExp object, create a new RegExp object with the same pattern and flags
        return new RegExp(obj);
      }
      if (Object.getPrototypeOf(obj) !== Object.prototype) {
        // If obj is a custom object, return a reference to it
        return obj;
      }
  
      // If obj is a plain object, create a new object and clone each property
      var clonedObj = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          clonedObj[key] = DeepClone(obj[key]);
        }
      }
      return clonedObj;
    }
  
    var SetBaseTexture = function SetBaseTexture(key, baseFrameName, columns, rows) {
      if (Array.isArray(baseFrameName)) {
        rows = columns;
        columns = baseFrameName;
        baseFrameName = undefined;
      }
      if (baseFrameName == null) {
        baseFrameName = '__BASE';
      }
      if (typeof columns === 'number' && arguments.length >= 6) {
        columns = [arguments[2], undefined, arguments[3]];
        rows = [arguments[4], undefined, arguments[5]];
      } else if (columns === undefined && rows === undefined && this.columns.data !== undefined && this.rows.data !== undefined) {
        columns = this.columns.data;
        rows = this.rows.data;
      } else {
        columns = DeepClone(columns);
        rows = DeepClone(rows);
      }
      this.textureKey = key;
      this.baseFrameName = baseFrameName;
      this.columns.data = columns;
      this.columns.count = columns ? columns.length : 0;
      this.columns.stretch = 0;
      this.columns.minWidth = 0;
      this.columns.scale = 1;
      this.rows.data = rows;
      this.rows.count = rows ? rows.length : 0;
      this.rows.stretch = 0;
      this.rows.minHeight = 0;
      this.rows.scale = 1;
      var texture = this.scene.sys.textures.get(key);
      if (!texture) {
        this.clear();
        return this;
      }
      if (!columns || !rows) {
        this.clear();
        return this;
      }
  
      // Get remainder width/height for unknown width/height
      var baseFrame = texture.get(baseFrameName);
      var remainderTextureWidth = baseFrame.width;
      var unknownColumnWidthCount = 0;
      for (var i = 0, cnt = columns.length; i < cnt; i++) {
        if (columns[i] === undefined) {
          unknownColumnWidthCount++;
        } else if (typeof columns[i] === 'number') {
          remainderTextureWidth -= columns[i];
        } else {
          remainderTextureWidth -= columns[i].width;
        }
      }
      var unknownColumnWidth = unknownColumnWidthCount > 0 ? remainderTextureWidth / unknownColumnWidthCount : 0;
      var remainderTextureHeight = baseFrame.height;
      var unknownRowHeightCount = 0;
      for (var i = 0, cnt = rows.length; i < cnt; i++) {
        if (rows[i] === undefined) {
          unknownRowHeightCount++;
        } else if (typeof rows[i] === 'number') {
          remainderTextureHeight -= rows[i];
        } else {
          remainderTextureHeight -= rows[i].width;
        }
      }
      var unknownRowHeight = unknownRowHeightCount ? remainderTextureHeight / unknownRowHeightCount : 0;
      var row, col, rowHeight, colWidth, frameName;
      var offsetX = 0,
        offsetY = 0;
      for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
        // Unknown height
        if (rows[j] === undefined) {
          rows[j] = unknownRowHeight;
        }
        if (typeof rows[j] === 'number') {
          rows[j] = {
            height: rows[j],
            stretch: j % 2
          };
        }
        row = rows[j];
        rowHeight = row.height;
        this.rows.stretch += row.stretch | 0;
        this.rows.minHeight += row.stretch > 0 ? 0 : rowHeight;
        offsetX = 0;
        for (var i = 0, icnt = columns.length; i < icnt; i++) {
          // Unknown width
          if (columns[i] === undefined) {
            columns[i] = unknownColumnWidth;
          }
          if (typeof columns[i] === 'number') {
            columns[i] = {
              width: columns[i],
              stretch: i % 2
            };
          }
          col = columns[i];
          colWidth = col.width;
          if (j === 0) {
            this.columns.stretch += col.stretch | 0;
            this.columns.minWidth += col.stretch > 0 ? 0 : colWidth;
          }
          if (colWidth >= 1 && rowHeight >= 1) {
            frameName = this.getFrameNameCallback(i, j, baseFrameName);
            var frameNameType = _typeof(frameName);
            if (frameNameType === 'string' || frameNameType === 'number') {
              texture.add(frameName, 0, offsetX + baseFrame.cutX, offsetY + baseFrame.cutY, colWidth, rowHeight);
              // Do nothing if frameName is existed
            }
          }
          offsetX += colWidth;
        }
        offsetY += rowHeight;
      }
      this.updateTexture();
      return this;
    };
  
    var UpdateTexture = function UpdateTexture() {
      this.clear();
      if (this.textureKey === undefined) {
        return this;
      }
      var texture = this.scene.sys.textures.get(this.textureKey);
      if (!texture) {
        return this;
      }
      var minWidth = this.columns.minWidth * this.maxFixedPartScaleX; // Fixed-part width
      var minHeight = this.rows.minHeight * this.maxFixedPartScaleY; // Fixed-part height
      var stretchWidth = this.width - minWidth;
      var stretchHeight = this.height - minHeight;
      var fixedPartScaleX = stretchWidth >= 0 ? this.maxFixedPartScaleX : this.width / minWidth;
      var fixedPartScaleY = stretchHeight >= 0 ? this.maxFixedPartScaleY : this.height / minHeight;
      if (this.preserveRatio) {
        var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
        if (fixedPartScaleX > minScale) {
          var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
          if (stretchWidth >= 0) {
            stretchWidth += compensationWidth;
          } else {
            stretchWidth = compensationWidth;
          }
          fixedPartScaleX = minScale;
        }
        if (fixedPartScaleY > minScale) {
          var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
          if (stretchHeight >= 0) {
            stretchHeight += compensationHeight;
          } else {
            stretchHeight = compensationHeight;
          }
          fixedPartScaleY = minScale;
        }
      }
      this.columns.scale = fixedPartScaleX;
      this.rows.scale = fixedPartScaleY;
      var proportionWidth;
      if (stretchWidth > 0) {
        proportionWidth = this.columns.stretch > 0 ? stretchWidth / this.columns.stretch : 0;
      } else {
        proportionWidth = 0;
      }
      var proportionHeight;
      if (stretchHeight > 0) {
        proportionHeight = this.rows.stretch > 0 ? stretchHeight / this.rows.stretch : 0;
      } else {
        proportionHeight = 0;
      }
      var frameName, col, row, colWidth, rowHeight;
      var offsetX = 0,
        offsetY = 0;
      var imageType;
      this._beginDraw();
      for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
        row = this.rows.data[j];
        rowHeight = row.stretch === 0 ? row.height * fixedPartScaleY : proportionHeight * row.stretch;
        offsetX = 0;
        for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
          col = this.columns.data[i];
          colWidth = col.stretch === 0 ? col.width * fixedPartScaleX : proportionWidth * col.stretch;
          frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
          if (texture.has(frameName) && colWidth > 0 && rowHeight > 0) {
            if (row.stretch === 0 && col.stretch === 0) {
              // Fixed parts
              imageType = 0; // Draw image
            } else {
              // Stretchable parts
              if (this.getStretchMode(i, j) === 0) {
                // Scaled image
                imageType = 0; // Draw scaled image
              } else {
                // Repeat tile-sprite
                imageType = 1; // Draw tile-sprite
              }
            }
            if (imageType === 0) {
              this._drawImage(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
            } else {
              this._drawTileSprite(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
            }
          }
          offsetX += colWidth;
        }
        offsetY += rowHeight;
      }
      this._endDraw();
    };
  
    var IsPlainObject$U = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3K = Phaser.Utils.Objects.GetValue;
    var SetStretchMode = function SetStretchMode(mode) {
      if (IsPlainObject$U(mode)) {
        this.stretchMode.edge = parseMode(GetValue$3K(mode, 'edge', 0));
        this.stretchMode.internal = parseMode(GetValue$3K(mode, 'internal', 0));
      } else {
        mode = parseMode(mode);
        this.stretchMode.edge = mode;
        this.stretchMode.internal = mode;
      }
      return this;
    };
    var parseMode = function parseMode(mode) {
      if (typeof mode === 'string') {
        mode = EXTENDMODE[mode];
      }
      return mode;
    };
    var EXTENDMODE = {
      scale: 0,
      repeat: 1
    };
  
    var IsEdge = function IsEdge(colIndex, rowIndex) {
      return colIndex === 0 || colIndex === this.columns.count - 1 || rowIndex === 0 || rowIndex === this.rows.count - 1;
    };
  
    var GetStretchMode = function GetStretchMode(colIndex, rowIndex) {
      return IsEdge.call(this, colIndex, rowIndex) ? this.stretchMode.edge : this.stretchMode.internal;
    };
  
    var SetPreserveRatio = function SetPreserveRatio(enable) {
      if (enable == undefined) {
        enable = true;
      }
      this.preserveRatio = enable;
      return this;
    };
  
    var SetMaxFixedPartScale = function SetMaxFixedPartScale(scaleX, scaleY) {
      if (scaleY === undefined) {
        scaleY = scaleX;
      }
      this.maxFixedPartScaleX = scaleX;
      this.maxFixedPartScaleY = scaleY;
      return this;
    };
  
    var NOOP = function NOOP() {
      //  NOOP
    };
  
    var Methods$l = {
      _beginDraw: NOOP,
      _drawImage: NOOP,
      _drawTileSprite: NOOP,
      _endDraw: NOOP,
      setGetFrameNameCallback: SetGetFrameNameCallback,
      setBaseTexture: SetBaseTexture,
      updateTexture: UpdateTexture,
      setStretchMode: SetStretchMode,
      getStretchMode: GetStretchMode,
      setPreserveRatio: SetPreserveRatio,
      setMaxFixedPartScale: SetMaxFixedPartScale
    };
  
    var IsPlainObject$T = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3J = Phaser.Utils.Objects.GetValue;
    var NinePatchBase = function NinePatchBase(GOClass, type) {
      var NinePatch = /*#__PURE__*/function (_GOClass) {
        _inherits(NinePatch, _GOClass);
        function NinePatch(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
          var _this;
          _classCallCheck(this, NinePatch);
          if (IsPlainObject$T(x)) {
            config = x;
            x = GetValue$3J(config, 'x', 0);
            y = GetValue$3J(config, 'y', 0);
            width = GetValue$3J(config, 'width', 1);
            height = GetValue$3J(config, 'height', 1);
            key = GetValue$3J(config, 'key', undefined);
            baseFrame = GetValue$3J(config, 'baseFrame', undefined);
            columns = GetValue$3J(config, 'columns', undefined);
            rows = GetValue$3J(config, 'rows', undefined);
          } else if (IsPlainObject$T(width)) {
            config = width;
            width = GetValue$3J(config, 'width', 1);
            height = GetValue$3J(config, 'height', 1);
            key = GetValue$3J(config, 'key', undefined);
            baseFrame = GetValue$3J(config, 'baseFrame', undefined);
            columns = GetValue$3J(config, 'columns', undefined);
            rows = GetValue$3J(config, 'rows', undefined);
          } else if (IsPlainObject$T(key)) {
            config = key;
            key = GetValue$3J(config, 'key', undefined);
            baseFrame = GetValue$3J(config, 'baseFrame', undefined);
            columns = GetValue$3J(config, 'columns', undefined);
            rows = GetValue$3J(config, 'rows', undefined);
          } else if (IsPlainObject$T(baseFrame)) {
            config = baseFrame;
            baseFrame = GetValue$3J(config, 'baseFrame', undefined);
            columns = GetValue$3J(config, 'columns', undefined);
            rows = GetValue$3J(config, 'rows', undefined);
          } else if (Array.isArray(baseFrame)) {
            config = rows;
            rows = columns;
            columns = baseFrame;
            baseFrame = GetValue$3J(config, 'baseFrame', undefined);
          } else if (IsPlainObject$T(columns)) {
            config = columns;
            columns = GetValue$3J(config, 'columns', undefined);
            rows = GetValue$3J(config, 'rows', undefined);
          }
          if (baseFrame === undefined) {
            baseFrame = GetValue$3J(config, 'frame', undefined);
          }
          if (columns === undefined) {
            var leftWidth = GetValue$3J(config, 'leftWidth', undefined);
            var rightWidth = GetValue$3J(config, 'rightWidth', undefined);
            if (leftWidth !== undefined && rightWidth !== undefined) {
              columns = [leftWidth, undefined, rightWidth];
            }
          }
          if (rows === undefined) {
            var topHeight = GetValue$3J(config, 'topHeight', undefined);
            var bottomHeight = GetValue$3J(config, 'bottomHeight', undefined);
            if (topHeight !== undefined && bottomHeight !== undefined) {
              rows = [topHeight, undefined, bottomHeight];
            }
          }
          _this = _callSuper(this, NinePatch, [scene]);
          _this.type = type;
          _this.setPosition(x, y).setSize(width, height).setOrigin(0.5, 0.5);
          _this.columns = {};
          _this.rows = {};
          _this.stretchMode = {};
          _this._tileSprite = undefined; // Reserved for drawing image
          _this._image = undefined; // Reserved for drawing image
  
          _this.setGetFrameNameCallback(GetValue$3J(config, 'getFrameNameCallback', undefined));
          _this.setStretchMode(GetValue$3J(config, 'stretchMode', 0));
          _this.setPreserveRatio(GetValue$3J(config, 'preserveRatio', true));
          var maxFixedPartScale = GetValue$3J(config, 'maxFixedPartScale', 1);
          var maxFixedPartScaleX = GetValue$3J(config, 'maxFixedPartScaleX', maxFixedPartScale);
          var maxFixedPartScaleY = GetValue$3J(config, 'maxFixedPartScaleY', undefined);
          _this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);
          _this.setBaseTexture(key, baseFrame, columns, rows);
          return _this;
        }
        _createClass(NinePatch, [{
          key: "minWidth",
          get: function get() {
            return this.columns.minWidth;
          }
        }, {
          key: "minHeight",
          get: function get() {
            return this.rows.minHeight;
          }
        }, {
          key: "fixedPartScaleX",
          get: function get() {
            return this.columns.scale;
          }
        }, {
          key: "fixedPartScaleY",
          get: function get() {
            return this.rows.scale;
          }
        }, {
          key: "resize",
          value: function resize(width, height) {
            if (this.width === width && this.height === height) {
              return this;
            }
            if (_get(_getPrototypeOf(NinePatch.prototype), "resize", this)) {
              _get(_getPrototypeOf(NinePatch.prototype), "resize", this).call(this, width, height);
            } else {
              // Use setSize method for alternative 
              _get(_getPrototypeOf(NinePatch.prototype), "setSize", this).call(this, width, height);
            }
            this.updateTexture();
            return this;
          }
        }, {
          key: "leftWidth",
          get: function get() {
            return this.columns.data[0];
          }
        }, {
          key: "rightWidth",
          get: function get() {
            return this.columns.data[this.columns.count - 1];
          }
        }, {
          key: "topHeight",
          get: function get() {
            return this.rows.data[0];
          }
        }, {
          key: "bottomHeight",
          get: function get() {
            return this.rows.data[this.rows.count - 1];
          }
        }]);
        return NinePatch;
      }(GOClass);
      Object.assign(NinePatch.prototype, Methods$l);
      return NinePatch;
    };
  
    var GameClass = Phaser.Game;
    var IsGame = function IsGame(object) {
      return object instanceof GameClass;
    };
  
    var SceneClass = Phaser.Scene;
    var IsSceneObject = function IsSceneObject(object) {
      return object instanceof SceneClass;
    };
  
    var GetGame = function GetGame(object) {
      if (object == null || _typeof(object) !== 'object') {
        return null;
      } else if (IsGame(object)) {
        return object;
      } else if (IsGame(object.game)) {
        return object.game;
      } else if (IsSceneObject(object)) {
        // object = scene object
        return object.sys.game;
      } else if (IsSceneObject(object.scene)) {
        // object = game object
        return object.scene.sys.game;
      }
    };
  
    var GameObjectClasses = Phaser.GameObjects;
    var GameObjects = undefined;
    var GetStampGameObject = function GetStampGameObject(gameObject, className) {
      if (!GameObjects) {
        GameObjects = {};
        GetGame(gameObject).events.once('destroy', function () {
          for (var name in GameObjects) {
            GameObjects[name].destroy();
          }
          GameObjects = undefined;
        });
      }
      if (!GameObjects.hasOwnProperty(className)) {
        var scene = GetGame(gameObject).scene.systemScene;
        var gameObject = new GameObjectClasses[className](scene);
        gameObject.setOrigin(0);
        GameObjects[className] = gameObject;
      }
      return GameObjects[className];
    };
  
    var DrawImage$2 = function DrawImage(key, frame, x, y, width, height) {
      var gameObject = GetStampGameObject(this, 'Image').setTexture(key, frame).setDisplaySize(width, height);
      this.draw(gameObject, x, y);
    };
  
    var DrawTileSprite$1 = function DrawTileSprite(key, frame, x, y, width, height) {
      var gameObject = GetStampGameObject(this, 'TileSprite').setTexture(key, frame).setSize(width, height);
      this.draw(gameObject, x, y);
    };
  
    var RenderTexture$2 = Phaser.GameObjects.RenderTexture;
    var NinePatch$1 = /*#__PURE__*/function (_NinePatchBase) {
      _inherits(NinePatch, _NinePatchBase);
      function NinePatch() {
        _classCallCheck(this, NinePatch);
        return _callSuper(this, NinePatch, arguments);
      }
      return _createClass(NinePatch);
    }(NinePatchBase(RenderTexture$2, 'rexNinePatch'));
    var Methods$k = {
      _drawImage: DrawImage$2,
      _drawTileSprite: DrawTileSprite$1
    };
    Object.assign(NinePatch$1.prototype, Methods$k);
  
    var IsInValidKey = function IsInValidKey(keys) {
      return keys == null || keys === '' || keys.length === 0;
    };
    var GetEntry = function GetEntry(target, keys, defaultEntry) {
      var entry = target;
      if (IsInValidKey(keys)) ; else {
        if (typeof keys === 'string') {
          keys = keys.split('.');
        }
        var key;
        for (var i = 0, cnt = keys.length; i < cnt; i++) {
          key = keys[i];
          if (entry[key] == null || _typeof(entry[key]) !== 'object') {
            var newEntry;
            if (i === cnt - 1) {
              if (defaultEntry === undefined) {
                newEntry = {};
              } else {
                newEntry = defaultEntry;
              }
            } else {
              newEntry = {};
            }
            entry[key] = newEntry;
          }
          entry = entry[key];
        }
      }
      return entry;
    };
    var SetValue = function SetValue(target, keys, value, delimiter) {
      if (delimiter === undefined) {
        delimiter = '.';
      }
  
      // no object
      if (_typeof(target) !== 'object') {
        return;
      }
  
      // invalid key
      else if (IsInValidKey(keys)) {
        // don't erase target
        if (value == null) {
          return;
        }
        // set target to another object
        else if (_typeof(value) === 'object') {
          target = value;
        }
      } else {
        if (typeof keys === 'string') {
          keys = keys.split(delimiter);
        }
        var lastKey = keys.pop();
        var entry = GetEntry(target, keys);
        entry[lastKey] = value;
      }
      return target;
    };
  
    ObjectFactory.register('ninePatch', function (x, y, width, height, key, columns, rows, config) {
      var gameObject = new NinePatch$1(this.scene, x, y, width, height, key, columns, rows, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.NinePatch', NinePatch$1);
  
    var GetCalcMatrix$2 = Phaser.GameObjects.GetCalcMatrix;
    var WebGLRenderer$3 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
      var bobs = src.getRenderList();
      if (bobs.length === 0) {
        return;
      }
      camera.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline);
      var texture = src.frame.glTexture;
      var textureUnit = pipeline.setGameObject(src);
      var roundPixels = camera.roundPixels;
      var result = GetCalcMatrix$2(src, camera, parentMatrix);
      var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var alpha = camera.alpha * src.alpha;
      renderer.pipelines.preBatch(src);
      for (var i = 0, cnt = bobs.length; i < cnt; i++) {
        bobs[i].webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels);
      }
      renderer.pipelines.postBatch(src);
    };
  
    var SetTransform$2 = Phaser.Renderer.Canvas.SetTransform;
    var CanvasRenderer$3 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
      var ctx = renderer.currentContext;
      var bobs = src.getRenderList();
      if (bobs.length === 0 || !SetTransform$2(renderer, ctx, src, camera, parentMatrix)) {
        return;
      }
      camera.addToRenderList(src);
      var roundPixels = camera.roundPixels;
      var dx = -src._displayOriginX,
        dy = -src._displayOriginY;
      ctx.translate(dx, dy);
      for (var i = 0, cnt = bobs.length; i < cnt; i++) {
        bobs[i].canvasRender(ctx, dx, dy, roundPixels);
      }
  
      //  Restore the context saved in SetTransform
      ctx.restore();
    };
  
    var Render$4 = {
      renderWebGL: WebGLRenderer$3,
      renderCanvas: CanvasRenderer$3
    };
  
    var SetTexture = function SetTexture(key, frame) {
      this.texture = this.scene.sys.textures.get(key);
      this.frame = this.texture.get(frame);
      return this;
    };
  
    var Resize$1 = function Resize(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      this.width = width;
      this.height = height;
      this.updateDisplayOrigin();
      var input = this.input;
      if (input && !input.customHitArea) {
        input.hitArea.width = width;
        input.hitArea.height = height;
      }
      return this;
    };
  
    var AddChild$4 = function AddChild(bob) {
      this.lastAppendedChildren.length = 0;
      if (Array.isArray(bob)) {
        var _this$lastAppendedChi;
        this.children.add(bob);
        (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(bob));
      } else {
        this.children.add(bob);
        this.lastAppendedChildren.push(bob);
      }
      return this;
    };
  
    var RemoveItem$e = Phaser.Utils.Array.Remove;
    var RemoveChild$3 = function RemoveChild(bob) {
      if (this.poolManager) {
        // Free this bob (bob.onFree())
        this.poolManager.free(bob);
      }
  
      // Remove this bob from blitter
      RemoveItem$e(this.children.list, bob);
      this.lastAppendedChildren.length = 0;
      this.dirty = true;
      return this;
    };
  
    var RemoveChildren$1 = function RemoveChildren() {
      if (this.poolManager) {
        // Free all bobs (bob.onFree())
        this.poolManager.freeMultiple(this.children.list);
      }
  
      // Remove all bobs from blitter
      this.children.list.length = 0;
      this.lastAppendedChildren.length = 0;
      this.dirty = true;
      return this;
    };
  
    var GetLastAppendedChildren$1 = function GetLastAppendedChildren() {
      return this.lastAppendedChildren;
    };
  
    var GetChildren$1 = function GetChildren() {
      return this.children.list;
    };
  
    var TintMethods = {
      setTint: function setTint(tint) {
        // 0: Solid tint + texture alpha
        this.tint = tint;
        this.tintFill = false;
        return this;
      },
      setTintFill: function setTintFill(tint) {
        // 1: Solid tint, no texture
        this.tint = tint;
        this.tintFill = true;
        return this;
      },
      clearTint: function clearTint() {
        this.setTint(0xffffff);
        return this;
      }
    };
  
    var methods$J = {
      setTexture: SetTexture,
      resize: Resize$1,
      setSize: Resize$1,
      addChild: AddChild$4,
      removeChild: RemoveChild$3,
      removeChildren: RemoveChildren$1,
      clear: RemoveChildren$1,
      getLastAppendedChildren: GetLastAppendedChildren$1,
      getChildren: GetChildren$1
    };
    Object.assign(methods$J, TintMethods);
  
    var Stack = /*#__PURE__*/function () {
      function Stack() {
        _classCallCheck(this, Stack);
        this.items = [];
      }
      _createClass(Stack, [{
        key: "destroy",
        value: function destroy() {
          this.clear();
          this.items = undefined;
        }
      }, {
        key: "pop",
        value: function pop() {
          return this.items.length > 0 ? this.items.pop() : null;
        }
      }, {
        key: "push",
        value: function push(l) {
          this.items.push(l);
          return this;
        }
      }, {
        key: "pushMultiple",
        value: function pushMultiple(arr) {
          this.items.push.apply(this.items, arr);
          arr.length = 0;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.items.length = 0;
          return this;
        }
      }]);
      return Stack;
    }();
  
    var GetValue$3I = Phaser.Utils.Objects.GetValue;
    var Pools$1 = {};
    var PoolManager$1 = /*#__PURE__*/function () {
      function PoolManager(config) {
        _classCallCheck(this, PoolManager);
        this.pools = GetValue$3I(config, 'pools', Pools$1);
      }
      _createClass(PoolManager, [{
        key: "destroy",
        value: function destroy() {
          this.pools = undefined;
        }
      }, {
        key: "free",
        value: function free(bob) {
          if (!this.pools) {
            return this;
          }
          var bobType = bob.type;
          if (!this.pools.hasOwnProperty(bobType)) {
            this.pools[bobType] = new Stack();
          }
          this.pools[bobType].push(bob);
          bob.onFree();
          return this;
        }
      }, {
        key: "freeMultiple",
        value: function freeMultiple(bobs) {
          if (!this.pools) {
            return this;
          }
          for (var i = 0, cnt = bobs.length; i < cnt; i++) {
            this.free(bobs[i]);
          }
          return this;
        }
      }, {
        key: "allocate",
        value: function allocate(bobType) {
          if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
            return null;
          }
          return this.pools[bobType].pop();
        }
      }]);
      return PoolManager;
    }();
  
    var MinVersion = 60;
    var IsChecked = false;
    var CheckP3Version = function CheckP3Version(minVersion) {
      if (IsChecked) {
        return;
      }
      if (minVersion === undefined) {
        minVersion = MinVersion;
      }
      var currentVersion = parseInt(Phaser.VERSION.match(/\.(\d+)\./)[1]);
      if (currentVersion < minVersion) {
        console.error("Minimum supported version : 3.".concat(minVersion));
      }
      IsChecked = true;
    };
  
    CheckP3Version();
    var GameObject$4 = Phaser.GameObjects.GameObject;
    var IsPlainObject$S = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3H = Phaser.Utils.Objects.GetValue;
    var List = Phaser.Structs.List;
    var StableSort = Phaser.Utils.Array.StableSort;
    var Blitter = /*#__PURE__*/function (_GameObject) {
      _inherits(Blitter, _GameObject);
      function Blitter(scene, x, y, texture, frame, config) {
        var _this;
        _classCallCheck(this, Blitter);
        if (IsPlainObject$S(x)) {
          config = x;
          x = GetValue$3H(config, 'x', 0);
          y = GetValue$3H(config, 'y', 0);
          texture = GetValue$3H(config, 'texture');
          frame = GetValue$3H(config, 'frame');
        }
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        _this = _callSuper(this, Blitter, [scene, 'rexBlitter']);
        _this.children = new List();
        _this.renderList = [];
        _this.displayListDirty = false;
        _this.lastAppendedChildren = [];
        var reuseBob = GetValue$3H(config, 'reuseBob', true);
        _this.poolManager = reuseBob ? new PoolManager$1(config) : undefined;
        _this.setTexture(texture, frame);
        _this.setPosition(x, y);
        _this.setOrigin(0, 0);
        _this.clearTint();
        _this.initPipeline();
        _this.initPostPipeline();
        return _this;
      }
      _createClass(Blitter, [{
        key: "preDestroy",
        value: function preDestroy() {
          this.removeChildren();
          this.children.destroy();
          this.renderList.length = 0;
          if (this.poolManager) {
            this.poolManager.destroy();
          }
        }
      }, {
        key: "getRenderList",
        value: function getRenderList() {
          if (this.displayListDirty) {
            this.renderList.length = 0;
            var needDepthSort = false;
            var children = this.children.list;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
              var child = children[i];
              if (ChildCanRender(child)) {
                this.renderList.push(child);
                if (!needDepthSort) {
                  needDepthSort = child.depth !== 0;
                }
              }
            }
            if (needDepthSort) {
              StableSort(this.renderList, SortByDepth);
            }
            this.displayListDirty = false;
          }
          return this.renderList;
        }
      }]);
      return Blitter;
    }(GameObject$4);
    var ChildCanRender = function ChildCanRender(child) {
      return child.active && child.visible && child.alpha > 0;
    };
    var SortByDepth = function SortByDepth(childA, childB) {
      return childA._depth - childB._depth;
    };
    var Components$4 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Blitter, [Components$4.Alpha, Components$4.BlendMode, Components$4.ComputedSize, Components$4.Depth, Components$4.GetBounds, Components$4.Mask, Components$4.Origin, Components$4.Pipeline, Components$4.PostPipeline, Components$4.ScrollFactor, Components$4.Transform, Components$4.Visible, Render$4, methods$J]);
  
    var ImageTypeName$1 = 'image';
  
    var GetValue$3G = function GetValue(source, key, defaultValue) {
      if (!source || typeof source === 'number') {
        return defaultValue;
      }
      if (typeof key === 'string') {
        if (source.hasOwnProperty(key)) {
          return source[key];
        }
        if (key.indexOf('.') !== -1) {
          key = key.split('.');
        } else {
          return defaultValue;
        }
      }
      var keys = key;
      var parent = source;
      var value = defaultValue;
  
      //  Use for loop here so we can break early
      for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        if (parent.hasOwnProperty(key)) {
          //  Yes it has a key property, let's carry on down
          value = parent[key];
          parent = value;
        } else {
          //  Can't go any further, so reset to default
          value = defaultValue;
          break;
        }
      }
      return value;
    };
  
    var Clear$1 = function Clear(obj) {
      if (_typeof(obj) !== 'object' || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        obj.length = 0;
      } else {
        for (var key in obj) {
          delete obj[key];
        }
      }
      return obj;
    };
  
    var DataMethods$2 = {
      enableData: function enableData() {
        if (this.data === undefined) {
          this.data = {};
        }
        return this;
      },
      setData: function setData(key, value) {
        this.enableData();
        if (arguments.length === 1) {
          var data = key;
          for (key in data) {
            this.data[key] = data[key];
          }
        } else {
          this.data[key] = value;
        }
        return this;
      },
      getData: function getData(key, defaultValue) {
        this.enableData();
        return key === undefined ? this.data : GetValue$3G(this.data, key, defaultValue);
      },
      incData: function incData(key, inc, defaultValue) {
        if (defaultValue === undefined) {
          defaultValue = 0;
        }
        this.enableData();
        this.setData(key, this.getData(key, defaultValue) + inc);
        return this;
      },
      mulData: function mulData(key, mul, defaultValue) {
        if (defaultValue === undefined) {
          defaultValue = 0;
        }
        this.enableData();
        this.setData(key, this.getData(key, defaultValue) * mul);
        return this;
      },
      clearData: function clearData() {
        if (this.data) {
          Clear$1(this.data);
        }
        return this;
      }
    };
  
    var Base$3 = /*#__PURE__*/function () {
      function Base(parent, type) {
        _classCallCheck(this, Base);
        this.type = type;
        this.data = undefined;
        this.setParent(parent).reset().setActive();
      }
      _createClass(Base, [{
        key: "destroy",
        value: function destroy() {
          if (this.parent) {
            this.parent.removeChild(this);
            // Remove this bob from blitter, and free it (bob.onFree())
            // Will set this.parent to undefined
          }
        }
      }, {
        key: "setParent",
        value: function setParent(parent) {
          this.parent = parent;
          return this;
        }
  
        // get scene() {
        //     if (this.parent) {
        //         return this.parent.scene;
        //     } else {
        //         return null;
        //     }
        // }
      }, {
        key: "setDisplayListDirty",
        value: function setDisplayListDirty(displayListDirty) {
          if (displayListDirty && this.parent) {
            this.parent.displayListDirty = true;
          }
          return this;
        }
      }, {
        key: "active",
        get: function get() {
          return this._active;
        },
        set: function set(value) {
          this.setDisplayListDirty(this._active != value);
          this._active = value;
        }
      }, {
        key: "setActive",
        value: function setActive(active) {
          if (active === undefined) {
            active = true;
          }
          this.active = active;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          return this;
        }
  
        // Override
      }, {
        key: "reset",
        value: function reset() {
          this.clearData();
        }
  
        // Override
      }, {
        key: "onFree",
        value: function onFree() {
          this.reset().setActive(false).setParent();
        }
      }]);
      return Base;
    }();
    Object.assign(Base$3.prototype, DataMethods$2);
  
    var DegToRad$g = Phaser.Math.DegToRad;
    var RadToDeg$9 = Phaser.Math.RadToDeg;
    var GetValue$3F = Phaser.Utils.Objects.GetValue;
    var RenderBase$1 = /*#__PURE__*/function (_Base) {
      _inherits(RenderBase, _Base);
      function RenderBase() {
        _classCallCheck(this, RenderBase);
        return _callSuper(this, RenderBase, arguments);
      }
      _createClass(RenderBase, [{
        key: "visible",
        get: function get() {
          return this._visible;
        },
        set: function set(value) {
          this.setDisplayListDirty(this._visible != value);
          this._visible = value;
        }
      }, {
        key: "setVisible",
        value: function setVisible(visible) {
          if (visible === undefined) {
            visible = true;
          }
          this.visible = visible;
          return this;
        }
      }, {
        key: "alpha",
        get: function get() {
          return this._alpha;
        },
        set: function set(value) {
          this.setDisplayListDirty(!!this._alpha !== !!value);
          this._alpha = value;
        }
      }, {
        key: "setAlpha",
        value: function setAlpha(alpha) {
          this.alpha = alpha;
          return this;
        }
      }, {
        key: "setX",
        value: function setX(x) {
          this.x = x;
          return this;
        }
      }, {
        key: "setY",
        value: function setY(y) {
          this.y = y;
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "setRotation",
        value: function setRotation(rotation) {
          this.rotation = rotation;
          return this;
        }
      }, {
        key: "angle",
        get: function get() {
          return RadToDeg$9(this.rotation);
        },
        set: function set(value) {
          this.rotation = DegToRad$g(value);
        }
      }, {
        key: "setAngle",
        value: function setAngle(angle) {
          this.angle = angle;
          return this;
        }
      }, {
        key: "setScaleX",
        value: function setScaleX(scaleX) {
          this.scaleX = scaleX;
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this._width = value;
        }
      }, {
        key: "setWidth",
        value: function setWidth(width, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.width = width;
          if (keepAspectRatio) {
            this.scaleY = this.scaleX;
          }
          return this;
        }
      }, {
        key: "setScaleY",
        value: function setScaleY(scaleY) {
          this.scaleY = scaleY;
          return this;
        }
      }, {
        key: "setScale",
        value: function setScale(scaleX, scaleY) {
          if (scaleY === undefined) {
            scaleY = scaleX;
          }
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          return this;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this._height = value;
        }
      }, {
        key: "setHeight",
        value: function setHeight(height, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.height = height;
          if (keepAspectRatio) {
            this.scaleX = this.scaleY;
          }
          return this;
        }
      }, {
        key: "displayWidth",
        get: function get() {
          return this._width * this.scaleX;
        },
        set: function set(value) {
          this.scaleX = value / this._width;
        }
      }, {
        key: "setDisplayWidth",
        value: function setDisplayWidth(width, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.displayWidth = width;
          if (keepAspectRatio) {
            this.scaleY = this.scaleX;
          }
          return this;
        }
      }, {
        key: "displayHeight",
        get: function get() {
          return this._height * this.scaleY;
        },
        set: function set(value) {
          this.scaleY = value / this._height;
        }
      }, {
        key: "setDisplayHeight",
        value: function setDisplayHeight(height, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.displayHeight = height;
          if (keepAspectRatio) {
            this.scaleX = this.scaleY;
          }
          return this;
        }
      }, {
        key: "setOriginX",
        value: function setOriginX(originX) {
          this.originX = originX;
          this._displayOriginX = this.width * originX;
          return this;
        }
      }, {
        key: "setOriginY",
        value: function setOriginY(originY) {
          this.originY = originY;
          this._displayOriginY = this.height * originY;
          return this;
        }
      }, {
        key: "setOrigin",
        value: function setOrigin(originX, originY) {
          if (originY === undefined) {
            originY = originX;
          }
          this.setOriginX(originX).setOriginY(originY);
          return this;
        }
      }, {
        key: "depth",
        get: function get() {
          return this._depth;
        },
        set: function set(value) {
          this.setDisplayListDirty(this._depth != value);
          this._depth = value;
        }
      }, {
        key: "setDepth",
        value: function setDepth(depth) {
          if (depth === undefined) {
            depth = 0;
          }
          this.depth = depth;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          if (!o) {
            return this;
          }
          if (o.hasOwnProperty('x')) {
            this.setX(o.x);
          }
          if (o.hasOwnProperty('y')) {
            this.setY(o.y);
          }
          if (o.hasOwnProperty('rotation')) {
            this.setRotation(o.rotation);
          } else if (o.hasOwnProperty('angle')) {
            this.setAngle(o.angle);
          }
          if (o.hasOwnProperty('alpha')) {
            this.setAlpha(o.alpha);
          }
  
          // ScaleX, ScaleY
          var width = GetValue$3F(o, 'width', undefined);
          var height = GetValue$3F(o, 'height', undefined);
          var scale = GetValue$3F(o, 'scale', undefined);
          var scaleX = GetValue$3F(o, 'scaleX', scale);
          var scaleY = GetValue$3F(o, 'scaleY', scale);
          if (width !== undefined) {
            if (height === undefined && scaleY === undefined) {
              this.setWidth(width, true);
            } else {
              this.setWidth(width);
            }
          } else if (scaleX !== undefined) {
            this.setScaleX(scaleX);
          } else if (o.hasOwnProperty('displayWidth')) {
            this.setDisplayWidth(o.displayWidth);
          }
          if (height !== undefined) {
            if (width === undefined && scaleX === undefined) {
              this.setHeight(height, true);
            } else {
              this.setHeight(height);
            }
          } else if (scaleY !== undefined) {
            this.setScaleY(scaleY);
          } else if (o.hasOwnProperty('displayHeight')) {
            this.setDisplayHeight(o.displayHeight);
          }
          var origin = GetValue$3F(o, 'origin', undefined);
          if (origin !== undefined) {
            this.setOrigin(origin);
          } else {
            if (o.hasOwnProperty('originX')) {
              this.setOriginX(o.originX);
            }
            if (o.hasOwnProperty('originY')) {
              this.setOriginY(o.originY);
            }
          }
          if (o.hasOwnProperty('depth')) {
            this.setDepth(o.depth);
          }
          return this;
        }
      }, {
        key: "reset",
        value: function reset() {
          _get(_getPrototypeOf(RenderBase.prototype), "reset", this).call(this);
          this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0);
          return this;
        }
  
        // Override
      }, {
        key: "webglRender",
        value: function webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {}
        // Override
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy, roundPixels) {}
      }]);
      return RenderBase;
    }(Base$3);
  
    var TransformMatrix$2 = Phaser.GameObjects.Components.TransformMatrix;
    var GetTint$2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
    var FrameMatrix = new TransformMatrix$2();
    var WebglRender = function WebglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
      var width = this._width,
        height = this._height;
      var displayOriginX = width * this.originX,
        displayOriginY = height * this.originY;
      var x = this.x - dx,
        y = this.y - dy;
      var flipX = 1;
      var flipY = 1;
      if (this.flipX) {
        x += width - displayOriginX * 2;
        flipX = -1;
      }
      if (this.flipY) {
        y += height - displayOriginY * 2;
        flipY = -1;
      }
      FrameMatrix.applyITRS(x, y, this.rotation, this.scaleX * flipX, this.scaleY * flipY);
      calcMatrix.multiply(FrameMatrix, FrameMatrix);
      var tx = -displayOriginX;
      var ty = -displayOriginY;
      var tw = tx + width;
      var th = ty + height;
      var quad = FrameMatrix.setQuad(tx, ty, tw, th, roundPixels);
      var u0 = this.frame.u0;
      var v0 = this.frame.v0;
      var u1 = this.frame.u1;
      var v1 = this.frame.v1;
      var tint = GetTint$2(this.tint, this.alpha * alpha);
      pipeline.batchQuad(this.parent, quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7], u0, v0, u1, v1, tint, tint, tint, tint, this.tintFill, texture, textureUnit);
    };
  
    var CanvasRender = function CanvasRender(ctx, dx, dy, roundPixels) {
      ctx.save();
      var width = this._width,
        height = this._height;
      var displayOriginX = width * this.originX,
        displayOriginY = height * this.originY;
      var x = this.x - displayOriginX,
        y = this.y - displayOriginY;
      var flipX = 1;
      var flipY = 1;
      if (this.flipX) {
        x += width;
        flipX = -1;
      }
      if (this.flipY) {
        y += height;
        flipY = -1;
      }
      if (roundPixels) {
        x = Math.round(x);
        y = Math.round(y);
      }
      ctx.translate(x, y);
      ctx.rotate(this.rotation);
      ctx.scale(this.scaleX * flipX, this.scaleY * flipY);
      var frame = this.frame;
      ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, width, height, 0, 0, width, height);
      ctx.restore();
    };
  
    var IsPlainObject$R = Phaser.Utils.Objects.IsPlainObject;
    var ImageData$1 = /*#__PURE__*/function (_RenderBase) {
      _inherits(ImageData, _RenderBase);
      function ImageData(parent, frame) {
        var _this;
        _classCallCheck(this, ImageData);
        _this = _callSuper(this, ImageData, [parent, ImageTypeName$1]);
        _this.setFrame(frame);
        return _this;
      }
      _createClass(ImageData, [{
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {}
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {}
      }, {
        key: "setFrame",
        value: function setFrame(frame) {
          if (arguments.length > 0 && !IsPlainObject$R(frame)) {
            frame = this.parent.texture.get(frame);
          }
          this.frame = frame;
          this._width = frame ? frame.width : 0;
          this._height = frame ? frame.height : 0;
          return this;
        }
      }, {
        key: "setFlipX",
        value: function setFlipX(flipX) {
          if (flipX === undefined) {
            flipX = true;
          }
          this.flipX = flipX;
          return this;
        }
      }, {
        key: "setFlipY",
        value: function setFlipY(flipY) {
          if (flipY === undefined) {
            flipY = true;
          }
          this.flipY = flipY;
          return this;
        }
      }, {
        key: "resetFlip",
        value: function resetFlip() {
          this.flipX = false;
          this.flipY = false;
          return this;
        }
      }, {
        key: "tint",
        get: function get() {
          if (this._tint === undefined) {
            return this.parent.tint;
          } else {
            return this._tint;
          }
        },
        set: function set(value) {
          this._tint = value;
        }
      }, {
        key: "setTint",
        value: function setTint(value) {
          this.tint = value;
          this.tintFill = false;
          return this;
        }
      }, {
        key: "setTintFill",
        value: function setTintFill(value) {
          this.tint = value;
          this.tintFill = true;
          return this;
        }
      }, {
        key: "clearTint",
        value: function clearTint() {
          this.setTint(0xffffff);
          return this;
        }
      }, {
        key: "resetTint",
        value: function resetTint() {
          this.tint = undefined;
          this.tintFill = undefined;
          return this;
        }
      }, {
        key: "tintFill",
        get: function get() {
          if (this._tintFill === undefined) {
            return this.parent.tintFill;
          } else {
            return this._tintFill;
          }
        },
        set: function set(value) {
          this._tintFill = value;
        }
      }, {
        key: "reset",
        value: function reset() {
          _get(_getPrototypeOf(ImageData.prototype), "reset", this).call(this);
          this.resetFlip().resetTint().setFrame();
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          if (!o) {
            return this;
          }
  
          // Size of Image is equal to frame size,
          // Move width, height properties to displayWidth,displayHeight
          if (o.hasOwnProperty('width')) {
            o.displayWidth = o.width;
            delete o.width;
          }
          if (o.hasOwnProperty('height')) {
            o.displayHeight = o.height;
            delete o.height;
          }
          if (o.hasOwnProperty('frame')) {
            this.setFrame(o.frame);
          }
          _get(_getPrototypeOf(ImageData.prototype), "modifyPorperties", this).call(this, o);
          if (o.hasOwnProperty('flipX')) {
            this.setFlipX(o.flipX);
          }
          if (o.hasOwnProperty('flipY')) {
            this.setFlipY(o.flipY);
          }
          if (o.hasOwnProperty('tint')) {
            this.setTint(o.tint);
          }
          if (o.hasOwnProperty('tintFill')) {
            this.setTintFill(o.tintFill);
          }
          return this;
        }
      }]);
      return ImageData;
    }(RenderBase$1);
    var methods$I = {
      webglRender: WebglRender,
      canvasRender: CanvasRender
    };
    Object.assign(ImageData$1.prototype, methods$I);
  
    var AddImage$2 = function AddImage(blitter, config) {
      if (typeof config === 'string') {
        config = {
          frame: config
        };
      }
      var bob = blitter.poolManager ? blitter.poolManager.allocate(ImageTypeName$1) : null;
      if (bob === null) {
        bob = new ImageData$1(blitter);
      } else {
        bob.setParent(blitter).setActive();
      }
      bob.modifyPorperties(config);
      blitter.addChild(bob);
      return bob;
    };
  
    var DrawImage$1 = function DrawImage(key, frame, x, y, width, height) {
      AddImage$2(this, {
        frame: frame,
        x: x,
        y: y,
        width: width,
        height: height
      });
    };
  
    var DrawTileSprite = function DrawTileSprite(key, frame, x, y, width, height) {
      var frameObj = this.texture.get(frame);
      var frameWidth = frameObj.width,
        frameHeight = frameObj.height;
      var colCount = Math.floor(width / frameWidth),
        rowCount = Math.floor(height / frameHeight);
      // Align images at center
      x += (width - colCount * frameWidth) / 2;
      y += (height - rowCount * frameHeight) / 2;
      for (var colIndex = 0; colIndex < colCount; colIndex++) {
        for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
          AddImage$2(this, {
            frame: frame,
            x: x + colIndex * frameWidth,
            y: y + rowIndex * frameHeight
          });
        }
      }
    };
  
    var Methods$j = {
      _drawImage: DrawImage$1,
      _drawTileSprite: DrawTileSprite
    };
  
    var NinePatch = /*#__PURE__*/function (_NinePatchBase) {
      _inherits(NinePatch, _NinePatchBase);
      function NinePatch() {
        _classCallCheck(this, NinePatch);
        return _callSuper(this, NinePatch, arguments);
      }
      _createClass(NinePatch, [{
        key: "setBaseTexture",
        value: function setBaseTexture(key, baseFrameName, columns, rows) {
          this.setTexture(key, baseFrameName);
          _get(_getPrototypeOf(NinePatch.prototype), "setBaseTexture", this).call(this, key, baseFrameName, columns, rows);
          return this;
        }
      }]);
      return NinePatch;
    }(NinePatchBase(Blitter, 'rexNinePatch2'));
    Object.assign(NinePatch.prototype, Methods$j);
  
    ObjectFactory.register('ninePatch2', function (x, y, width, height, key, columns, rows, config) {
      var gameObject = new NinePatch(this.scene, x, y, width, height, key, columns, rows, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.NinePatch2', NinePatch);
  
    /*
    src: {
        fillColor, 
        fillAlpha, 
        pathData, 
        pathIndexes  // Earcut(pathData)
    }
    */
  
    var Utils$3 = Phaser.Renderer.WebGL.Utils;
    var FillPathWebGL = function FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy) {
      var fillTintColor = Utils$3.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
      var path = src.pathData;
      var pathIndexes = src.pathIndexes;
      for (var i = 0; i < pathIndexes.length; i += 3) {
        var p0 = pathIndexes[i] * 2;
        var p1 = pathIndexes[i + 1] * 2;
        var p2 = pathIndexes[i + 2] * 2;
        var x0 = path[p0 + 0] - dx;
        var y0 = path[p0 + 1] - dy;
        var x1 = path[p1 + 0] - dx;
        var y1 = path[p1 + 1] - dy;
        var x2 = path[p2 + 0] - dx;
        var y2 = path[p2 + 1] - dy;
        var tx0 = calcMatrix.getX(x0, y0);
        var ty0 = calcMatrix.getY(x0, y0);
        var tx1 = calcMatrix.getX(x1, y1);
        var ty1 = calcMatrix.getY(x1, y1);
        var tx2 = calcMatrix.getX(x2, y2);
        var ty2 = calcMatrix.getY(x2, y2);
        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
      }
    };
  
    /*
    src: {
        strokeColor,
        strokeAlpha,
        pathData,
        lineWidth,
        closePath
    }
    */
    var Utils$2 = Phaser.Renderer.WebGL.Utils;
    var StrokePathWebGL = function StrokePathWebGL(pipeline, src, alpha, dx, dy) {
      var strokeTint = pipeline.strokeTint;
      var strokeTintColor = Utils$2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
      strokeTint.TL = strokeTintColor;
      strokeTint.TR = strokeTintColor;
      strokeTint.BL = strokeTintColor;
      strokeTint.BR = strokeTintColor;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var lineWidth = src.lineWidth;
      var halfLineWidth = lineWidth / 2;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
        px1 = px2;
        py1 = py2;
      }
    };
  
    var GetCalcMatrix$1 = Phaser.GameObjects.GetCalcMatrix;
    var PolygonWebGLRenderer = function PolygonWebGLRenderer(renderer, src, camera, parentMatrix) {
      if (src.dirty) {
        src.updateData();
        src.dirty = false;
      }
      camera.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline);
      var result = GetCalcMatrix$1(src, camera, parentMatrix);
      var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var alpha = camera.alpha * src.alpha;
      renderer.pipelines.preBatch(src);
      if (src.isFilled) {
        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
      }
      if (src.isStroked) {
        StrokePathWebGL(pipeline, src, alpha, dx, dy);
      }
      renderer.pipelines.postBatch(src);
    };
  
    var FillStyleCanvas = function FillStyleCanvas(ctx, src, altColor, altAlpha) {
      var fillColor = altColor ? altColor : src.fillColor;
      var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
      var red = (fillColor & 0xFF0000) >>> 16;
      var green = (fillColor & 0xFF00) >>> 8;
      var blue = fillColor & 0xFF;
      ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
    };
  
    var LineStyleCanvas = function LineStyleCanvas(ctx, src, altColor, altAlpha) {
      var strokeColor = altColor ? altColor : src.strokeColor;
      var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
      var red = (strokeColor & 0xFF0000) >>> 16;
      var green = (strokeColor & 0xFF00) >>> 8;
      var blue = strokeColor & 0xFF;
      ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
      ctx.lineWidth = src.lineWidth;
    };
  
    var SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;
    var PolygonCanvasRenderer = function PolygonCanvasRenderer(renderer, src, camera, parentMatrix) {
      if (src.dirty) {
        src.updateData();
        src.dirty = false;
      }
      camera.addToRenderList(src);
      var ctx = renderer.currentContext;
      if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;
        var path = src.pathData;
        var pathLength = path.length - 1;
        var px1 = path[0] - dx;
        var py1 = path[1] - dy;
        ctx.beginPath();
        ctx.moveTo(px1, py1);
        if (!src.closePath) {
          pathLength -= 2;
        }
        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx;
          var py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }
        ctx.closePath();
        if (src.isFilled) {
          FillStyleCanvas(ctx, src);
          ctx.fill();
        }
        if (src.isStroked) {
          LineStyleCanvas(ctx, src);
          ctx.stroke();
        }
  
        //  Restore the context saved in SetTransform
        ctx.restore();
      }
    };
  
    var Render$3 = {
      renderWebGL: PolygonWebGLRenderer,
      renderCanvas: PolygonCanvasRenderer
    };
  
    var Shape$1 = Phaser.GameObjects.Shape;
    var PolygnBase = /*#__PURE__*/function (_Shape) {
      _inherits(PolygnBase, _Shape);
      function PolygnBase() {
        _classCallCheck(this, PolygnBase);
        return _callSuper(this, PolygnBase, arguments);
      }
      _createClass(PolygnBase, [{
        key: "fillColor",
        get: function get() {
          return this._fillColor;
        },
        set: function set(value) {
          this._fillColor = value;
          this.isFilled = value != null && this._fillAlpha > 0;
        }
      }, {
        key: "fillAlpha",
        get: function get() {
          return this._fillAlpha;
        },
        set: function set(value) {
          this._fillAlpha = value;
          this.isFilled = value > 0 && this._fillColor != null;
        }
  
        // Fully override setFillStyle method
      }, {
        key: "setFillStyle",
        value: function setFillStyle(color, alpha) {
          if (alpha === undefined) {
            alpha = 1;
          }
          this.fillColor = color;
          this.fillAlpha = alpha;
          return this;
        }
      }, {
        key: "strokeColor",
        get: function get() {
          return this._strokeColor;
        },
        set: function set(value) {
          this._strokeColor = value;
          this.isStroked = value != null && this._strokeAlpha > 0 && this._lineWidth > 0;
        }
      }, {
        key: "strokeAlpha",
        get: function get() {
          return this._strokeAlpha;
        },
        set: function set(value) {
          this._strokeAlpha = value;
          this.isStroked = value > 0 && this._strokeColor != null && this._lineWidth > 0;
        }
      }, {
        key: "lineWidth",
        get: function get() {
          return this._lineWidth;
        },
        set: function set(value) {
          this._lineWidth = value;
          this.isStroked = value > 0 && this._strokeColor != null;
        }
  
        // Fully override setStrokeStyle method
      }, {
        key: "setStrokeStyle",
        value: function setStrokeStyle(lineWidth, color, alpha) {
          if (alpha === undefined) {
            alpha = 1;
          }
          this.lineWidth = lineWidth;
          this.strokeColor = color;
          this.strokeAlpha = alpha;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this.geom.width;
        },
        set: function set(value) {
          this.resize(value, this.height);
        }
      }, {
        key: "height",
        get: function get() {
          return this.geom.height;
        },
        set: function set(value) {
          this.resize(this.width, value);
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
          }
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          this.setSize(width, height);
          return this;
        }
      }]);
      return PolygnBase;
    }(Shape$1);
    Object.assign(PolygnBase.prototype, Render$3);
  
    var GetValue$3E = Phaser.Utils.Objects.GetValue;
    var RoundRectangle$3 = /*#__PURE__*/function () {
      function RoundRectangle(x, y, width, height, radiusConfig) {
        _classCallCheck(this, RoundRectangle);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = x;
        }
        if (width === undefined) {
          width = 0;
        }
        if (height === undefined) {
          height = 0;
        }
        if (radiusConfig === undefined) {
          radiusConfig = 0;
        }
        this.cornerRadius = {};
        this._width = 0;
        this._height = 0;
        this.setTo(x, y, width, height, radiusConfig);
      }
      _createClass(RoundRectangle, [{
        key: "setTo",
        value: function setTo(x, y, width, height, radiusConfig) {
          this.setPosition(x, y);
          this.setRadius(radiusConfig);
          this.setSize(width, height);
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "setRadius",
        value: function setRadius(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radius = value;
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.width = width;
          this.height = height;
          return this;
        }
      }, {
        key: "minWidth",
        get: function get() {
          var radius = this.cornerRadius;
          return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
        }
      }, {
        key: "minHeight",
        get: function get() {
          var radius = this.cornerRadius;
          return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          if (value == null) {
            value = 0;
          }
          this._width = Math.max(value, this.minWidth);
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          if (value == null) {
            value = 0;
          }
          this._height = Math.max(value, this.minHeight);
        }
      }, {
        key: "radius",
        get: function get() {
          var radius = this.cornerRadius;
          return Math.max(radius.tl.x, radius.tl.y, radius.tr.x, radius.tr.y, radius.bl.x, radius.bl.y, radius.br.x, radius.br.y);
        },
        set: function set(value) {
          var defaultRadiusX, defaultRadiusY;
          if (typeof value === 'number') {
            defaultRadiusX = value;
            defaultRadiusY = value;
          } else {
            defaultRadiusX = GetValue$3E(value, 'x', 0);
            defaultRadiusY = GetValue$3E(value, 'y', 0);
          }
          var radius = this.cornerRadius;
          radius.tl = GetRadius(GetValue$3E(value, 'tl', undefined), defaultRadiusX, defaultRadiusY);
          radius.tr = GetRadius(GetValue$3E(value, 'tr', undefined), defaultRadiusX, defaultRadiusY);
          radius.bl = GetRadius(GetValue$3E(value, 'bl', undefined), defaultRadiusX, defaultRadiusY);
          radius.br = GetRadius(GetValue$3E(value, 'br', undefined), defaultRadiusX, defaultRadiusY);
        }
      }, {
        key: "radiusTL",
        get: function get() {
          var radius = this.cornerRadius.tl;
          return Math.max(radius.x, radius.y);
        },
        set: function set(value) {
          SetRadius(this.cornerRadius.tl, value);
        }
      }, {
        key: "radiusTR",
        get: function get() {
          var radius = this.cornerRadius.tr;
          return Math.max(radius.x, radius.y);
        },
        set: function set(value) {
          SetRadius(this.cornerRadius.tr, value);
        }
      }, {
        key: "radiusBL",
        get: function get() {
          var radius = this.cornerRadius.bl;
          return Math.max(radius.x, radius.y);
        },
        set: function set(value) {
          SetRadius(this.cornerRadius.bl, value);
        }
      }, {
        key: "radiusBR",
        get: function get() {
          var radius = this.cornerRadius.br;
          return Math.max(radius.x, radius.y);
        },
        set: function set(value) {
          SetRadius(this.cornerRadius.br, value);
        }
      }]);
      return RoundRectangle;
    }();
    var GetRadius = function GetRadius(radius, defaultRadiusX, defaultRadiusY) {
      if (radius === undefined) {
        radius = {
          x: defaultRadiusX,
          y: defaultRadiusY
        };
      } else if (typeof radius === 'number') {
        radius = {
          x: radius,
          y: radius
        };
      }
      SetConvex(radius);
      return radius;
    };
    var SetRadius = function SetRadius(radius, value) {
      if (typeof value === 'number') {
        radius.x = value;
        radius.y = value;
      } else {
        radius.x = GetValue$3E(value, 'x', 0);
        radius.y = GetValue$3E(value, 'y', 0);
      }
      SetConvex(radius);
    };
    var SetConvex = function SetConvex(radius) {
      radius.convex = radius.x >= 0 || radius.y >= 0;
      radius.x = Math.abs(radius.x);
      radius.y = Math.abs(radius.y);
    };
  
    var LineTo = function LineTo(x, y, pathData) {
      var cnt = pathData.length;
      if (cnt >= 2) {
        var lastX = pathData[cnt - 2];
        var lastY = pathData[cnt - 1];
        if (x === lastX && y === lastY) {
          return pathData;
        }
      }
      pathData.push(x, y);
      return pathData;
    };
  
    var DegToRad$f = Phaser.Math.DegToRad;
    var ArcTo$1 = function ArcTo(centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
      // startAngle, endAngle: 0 ~ 360
      if (antiClockWise && endAngle > startAngle) {
        endAngle -= 360;
      } else if (!antiClockWise && endAngle < startAngle) {
        endAngle += 360;
      }
      var deltaAngle = endAngle - startAngle;
      var step = DegToRad$f(deltaAngle) / iteration;
      startAngle = DegToRad$f(startAngle);
      for (var i = 0; i <= iteration; i++) {
        var angle = startAngle + step * i;
        var x = centerX + radiusX * Math.cos(angle);
        var y = centerY + radiusY * Math.sin(angle);
        LineTo(x, y, pathData);
      }
      return pathData;
    };
  
    var IsPlainObject$Q = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3D = Phaser.Utils.Objects.GetValue;
    var Earcut$2 = Phaser.Geom.Polygon.Earcut;
    var RoundRectangle$2 = /*#__PURE__*/function (_PolygnBase) {
      _inherits(RoundRectangle, _PolygnBase);
      function RoundRectangle(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
        var _this;
        _classCallCheck(this, RoundRectangle);
        var strokeColor, strokeAlpha, strokeWidth, shapeType;
        if (IsPlainObject$Q(x)) {
          var config = x;
          x = config.x;
          y = config.y;
          width = config.width;
          height = config.height;
          radiusConfig = config.radius;
          fillColor = config.color;
          fillAlpha = config.alpha;
          strokeColor = config.strokeColor;
          strokeAlpha = config.strokeAlpha;
          strokeWidth = config.strokeWidth;
          shapeType = config.shape;
        }
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = width;
        }
        if (radiusConfig === undefined) {
          radiusConfig = 0;
        }
        if (shapeType === undefined) {
          shapeType = 0;
        }
        var geom = new RoundRectangle$3(); // Configurate it later
        _this = _callSuper(this, RoundRectangle, [scene, 'rexRoundRectangleShape', geom]);
        _this.setShapeType(shapeType);
        if (_this.shapeType === 0) {
          var radius = GetValue$3D(radiusConfig, 'radius', radiusConfig);
          geom.setTo(0, 0, width, height, radius);
        } else {
          var radius = {
            x: width / 2,
            y: height / 2
          };
          geom.setTo(0, 0, width, height, radius);
        }
        var iteration = GetValue$3D(radiusConfig, 'iteration', undefined);
        _this.setIteration(iteration);
        _this.setPosition(x, y);
        _this.setFillStyle(fillColor, fillAlpha);
        if (strokeColor !== undefined && strokeWidth === undefined) {
          strokeWidth = 2;
        }
        _this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
        _this.updateDisplayOrigin();
        _this.dirty = true;
        return _this;
      }
      _createClass(RoundRectangle, [{
        key: "updateData",
        value: function updateData() {
          var geom = this.geom;
          var pathData = this.pathData;
          pathData.length = 0;
          var width = geom.width,
            height = geom.height,
            cornerRadius = geom.cornerRadius,
            radius,
            iteration = this.iteration + 1;
  
          // Top-left
          radius = cornerRadius.tl;
          if (IsArcCorner$1(radius)) {
            if (radius.convex) {
              var centerX = radius.x;
              var centerY = radius.y;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
            } else {
              var centerX = 0;
              var centerY = 0;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 0, true, iteration, pathData);
            }
          } else {
            LineTo(0, 0, pathData);
          }
  
          // Top-right
          radius = cornerRadius.tr;
          if (IsArcCorner$1(radius)) {
            if (radius.convex) {
              var centerX = width - radius.x;
              var centerY = radius.y;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
            } else {
              var centerX = width;
              var centerY = 0;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 90, true, iteration, pathData);
            }
          } else {
            LineTo(width, 0, pathData);
          }
  
          // Bottom-right
          radius = cornerRadius.br;
          if (IsArcCorner$1(radius)) {
            if (radius.convex) {
              var centerX = width - radius.x;
              var centerY = height - radius.y;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
            } else {
              var centerX = width;
              var centerY = height;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 180, true, iteration, pathData);
            }
          } else {
            LineTo(width, height, pathData);
          }
  
          // Bottom-left
          radius = cornerRadius.bl;
          if (IsArcCorner$1(radius)) {
            if (radius.convex) {
              var centerX = radius.x;
              var centerY = height - radius.y;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
            } else {
              var centerX = 0;
              var centerY = height;
              ArcTo$1(centerX, centerY, radius.x, radius.y, 360, 270, true, iteration, pathData);
            }
          } else {
            LineTo(0, height, pathData);
          }
          pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
          this.pathIndexes = Earcut$2(pathData);
          return this;
        }
      }, {
        key: "setShapeType",
        value: function setShapeType(shapeType) {
          if (typeof shapeType === 'string') {
            shapeType = ShapeTypeMap[shapeType];
          }
          this.shapeType = shapeType;
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          // Override Shape's setSize method
          if (height === undefined) {
            height = width;
          }
          if (this.geom.width === width && this.geom.height === height) {
            return this;
          }
          this.geom.setSize(width, height);
          if (this.shapeType === 1) {
            this.setRadius({
              x: width / 2,
              y: height / 2
            });
          }
          this.updateDisplayOrigin();
          this.dirty = true;
          _get(_getPrototypeOf(RoundRectangle.prototype), "setSize", this).call(this, width, height);
          return this;
        }
      }, {
        key: "radius",
        get: function get() {
          return this.geom.radius;
        },
        set: function set(value) {
          this.geom.setRadius(value);
          this.updateDisplayOrigin();
          this.dirty = true;
        }
      }, {
        key: "radiusTL",
        get: function get() {
          return this.geom.radiusTL;
        },
        set: function set(value) {
          this.geom.radiusTL = value;
          this.dirty = true;
        }
      }, {
        key: "radiusTR",
        get: function get() {
          return this.geom.radiusTR;
        },
        set: function set(value) {
          this.geom.radiusTR = value;
          this.dirty = true;
        }
      }, {
        key: "radiusBL",
        get: function get() {
          return this.geom.radiusBL;
        },
        set: function set(value) {
          this.geom.radiusBL = value;
          this.dirty = true;
        }
      }, {
        key: "radiusBR",
        get: function get() {
          return this.geom.radiusBR;
        },
        set: function set(value) {
          this.geom.radiusBR = value;
          this.dirty = true;
        }
      }, {
        key: "setRadius",
        value: function setRadius(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radius = value;
          return this;
        }
      }, {
        key: "setRadiusTL",
        value: function setRadiusTL(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radiusTL = value;
          return this;
        }
      }, {
        key: "setRadiusTR",
        value: function setRadiusTR(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radiusTR = value;
          return this;
        }
      }, {
        key: "setRadiusBL",
        value: function setRadiusBL(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radiusBL = value;
          return this;
        }
      }, {
        key: "setRadiusBR",
        value: function setRadiusBR(value) {
          if (value === undefined) {
            value = 0;
          }
          this.radiusBR = value;
          return this;
        }
      }, {
        key: "cornerRadius",
        get: function get() {
          return this.geom.cornerRadius;
        },
        set: function set(value) {
          this.radius = value;
        }
      }, {
        key: "setCornerRadius",
        value: function setCornerRadius(value) {
          return this.setRadius(value);
        }
      }, {
        key: "iteration",
        get: function get() {
          return this._iteration;
        },
        set: function set(value) {
          // Set iteration first time
          if (this._iteration === undefined) {
            this._iteration = value;
            return;
          }
  
          // Change iteration value
          if (this._iteration === value) {
            return;
          }
          this._iteration = value;
          this.dirty = true;
        }
      }, {
        key: "setIteration",
        value: function setIteration(iteration) {
          if (iteration === undefined) {
            iteration = 6;
          }
          this.iteration = iteration;
          return this;
        }
      }]);
      return RoundRectangle;
    }(PolygnBase);
    var IsArcCorner$1 = function IsArcCorner(radius) {
      return radius.x > 0 && radius.y > 0;
    };
    var ShapeTypeMap = {
      rectangle: 0,
      circle: 1
    };
  
    ObjectFactory.register('roundRectangle', function (x, y, width, height, radiusConfig, fillColor, fillAlpha) {
      var gameObject = new RoundRectangle$2(this.scene, x, y, width, height, radiusConfig, fillColor, fillAlpha);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.RoundRectangle', RoundRectangle$2);
  
    // copy from Phaser.GameObjects.Text
  
    var Utils$1 = Phaser.Renderer.WebGL.Utils;
    var WebGLRenderer$2 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
      if (src.dirty) {
        src.updateTexture();
        src.dirty = false;
      }
      if (src.width === 0 || src.height === 0) {
        return;
      }
      camera.addToRenderList(src);
      var frame = src.frame;
      var width = frame.width;
      var height = frame.height;
      var getTint = Utils$1.getTintAppendFloatAlpha;
      var pipeline = renderer.pipelines.set(src.pipeline, src);
      var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
      renderer.pipelines.preBatch(src);
      pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.resolution, height / src.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
      renderer.pipelines.postBatch(src);
    };
  
    // copy from Phaser.GameObjects.Text
  
    var CanvasRenderer$2 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
      if (src.dirty) {
        src.updateTexture();
        src.dirty = false;
      }
      if (src.width === 0 || src.height === 0) {
        return;
      }
      camera.addToRenderList(src);
      renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  
    var Render$2 = {
      renderWebGL: WebGLRenderer$2,
      renderCanvas: CanvasRenderer$2
    };
  
    var Color$4 = Phaser.Display.Color;
    var CanvasMethods = {
      clear: function clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.dirty = true;
        return this;
      },
      fill: function fill(color) {
        this.context.fillStyle = color;
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.dirty = true;
        return this;
      },
      drawFrame: function drawFrame(key, frame, dx, dy, dWidth, dHeight, sxOffset, syOffset, sWidth, sHeight) {
        var textureFrame = this.scene.sys.textures.getFrame(key, frame);
        if (!textureFrame) {
          return this;
        }
        var frameWidth = textureFrame.cutWidth,
          frameHeight = textureFrame.cutHeight;
        if (dx === undefined) {
          dx = 0;
        }
        if (dy === undefined) {
          dy = 0;
        }
        if (dWidth === undefined) {
          dWidth = frameWidth;
        }
        if (dHeight === undefined) {
          dHeight = frameHeight;
        }
        if (sxOffset === undefined) {
          sxOffset = 0;
        }
        if (syOffset === undefined) {
          syOffset = 0;
        }
        if (sWidth === undefined) {
          sWidth = frameWidth;
        }
        if (sHeight === undefined) {
          sHeight = frameHeight;
        }
        var sx = textureFrame.cutX + sxOffset;
        var sy = textureFrame.cutY + syOffset;
        this.context.drawImage(textureFrame.source.image,
        // image
        sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        this.dirty = true;
        return this;
      },
      getDataURL: function getDataURL(type, encoderOptions) {
        return this.canvas.toDataURL(type, encoderOptions);
      },
      getPixel: function getPixel(x, y, out) {
        if (out === undefined) {
          out = new Color$4();
        }
        var rgb = this.context.getImageData(x, y, 1, 1);
        out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
        return out;
      },
      setPixel: function setPixel(x, y, r, g, b, a) {
        if (typeof r !== 'number') {
          var color = r;
          r = color.red;
          g = color.green;
          b = color.blue;
          a = color.alpha;
        }
        if (a === undefined) {
          a = r !== 0 || g !== 0 || b !== 0 ? 255 : 0;
        }
        var imgData = this.context.createImageData(1, 1);
        imgData.data[0] = r;
        imgData.data[1] = g;
        imgData.data[2] = b;
        imgData.data[3] = a;
        this.context.putImageData(imgData, x, y);
        this.dirty = true;
        return this;
      }
    };
  
    var CopyCanvasToTexture = function CopyCanvasToTexture(scene, srcCanvas, key, x, y, width, height) {
      var textures = scene.sys.textures;
      var renderer = scene.renderer;
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = srcCanvas.width;
      }
      if (height === undefined) {
        height = srcCanvas.height;
      }
      var texture;
      if (textures.exists(key)) {
        texture = textures.get(key);
      } else {
        texture = textures.createCanvas(key, width, height);
      }
      var destCanvas = texture.getSourceImage();
      if (destCanvas.width !== width) {
        destCanvas.width = width;
      }
      if (destCanvas.height !== height) {
        destCanvas.height = height;
      }
      var destCtx = destCanvas.getContext('2d', {
        willReadFrequently: true
      });
      destCtx.clearRect(0, 0, width, height);
      destCtx.drawImage(srcCanvas, x, y, width, height);
      if (renderer.gl && texture) {
        renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
      }
    };
  
    var TextureMethods = {
      updateTexture: function updateTexture(callback, scope) {
        if (callback) {
          if (scope) {
            callback.call(scope, this.canvas, this.context);
          } else {
            callback(this.canvas, this.context);
          }
        }
        if (this.canvas.width !== this.frame.width || this.canvas.height !== this.frame.height) {
          this.frame.setSize(this.canvas.width, this.canvas.height);
        }
        if (this.renderer && this.renderer.gl) {
          this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
          if (typeof WEBGL_DEBUG === "undefined" ? "undefined" : _typeof(WEBGL_DEBUG)) {
            this.frame.glTexture.spectorMetadata = {
              textureKey: 'Canvas Game Object'
            };
          }
        }
        this.dirty = false;
        var input = this.input;
        if (input && !input.customHitArea) {
          input.hitArea.width = this.width;
          input.hitArea.height = this.height;
        }
        return this;
      },
      generateTexture: function generateTexture(key, x, y, width, height) {
        var srcCanvas = this.canvas;
        if (width === undefined) {
          width = srcCanvas.width;
        } else {
          width *= this.resolution;
        }
        if (height === undefined) {
          height = srcCanvas.height;
        } else {
          height *= this.resolution;
        }
        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
        return this;
      },
      loadTexture: function loadTexture(key, frame) {
        var textureFrame = this.scene.sys.textures.getFrame(key, frame);
        if (!textureFrame) {
          return this;
        }
        if (this.width !== textureFrame.cutWidth || this.height !== textureFrame.cutHeight) {
          this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
        } else {
          this.clear();
        }
        this.drawFrame(key, frame);
        this.dirty = true;
        return this;
      }
    };
  
    CheckP3Version();
    var CanvasPool$4 = Phaser.Display.Canvas.CanvasPool;
    var GameObject$3 = Phaser.GameObjects.GameObject;
    var UUID$5 = Phaser.Utils.String.UUID;
    var Canvas$1 = /*#__PURE__*/function (_GameObject) {
      _inherits(Canvas, _GameObject);
      function Canvas(scene, x, y, width, height) {
        var _this;
        _classCallCheck(this, Canvas);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = 1;
        }
        _this = _callSuper(this, Canvas, [scene, 'rexCanvas']);
        _this.renderer = scene.sys.game.renderer;
        _this.resolution = 1;
        _this._width = width;
        _this._height = height;
        width = Math.max(Math.ceil(width * _this.resolution), 1);
        height = Math.max(Math.ceil(height * _this.resolution), 1);
        _this.canvas = CanvasPool$4.create(_assertThisInitialized(_this), width, height);
        _this.context = _this.canvas.getContext('2d', {
          willReadFrequently: true
        });
        _this.dirty = false;
        _this.setPosition(x, y);
        _this.setOrigin(0.5, 0.5);
        _this.initPipeline();
        _this.initPostPipeline(true);
        _this._crop = _this.resetCropObject();
  
        //  Create a Texture for this Text object
        _this._textureKey = UUID$5();
        _this.texture = scene.sys.textures.addCanvas(_this._textureKey, _this.canvas);
  
        //  Get the frame
        _this.frame = _this.texture.get();
  
        //  Set the resolution
        _this.frame.source.resolution = _this.resolution;
        if (_this.renderer && _this.renderer.gl) {
          //  Clear the default 1x1 glTexture, as we override it later
          _this.renderer.deleteTexture(_this.frame.source.glTexture);
          _this.frame.source.glTexture = null;
        }
        _this.dirty = true;
        return _this;
      }
      _createClass(Canvas, [{
        key: "preDestroy",
        value: function preDestroy() {
          CanvasPool$4.remove(this.canvas);
          this.canvas = null;
          this.context = null;
          var texture = this.texture;
          if (texture) {
            texture.destroy();
          }
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this.setSize(value, this._height);
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this.setSize(this._width, value);
        }
      }, {
        key: "setCanvasSize",
        value: function setCanvasSize(width, height) {
          if (this._width === width && this._height === height) {
            return this;
          }
          this._width = width;
          this._height = height;
          this.updateDisplayOrigin();
          width = Math.max(Math.ceil(width * this.resolution), 1);
          height = Math.max(Math.ceil(height * this.resolution), 1);
          this.canvas.width = width;
          this.canvas.height = height;
          this.frame.setSize(width, height);
          this.dirty = true;
          return this;
        }
  
        // setSize might be override
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.setCanvasSize(width, height);
          return this;
        }
      }, {
        key: "displayWidth",
        get: function get() {
          return this.scaleX * this._width;
        },
        set: function set(value) {
          this.scaleX = value / this._width;
        }
      }, {
        key: "displayHeight",
        get: function get() {
          return this.scaleY * this._height;
        },
        set: function set(value) {
          this.scaleY = value / this._height;
        }
      }, {
        key: "setDisplaySize",
        value: function setDisplaySize(width, height) {
          this.displayWidth = width;
          this.displayHeight = height;
          return this;
        }
      }, {
        key: "getCanvas",
        value: function getCanvas(readOnly) {
          if (!readOnly) {
            this.dirty = true;
          }
          return this.canvas;
        }
      }, {
        key: "getContext",
        value: function getContext(readOnly) {
          if (!readOnly) {
            this.dirty = true;
          }
          return this.context;
        }
      }, {
        key: "needRedraw",
        value: function needRedraw() {
          this.dirty = true;
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          this.setSize(width, height);
          return this;
        }
      }]);
      return Canvas;
    }(GameObject$3);
    var Components$3 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Canvas$1, [Components$3.Alpha, Components$3.BlendMode, Components$3.Crop, Components$3.Depth, Components$3.Flip, Components$3.GetBounds, Components$3.Mask, Components$3.Origin, Components$3.Pipeline, Components$3.PostPipeline, Components$3.ScrollFactor, Components$3.Tint, Components$3.Transform, Components$3.Visible, Render$2, CanvasMethods, TextureMethods]);
  
    var Pad$1 = Phaser.Utils.String.Pad;
    var GetStyle = function GetStyle(style, canvas, context) {
      if (style == null) {
        return style;
      }
      switch (_typeof(style)) {
        case 'string':
          return style;
        case 'number':
          return "#".concat(Pad$1(Math.floor(style).toString(16), 6, '0', 1));
        case 'function':
          return style(canvas, context);
        case 'object':
          if (style.hasOwnProperty('r')) {
            if (style.hasOwnProperty('a')) {
              // rgba
              return "rgba(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ",").concat(style.a, ")");
            } else {
              // rgb
              return "rgb(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ")");
            }
          } else if (style.hasOwnProperty('h')) {
            if (style.hasOwnProperty('a')) {
              // hsla
              return "hsla(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ",").concat(style.a, ")");
            } else {
              // hsl
              return "hsl(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ")");
            }
          } else {
            return style; // Not a valid input
          }
        default:
          return style;
      }
    };
  
    var DegToRad$e = Phaser.Math.DegToRad;
    var AddRoundRectanglePath = function AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration) {
      var geom = new RoundRectangle$3(x, y, width, height, radiusConfig),
        minWidth = geom.minWidth,
        minHeight = geom.minHeight,
        scaleRX = width >= minWidth ? 1 : width / minWidth,
        scaleRY = height >= minHeight ? 1 : height / minHeight;
      var cornerRadius = geom.cornerRadius;
      var radius, radiusX, radiusY, centerX, centerY;
      var startX, startY;
      context.save();
      context.beginPath();
      context.translate(x, y);
  
      // Top-left
      radius = cornerRadius.tl;
      if (IsArcCorner(radius)) {
        radiusX = radius.x * scaleRX;
        radiusY = radius.y * scaleRY;
        if (IsConvexArc(radius)) {
          centerX = radiusX;
          centerY = radiusY;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
        } else {
          centerX = 0;
          centerY = 0;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
        }
        startX = 0;
        startY = radiusY;
      } else {
        context.lineTo(0, 0);
        startX = 0;
        startY = 0;
      }
  
      // Top-right
      radius = cornerRadius.tr;
      if (IsArcCorner(radius)) {
        radiusX = radius.x * scaleRX;
        radiusY = radius.y * scaleRY;
        if (IsConvexArc(radius)) {
          centerX = width - radiusX;
          centerY = radiusY;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
        } else {
          centerX = width;
          centerY = 0;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
        }
      } else {
        context.lineTo(width, 0);
      }
  
      // Bottom-right
      radius = cornerRadius.br;
      if (IsArcCorner(radius)) {
        radiusX = radius.x * scaleRX;
        radiusY = radius.y * scaleRY;
        if (IsConvexArc(radius)) {
          centerX = width - radiusX;
          centerY = height - radiusY;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
        } else {
          centerX = width;
          centerY = height;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
        }
      } else {
        context.lineTo(width, height);
      }
  
      // Bottom-left
      radius = cornerRadius.bl;
      if (IsArcCorner(radius)) {
        radiusX = radius.x * scaleRX;
        radiusY = radius.y * scaleRY;
        if (IsConvexArc(radius)) {
          centerX = radiusX;
          centerY = height - radiusY;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
        } else {
          centerX = 0;
          centerY = height;
          ArcTo(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
        }
      } else {
        context.lineTo(0, height);
      }
      context.lineTo(startX, startY);
      context.closePath();
      context.restore();
    };
    var IsConvexArc = function IsConvexArc(radius) {
      return !radius.hasOwnProperty('convex') ||
      // radius does not have convex property
      radius.convex;
    };
    var IsArcCorner = function IsArcCorner(radius) {
      return radius.x > 0 && radius.y > 0;
    };
    var ArcTo = function ArcTo(context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration) {
      // startAngle, endAngle: 0 ~ 360
      if (antiClockWise && endAngle > startAngle) {
        endAngle -= 360;
      } else if (!antiClockWise && endAngle < startAngle) {
        endAngle += 360;
      }
      startAngle = DegToRad$e(startAngle);
      endAngle = DegToRad$e(endAngle);
      if (iteration == null) {
        // undefined, or null
        context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
      } else {
        iteration += 1;
        var x, y, angle;
        var step = (endAngle - startAngle) / iteration;
        for (var i = 0; i <= iteration; i++) {
          angle = startAngle + step * i;
          x = centerX + radiusX * Math.cos(angle);
          y = centerY + radiusY * Math.sin(angle);
          context.lineTo(x, y);
        }
      }
    };
  
    var DrawRoundRectangle = function DrawRoundRectangle(canvas, context, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, iteration) {
      AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);
      if (fillStyle != null) {
        if (fillColor2 != null) {
          var grd;
          if (isHorizontalGradient) {
            grd = context.createLinearGradient(0, 0, width, 0);
          } else {
            grd = context.createLinearGradient(0, 0, 0, height);
          }
          grd.addColorStop(0, fillStyle);
          grd.addColorStop(1, fillColor2);
          fillStyle = grd;
        }
        context.fillStyle = fillStyle;
        context.fill();
      }
      if (strokeStyle != null && lineWidth > 0) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = lineWidth;
        context.stroke();
      }
    };
  
    var DrawRoundRectangleBackground = function DrawRoundRectangleBackground(canvasObject, color, strokeColor, strokeLineWidth, radius, color2, isHorizontalGradient, iteration) {
      if (color == null && strokeColor == null) {
        return;
      }
      var width = canvasObject.canvas.width,
        height = canvasObject.canvas.height;
      if (strokeColor == null) {
        strokeLineWidth = 0;
      }
      var x = strokeLineWidth / 2;
      width = Math.max(1, width - strokeLineWidth); // Min width is 1
      height = Math.max(1, height - strokeLineWidth); // Min height is 1
      DrawRoundRectangle(canvasObject.canvas, canvasObject.context, x, x, width, height, radius, color, strokeColor, strokeLineWidth, color2, isHorizontalGradient, iteration);
    };
  
    var DrawContent$2 = function DrawContent() {
      DrawRoundRectangleBackground(this, this.fillStyle, this.strokeStyle, this.lineWidth, this.radius, this.fillColor2, this.isHorizontalGradient, this.iteration);
    };
  
    var GetValue$3C = Phaser.Utils.Objects.GetValue;
    var RoundRectangle$1 = /*#__PURE__*/function (_Canvas) {
      _inherits(RoundRectangle, _Canvas);
      function RoundRectangle(scene, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
        var _this;
        _classCallCheck(this, RoundRectangle);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = width;
        }
        if (radiusConfig === undefined) {
          radiusConfig = 0;
        }
        _this = _callSuper(this, RoundRectangle, [scene, x, y, width, height]);
        _this.type = 'rexRoundRectangleCanvas';
        var radius = GetValue$3C(radiusConfig, 'radius', radiusConfig);
        var iteration = GetValue$3C(radiusConfig, 'iteration', undefined);
        _this.setRadius(radius);
        _this.setIteration(iteration);
        _this.setFillStyle(fillStyle, fillColor2, isHorizontalGradient);
        _this.setStrokeStyle(strokeStyle, lineWidth);
        return _this;
      }
      _createClass(RoundRectangle, [{
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this.dirty |= this._radius != value;
          this._radius = value;
        }
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          this.radius = radius;
          return this;
        }
      }, {
        key: "iteration",
        get: function get() {
          return this._iteration;
        },
        set: function set(value) {
          this.dirty |= this._iteration != value;
          this._iteration = value;
        }
      }, {
        key: "setIteration",
        value: function setIteration(iteration) {
          this.iteration = iteration;
          return this;
        }
      }, {
        key: "fillStyle",
        get: function get() {
          return this._fillStyle;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty |= this._fillStyle != value;
          this._fillStyle = value;
        }
      }, {
        key: "fillColor2",
        get: function get() {
          return this._fillColor2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty |= this._fillColor2 != value;
          this._fillColor2 = value;
        }
      }, {
        key: "isHorizontalGradient",
        get: function get() {
          return this._isHorizontalGradient;
        },
        set: function set(value) {
          this.dirty |= this._isHorizontalGradient != value;
          this._isHorizontalGradient = value;
        }
      }, {
        key: "setFillStyle",
        value: function setFillStyle(fillStyle, fillColor2, isHorizontalGradient) {
          if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
          }
          this.fillStyle = fillStyle;
          this.fillColor2 = fillColor2;
          this.isHorizontalGradient = isHorizontalGradient;
          return this;
        }
      }, {
        key: "strokeStyle",
        get: function get() {
          return this._strokeStyle;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty |= this._strokeStyle != value;
          this._strokeStyle = value;
        }
      }, {
        key: "lineWidth",
        get: function get() {
          return this._lineWidth;
        },
        set: function set(value) {
          this.dirty |= this._lineWidth != value;
          this._lineWidth = value;
        }
      }, {
        key: "setStrokeStyle",
        value: function setStrokeStyle(strokeStyle, lineWidth) {
          this.strokeStyle = strokeStyle;
          this.lineWidth = lineWidth;
          return this;
        }
      }, {
        key: "updateTexture",
        value: function updateTexture() {
          this.clear();
          DrawContent$2.call(this);
          _get(_getPrototypeOf(RoundRectangle.prototype), "updateTexture", this).call(this);
          return this;
        }
      }]);
      return RoundRectangle;
    }(Canvas$1);
  
    ObjectFactory.register('roundRectangleCanvas', function (x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
      var gameObject = new RoundRectangle$1(this.scene, x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.RoundRectangleCanvas', RoundRectangle$1);
  
    var HasProperty = function HasProperty(obj, prop) {
      if (!obj) {
        return false;
      }
      if (obj.hasOwnProperty(prop)) {
        return true;
      }
      while (obj) {
        if (Object.getOwnPropertyDescriptor(obj, prop)) {
          return true;
        }
        obj = obj.__proto__;
      }
      return false;
    };
  
    var InjectPointAccessProperties = function InjectPointAccessProperties(gameObject, key, point) {
      if (!key || HasProperty(gameObject, "".concat(key, "X"))) {
        return;
      }
      Object.defineProperty(gameObject, "".concat(key, "X"), {
        get: function get() {
          return point.x;
        },
        set: function set(value) {
          point.x = value;
          gameObject.dirty = true;
        }
      });
      Object.defineProperty(gameObject, "".concat(key, "Y"), {
        get: function get() {
          return point.y;
        },
        set: function set(value) {
          point.y = value;
          gameObject.dirty = true;
        }
      });
      Object.defineProperty(gameObject, "".concat(key, "T"), {
        get: function get() {
          return point.t;
        },
        set: function set(value) {
          point.t = value;
          gameObject.dirty = true;
        }
      });
    };
    var PointMethods = {
      setTLPosition: function setTLPosition(x, y) {
        this.geom.setTLPosition(x, y);
        this.dirty = true;
        return this;
      },
      setTRPosition: function setTRPosition(x, y) {
        this.geom.setTRPosition(x, y);
        this.dirty = true;
        return this;
      },
      setBLPosition: function setBLPosition(x, y) {
        this.geom.setBLPosition(x, y);
        this.dirty = true;
        return this;
      },
      setBRPosition: function setBRPosition(x, y) {
        this.geom.setBRPosition(x, y);
        this.dirty = true;
        return this;
      },
      resetCornerPosition: function resetCornerPosition() {
        this.geom.resetCornerPosition();
        this.dirty = true;
        return this;
      },
      insertTopSidePoint: function insertTopSidePoint(t, x, y, key) {
        var points = this.geom.topSidePoints;
        if (Array.isArray(t)) {
          var points = t,
            point;
          for (var i = 0, cnt = points.length; i < cnt; i++) {
            point = points[i];
            this.geom.insertTopSidePoint(point.t, point.x, point.y);
            InjectPointAccessProperties(this, point.key, points[points.length - 1]);
          }
        } else {
          this.geom.insertTopSidePoint(t, x, y);
          InjectPointAccessProperties(this, key, points[points.length - 1]);
        }
        this.dirty = true;
        return this;
      },
      insertRightSidePoint: function insertRightSidePoint(t, x, y, key) {
        var points = this.geom.rightSidePoints;
        if (Array.isArray(t)) {
          var points = t,
            point;
          for (var i = 0, cnt = points.length; i < cnt; i++) {
            point = points[i];
            this.geom.insertRightSidePoint(point.t, point.x, point.y);
            InjectPointAccessProperties(this, point.key, points[points.length - 1]);
          }
        } else {
          this.geom.insertRightSidePoint(t, x, y);
          InjectPointAccessProperties(this, key, points[points.length - 1]);
        }
        this.dirty = true;
        return this;
      },
      insertBottomSidePoint: function insertBottomSidePoint(t, x, y, key) {
        var points = this.geom.bottomSidePoints;
        if (Array.isArray(t)) {
          var points = t,
            point;
          for (var i = 0, cnt = points.length; i < cnt; i++) {
            point = points[i];
            this.geom.insertBottomSidePoint(point.t, point.x, point.y);
            InjectPointAccessProperties(this, point.key, points[points.length - 1]);
          }
        } else {
          this.geom.insertBottomSidePoint(t, x, y);
          InjectPointAccessProperties(this, key, points[points.length - 1]);
        }
        this.dirty = true;
        return this;
      },
      insertLeftSidePoint: function insertLeftSidePoint(t, x, y, key) {
        var points = this.geom.leftSidePoints;
        if (Array.isArray(t)) {
          var points = t,
            point;
          for (var i = 0, cnt = points.length; i < cnt; i++) {
            point = points[i];
            this.geom.insertLeftSidePoint(point.t, point.x, point.y);
            InjectPointAccessProperties(this, point.key, points[points.length - 1]);
          }
        } else {
          this.geom.insertLeftSidePoint(t, x, y);
          InjectPointAccessProperties(this, key, points[points.length - 1]);
        }
        this.dirty = true;
        return this;
      },
      clearTopSidePoints: function clearTopSidePoints() {
        this.geom.clearTopSidePoints();
        this.dirty = true;
        return this;
      },
      clearRightSidePoints: function clearRightSidePoints() {
        this.geom.clearRightSidePoints();
        this.dirty = true;
        return this;
      },
      clearBottomSidePoints: function clearBottomSidePoints() {
        this.geom.clearBottomSidePoints();
        this.dirty = true;
        return this;
      },
      clearLeftSidePoints: function clearLeftSidePoints() {
        this.geom.clearLeftSidePoints();
        this.dirty = true;
        return this;
      },
      clearAllSidesPoints: function clearAllSidesPoints() {
        this.geom.clearAllSidesPoints();
        this.dirty = true;
        return this;
      }
    };
  
    var QuadGeom = /*#__PURE__*/function () {
      function QuadGeom(x, y, width, height) {
        _classCallCheck(this, QuadGeom);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = x;
        }
        if (width === undefined) {
          width = 0;
        }
        if (height === undefined) {
          height = 0;
        }
        this.setTo(x, y, width, height);
        this.tlx = 0;
        this.tly = 0;
        this.trx = 0;
        this["try"] = 0;
        this.blx = 0;
        this.bly = 0;
        this.brx = 0;
        this.bry = 0;
        this.topSidePoints = [];
        this.rightSidePoints = [];
        this.bottomSidePoints = [];
        this.leftSidePoints = [];
      }
      _createClass(QuadGeom, [{
        key: "setTo",
        value: function setTo(x, y, width, height) {
          this.setPosition(x, y);
          this.setSize(width, height);
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.width = width;
          this.height = height;
          return this;
        }
      }, {
        key: "setTLPosition",
        value: function setTLPosition(x, y) {
          this.tlx = x;
          this.tly = y;
          return this;
        }
      }, {
        key: "setTRPosition",
        value: function setTRPosition(x, y) {
          this.trx = x;
          this["try"] = y;
          return this;
        }
      }, {
        key: "setBLPosition",
        value: function setBLPosition(x, y) {
          this.blx = x;
          this.bly = y;
          return this;
        }
      }, {
        key: "setBRPosition",
        value: function setBRPosition(x, y) {
          this.brx = x;
          this.bry = y;
          return this;
        }
      }, {
        key: "resetCornerPosition",
        value: function resetCornerPosition() {
          this.setTLPosition(0, 0).setTRPosition(0, 0).setBLPosition(0, 0).setBRPosition(0, 0);
          return this;
        }
      }, {
        key: "insertTopSidePoint",
        value: function insertTopSidePoint(t, x, y) {
          AddPoint(this.topSidePoints, t, x, y);
          return this;
        }
      }, {
        key: "insertRightSidePoint",
        value: function insertRightSidePoint(t, x, y) {
          AddPoint(this.rightSidePoints, t, x, y);
          return this;
        }
      }, {
        key: "insertBottomSidePoint",
        value: function insertBottomSidePoint(t, x, y) {
          AddPoint(this.bottomSidePoints, t, x, y);
          return this;
        }
      }, {
        key: "insertLeftSidePoint",
        value: function insertLeftSidePoint(t, x, y) {
          AddPoint(this.leftSidePoints, t, x, y);
          return this;
        }
      }, {
        key: "clearTopSidePoints",
        value: function clearTopSidePoints() {
          this.topSidePoints.length = 0;
          return this;
        }
      }, {
        key: "clearRightSidePoints",
        value: function clearRightSidePoints() {
          this.rightSidePoints.length = 0;
          return this;
        }
      }, {
        key: "clearBottomSidePoints",
        value: function clearBottomSidePoints() {
          this.bottomSidePoints.length = 0;
          return this;
        }
      }, {
        key: "clearLeftSidePoints",
        value: function clearLeftSidePoints() {
          this.leftSidePoints.length = 0;
          return this;
        }
      }, {
        key: "clearAllSidesPoints",
        value: function clearAllSidesPoints() {
          this.clearTopSidePoints().clearRightSidePoints().clearBottomSidePoints().clearLeftSidePoints();
          return this;
        }
      }]);
      return QuadGeom;
    }();
    var AddPoint = function AddPoint(points, t, x, y) {
      if (typeof t !== 'number') {
        var config = t;
        t = config.t;
        x = config.x;
        y = config.y;
      }
      points.push({
        t: t,
        x: x,
        y: y
      });
    };
  
    var IsPlainObject$P = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3B = Phaser.Utils.Objects.GetValue;
    var Linear$e = Phaser.Math.Linear;
    var Earcut$1 = Phaser.Geom.Polygon.Earcut;
    var Quad = /*#__PURE__*/function (_PolygnBase) {
      _inherits(Quad, _PolygnBase);
      function Quad(scene, x, y, width, height, fillColor, fillAlpha) {
        var _this;
        _classCallCheck(this, Quad);
        var strokeColor, strokeAlpha, strokeWidth;
        if (IsPlainObject$P(x)) {
          var config = x;
          x = config.x;
          y = config.y;
          width = config.width;
          height = config.height;
          fillColor = config.color;
          fillAlpha = config.alpha;
          strokeColor = config.strokeColor;
          strokeAlpha = config.strokeAlpha;
          strokeWidth = config.strokeWidth;
        }
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = width;
        }
        var geom = new QuadGeom(); // Configurate it later
        _this = _callSuper(this, Quad, [scene, 'rexQuadShape', geom]);
        geom.setTo(0, 0, width, height);
        _this.setPosition(x, y);
        _this.setFillStyle(fillColor, fillAlpha);
        if (strokeColor !== undefined && strokeWidth === undefined) {
          strokeWidth = 2;
        }
        _this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
        _this.setTLPosition(GetValue$3B(config, 'tlx', 0), GetValue$3B(config, 'tly', 0)).setTRPosition(GetValue$3B(config, 'trx', 0), GetValue$3B(config, 'try', 0)).setBLPosition(GetValue$3B(config, 'blx', 0), GetValue$3B(config, 'bly', 0)).setBRPosition(GetValue$3B(config, 'brx', 0), GetValue$3B(config, 'bry', 0));
        var leftSidePoints = GetValue$3B(config, 'leftSidePoints');
        if (leftSidePoints) {
          _this.insertLeftSidePoint(leftSidePoints);
        }
        var topSidePoints = GetValue$3B(config, 'topSidePoints');
        if (topSidePoints) {
          _this.insertTopSidePoint(topSidePoints);
        }
        var rightSidePoints = GetValue$3B(config, 'rightSidePoints');
        if (rightSidePoints) {
          _this.insertRightSidePoint(rightSidePoints);
        }
        var bottomSidePoints = GetValue$3B(config, 'bottomSidePoints');
        if (bottomSidePoints) {
          _this.insertBottomSidePoint(bottomSidePoints);
        }
        _this.updateDisplayOrigin();
        _this.dirty = true;
        return _this;
      }
      _createClass(Quad, [{
        key: "updateData",
        value: function updateData() {
          var geom = this.geom;
          var pathData = this.pathData;
          pathData.length = 0;
          var width = geom.width;
          var height = geom.height;
          var tlx = 0 + geom.tlx;
          var tly = 0 + geom.tly;
          var trx = width + geom.trx;
          var try_ = 0 + geom["try"];
          var brx = width + geom.brx;
          var bry = height + geom.bry;
          var blx = 0 + geom.blx;
          var bly = height + geom.bly;
          var topSidePoints = geom.topSidePoints;
          var rightSidePoints = geom.rightSidePoints;
          var bottomSidePoints = geom.bottomSidePoints;
          var leftSidePoints = geom.leftSidePoints;
  
          // Top side
          LineTo(tlx, tly, pathData);
          SortPoints(topSidePoints);
          for (var i = 0, cnt = topSidePoints.length; i < cnt; i++) {
            var point = topSidePoints[i];
            var px = Linear$e(tlx, trx, point.t) + point.x;
            var py = Linear$e(tly, try_, point.t) + point.y;
            LineTo(px, py, pathData);
          }
  
          // Right side
          LineTo(trx, try_, pathData);
          SortPoints(rightSidePoints);
          for (var i = 0, cnt = rightSidePoints.length; i < cnt; i++) {
            var point = rightSidePoints[i];
            var px = Linear$e(trx, brx, point.t) + point.x;
            var py = Linear$e(try_, bry, point.t) + point.y;
            LineTo(px, py, pathData);
          }
  
          // Bottom side
          LineTo(brx, bry, pathData);
          SortPoints(bottomSidePoints);
          for (var i = bottomSidePoints.length - 1; i >= 0; i--) {
            var point = bottomSidePoints[i];
            var px = Linear$e(blx, brx, point.t) + point.x;
            var py = Linear$e(bly, bry, point.t) + point.y;
            LineTo(px, py, pathData);
          }
  
          // Left side
          LineTo(blx, bly, pathData);
          SortPoints(leftSidePoints);
          for (var i = leftSidePoints.length - 1; i >= 0; i--) {
            var point = leftSidePoints[i];
            var px = Linear$e(tlx, blx, point.t) + point.x;
            var py = Linear$e(tly, bly, point.t) + point.y;
            LineTo(px, py, pathData);
          }
          pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
          this.pathIndexes = Earcut$1(pathData);
          return this;
        }
      }, {
        key: "tlx",
        get: function get() {
          return this.geom.tlx;
        },
        set: function set(value) {
          this.geom.tlx = value;
          this.dirty = true;
        }
      }, {
        key: "tly",
        get: function get() {
          return this.geom.tly;
        },
        set: function set(value) {
          this.geom.tly = value;
          this.dirty = true;
        }
      }, {
        key: "trx",
        get: function get() {
          return this.geom.trx;
        },
        set: function set(value) {
          this.geom.trx = value;
          this.dirty = true;
        }
      }, {
        key: "try",
        get: function get() {
          return this.geom["try"];
        },
        set: function set(value) {
          this.geom["try"] = value;
          this.dirty = true;
        }
      }, {
        key: "blx",
        get: function get() {
          return this.geom.blx;
        },
        set: function set(value) {
          this.geom.blx = value;
          this.dirty = true;
        }
      }, {
        key: "bly",
        get: function get() {
          return this.geom.bly;
        },
        set: function set(value) {
          this.geom.bly = value;
          this.dirty = true;
        }
      }, {
        key: "brx",
        get: function get() {
          return this.geom.brx;
        },
        set: function set(value) {
          this.geom.brx = value;
          this.dirty = true;
        }
      }, {
        key: "bry",
        get: function get() {
          return this.geom.bry;
        },
        set: function set(value) {
          this.geom.bry = value;
          this.dirty = true;
        }
      }, {
        key: "leftSidePoints",
        get: function get() {
          return this.geom.leftSidePoints;
        }
      }, {
        key: "topSidePoints",
        get: function get() {
          return this.geom.topSidePoints;
        }
      }, {
        key: "bottomSidePoints",
        get: function get() {
          return this.geom.bottomSidePoints;
        }
      }, {
        key: "rightSidePoints",
        get: function get() {
          return this.geom.rightSidePoints;
        }
      }]);
      return Quad;
    }(PolygnBase);
    var SortPoints = function SortPoints(points) {
      if (points.length <= 1) {
        return;
      }
      points.sort(function (pointA, pointB) {
        return pointA.t - pointB.t;
      });
    };
    Object.assign(Quad.prototype, PointMethods);
  
    ObjectFactory.register('QuadShape', function (x, y, width, height, fillColor, fillAlpha) {
      var gameObject = new Quad(this.scene, x, y, width, height, fillColor, fillAlpha);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.QuadShape', Quad);
  
    var Utils = Phaser.Renderer.WebGL.Utils;
    var WebGLRenderer$1 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
      if (src.width === 0 || src.height === 0) {
        return;
      }
      camera.addToRenderList(src);
      var frame = src.frame;
      var width = frame.width;
      var height = frame.height;
      var getTint = Utils.getTintAppendFloatAlpha;
      var pipeline = renderer.pipelines.set(src.pipeline, src);
      var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
      renderer.pipelines.preBatch(src);
      pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
      renderer.pipelines.postBatch(src);
    };
  
    var CanvasRenderer$1 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
      if (src.width === 0 || src.height === 0) {
        return;
      }
      camera.addToRenderList(src);
      renderer.batchSprite(src, src.frame, camera, parentMatrix);
    };
  
    var Render$1 = {
      renderWebGL: WebGLRenderer$1,
      renderCanvas: CanvasRenderer$1
    };
  
    var CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;
    var MeasureTextMargins = function MeasureTextMargins(textStyle, testString, out) {
      if (out === undefined) {
        out = {};
      }
      var canvas = CanvasPool$3.create(this);
      var context = canvas.getContext('2d', {
        willReadFrequently: true
      });
      textStyle.syncFont(canvas, context);
      var metrics = context.measureText(testString);
      var width = Math.ceil(metrics.width * textStyle.baselineX);
      var baseline = width;
      var height = 2 * baseline;
      baseline = baseline * textStyle.baselineY | 0;
      canvas.width = width;
      canvas.height = height;
      context.fillStyle = '#f00';
      context.fillRect(0, 0, width, height);
      context.font = textStyle._font;
      context.textBaseline = 'alphabetic';
      context.fillStyle = '#000';
      context.fillText(textStyle.testString, 0, baseline);
      out.left = 0;
      if (width === 0 || height === 0 || !context.getImageData(0, 0, width, height)) {
        CanvasPool$3.remove(canvas);
        return out;
      }
      var imagedata = context.getImageData(0, 0, width, height).data;
      var stop = false;
      for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
          var idx = (y * width + x) * 4;
          if (imagedata[idx] !== 255) {
            out.left = x;
            stop = true;
            break;
          }
        }
        if (stop) {
          break;
        }
      }
      CanvasPool$3.remove(canvas);
      return out;
    };
  
    CheckP3Version();
    var GameObject$2 = Phaser.GameObjects.GameObject;
    var TextBase = /*#__PURE__*/function (_GameObject) {
      _inherits(TextBase, _GameObject);
      function TextBase() {
        _classCallCheck(this, TextBase);
        return _callSuper(this, TextBase, arguments);
      }
      _createClass(TextBase, [{
        key: "setStyle",
        value: function setStyle(style) {
          return this.style.setStyle(style);
        }
      }, {
        key: "setFont",
        value: function setFont(font) {
          return this.style.setFont(font);
        }
      }, {
        key: "setFontFamily",
        value: function setFontFamily(family) {
          return this.style.setFontFamily(family);
        }
      }, {
        key: "setFontSize",
        value: function setFontSize(size) {
          return this.style.setFontSize(size);
        }
      }, {
        key: "setFontStyle",
        value: function setFontStyle(style) {
          return this.style.setFontStyle(style);
        }
      }, {
        key: "setTestString",
        value: function setTestString(string) {
          return this.style.setTestString(string);
        }
      }, {
        key: "setFixedSize",
        value: function setFixedSize(width, height) {
          return this.style.setFixedSize(width, height);
        }
      }, {
        key: "setBackgroundColor",
        value: function setBackgroundColor(color, color2, isHorizontalGradient) {
          return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
        }
      }, {
        key: "setBackgroundStrokeColor",
        value: function setBackgroundStrokeColor(color, lineWidth) {
          return this.style.setBackgroundStrokeColor(color, lineWidth);
        }
      }, {
        key: "setBackgroundCornerRadius",
        value: function setBackgroundCornerRadius(radius, iteration) {
          return this.style.setBackgroundCornerRadius(radius, iteration);
        }
      }, {
        key: "setFill",
        value: function setFill(color) {
          return this.style.setFill(color);
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          return this.style.setColor(color);
        }
      }, {
        key: "setStroke",
        value: function setStroke(color, thickness) {
          return this.style.setStroke(color, thickness);
        }
      }, {
        key: "setShadow",
        value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
          return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
        }
      }, {
        key: "setShadowOffset",
        value: function setShadowOffset(x, y) {
          return this.style.setShadowOffset(x, y);
        }
      }, {
        key: "setShadowColor",
        value: function setShadowColor(color) {
          return this.style.setShadowColor(color);
        }
      }, {
        key: "setShadowBlur",
        value: function setShadowBlur(blur) {
          return this.style.setShadowBlur(blur);
        }
      }, {
        key: "setShadowStroke",
        value: function setShadowStroke(enabled) {
          return this.style.setShadowStroke(enabled);
        }
      }, {
        key: "setShadowFill",
        value: function setShadowFill(enabled) {
          return this.style.setShadowFill(enabled);
        }
      }, {
        key: "setWrapMode",
        value: function setWrapMode(mode) {
          return this.style.setWrapMode(mode);
        }
      }, {
        key: "setWrapWidth",
        value: function setWrapWidth(width) {
          return this.style.setWrapWidth(width);
        }
  
        // Align with built-in text game object
      }, {
        key: "setWordWrapWidth",
        value: function setWordWrapWidth(width) {
          return this.style.setWrapWidth(width);
        }
      }, {
        key: "setAlign",
        value: function setAlign(align) {
          return this.style.setHAlign(align);
        }
      }, {
        key: "setHAlign",
        value: function setHAlign(align) {
          return this.style.setHAlign(align);
        }
      }, {
        key: "setVAlign",
        value: function setVAlign(align) {
          return this.style.setVAlign(align);
        }
      }, {
        key: "setLineSpacing",
        value: function setLineSpacing(value) {
          this.lineSpacing = value;
          this.updateText(false);
          return this;
        }
      }, {
        key: "setXOffset",
        value: function setXOffset(value) {
          return this.style.setXOffset(value);
        }
      }, {
        key: "setMaxLines",
        value: function setMaxLines(max) {
          return this.style.setMaxLines(max);
        }
      }, {
        key: "setResolution",
        value: function setResolution(value) {
          return this.style.setResolution(value);
        }
      }, {
        key: "getTextMetrics",
        value: function getTextMetrics() {
          return this.style.getTextMetrics();
        }
      }, {
        key: "setTextMetrics",
        value: function setTextMetrics(metrics, font) {
          return this.style.setTextMetrics(metrics, font);
        }
      }, {
        key: "measureTextMargins",
        value: function measureTextMargins(testString, out) {
          return MeasureTextMargins(this.style, testString, out);
        }
      }]);
      return TextBase;
    }(GameObject$2);
    var Components$2 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(TextBase, [Components$2.Alpha, Components$2.BlendMode, Components$2.ComputedSize, Components$2.Crop, Components$2.Depth, Components$2.Flip, Components$2.GetBounds, Components$2.Mask, Components$2.Origin, Components$2.Pipeline, Components$2.PostPipeline, Components$2.ScrollFactor, Components$2.Tint, Components$2.Transform, Components$2.Visible, Render$1]);
  
    //  Key: [ Object Key, Default Value, postCallback ]
  
    var PropertyMap = {
      // background
      backgroundColor: ['backgroundColor', null, GetStyle],
      backgroundColor2: ['backgroundColor2', null, GetStyle],
      backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
      backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
      backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
      backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
      backgroundCornerIteration: ['backgroundCornerIteration', null, null],
      // font
      fontFamily: ['fontFamily', 'Courier', null],
      fontSize: ['fontSize', '16px', null],
      fontStyle: ['fontStyle', '', null],
      color: ['color', '#fff', GetStyle],
      stroke: ['stroke', '#fff', GetStyle],
      strokeThickness: ['strokeThickness', 0, null],
      shadowOffsetX: ['shadow.offsetX', 0, null],
      shadowOffsetY: ['shadow.offsetY', 0, null],
      shadowColor: ['shadow.color', '#000', GetStyle],
      shadowBlur: ['shadow.blur', 0, null],
      shadowStroke: ['shadow.stroke', false, null],
      shadowFill: ['shadow.fill', false, null],
      // underline
      underlineColor: ['underline.color', '#000', GetStyle],
      underlineThickness: ['underline.thickness', 0, null],
      underlineOffset: ['underline.offset', 0, null],
      // strikethrough
      strikethroughColor: ['strikethrough.color', '#000', GetStyle],
      strikethroughThickness: ['strikethrough.thickness', 0, null],
      strikethroughOffset: ['strikethrough.offset', 0, null],
      // align
      halign: ['halign', 'left', null],
      valign: ['valign', 'top', null],
      // size
      maxLines: ['maxLines', 0, null],
      fixedWidth: ['fixedWidth', 0, null],
      fixedHeight: ['fixedHeight', 0, null],
      resolution: ['resolution', 0, null],
      lineSpacing: ['lineSpacing', 0, null],
      xOffset: ['xOffset', 0, null],
      rtl: ['rtl', false, null],
      testString: ['testString', '|MÃ‰qgy', null],
      baselineX: ['baselineX', 1.2, null],
      baselineY: ['baselineY', 1.4, null],
      // wrap
      wrapMode: ['wrap.mode', 0, null],
      wrapWidth: ['wrap.width', 0, null],
      wrapCallback: ['wrap.callback', null],
      wrapCallbackScope: ['wrap.callbackScope', null]
    };
  
    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2018 Photon Storm Ltd.
     * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
     */
  
    var CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;
  
    /**
     * Calculates the ascent, descent and fontSize of a given font style.
     *
     * @function Phaser.GameObjects.MeasureText
     * @since 3.0.0
     *
     * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
     *
     * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
     */
    var MeasureText = function MeasureText(textStyle) {
      // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
      var canvas = CanvasPool$2.create(this);
  
      // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
      var context = canvas.getContext('2d', {
        willReadFrequently: true
      });
      textStyle.syncFont(canvas, context);
      var metrics = context.measureText(textStyle.testString);
      if ('actualBoundingBoxAscent' in metrics) {
        var ascent = metrics.actualBoundingBoxAscent;
        var descent = metrics.actualBoundingBoxDescent;
        var output = {
          ascent: ascent,
          descent: descent,
          fontSize: ascent + descent
        };
        CanvasPool$2.remove(canvas);
        return output;
      }
      var width = Math.ceil(metrics.width * textStyle.baselineX);
      var baseline = width;
      var height = 2 * baseline;
      baseline = baseline * textStyle.baselineY | 0;
      canvas.width = width;
      canvas.height = height;
      context.fillStyle = '#f00';
      context.fillRect(0, 0, width, height);
      context.font = textStyle._font;
      context.textBaseline = 'alphabetic';
      context.fillStyle = '#000';
      context.fillText(textStyle.testString, 0, baseline);
      var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      if (!context.getImageData(0, 0, width, height)) {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;
        CanvasPool$2.remove(canvas);
        return output;
      }
      var imagedata = context.getImageData(0, 0, width, height).data;
      var pixels = imagedata.length;
      var line = width * 4;
      var i;
      var j;
      var idx = 0;
      var stop = false;
  
      // ascent. scan from top to bottom until we find a non red pixel
      for (i = 0; i < baseline; i++) {
        for (j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line;
        } else {
          break;
        }
      }
      output.ascent = baseline - i;
      idx = pixels - line;
      stop = false;
  
      // descent. scan from bottom to top until we find a non red pixel
      for (i = height; i > baseline; i--) {
        for (j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line;
        } else {
          break;
        }
      }
      output.descent = i - baseline;
      output.fontSize = output.ascent + output.descent;
      CanvasPool$2.remove(canvas);
      return output;
    };
  
    var CONST = {
      // new line mode
      NO_NEWLINE: 0,
      RAW_NEWLINE: 1,
      WRAPPED_NEWLINE: 2,
      // wrap mode
      NO_WRAP: 0,
      WORD_WRAP: 1,
      CHAR_WRAP: 2,
      MIX_WRAP: 3,
      // split lines
      SPLITREGEXP: /(?:\r\n|\r|\n)/
    };
  
    var WRAPMODE$1 = {
      none: CONST.NO_WRAP,
      word: CONST.WORD_WRAP,
      "char": CONST.CHAR_WRAP,
      character: CONST.CHAR_WRAP,
      mix: CONST.MIX_WRAP
    };
  
    var GetAdvancedValue$6 = Phaser.Utils.Objects.GetAdvancedValue;
    var GetValue$3A = Phaser.Utils.Objects.GetValue;
    var TextStyle$1 = /*#__PURE__*/function () {
      function TextStyle(text, style, propertyMap) {
        _classCallCheck(this, TextStyle);
        this.parent = text;
        // parent.updateText()
        // parent.width, parent.height
  
        if (propertyMap === undefined) {
          propertyMap = PropertyMap;
        }
        this.propertyMap = propertyMap;
        this.backgroundColor;
        this.backgroundColor2;
        this.backgroundHorizontalGradient;
        this.backgroundStrokeColor;
        this.backgroundStrokeLineWidth;
        this.backgroundCornerRadius;
        this.backgroundCornerIteration;
        this.fontFamily;
        this.fontSize;
        this.fontStyle;
        this.color;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;
        this.underlineColor;
        this.underlineThickness;
        this.underlineOffset;
        this.strikethroughColor;
        this.strikethroughThickness;
        this.strikethroughOffset;
        this.halign;
        this.valign;
        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.resolution;
        this.xOffset;
        this.rtl;
        this.testString;
        this.baselineX;
        this.baselineY;
        this.wrapMode;
        this.wrapWidth;
        this.wrapCallback;
        this.wrapCallbackScope;
        this._font;
  
        //  Set to defaults + user style
        this.setStyle(style, false, true);
      }
      _createClass(TextStyle, [{
        key: "isWrapFitMode",
        get: function get() {
          return this.fixedWidth > 0 && this.wrapMode !== CONST.NO_WRAP && this.wrapWidth === 0;
        }
      }, {
        key: "setStyle",
        value: function setStyle(style, updateText, setDefaults) {
          if (updateText === undefined) {
            updateText = true;
          }
          if (setDefaults === undefined) {
            setDefaults = false;
          }
  
          // Compatible with Text game object
          if (style && style.hasOwnProperty('wordWrap')) {
            var wordWrap = style.wordWrap;
            if (wordWrap.hasOwnProperty('width')) {
              style.wrap = {
                mode: 'word',
                width: wordWrap.width
              };
            }
          }
          if (style && style.hasOwnProperty('wrap')) {
            var wrap = style.wrap;
            if (wrap.hasOwnProperty('mode')) {
              var mode = wrap.mode;
              if (typeof mode === 'string') {
                wrap.mode = WRAPMODE$1[mode];
              }
            } else {
              if (wrap.hasOwnProperty('width')) {
                wrap.mode = 1;
              }
            }
          }
  
          // default halign of RTL is 'right'
          if (style && style.rtl && setDefaults && !style.hasOwnProperty('halign')) {
            style.halign = 'right';
          }
  
          //  Avoid type mutation
          if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
            style.fontSize = style.fontSize.toString() + 'px';
          }
          var propertyMap = this.propertyMap;
          for (var key in propertyMap) {
            var prop = propertyMap[key]; // [ Object Key, Default Value, preCallback ]
            var objKey = prop[0];
            var defaultValue = setDefaults ? prop[1] : this[key];
            var postCallback = prop[2];
            if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
              // Callback & scope should be set without processing the values
              this[key] = GetValue$3A(style, objKey, defaultValue);
            } else {
              var value = GetAdvancedValue$6(style, objKey, defaultValue);
              if (postCallback) {
                value = postCallback(value);
              }
              this[key] = value;
            }
          }
  
          //  Allow for 'font' override
          var font = GetValue$3A(style, 'font', null);
          if (font === null) {
            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
          } else {
            this._font = font;
          }
  
          //  Allow for 'fill' to be used in place of 'color'
          var fill = GetValue$3A(style, 'fill', null);
          if (fill !== null) {
            this.color = GetStyle(fill);
          }
          var metrics = GetValue$3A(style, 'metrics', false);
  
          //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
          //  Doing this is reset if you then change the font of this TextStyle after creation
          if (metrics) {
            this.metrics = {
              ascent: GetValue$3A(metrics, 'ascent', 0),
              descent: GetValue$3A(metrics, 'descent', 0),
              fontSize: GetValue$3A(metrics, 'fontSize', 0)
            };
          } else if (updateText || !this.metrics) {
            this.metrics = MeasureText(this);
          }
          if (updateText) {
            return this.parent.updateText();
          } else {
            return this.parent;
          }
        }
      }, {
        key: "syncFont",
        value: function syncFont(canvas, context) {
          context.font = this._font;
        }
      }, {
        key: "syncStyle",
        value: function syncStyle(canvas, context) {
          context.textBaseline = 'alphabetic';
          context.fillStyle = this.color;
          context.strokeStyle = this.stroke;
          context.lineWidth = this.strokeThickness;
          context.lineCap = 'round';
          context.lineJoin = 'round';
        }
      }, {
        key: "syncShadow",
        value: function syncShadow(context, enabled) {
          if (enabled) {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
          } else {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
          }
        }
      }, {
        key: "update",
        value: function update(recalculateMetrics) {
          if (recalculateMetrics) {
            this._font = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();
            this.metrics = MeasureText(this);
          }
          return this.parent.updateText(recalculateMetrics);
        }
      }, {
        key: "buildFont",
        value: function buildFont() {
          var newFont = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();
          if (newFont !== this._font) {
            this._font = newFont;
            //this.metrics = MeasureText(this);
          }
          return this;
        }
      }, {
        key: "setFont",
        value: function setFont(font) {
          if (typeof font === 'string') {
            this.fontFamily = font;
            this.fontSize = '';
            this.fontStyle = '';
          } else {
            this.fontFamily = GetValue$3A(font, 'fontFamily', 'Courier');
            this.fontSize = GetValue$3A(font, 'fontSize', '16px');
            this.fontStyle = GetValue$3A(font, 'fontStyle', '');
          }
          return this.update(true);
        }
      }, {
        key: "setFontFamily",
        value: function setFontFamily(family) {
          this.fontFamily = family;
          return this.update(true);
        }
      }, {
        key: "setFontStyle",
        value: function setFontStyle(style) {
          this.fontStyle = style;
          return this.update(true);
        }
      }, {
        key: "setFontSize",
        value: function setFontSize(size) {
          if (typeof size === 'number') {
            size = size.toString() + 'px';
          }
          this.fontSize = size;
          return this.update(true);
        }
      }, {
        key: "setTestString",
        value: function setTestString(string) {
          this.testString = string;
          return this.update(true);
        }
      }, {
        key: "setFixedSize",
        value: function setFixedSize(width, height) {
          this.fixedWidth = width;
          this.fixedHeight = height;
          if (width) {
            this.parent.width = width;
          }
          if (height) {
            this.parent.height = height;
          }
          return this.update(this.isWrapFitMode);
        }
      }, {
        key: "setResolution",
        value: function setResolution(value) {
          this.resolution = value;
          return this.update(false);
        }
      }, {
        key: "setXOffset",
        value: function setXOffset(value) {
          this.xOffset = value;
          return this.update(false);
        }
      }, {
        key: "setBackgroundColor",
        value: function setBackgroundColor(color, color2, isHorizontalGradient) {
          if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
          }
          this.backgroundColor = GetStyle(color, this.parent.canvas, this.parent.context);
          this.backgroundColor2 = GetStyle(color2, this.parent.canvas, this.parent.context);
          this.backgroundHorizontalGradient = isHorizontalGradient;
          return this.update(false);
        }
      }, {
        key: "setBackgroundStrokeColor",
        value: function setBackgroundStrokeColor(color, lineWidth) {
          this.backgroundStrokeColor = GetStyle(color, this.parent.canvas, this.parent.context);
          this.backgroundStrokeLineWidth = lineWidth;
          return this.update(false);
        }
      }, {
        key: "setBackgroundCornerRadius",
        value: function setBackgroundCornerRadius(radius, iteration) {
          this.backgroundCornerRadius = radius;
          this.backgroundCornerIteration = iteration;
          return this.update(false);
        }
      }, {
        key: "setFill",
        value: function setFill(color) {
          this.color = GetStyle(color, this.parent.canvas, this.parent.context);
          return this.update(false);
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = GetStyle(color, this.parent.canvas, this.parent.context);
          return this.update(false);
        }
      }, {
        key: "setStroke",
        value: function setStroke(color, thickness) {
          if (color === undefined) {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
          } else {
            if (thickness === undefined) {
              thickness = this.strokeThickness;
            }
            this.stroke = GetStyle(color, this.parent.canvas, this.parent.context);
            this.strokeThickness = thickness;
          }
          return this.update(true);
        }
      }, {
        key: "setShadow",
        value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
          if (x === undefined) {
            x = 0;
          }
          if (y === undefined) {
            y = 0;
          }
          if (color === undefined) {
            color = '#000';
          }
          if (blur === undefined) {
            blur = 0;
          }
          if (shadowStroke === undefined) {
            shadowStroke = false;
          }
          if (shadowFill === undefined) {
            shadowFill = true;
          }
          this.shadowOffsetX = x;
          this.shadowOffsetY = y;
          this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
          this.shadowBlur = blur;
          this.shadowStroke = shadowStroke;
          this.shadowFill = shadowFill;
          return this.update(false);
        }
      }, {
        key: "setShadowOffset",
        value: function setShadowOffset(x, y) {
          if (x === undefined) {
            x = 0;
          }
          if (y === undefined) {
            y = x;
          }
          this.shadowOffsetX = x;
          this.shadowOffsetY = y;
          return this.update(false);
        }
      }, {
        key: "setShadowColor",
        value: function setShadowColor(color) {
          if (color === undefined) {
            color = '#000';
          }
          this.shadowColor = GetStyle(color, this.parent.canvas, this.parent.context);
          return this.update(false);
        }
      }, {
        key: "setShadowBlur",
        value: function setShadowBlur(blur) {
          if (blur === undefined) {
            blur = 0;
          }
          this.shadowBlur = blur;
          return this.update(false);
        }
      }, {
        key: "setShadowStroke",
        value: function setShadowStroke(enabled) {
          this.shadowStroke = enabled;
          return this.update(false);
        }
      }, {
        key: "setShadowFill",
        value: function setShadowFill(enabled) {
          this.shadowFill = enabled;
          return this.update(false);
        }
      }, {
        key: "setUnderline",
        value: function setUnderline(color, thickness, offset) {
          if (color === undefined) {
            color = '#000';
          }
          if (thickness === undefined) {
            thickness = 0;
          }
          if (offset === undefined) {
            offset = 0;
          }
          this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
          this.underlineThickness = thickness;
          this.underlineOffset = offset;
          return this.update(false);
        }
      }, {
        key: "setUnderlineColor",
        value: function setUnderlineColor(color) {
          if (color === undefined) {
            color = '#000';
          }
          this.underlineColor = GetStyle(color, this.parent.canvas, this.parent.context);
          return this.update(false);
        }
      }, {
        key: "setUnderlineThickness",
        value: function setUnderlineThickness(thickness) {
          if (thickness === undefined) {
            thickness = 0;
          }
          this.underlineThickness = thickness;
          return this.update(false);
        }
      }, {
        key: "setUnderlineOffset",
        value: function setUnderlineOffset(offset) {
          if (offset === undefined) {
            offset = 0;
          }
          this.underlineOffset = offset;
          return this.update(false);
        }
      }, {
        key: "setStrikethrough",
        value: function setStrikethrough(color, thickness, offset) {
          if (color === undefined) {
            color = '#000';
          }
          if (thickness === undefined) {
            thickness = 0;
          }
          if (offset === undefined) {
            offset = 0;
          }
          this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
          this.strikethroughThickness = thickness;
          this.strikethroughOffset = offset;
          return this.update(false);
        }
      }, {
        key: "setStrikethroughColor",
        value: function setStrikethroughColor(color) {
          if (color === undefined) {
            color = '#000';
          }
          this.strikethroughColor = GetStyle(color, this.parent.canvas, this.parent.context);
          return this.update(false);
        }
      }, {
        key: "setStrikethroughThickness",
        value: function setStrikethroughThickness(thickness) {
          if (thickness === undefined) {
            thickness = 0;
          }
          this.strikethroughThickness = thickness;
          return this.update(false);
        }
      }, {
        key: "setStrikethroughOffset",
        value: function setStrikethroughOffset(offset) {
          if (offset === undefined) {
            offset = 0;
          }
          this.strikethroughOffset = offset;
          return this.update(false);
        }
      }, {
        key: "setWrapMode",
        value: function setWrapMode(mode) {
          if (typeof mode === 'string') {
            mode = WRAPMODE$1[mode.toLowerCase()] || 0;
          }
          this.wrapMode = mode;
          return this.update(true);
        }
      }, {
        key: "setWrapWidth",
        value: function setWrapWidth(width) {
          this.wrapWidth = width;
          return this.update(false);
        }
      }, {
        key: "setAlign",
        value: function setAlign(halign, valign) {
          if (halign === undefined) {
            halign = 'left';
          }
          if (valign === undefined) {
            valign = 'top';
          }
          this.halign = halign;
          this.valign = valign;
          return this.update(false);
        }
      }, {
        key: "setHAlign",
        value: function setHAlign(halign) {
          if (halign === undefined) {
            halign = 'left';
          }
          this.halign = halign;
          return this.update(false);
        }
      }, {
        key: "setVAlign",
        value: function setVAlign(valign) {
          if (valign === undefined) {
            valign = 'top';
          }
          this.valign = valign;
          return this.update(false);
        }
      }, {
        key: "setMaxLines",
        value: function setMaxLines(max) {
          if (max === undefined) {
            max = 0;
          }
          this.maxLines = max;
          return this.update(false);
        }
      }, {
        key: "getTextMetrics",
        value: function getTextMetrics() {
          var metrics = this.metrics;
          return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
          };
        }
      }, {
        key: "setTextMetrics",
        value: function setTextMetrics(metrics, font) {
          this.metrics.ascent = metrics.ascent;
          this.metrics.descent = metrics.descent;
          this.metrics.fontSize = metrics.fontSize;
          if (font) {
            if (typeof font === 'string') {
              this.fontFamily = font;
              this.fontSize = '';
              this.fontStyle = '';
            } else {
              this.fontFamily = GetValue$3A(font, 'fontFamily', this.fontFamily);
              this.fontSize = GetValue$3A(font, 'fontSize', this.fontSize);
              this.fontStyle = GetValue$3A(font, 'fontStyle', this.fontStyle);
            }
          }
          return this.parent.updateText(true);
        }
      }, {
        key: "lineHeight",
        get: function get() {
          return this.metrics.fontSize + this.strokeThickness + this.parent.lineSpacing;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var output = {};
          var propertyMap = this.propertyMap;
          for (var key in propertyMap) {
            output[key] = this[key];
          }
          output.metrics = this.getTextMetrics();
          return output;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.parent = undefined;
        }
      }]);
      return TextStyle;
    }();
  
    var DrawMethods = {
      draw: function draw(startX, startY, textWidth, textHeight) {
        var penManager = this.penManager;
        this.hitAreaManager.clear();
        var context = this.context;
        context.save();
        var defaultStyle = this.defaultStyle;
        this.clear();
        DrawRoundRectangleBackground(this, defaultStyle.backgroundColor, defaultStyle.backgroundStrokeColor, defaultStyle.backgroundStrokeLineWidth, defaultStyle.backgroundCornerRadius, defaultStyle.backgroundColor2, defaultStyle.backgroundHorizontalGradient, defaultStyle.backgroundCornerIteration);
  
        // draw lines
        startX += this.startXOffset;
        startY += this.startYOffset;
        var defaultHalign = defaultStyle.halign,
          valign = defaultStyle.valign;
        var lineWidth,
          lineHeight = defaultStyle.lineHeight;
        var lines = penManager.lines;
        var totalLinesNum = lines.length,
          maxLines = defaultStyle.maxLines;
        var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
        if (maxLines > 0 && totalLinesNum > maxLines) {
          drawLinesNum = maxLines;
          if (valign === 'center') {
            // center
            drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
          } else if (valign === 'bottom') {
            // bottom
            drawLineStartIdx = totalLinesNum - drawLinesNum;
          } else {
            drawLineStartIdx = 0;
          }
        } else {
          drawLinesNum = totalLinesNum;
          drawLineStartIdx = 0;
        }
        drawLineEndIdx = drawLineStartIdx + drawLinesNum;
        var offsetX, offsetY;
        var rtl = this.rtl,
          rtlOffset = rtl ? this.parent.width : undefined;
        if (valign === 'center') {
          // center
          offsetY = Math.max((textHeight - drawLinesNum * lineHeight) / 2, 0);
        } else if (valign === 'bottom') {
          // bottom
          offsetY = Math.max(textHeight - drawLinesNum * lineHeight - 2, 0);
        } else {
          offsetY = 0;
        }
        offsetY += startY;
        for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
          lineWidth = penManager.getLineWidth(lineIdx);
          if (lineWidth === 0) {
            continue;
          }
          var pens = lines[lineIdx],
            penCount = pens.length;
          var halign = defaultHalign;
          // Seek if there has algin tag
          for (var penIdx = 0; penIdx < penCount; penIdx++) {
            var penAlign = pens[penIdx].prop.align;
            if (penAlign !== undefined) {
              halign = penAlign;
              break;
            }
          }
          if (halign === 'center') {
            // center
            offsetX = (textWidth - lineWidth) / 2;
          } else if (halign === 'right') {
            // right
            offsetX = !rtl ? textWidth - lineWidth : 0;
          } else {
            offsetX = !rtl ? 0 : textWidth - lineWidth;
          }
          offsetX += startX;
          for (var penIdx = 0; penIdx < penCount; penIdx++) {
            this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
          }
        }
        context.restore();
      },
      drawPen: function drawPen(pen, offsetX, offsetY, rtlOffset) {
        offsetX += pen.x;
        offsetY += pen.y + (pen.prop.y || 0);
        if (rtlOffset !== undefined) {
          offsetX = rtlOffset - offsetX;
        }
        var canvas = this.canvas;
        var context = this.context;
        context.save();
        var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);
  
        // Background
        if (curStyle.bgcolor !== null && pen.width > 0) {
          var metrics = this.defaultStyle.metrics;
          var bgTLY = offsetY - metrics.ascent;
          var bgHeight = metrics.fontSize;
          this.drawRectangle(offsetX, bgTLY, pen.width, bgHeight, curStyle.bgcolor, curStyle);
        }
  
        // Underline
        if (curStyle.underlineThickness > 0 && pen.width > 0) {
          var lineOffsetY = offsetY + curStyle.underlineOffset - curStyle.underlineThickness / 2;
          this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
        }
  
        // Text
        if (pen.isTextPen) {
          curStyle.buildFont();
          curStyle.syncFont(canvas, context);
          curStyle.syncStyle(canvas, context);
          this.drawText(offsetX, offsetY, pen.text, curStyle);
        }
  
        // Image
        if (pen.isImagePen) {
          this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
        }
  
        // Strikethrough
        if (curStyle.strikethroughThickness > 0 && pen.width > 0) {
          var lineOffsetY = offsetY + curStyle.strikethroughOffset - curStyle.strikethroughThickness / 2;
          this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
        }
        context.restore();
        if (pen.hasAreaMarker && pen.width > 0) {
          var data;
          var areaKey = pen.prop.area;
          if (areaKey) {
            data = {
              key: areaKey
            };
          } else {
            var url = pen.prop.url;
            data = {
              key: "url:".concat(url),
              url: url
            };
          }
          this.hitAreaManager.add(offsetX,
          // x
          offsetY - this.startYOffset,
          // y
          pen.width,
          // width
          this.defaultStyle.lineHeight,
          // height
          data);
        }
      },
      clear: function clear() {
        var canvas = this.canvas;
        this.context.clearRect(0, 0, canvas.width, canvas.height);
      },
      drawRectangle: function drawRectangle(x, y, width, height, color, style) {
        if (this.autoRound) {
          x = Math.round(x);
          y = Math.round(y);
        }
        var context = this.context;
        context.fillStyle = color;
        context.fillRect(x, y, width, height);
      },
      drawLine: function drawLine(x, y, width, height, color, style) {
        if (this.autoRound) {
          x = Math.round(x);
          y = Math.round(y);
        }
        var context = this.context;
        style.syncShadow(context, style.shadowStroke);
        var savedLineCap = context.lineCap;
        context.lineCap = 'butt';
        context.strokeStyle = color;
        context.lineWidth = height;
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x + width, y);
        context.stroke();
        context.lineCap = savedLineCap;
      },
      drawText: function drawText(x, y, text, style) {
        if (this.autoRound) {
          x = Math.round(x);
          y = Math.round(y);
        }
        var context = this.context;
        if (style.stroke && style.stroke !== 'none' && style.strokeThickness > 0) {
          style.syncShadow(context, style.shadowStroke);
          context.strokeText(text, x, y);
        }
        if (style.color && style.color !== 'none') {
          style.syncShadow(context, style.shadowFill);
          context.fillText(text, x, y);
        }
      },
      drawImage: function drawImage(x, y, imgKey, color, style) {
        y -= this.startYOffset;
        this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
      }
    };
  
    var GetValue$3z = Phaser.Utils.Objects.GetValue;
    var NO_NEWLINE$3 = CONST.NO_NEWLINE;
    var RAW_NEWLINE$1 = CONST.RAW_NEWLINE;
    var Pen = /*#__PURE__*/function () {
      function Pen(config) {
        _classCallCheck(this, Pen);
        this.prop = {};
        this.resetFromJSON(config);
      }
      _createClass(Pen, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          // (txt, x, y, width, prop, newLineMode, startIndex)
          this.text = GetValue$3z(o, 'text', '');
          this.x = GetValue$3z(o, 'x', 0);
          this.y = GetValue$3z(o, 'y', 0);
          this.width = GetValue$3z(o, 'width', 0);
          var prop = GetValue$3z(o, 'prop', null);
          if (prop === null) {
            prop = {};
          }
          this.prop = prop;
          this.newLineMode = GetValue$3z(o, 'newLineMode', 0);
          this.startIndex = GetValue$3z(o, 'startIndex', 0);
        }
      }, {
        key: "plainText",
        get: function get() {
          var txt = this.text;
          if (this.newLineMode === RAW_NEWLINE$1) {
            txt += "\n";
          }
          return txt;
        }
      }, {
        key: "wrapText",
        get: function get() {
          var txt = this.text;
          if (this.newLineMode !== NO_NEWLINE$3) {
            txt += "\n";
          }
          return txt;
        }
      }, {
        key: "rawTextLength",
        get: function get() {
          var len = this.text.length;
          if (this.newLineMode === RAW_NEWLINE$1) {
            len += 1;
          }
          return len;
        }
      }, {
        key: "endIndex",
        get: function get() {
          return this.startIndex + this.rawTextLength;
        }
      }, {
        key: "lastX",
        get: function get() {
          return this.x + this.width;
        }
      }, {
        key: "isTextPen",
        get: function get() {
          return this.text !== '';
        }
      }, {
        key: "isImagePen",
        get: function get() {
          return !!this.prop.img;
        }
      }, {
        key: "hasAreaMarker",
        get: function get() {
          return !!this.prop.area || !!this.prop.url;
        }
      }]);
      return Pen;
    }();
  
    /**
     * Shallow Object Clone. Will not out nested objects.
     * @param {object} obj JSON object
     * @param {object} ret JSON object to return, set null to return a new object
     * @returns {object} this object
     */
    var Clone$2 = function Clone(obj, out) {
      var objIsArray = Array.isArray(obj);
      if (out === undefined) {
        out = objIsArray ? [] : {};
      } else {
        Clear$1(out);
      }
      if (objIsArray) {
        out.length = obj.length;
        for (var i = 0, cnt = obj.length; i < cnt; i++) {
          out[i] = obj[i];
        }
      } else {
        for (var key in obj) {
          out[key] = obj[key];
        }
      }
      return out;
    };
  
    var GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
    var NO_NEWLINE$2 = CONST.NO_NEWLINE;
    var WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE;
    var PenManager = /*#__PURE__*/function () {
      function PenManager(config) {
        _classCallCheck(this, PenManager);
        this.pens = []; // all pens
        this.lines = []; // pens in lines [ [],[],[],.. ]
        this.maxLinesWidth = undefined;
        this.pensPool = config.pensPool; // Required
        this.linesPool = config.linesPool; // Required
        this.tagToText = GetFastValue$2(config, 'tagToText', NOOP);
        this.tagToTextScope = GetFastValue$2(config, 'tagToTextScope', undefined);
      }
      _createClass(PenManager, [{
        key: "destroy",
        value: function destroy() {
          this.clear();
          this.tagToText = undefined;
          this.tagToTextScope = undefined;
        }
      }, {
        key: "clear",
        value: function clear() {
          for (var i = 0, len = this.lines.length; i < len; i++) {
            this.lines[i].length = 0;
          }
          this.pensPool.pushMultiple(this.pens);
          this.linesPool.pushMultiple(this.lines);
          this.maxLinesWidth = undefined;
        }
      }, {
        key: "addTextPen",
        value: function addTextPen(text, x, y, width, prop, newLineMode) {
          var pen = this.pensPool.pop();
          if (pen == null) {
            pen = new Pen();
          }
          PEN_CONFIG.text = text;
          PEN_CONFIG.x = x;
          PEN_CONFIG.y = y;
          PEN_CONFIG.width = width;
          PEN_CONFIG.prop = prop;
          PEN_CONFIG.newLineMode = newLineMode;
          pen.resetFromJSON(PEN_CONFIG);
          this.addPen(pen);
          return this;
        }
      }, {
        key: "addImagePen",
        value: function addImagePen(x, y, width, prop) {
          this.addTextPen('', x, y, width, prop, NO_NEWLINE$2);
          return this;
        }
      }, {
        key: "addNewLinePen",
        value: function addNewLinePen() {
          var previousPen = this.lastPen;
          var x = previousPen ? previousPen.lastX : 0;
          var y = previousPen ? previousPen.y : 0;
          var prop = previousPen ? Clone$2(previousPen.prop) : null;
          this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE$1);
          return this;
        }
      }, {
        key: "addPen",
        value: function addPen(pen) {
          var previousPen = this.lastPen;
          if (previousPen == null) {
            pen.startIndex = 0;
          } else {
            pen.startIndex = previousPen.endIndex;
          }
          this.pens.push(pen);
  
          // maintan lines
          var line = this.lastLine;
          if (line == null) {
            line = this.linesPool.pop() || [];
            this.lines.push(line);
          }
          line.push(pen);
  
          // new line, add an empty line
          if (pen.newLineMode !== NO_NEWLINE$2) {
            line = this.linesPool.pop() || [];
            this.lines.push(line);
          }
          this.maxLinesWidth = undefined;
        }
      }, {
        key: "clone",
        value: function clone(targetPenManager) {
          if (targetPenManager == null) targetPenManager = new PenManager();
          targetPenManager.clear();
          for (var li = 0, llen = this.lines.length; li < llen; li++) {
            var pens = this.lines[li];
            for (var pi = 0, plen = pens.length; pi < plen; pi++) {
              var pen = pens[pi];
              targetPenManager.addPen(pen.text, pen.x, pen.y, pen.width, Clone$2(pen.prop), pen.newLineMode);
            }
          }
          return targetPenManager;
        }
      }, {
        key: "lastPen",
        get: function get() {
          return this.pens[this.pens.length - 1];
        }
      }, {
        key: "lastLine",
        get: function get() {
          return this.lines[this.lines.length - 1];
        }
      }, {
        key: "getLineStartIndex",
        value: function getLineStartIndex(i) {
          if (i >= this.lines.length) {
            return this.getLineEndIndex(i);
          } else {
            var line = this.lines[i];
            return line && line[0] ? line[0].startIndex : 0;
          }
        }
      }, {
        key: "getLineEndIndex",
        value: function getLineEndIndex(i) {
          if (i >= this.lines.length) {
            i = this.lines.length - 1;
          }
          var li,
            hasLastPen = false,
            line;
          for (li = i; li >= 0; li--) {
            line = this.lines[li];
            hasLastPen = line != null && line.length > 0;
            if (hasLastPen) {
              break;
            }
          }
          if (!hasLastPen) {
            return 0;
          }
          var lastPen = line[line.length - 1];
          return lastPen.endIndex;
        }
      }, {
        key: "getLineWidth",
        value: function getLineWidth(i) {
          var line = this.lines[i];
          if (!line) {
            return 0;
          }
          var lastPen = line[line.length - 1];
          if (lastPen == null) {
            return 0;
          }
          var lineWidth = lastPen.lastX; // start from 0
          return lineWidth;
        }
      }, {
        key: "getMaxLineWidth",
        value: function getMaxLineWidth() {
          if (this.maxLinesWidth !== undefined) {
            return this.maxLinesWidth;
          }
          var w,
            maxW = 0;
          for (var i = 0, len = this.lines.length; i < len; i++) {
            w = this.getLineWidth(i);
            if (w > maxW) {
              maxW = w;
            }
          }
          this.maxLinesWidth = maxW;
          return maxW;
        }
      }, {
        key: "getLineWidths",
        value: function getLineWidths() {
          var result = [];
          for (var i = 0, len = this.lines.length; i < len; i++) {
            result.push(this.getLineWidth(i));
          }
          return result;
        }
      }, {
        key: "linesCount",
        get: function get() {
          return this.lines.length;
        }
      }, {
        key: "plainText",
        get: function get() {
          var txt = "",
            pens = this.pens;
          for (var i = 0, len = pens.length; i < len; i++) {
            txt += pens[i].plainText;
          }
          return txt;
        }
      }, {
        key: "rawTextLength",
        get: function get() {
          var l = 0,
            pens = this.pens;
          for (var i = 0, len = this.pens.length; i < len; i++) {
            l += pens[i].rawTextLength;
          }
          return l;
        }
      }, {
        key: "getSliceTagText",
        value: function getSliceTagText(start, end, wrap) {
          var lastPen = this.lastPen;
          if (lastPen == null) {
            return '';
          }
          var lastPenEnd = lastPen.endIndex;
          if (start === undefined || start === 0) {
            // Image pen before first character
            start = -1;
          }
          if (end === undefined || end === lastPenEnd) {
            // Image pen after last character
            end = lastPenEnd + 1;
          }
          if (wrap === undefined) {
            wrap = false;
          }
          var txt = "",
            pen,
            penTxt,
            penStartIdx,
            penEndIdx,
            isInRange;
          var currentProp, previousProp;
          for (var i = 0, len = this.pens.length; i < len; i++) {
            pen = this.pens[i];
            penEndIdx = pen.endIndex;
            if (penEndIdx <= start) {
              continue;
            }
            pen = this.pens[i];
            penTxt = !wrap ? pen.plainText : pen.wrapText;
            currentProp = pen.prop;
            penStartIdx = pen.startIndex;
            isInRange = penStartIdx >= start && penEndIdx <= end;
            if (!isInRange) {
              penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
            }
            if (this.tagToTextScope) {
              txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
            } else {
              txt += this.tagToText(penTxt, currentProp, previousProp);
            }
            previousProp = currentProp;
            if (penEndIdx >= end) {
              break;
            }
          }
          return txt;
        }
      }, {
        key: "length",
        get: function get() {
          return this.lines.length;
        },
        set: function set(value) {
          // Only for set length to 0 (clear)
          this.clear();
        }
      }]);
      return PenManager;
    }();
    var PEN_CONFIG = {};
  
    var Rectangle$6 = Phaser.Geom.Rectangle;
    var RectanglePool = new Stack();
    var HitAreaManager = /*#__PURE__*/function () {
      function HitAreaManager() {
        _classCallCheck(this, HitAreaManager);
        this.hitAreas = [];
      }
      _createClass(HitAreaManager, [{
        key: "destroy",
        value: function destroy() {
          this.clear();
        }
      }, {
        key: "clear",
        value: function clear() {
          // Reuse hitArea(rectangle) later
          for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
            Clear$1(this.hitAreas[i].data);
          }
          RectanglePool.pushMultiple(this.hitAreas);
          return this;
        }
      }, {
        key: "add",
        value: function add(x, y, width, height, data) {
          var rectangle = RectanglePool.pop();
          if (rectangle === null) {
            rectangle = new Rectangle$6(x, y, width, height);
          } else {
            rectangle.setTo(x, y, width, height);
          }
          rectangle.data = data;
          this.hitAreas.push(rectangle);
          return this;
        }
      }, {
        key: "getFirst",
        value: function getFirst(x, y) {
          for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
            var hitArea = this.hitAreas[i];
            if (hitArea.contains(x, y)) {
              return hitArea;
            }
          }
          return null;
        }
      }, {
        key: "getByKey",
        value: function getByKey(key) {
          for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
            var hitArea = this.hitAreas[i];
            if (hitArea.data.key === key) {
              return hitArea;
            }
          }
          return null;
        }
      }, {
        key: "drawBounds",
        value: function drawBounds(graphics, color, parent) {
          if (color === undefined) {
            color = 0xffffff;
          }
          if (parent) {
            graphics.save().scaleCanvas(parent.scaleX, parent.scaleY).rotateCanvas(parent.rotation).translateCanvas(parent.x, parent.y);
          }
          for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
            var hitArea = this.hitAreas[i];
            graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
          }
          if (parent) {
            graphics.restore();
          }
          return this;
        }
      }]);
      return HitAreaManager;
    }();
  
    var SetInteractive$1 = function SetInteractive() {
      this.parent.on('pointerdown', OnAreaDown, this).on('pointerup', OnAreaUp, this).on('pointermove', OnAreaOverOut, this).on('pointerover', OnAreaOverOut, this).on('pointerout', function (pointer, event) {
        OnAreaOverOut.call(this, pointer, null, null, event);
      }, this);
    };
    var OnAreaDown = function OnAreaDown(pointer, localX, localY, event) {
      var area = this.hitAreaManager.getFirst(localX, localY);
      if (area === null) {
        return;
      }
      var key = area.data.key;
      FireEvent$2.call(this, 'areadown', key, pointer, localX, localY, event);
      area.data.isDown = true;
    };
    var OnAreaUp = function OnAreaUp(pointer, localX, localY, event) {
      var area = this.hitAreaManager.getFirst(localX, localY);
      if (area === null) {
        return;
      }
      var areaData = area.data;
      var key = areaData.key;
      FireEvent$2.call(this, 'areaup', key, pointer, localX, localY, event);
      if (areaData.isDown) {
        FireEvent$2.call(this, 'areaclick', key, pointer, localX, localY, event);
        var url = areaData.url;
        if (url) {
          window.open(url, '_blank');
        }
      }
      areaData.isDown = false;
    };
    var OnAreaOverOut = function OnAreaOverOut(pointer, localX, localY, event) {
      if (localX === null) {
        // Case of pointerout
        if (this.lastHitAreaKey !== null) {
          FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
          this.hitAreaManager.getByKey(this.lastHitAreaKey).isDown = false;
          this.lastHitAreaKey = null;
        }
        return;
      }
      var area = this.hitAreaManager.getFirst(localX, localY);
      var key = area ? area.data.key : null;
      if (this.lastHitAreaKey === key) {
        return;
      }
      if (this.lastHitAreaKey !== null) {
        FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
        var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);
        if (this.urlTagCursorStyle && !!prevHitArea.data.url) {
          this.scene.input.manager.canvas.style.cursor = '';
        }
        prevHitArea.isDown = false;
      }
      if (key !== null) {
        FireEvent$2.call(this, 'areaover', key, pointer, localX, localY, event);
        if (this.urlTagCursorStyle && !!area.data.url) {
          this.scene.input.manager.canvas.style.cursor = this.urlTagCursorStyle;
        }
      }
      this.lastHitAreaKey = key;
    };
    var FireEvent$2 = function FireEvent(eventName, key, pointer, localX, localY, event) {
      this.parent.emit("".concat(eventName, "-").concat(key), pointer, localX, localY, event);
      this.parent.emit(eventName, key, pointer, localX, localY, event);
    };
  
    var RE_ASCII = /^[\x00-\x7F]+$/;
    var IsASCIIString = function IsASCIIString(s) {
      return RE_ASCII.test(s);
    };
  
    var NO_NEWLINE$1 = CONST.NO_NEWLINE;
    var RAW_NEWLINE = CONST.RAW_NEWLINE;
    var WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;
    var NO_WRAP$1 = CONST.NO_WRAP;
    var WORD_WRAP = CONST.WORD_WRAP;
    var CHAR_WRAP = CONST.CHAR_WRAP;
    var splitRegExp = CONST.SPLITREGEXP;
    var WrapText = function WrapText(text, getTextWidth, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
      if (wrapWidth <= 0) {
        wrapMode = NO_WRAP$1;
      }
      var retLines = [];
      if (!text || !text.length) {
        return retLines;
      }
      var isNoWrap = wrapMode === NO_WRAP$1;
      var lines = text.split(splitRegExp),
        line,
        remainWidth,
        newLineMode;
      for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
        line = lines[i];
        newLineMode = i === linesLen - 1 ? NO_NEWLINE$1 : RAW_NEWLINE;
        if (isNoWrap) {
          var textWidth = getTextWidth(line);
          retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
          continue;
        }
        remainWidth = i === 0 ? wrapWidth - offset : wrapWidth;
  
        // Short string testing
        if (line.length <= 100) {
          var textWidth = getTextWidth(line);
          if (textWidth <= remainWidth) {
            retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
            continue;
          }
        }
        var tokenArray = ParseLine(line, wrapMode);
        var token, tokenWidth;
        var lineText = '',
          lineWidth = 0;
        var currLineWidth;
        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
          token = tokenArray[j];
          tokenWidth = getTextWidth(token);
  
          // Text width of single token is larger than a line width
          if (tokenWidth > wrapWidth && IsWord(token)) {
            if (lineText !== '') {
              // Has pending lineText, flush it out
              retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE));
            } else if (j === 0 && offset > 0) {
              // No pending lineText, but has previous text. Append a newline
              retLines.push(wrapTextLinesPool.getLine('', 0, WRAPPED_NEWLINE));
            }
  
            // Word break
            retLines.push.apply(retLines, _toConsumableArray(WrapText(token, getTextWidth, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool)));
            // Continue at last-wordBreak-line
            var lastwordBreakLine = retLines.pop();
            lineText = lastwordBreakLine.text;
            lineWidth = lastwordBreakLine.width;
            // Free this line
            wrapTextLinesPool.freeLine(lastwordBreakLine);
  
            // Special case : Start at a space character, discard it
            if (lineText === ' ') {
              lineText = '';
              lineWidth = 0;
            }
            continue;
          }
          currLineWidth = lineWidth + tokenWidth;
          if (currLineWidth > remainWidth) {
            // New line
            retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE));
            lineText = token;
            lineWidth = tokenWidth;
            remainWidth = wrapWidth;
          } else {
            // Append token, continue
            lineText += token;
            lineWidth = currLineWidth;
          }
          if (j === tokenLen - 1) {
            // Flush remain text
            retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
          }
        } // for token in tokenArray
      } // for each line in lines
  
      return retLines;
    };
    var ParseLine = function ParseLine(s, mode) {
      var tokens;
      switch (mode) {
        case WORD_WRAP:
          tokens = [];
          s = s.split(' ');
          for (var i = 0, icnt = s.length; i < icnt; i++) {
            var token = s[i];
            if (i < icnt - 1) {
              tokens.push(token + ' ');
            } else {
              // The last token
              if (token !== '') {
                tokens.push(token);
              }
            }
          }
          break;
        case CHAR_WRAP:
          tokens = s.split('');
          break;
        default:
          // MIX_WRAP
          tokens = [];
          s = s.split(' ');
          for (var i = 0, icnt = s.length; i < icnt; i++) {
            var token = s[i];
            if (i < icnt - 1) {
              if (IsASCIIString(token)) {
                tokens.push(token + ' ');
              } else {
                var _tokens;
                (_tokens = tokens).push.apply(_tokens, _toConsumableArray(token.split('')));
                // Add space as last token
                tokens.push(' ');
              }
            } else {
              // The last token
              if (token !== '') {
                if (IsASCIIString(token)) {
                  tokens.push(token);
                } else {
                  var _tokens2;
                  (_tokens2 = tokens).push.apply(_tokens2, _toConsumableArray(token.split('')));
                }
              }
            }
          }
          break;
      }
      return tokens;
    };
    var IsWord = function IsWord(s) {
      switch (s.length) {
        case 1:
          return false;
        case 2:
          return s.charAt(1) !== ' ';
        default:
          return true;
      }
    };
  
    var GetValue$3y = Phaser.Utils.Objects.GetValue;
    var NO_WRAP = CONST.NO_WRAP;
    var NO_NEWLINE = CONST.NO_NEWLINE;
    var CanvasText = /*#__PURE__*/function () {
      function CanvasText(config) {
        _classCallCheck(this, CanvasText);
        this.parent = config.parent;
        this.scene = this.parent.scene;
        this.context = GetValue$3y(config, 'context', null);
        this.canvas = this.context.canvas;
        this.parser = GetValue$3y(config, 'parser', null);
        this.defaultStyle = GetValue$3y(config, 'style', null);
        this.autoRound = true;
        this.pensPool = config.pensPool; // Required
        this.linesPool = config.linesPool; // Required
        this.wrapTextLinesPool = config.wrapTextLinesPool; // Required
  
        this.penManager = this.newPenManager();
        this._tmpPenManager = null;
        this.hitAreaManager = new HitAreaManager();
        this.lastHitAreaKey = null;
        this.urlTagCursorStyle = null;
        var context = this.context;
        this.getTextWidth = function (text) {
          return context.measureText(text).width;
        };
      }
      _createClass(CanvasText, [{
        key: "destroy",
        value: function destroy() {
          this.parent = undefined;
          this.scene = undefined;
          this.context = undefined;
          this.canvas = undefined;
          this.parser = undefined;
          this.defaultStyle = undefined;
          if (this.penManager) {
            this.penManager.destroy();
            this.penManager = undefined;
          }
          if (this._tmpPenManager) {
            this._tmpPenManager.destroy();
            this._tmpPenManager = undefined;
          }
          if (this.hitAreaManager) {
            this.hitAreaManager.destroy();
            this.hitAreaManager = undefined;
          }
          this.pensPool = undefined;
          this.linesPool = undefined;
          this.wrapTextLinesPool = undefined;
        }
      }, {
        key: "updatePenManager",
        value: function updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
          if (penManager === undefined) {
            penManager = this.penManager;
          }
          penManager.clear();
          if (text === "") {
            return penManager;
          }
          var textStyle = this.parent.style;
          if (textStyle.isWrapFitMode) {
            var padding = this.parent.padding;
            wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
          }
          var canvas = this.canvas;
          var context = this.context;
          var MeasureText = function MeasureText(text) {
            return context.measureText(text).width;
          };
          var cursorX = 0,
            cursorY = 0;
          var customTextWrapCallback = textStyle.wrapCallback,
            customTextWrapCallbackScope = textStyle.wrapCallbackScope;
          var reuseLines = true;
          var plainText, curProp, curStyle;
          var match = this.parser.splitText(text),
            result,
            wrapLines,
            wrapTextLinesPool = this.wrapTextLinesPool;
          for (var i = 0, len = match.length; i < len; i++) {
            result = this.parser.tagTextToProp(match[i], curProp);
            plainText = result.plainText;
            curProp = result.prop;
            if (curProp.img) {
              // Image tag                
              var imgWidth = this.imageManager.getOuterWidth(curProp.img);
              if (wrapWidth > 0 && wrapMode !== NO_WRAP) {
                // Wrap mode
                if (wrapWidth < cursorX + imgWidth) {
                  penManager.addNewLinePen();
                  cursorY += lineHeight;
                  cursorX = 0;
                }
              }
              penManager.addImagePen(cursorX, cursorY, imgWidth, Clone$2(curProp));
              cursorX += imgWidth;
            } else if (plainText !== '') {
              // wrap text to lines
              // Save the current context.
              context.save();
              curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
              curStyle.buildFont();
              curStyle.syncFont(canvas, context);
              curStyle.syncStyle(canvas, context);
              if (!customTextWrapCallback) {
                wrapLines = WrapText(plainText, MeasureText, wrapMode, wrapWidth, cursorX, wrapTextLinesPool);
              } else {
                // customTextWrapCallback
                wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope, plainText, MeasureText, wrapWidth, cursorX);
                if (typeof wrapLines === 'string') {
                  wrapLines = wrapLines.split('\n');
                }
                var n;
                for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                  n = wrapLines[j];
                  if (typeof n === 'string') {
                    wrapLines[j] = wrapTextLinesPool.getLine(n, MeasureText(n), j < jLen - 1 ? 2 : 0);
                  } else {
                    reuseLines = false;
                  }
                }
              } // customTextWrapCallback
  
              // add pens
              var n;
              for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                n = wrapLines[j];
                penManager.addTextPen(n.text, cursorX, cursorY, n.width, Clone$2(curProp), n.newLineMode);
                if (n.newLineMode !== NO_NEWLINE) {
                  cursorX = 0;
                  cursorY += lineHeight;
                } else {
                  cursorX += n.width;
                }
              }
              if (reuseLines) {
                wrapTextLinesPool.freeLines(wrapLines);
              }
              wrapLines = null;
              context.restore();
            }
          }
  
          // Add strokeThinkness to last pen of each line
          for (var i = 0, len = this.lines.length; i < len; i++) {
            var line = this.lines[i];
            var lastPen = line[line.length - 1];
            if (lastPen) {
              lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
            }
          }
          return penManager;
        }
      }, {
        key: "startXOffset",
        get: function get() {
          return this.defaultStyle.xOffset;
        }
      }, {
        key: "startYOffset",
        get: function get() {
          return this.defaultStyle.metrics.ascent;
        }
      }, {
        key: "lines",
        get: function get() {
          return this.penManager.lines;
        }
      }, {
        key: "desplayLinesCount",
        get: function get() {
          var linesCount = this.penManager.linesCount,
            maxLines = this.defaultStyle.maxLines;
          if (maxLines > 0 && linesCount > maxLines) {
            linesCount = maxLines;
          }
          return linesCount;
        }
      }, {
        key: "linesWidth",
        get: function get() {
          return Math.ceil(this.penManager.getMaxLineWidth());
        }
      }, {
        key: "linesHeight",
        get: function get() {
          var linesCount = this.desplayLinesCount;
          var linesHeight = this.defaultStyle.lineHeight * linesCount;
          if (linesCount > 0) {
            linesHeight -= this.defaultStyle.lineSpacing;
          }
          return linesHeight;
        }
      }, {
        key: "imageManager",
        get: function get() {
          return this.parent.imageManager;
        }
      }, {
        key: "rtl",
        get: function get() {
          return this.parent.style.rtl;
        }
      }, {
        key: "newPenManager",
        value: function newPenManager() {
          return new PenManager({
            pensPool: this.pensPool,
            linesPool: this.linesPool,
            tagToText: this.parser.propToTagText,
            tagToTextScope: this.parser
          });
        }
      }, {
        key: "tmpPenManager",
        get: function get() {
          if (this._tmpPenManager === null) {
            this._tmpPenManager = this.newPenManager();
          }
          return this._tmpPenManager;
        }
      }, {
        key: "getPlainText",
        value: function getPlainText(text, start, end) {
          var plainText;
          if (text == null) {
            plainText = this.penManager.plainText;
          } else {
            var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
            plainText = "";
            for (var i = 0, len = match.length; i < len; i++) {
              plainText += match[i];
            }
          }
          if (start != null || end != null) {
            if (start == null) {
              start = 0;
            }
            if (end == null) {
              end = plainText.length;
            }
            plainText = plainText.substring(start, end);
          }
          return plainText;
        }
      }, {
        key: "getPenManager",
        value: function getPenManager(text, retPenManager) {
          if (text === undefined) {
            return this.copyPenManager(retPenManager, this.penManager);
          }
          if (retPenManager === undefined) {
            retPenManager = this.newPenManager();
          }
          var defaultStyle = this.defaultStyle;
          this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, retPenManager);
          return retPenManager;
        }
      }, {
        key: "getText",
        value: function getText(text, start, end, wrap) {
          if (text == null) {
            return this.penManager.getSliceTagText(start, end, wrap);
          }
          var penManager = this.tmpPenManager;
          var defaultStyle = this.defaultStyle;
          this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, penManager);
          return penManager.getSliceTagText(start, end, wrap);
        }
      }, {
        key: "copyPenManager",
        value: function copyPenManager(ret, src) {
          if (src === undefined) {
            src = this.penManager;
          }
          return src.copy(ret);
        }
      }, {
        key: "getTextWidth",
        value: function getTextWidth(penManager) {
          if (penManager === undefined) {
            penManager = this.penManager;
          }
          return penManager.getMaxLineWidth();
        }
      }, {
        key: "getLastPen",
        value: function getLastPen(penManager) {
          if (penManager === undefined) {
            penManager = this.penManager;
          }
          return penManager.lastPen;
        }
      }]);
      return CanvasText;
    }();
    var methods$H = {
      setInteractive: SetInteractive$1
    };
    Object.assign(CanvasText.prototype, DrawMethods, methods$H);
  
    var WrapTextLinesPool = /*#__PURE__*/function (_Pool) {
      _inherits(WrapTextLinesPool, _Pool);
      function WrapTextLinesPool() {
        _classCallCheck(this, WrapTextLinesPool);
        return _callSuper(this, WrapTextLinesPool, arguments);
      }
      _createClass(WrapTextLinesPool, [{
        key: "freeLine",
        value: function freeLine(line) {
          if (!line) {
            return;
          }
          this.push(line);
          return this;
        }
      }, {
        key: "freeLines",
        value: function freeLines(lines) {
          if (!lines) {
            return;
          }
          this.pushMultiple(lines);
          return this;
        }
      }, {
        key: "getLine",
        value: function getLine(text, width, newLineMode) {
          var l = this.pop();
          if (l === null) {
            l = {};
          }
          l.text = text;
          l.width = width;
          l.newLineMode = newLineMode;
          return l;
        }
      }]);
      return WrapTextLinesPool;
    }(Stack);
  
    var IsPlainObject$O = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3x = Phaser.Utils.Objects.GetValue;
    var AddImage$1 = function AddImage(key, config) {
      if (IsPlainObject$O(key)) {
        config = key;
        key = config.key;
      } else if (config === undefined) {
        config = {
          key: key
        };
      }
      if (!config.hasOwnProperty('key')) {
        config.key = key;
      }
      var textureKey = config.key,
        frameKey = config.frame;
      var width = config.width,
        height = config.height;
      if (width === undefined || height === undefined) {
        var frame = this.textureManager.getFrame(textureKey, frameKey);
        var frameWidth = frame ? frame.cutWidth : 0;
        var frameHeight = frame ? frame.cutHeight : 0;
        if (width === undefined && height === undefined) {
          width = frameWidth;
          height = frameHeight;
        } else if (width === undefined) {
          width = frameWidth * (height / frameHeight);
        } else if (height === undefined) {
          height = frameHeight * (width / frameWidth);
        }
      }
      this.images[key] = {
        key: textureKey,
        frame: frameKey,
        width: width,
        height: height,
        y: GetValue$3x(config, 'y', 0),
        left: GetValue$3x(config, 'left', 0),
        right: GetValue$3x(config, 'right', 0),
        originX: GetValue$3x(config, 'originX', 0),
        originY: GetValue$3x(config, 'originY', 0),
        tintFill: GetValue$3x(config, 'tintFill', false)
      };
    };
  
    var CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;
    var DrawFrameToCanvas = function DrawFrameToCanvas(frame, canvas, x, y, width, height, color, autoRound) {
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (width === undefined) {
        width = frame.cutWidth;
      }
      if (height === undefined) {
        height = frame.cutHeight;
      }
      if (autoRound === undefined) {
        autoRound = false;
      }
      if (autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }
      var context = canvas.getContext('2d', {
        willReadFrequently: true
      });
      if (color) {
        // Draw image at tempCanvas
  
        // Get tempCanvas
        var tempCanvas = CanvasPool$1.create(null, width, height, Phaser.CANVAS, true);
        var tempContext = tempCanvas.getContext('2d', {
          willReadFrequently: true
        });
        tempContext.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, width, height);
  
        // Tint-fill
        tempContext.globalCompositeOperation = 'source-in';
        tempContext.fillStyle = color;
        tempContext.fillRect(0, 0, width, height);
  
        // Draw tempCanvas at context
        context.drawImage(tempCanvas, 0, 0, width, height, x, y, width, height);
  
        // Release tempCanvas
        CanvasPool$1.remove(tempCanvas);
      } else {
        context.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, x, y, width, height);
      }
    };
  
    var DrawImage = function DrawImage(key, context, x, y, color, autoRound) {
      var imgData = this.get(key);
      if (!imgData) {
        // Invalid key
        return;
      }
      var frame = this.textureManager.getFrame(imgData.key, imgData.frame);
      var width = imgData.width,
        height = imgData.height;
      x += imgData.left - imgData.originX * width;
      y += imgData.y - imgData.originY * height;
      if (!imgData.tintFill) {
        color = undefined;
      }
      DrawFrameToCanvas(frame, context.canvas, x, y, width, height, color, autoRound);
    };
  
    var ImageManager = /*#__PURE__*/function () {
      function ImageManager(scene) {
        _classCallCheck(this, ImageManager);
        this.textureManager = scene.sys.textures;
        this.images = {};
      }
      _createClass(ImageManager, [{
        key: "destroy",
        value: function destroy() {
          this.textureManager = undefined;
          this.images = undefined;
        }
      }, {
        key: "add",
        value: function add(key, config) {
          if (typeof key === 'string') {
            AddImage$1.call(this, key, config);
          } else if (Array.isArray(key)) {
            var data = key;
            for (var i = 0, cnt = data.length; i < cnt; i++) {
              AddImage$1.call(this, data[i]);
            }
          } else {
            var data = key;
            for (var key in data) {
              AddImage$1.call(this, key, data[key]);
            }
          }
          return this;
        }
      }, {
        key: "has",
        value: function has(key) {
          return this.images.hasOwnProperty(key);
        }
      }, {
        key: "remove",
        value: function remove(key) {
          if (this.has(key)) {
            delete this.images[key];
          }
          return this;
        }
      }, {
        key: "get",
        value: function get(key) {
          if (!this.has(key)) {
            if (this.textureManager.exists(key)) {
              this.add(key);
            }
          }
          return this.images[key];
        }
      }, {
        key: "getOuterWidth",
        value: function getOuterWidth(key) {
          var data = this.get(key);
          return data ? data.width + data.left + data.right : 0;
        }
      }, {
        key: "getFrame",
        value: function getFrame(key) {
          var data = this.get(key);
          return data ? this.textureManager.getFrame(data.key, data.frame) : undefined;
        }
      }, {
        key: "hasTexture",
        value: function hasTexture(key) {
          return !!this.getFrame(key);
        }
      }]);
      return ImageManager;
    }();
    var methods$G = {
      draw: DrawImage
    };
    Object.assign(ImageManager.prototype, methods$G);
  
    var AppendText$2 = function AppendText(value, addCR) {
      if (!value && value !== 0) {
        value = '';
      }
      if (addCR === undefined) {
        addCR = true;
      }
      if (Array.isArray(value)) {
        value = value.join('\n');
      }
      var newText;
      if (addCR) {
        newText = "".concat(this.text, "\n").concat(value);
      } else {
        newText = "".concat(this.text).concat(value);
      }
      if (newText != this.text) {
        this.setText(newText);
      }
      return this;
    };
  
    var IsPlainObject$N = Phaser.Utils.Objects.IsPlainObject;
    var AddToDOM = Phaser.DOM.AddToDOM;
    var CanvasPool = Phaser.Display.Canvas.CanvasPool;
    var GameObject$1 = Phaser.GameObjects.GameObject;
    var GetValue$3w = Phaser.Utils.Objects.GetValue;
    var RemoveFromDOM$1 = Phaser.DOM.RemoveFromDOM;
    var SPLITREGEXP = CONST.SPLITREGEXP;
    var UUID$4 = Phaser.Utils.String.UUID;
  
    // Reuse objects can increase performance
    var SharedPensPools = null;
    var SharedLinesPool = null;
    var SharedWrapTextLinesPool = null;
    var Text = /*#__PURE__*/function (_TextBase) {
      _inherits(Text, _TextBase);
      function Text(scene, x, y, text, style, type, parser) {
        var _this;
        _classCallCheck(this, Text);
        if (IsPlainObject$N(x)) {
          var config = x;
          x = GetValue$3w(config, 'x', 0);
          y = GetValue$3w(config, 'y', 0);
          text = GetValue$3w(config, 'text', '');
          style = GetValue$3w(config, 'style');
        }
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        _this = _callSuper(this, Text, [scene, type]);
        _this.renderer = scene.sys.game.renderer;
        _this.setPosition(x, y);
        _this.setOrigin(0, 0);
        _this.initPipeline();
        _this.initPostPipeline(true);
        _this.canvas = CanvasPool.create(_assertThisInitialized(_this));
        _this.context = _this.canvas.getContext('2d', {
          willReadFrequently: true
        });
        _this._imageManager = undefined;
        if (style) {
          // Override align
          if (style.hasOwnProperty('align')) {
            var halign = style.align;
            delete style.align;
            style.halign = halign;
          }
          // Has Stroke color but stroke thinkness, set stroke thinkness to 1
          if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
            style.strokeThickness = 1;
          }
        }
        _this.style = new TextStyle$1(_assertThisInitialized(_this), style);
        var imageData = GetValue$3w(style, 'images', undefined);
        if (imageData) {
          _this.addImage(imageData);
        }
        _this.autoRound = true;
        _this._text = undefined;
        _this.padding = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        _this.width = 1;
        _this.height = 1;
        _this.lineSpacing = 0;
        _this.dirty = false;
  
        //  If resolution wasn't set, force it to 1
        if (_this.style.resolution === 0) {
          _this.style.resolution = 1;
        }
        _this._crop = _this.resetCropObject();
  
        //  Create a Texture for this Text object
        _this._textureKey = UUID$4();
        _this.texture = scene.sys.textures.addCanvas(_this._textureKey, _this.canvas);
  
        //  Get the frame
        _this.frame = _this.texture.get();
  
        //  Set the resolution
        _this.frame.source.resolution = _this.style.resolution;
        if (_this.renderer && _this.renderer.gl) {
          //  Clear the default 1x1 glTexture, as we override it later
          _this.renderer.deleteTexture(_this.frame.source.glTexture);
          _this.frame.source.glTexture = null;
        }
        var sharedPoolMode = GetValue$3w(style, 'sharedPool', true);
        var pensPool, linesPool, wrapTextLinesPool;
        if (sharedPoolMode) {
          // Use pools first time
          if (!SharedPensPools) {
            SharedPensPools = {};
            SharedLinesPool = new Stack();
            SharedWrapTextLinesPool = new WrapTextLinesPool();
  
            // Remove cached data
            _this.scene.game.events.once('destroy', function () {
              SharedPensPools = null;
              SharedLinesPool = null;
              SharedWrapTextLinesPool = null;
            });
          }
          if (!SharedPensPools.hasOwnProperty(type)) {
            SharedPensPools[type] = new Stack();
          }
          pensPool = SharedPensPools[type];
          linesPool = SharedLinesPool;
          wrapTextLinesPool = SharedWrapTextLinesPool;
        } else {
          pensPool = new Stack();
          linesPool = new Stack();
          wrapTextLinesPool = new WrapTextLinesPool();
        }
        _this.canvasText = new CanvasText({
          parent: _assertThisInitialized(_this),
          context: _this.context,
          parser: parser,
          style: _this.style,
          pensPool: pensPool,
          linesPool: linesPool,
          wrapTextLinesPool: wrapTextLinesPool
        });
        _this.parser = parser;
        _this.initRTL();
        if (style && style.padding) {
          _this.setPadding(style.padding);
        }
        if (style && style.lineSpacing) {
          _this.setLineSpacing(style.lineSpacing);
        }
        _this.setText(text);
        _this.setUrlTagCursorStyle(GetValue$3w(style, 'urlTagCursorStyle', 'pointer'));
        if (GetValue$3w(style, 'interactive', false)) {
          _this.setInteractive();
        }
        return _this;
      }
      _createClass(Text, [{
        key: "preDestroy",
        value: function preDestroy() {
          RemoveFromDOM$1(this.canvas);
          // Do nothing if canvas did not add to parent node before
  
          this.canvasText.destroy();
          this.canvasText = undefined;
          if (this._imageManager) {
            this._imageManager.destroy();
            this._imageManager = undefined;
          }
          CanvasPool.remove(this.canvas);
          var texture = this.texture;
          if (texture) {
            texture.destroy();
          }
        }
      }, {
        key: "text",
        get: function get() {
          return this._text;
        },
        set: function set(value) {
          this.setText(value);
        }
      }, {
        key: "initRTL",
        value: function initRTL() {
          if (!this.style.rtl) {
            return;
          }
  
          //  Here is where the crazy starts.
          //
          //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
          //  that is not part of the DOM. It just completely ignores the direction property.
  
          this.canvas.dir = 'rtl';
  
          //  Experimental atm, but one day ...
          this.context.direction = 'rtl';
  
          //  Add it to the DOM, but hidden within the parent canvas.
          this.canvas.style.display = 'none';
          AddToDOM(this.canvas, this.scene.sys.canvas);
  
          //  And finally we set the x origin
          this.originX = 1;
        }
      }, {
        key: "setRTL",
        value: function setRTL(rtl) {
          if (rtl === undefined) {
            rtl = true;
          }
          var style = this.style;
          if (style.rtl === rtl) {
            return this;
          }
          style.rtl = rtl;
          if (rtl) {
            this.canvas.dir = 'rtl';
            this.context.direction = 'rtl';
            this.canvas.style.display = 'none';
            AddToDOM(this.canvas, this.scene.sys.canvas);
          } else {
            this.canvas.dir = 'ltr';
            this.context.direction = 'ltr';
          }
          if (style.halign === 'left') {
            style.halign = 'right';
          } else if (style.halign === 'right') {
            style.halign = 'left';
          }
          if (this._imageManager) {
            var images = this._imageManager.images;
            for (var key in images) {
              images[key].originX = 1 - images[key].originX;
            }
          }
          return this;
        }
      }, {
        key: "setText",
        value: function setText(value) {
          if (value == null) {
            value = '';
          } else if (Array.isArray(value)) {
            value = value.join('\n');
          } else {
            value = value.toString();
          }
          if (value === this._text) {
            return this;
          }
          this._text = value;
          this.updateText();
          return this;
        }
      }, {
        key: "setPadding",
        value: function setPadding(left, top, right, bottom) {
          if (_typeof(left) === 'object') {
            var config = left;
  
            //  If they specify x and/or y this applies to all
            var x = GetValue$3w(config, 'x', null);
            if (x !== null) {
              left = x;
              right = x;
            } else {
              left = GetValue$3w(config, 'left', 0);
              right = GetValue$3w(config, 'right', left);
            }
            var y = GetValue$3w(config, 'y', null);
            if (y !== null) {
              top = y;
              bottom = y;
            } else {
              top = GetValue$3w(config, 'top', 0);
              bottom = GetValue$3w(config, 'bottom', top);
            }
          } else {
            if (left === undefined) {
              left = 0;
            }
            if (top === undefined) {
              top = left;
            }
            if (right === undefined) {
              right = left;
            }
            if (bottom === undefined) {
              bottom = top;
            }
          }
          this.padding.left = left;
          this.padding.top = top;
          this.padding.right = right;
          this.padding.bottom = bottom;
          return this.updateText(false);
        }
      }, {
        key: "updateText",
        value: function updateText(runWrap) {
          if (runWrap === undefined) {
            runWrap = true;
          }
          var canvasText = this.canvasText;
  
          // wrap text to pens
          var style = this.style;
          if (runWrap) {
            canvasText.updatePenManager(this._text, style.wrapMode, style.wrapWidth, style.lineHeight);
          }
  
          // resize
          var padding = this.padding;
          var textWidth, textHeight;
          var linesWidth = Math.ceil(canvasText.linesWidth);
          if (style.fixedWidth === 0) {
            this.width = linesWidth + padding.left + padding.right;
            textWidth = linesWidth;
          } else {
            this.width = style.fixedWidth;
            textWidth = this.width - padding.left - padding.right;
            if (textWidth < linesWidth) {
              textWidth = linesWidth;
            }
          }
          if (style.fixedHeight === 0) {
            this.height = canvasText.linesHeight + padding.top + padding.bottom;
            textHeight = canvasText.linesHeight;
          } else {
            this.height = style.fixedHeight;
            textHeight = this.height - padding.top - padding.bottom;
            if (textHeight < canvasText.linesHeight) {
              textHeight = canvasText.linesHeight;
            }
          }
          var w = this.width;
          var h = this.height;
          this.updateDisplayOrigin();
          var resolution = style.resolution;
          w *= resolution;
          h *= resolution;
          w = Math.max(Math.ceil(w), 1);
          h = Math.max(Math.ceil(h), 1);
          var canvas = this.canvas;
          var context = this.context;
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            this.frame.setSize(w, h);
          } else {
            context.clearRect(0, 0, w, h);
          }
          context.save();
          context.scale(resolution, resolution);
  
          // draw
          var startX = !this.style.rtl ? padding.left : padding.right;
          var startY = padding.top;
          canvasText.draw(startX, startY, textWidth, textHeight);
          context.restore();
          if (this.renderer && this.renderer.gl) {
            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
            if (typeof WEBGL_DEBUG === "undefined" ? "undefined" : _typeof(WEBGL_DEBUG)) {
              this.frame.glTexture.spectorMetadata = {
                textureKey: 'BBCodeText Game Object'
              };
            }
          }
          this.dirty = true;
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
          }
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var out = Components.ToJSON(this);
  
          //  Extra Text data is added here
  
          var data = {
            autoRound: this.autoRound,
            text: this._text,
            style: this.style.toJSON(),
            resolution: this.resolution,
            padding: {
              left: this.padding.left,
              right: this.padding.right,
              top: this.padding.top,
              bottom: this.padding.bottom
            }
          };
          out.data = data;
          return out;
        }
      }, {
        key: "setInteractive",
        value: function setInteractive(hitArea, hitAreaCallback, dropZone) {
          var isInteractived = !!this.input;
          GameObject$1.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
          if (!isInteractived) {
            this.canvasText.setInteractive();
          }
          return this;
        }
      }, {
        key: "setUrlTagCursorStyle",
        value: function setUrlTagCursorStyle(cursor) {
          this.urlTagCursorStyle = cursor;
          return this;
        }
      }, {
        key: "urlTagCursorStyle",
        get: function get() {
          return this.canvasText.urlTagCursorStyle;
        },
        set: function set(value) {
          this.canvasText.urlTagCursorStyle = value;
        }
      }, {
        key: "getWrappedText",
        value: function getWrappedText(text, start, end) {
          if (typeof text === 'number') {
            end = start;
            start = text;
            text = undefined;
          }
          text = this.canvasText.getText(text, start, end, true);
          return text.split(SPLITREGEXP);
        }
      }, {
        key: "getPlainText",
        value: function getPlainText(text, start, end) {
          if (typeof text === 'number') {
            end = start;
            start = text;
            text = undefined;
          }
          return this.canvasText.getPlainText(text, start, end);
        }
      }, {
        key: "getText",
        value: function getText(text, start, end, wrap) {
          if (typeof text === 'number') {
            wrap = end;
            end = start;
            start = text;
            text = undefined;
          }
          if (wrap === undefined) {
            wrap = false;
          }
          return this.canvasText.getText(text, start, end, wrap);
        }
      }, {
        key: "getSubString",
        value: function getSubString(text, start, end) {
          if (typeof text === 'number') {
            end = start;
            start = text;
            text = undefined;
          }
          return this.getText(text, start, end);
        }
      }, {
        key: "copyPenManager",
        value: function copyPenManager(penManager) {
          return this.canvasText.copyPenManager(penManager);
        }
      }, {
        key: "getPenManager",
        value: function getPenManager(text, penManager) {
          return this.canvasText.getPenManager(text, penManager);
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          return this.setFixedSize(width, height);
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          return this.setFixedSize(width, height);
        }
      }, {
        key: "imageManager",
        get: function get() {
          if (!this._imageManager) {
            this._imageManager = new ImageManager(this.scene);
          }
          return this._imageManager;
        }
      }, {
        key: "addImage",
        value: function addImage(key, config) {
          this.imageManager.add(key, config);
          return this;
        }
      }, {
        key: "drawAreaBounds",
        value: function drawAreaBounds(graphics, color) {
          this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
          return this;
        }
      }, {
        key: "generateTexture",
        value: function generateTexture(key, x, y, width, height) {
          var srcCanvas = this.canvas;
          if (width === undefined) {
            width = srcCanvas.width;
          } else {
            width *= this.resolution;
          }
          if (height === undefined) {
            height = srcCanvas.height;
          } else {
            height *= this.resolution;
          }
          CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
          return this;
        }
      }]);
      return Text;
    }(TextBase);
    var methods$F = {
      appendText: AppendText$2
    };
    Object.assign(Text.prototype, methods$F);
  
    var SplitText = function SplitText(text, mode) {
      var TagRegex = this.tagRegex;
      var result = [];
      var charIdx = 0;
      var rawMode = false,
        escMode = false;
      while (true) {
        var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
        if (!regexResult) {
          break;
        }
        var match = regexResult[0];
        if (escMode) {
          if (TagRegex.RE_ESC_CLOSE.test(match)) {
            escMode = false;
          } else {
            continue; // Skip other tags
          }
        } else if (rawMode) {
          if (TagRegex.RE_RAW_CLOSE.test(match)) {
            rawMode = false;
          } else {
            continue; // Skip other tags
          }
        } else {
          if (TagRegex.RE_ESC_OPEN.test(match)) {
            escMode = true;
          } else if (TagRegex.RE_RAW_OPEN.test(match)) {
            rawMode = true;
          }
        }
        var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
        var matchStart = matchEnd - match.length;
        if (charIdx < matchStart) {
          var content = text.substring(charIdx, matchStart);
          result.push(content);
        }
        if (mode === undefined) {
          result.push(match);
        }
        charIdx = matchEnd;
      }
      var totalLen = text.length;
      if (charIdx < totalLen) {
        // Push remainder string
        result.push(text.substring(charIdx, totalLen));
      }
      return result; // [text,...]
    };
  
    var PROP_REMOVE = false;
    var PROP_ADD = true;
    var GETPROP_RESULT$1 = {
      plainText: null,
      prevProp: null
    };
    var TagTextToProp = function TagTextToProp(text, prevProp) {
      var TagRegex = this.tagRegex;
  
      // text : result of splitText()
      if (prevProp == null) {
        prevProp = {};
      }
      var plainText = '';
  
      // close image tag
      if (prevProp.img) {
        UpdateProp(prevProp, PROP_REMOVE, 'img');
      }
      if (prevProp.esc) {
        if (TagRegex.RE_ESC_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'esc');
        } else {
          plainText = text;
        }
      } else if (prevProp.raw) {
        if (TagRegex.RE_RAW_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'raw');
        } else {
          plainText = text;
        }
      } else {
        if (TagRegex.RE_ESC_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'esc', true);
        } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'esc');
        } else if (TagRegex.RE_RAW_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'raw', true);
        } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'raw');
        } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'b', true);
        } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'b');
        } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'i', true);
        } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'i');
        } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'weight', innerMatch[1]);
        } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'weight');
        } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'size', "".concat(innerMatch[1], "px"));
        } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'size');
        } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
        } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'color');
        } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'u', true);
        } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
          var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
          UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
        } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'u');
        } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 's', true);
        } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
          var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
          UpdateProp(prevProp, PROP_ADD, 's', innerMatch[1]);
        } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 's');
        } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'shadow', true);
        } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
          var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
          UpdateProp(prevProp, PROP_ADD, 'shadow', innerMatch[1]);
        } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'shadow');
        } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
          UpdateProp(prevProp, PROP_ADD, 'stroke', true);
        } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
          var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
          UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
        } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'stroke');
        } else if (TagRegex.RE_BGCOLOR_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_BGCOLOR_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'bgcolor', innerMatch[1]);
        } else if (TagRegex.RE_BGCOLOR_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'bgcolor');
        } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
        } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'y');
        } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
        } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'img');
        } else if (TagRegex.RE_AREA_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
        } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'area');
        } else if (TagRegex.RE_URL_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_URL_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'url', innerMatch[1]);
        } else if (TagRegex.RE_URL_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'url');
        } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
        } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'align');
        } else if (TagRegex.RE_ID_OPEN.test(text)) {
          var innerMatch = text.match(TagRegex.RE_ID_OPEN);
          UpdateProp(prevProp, PROP_ADD, 'id', innerMatch[1]);
        } else if (TagRegex.RE_ID_CLOSE.test(text)) {
          UpdateProp(prevProp, PROP_REMOVE, 'id');
        } else {
          plainText = text;
        }
      }
      var result = GETPROP_RESULT$1;
      result.plainText = plainText;
      result.prop = prevProp;
      return result;
    };
    var UpdateProp = function UpdateProp(prop, op, key, value) {
      if (op === PROP_ADD) {
        // PROP_ADD     
        prop[key] = value;
      } else {
        // PROP_REMOVE        
        if (prop.hasOwnProperty(key)) {
          delete prop[key];
        }
      }
      return prop;
    };
  
    var PropToContextStyle = function PropToContextStyle(defaultStyle, prop) {
      var result = STYLE_RESULT$1;
      if (!prop.hasOwnProperty('img')) {
        result.image = null;
        if (prop.hasOwnProperty('family')) {
          result.fontFamily = prop.family;
        } else {
          result.fontFamily = defaultStyle.fontFamily;
        }
        if (prop.hasOwnProperty('size')) {
          var size = prop.size;
          if (typeof size === 'number') {
            size = "".concat(size, "px");
          }
          result.fontSize = size;
        } else {
          result.fontSize = defaultStyle.fontSize;
        }
        result.fontStyle = GetFontStyle(prop);
        if (prop.hasOwnProperty('color')) {
          result.color = prop.color;
        } else {
          result.color = defaultStyle.color;
        }
        if (prop.hasOwnProperty('stroke')) {
          if (prop.stroke === true) {
            result.stroke = defaultStyle.stroke;
            result.strokeThickness = defaultStyle.strokeThickness;
          } else {
            result.stroke = prop.stroke;
            result.strokeThickness = defaultStyle.strokeThickness;
          }
        } else {
          result.stroke = defaultStyle.stroke;
          result.strokeThickness = 0;
        }
      } else {
        result.image = prop.img;
      }
      if (prop.hasOwnProperty('shadow')) {
        if (prop.shadow === true) {
          result.shadowColor = defaultStyle.shadowColor;
          result.shadowOffsetX = defaultStyle.shadowOffsetX;
          result.shadowOffsetY = defaultStyle.shadowOffsetY;
          result.shadowBlur = defaultStyle.shadowBlur;
          result.shadowStroke = true;
          result.shadowFill = true;
        } else {
          result.shadowColor = prop.shadow;
          result.shadowOffsetX = defaultStyle.shadowOffsetX;
          result.shadowOffsetY = defaultStyle.shadowOffsetY;
          result.shadowBlur = defaultStyle.shadowBlur;
          result.shadowStroke = true;
          result.shadowFill = true;
        }
      } else {
        result.shadowColor = '#000';
        result.shadowOffsetX = 0;
        result.shadowOffsetY = 0;
        result.shadowBlur = 0;
        result.shadowStroke = false;
        result.shadowFill = false;
      }
      if (prop.hasOwnProperty('u')) {
        if (prop.u === true) {
          result.underlineColor = defaultStyle.underlineColor;
          result.underlineThickness = defaultStyle.underlineThickness;
          result.underlineOffset = defaultStyle.underlineOffset;
        } else {
          result.underlineColor = prop.u;
          result.underlineThickness = defaultStyle.underlineThickness;
          result.underlineOffset = defaultStyle.underlineOffset;
        }
      } else {
        result.underlineColor = '#000';
        result.underlineThickness = 0;
        result.underlineOffset = 0;
      }
      if (prop.hasOwnProperty('s')) {
        if (prop.s === true) {
          result.strikethroughColor = defaultStyle.strikethroughColor;
          result.strikethroughThickness = defaultStyle.strikethroughThickness;
          result.strikethroughOffset = defaultStyle.strikethroughOffset;
        } else {
          result.strikethroughColor = prop.s;
          result.strikethroughThickness = defaultStyle.strikethroughThickness;
          result.strikethroughOffset = defaultStyle.strikethroughOffset;
        }
      } else {
        result.strikethroughColor = '#000';
        result.strikethroughThickness = 0;
        result.strikethroughOffset = 0;
      }
      if (prop.hasOwnProperty('bgcolor')) {
        result.bgcolor = prop.bgcolor;
      } else {
        result.bgcolor = null;
      }
      return result;
    };
    var GetFontStyle = function GetFontStyle(prop) {
      var isBold = prop.b;
      var weight = prop.weight;
      var isItalic = prop.i;
      if (isBold || weight || isItalic) {
        if (isItalic) {
          if (isBold) {
            return 'bold italic';
          } else if (weight) {
            return "".concat(weight, " italic");
          } else {
            return 'italic';
          }
        } else {
          // !isItalic
          if (isBold) {
            return 'bold';
          } else {
            return weight.toString();
          }
        }
      } else {
        return '';
      }
    };
    var STYLE_RESULT$1 = new TextStyle$1();
  
    var PropToTagText = function PropToTagText(text, prop, prevProp) {
      if (prevProp == null) {
        prevProp = EMPTYPROP;
      }
      var delimiterLeft = this.delimiters[0];
      var delimiterRight = this.delimiters[1];
      var headers = [];
      for (var k in prevProp) {
        if (!prop.hasOwnProperty(k)) {
          headers.push("".concat(delimiterLeft, "/").concat(k).concat(delimiterRight));
        }
      }
      for (var k in prop) {
        var value = prop[k];
        if (k === 'img') ; else {
          if (prevProp[k] === value) {
            continue;
          }
        }
        switch (k) {
          case 'size':
            headers.push("".concat(delimiterLeft, "size=").concat(value.replace('px', '')).concat(delimiterRight));
            break;
          case 'color':
          case 'weight':
          case 'stroke':
          case 'bgcolor':
          case 'y':
          case 'img':
          case 'area':
          case 'url':
          case 'align':
          case 'id':
            headers.push("".concat(delimiterLeft).concat(k, "=").concat(value).concat(delimiterRight));
            break;
          case 'u':
          case 's':
            if (value === true) {
              headers.push("".concat(delimiterLeft).concat(k).concat(delimiterRight));
            } else {
              headers.push("".concat(delimiterLeft).concat(k, "=").concat(value).concat(delimiterRight));
            }
            break;
          default:
            headers.push("".concat(delimiterLeft).concat(k).concat(delimiterRight));
            break;
        }
      }
      headers.push(text);
      return headers.join('');
    };
    var EMPTYPROP = {};
  
    // https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js
  
    var EscapeRegex = function EscapeRegex(s) {
      return s.replace(re0, '\\$&').replace(re1, '\\x2d');
    };
    var re0 = /[|\\{}()[\]^$+*?.]/g;
    var re1 = /-/g;
  
    var DelimiterLeftSave;
    var DelimiterRightSave;
    var TagRegexSave = {};
    var GetOpenTagRegString = function GetOpenTagRegString(delimiterLeft, delimiterRight, tagName, param) {
      if (param === undefined) {
        return "".concat(delimiterLeft).concat(tagName).concat(delimiterRight);
      } else {
        return "".concat(delimiterLeft).concat(tagName, "=(").concat(param, ")").concat(delimiterRight);
      }
    };
    var GetCloseTagRegString = function GetCloseTagRegString(delimiterLeft, delimiterRight, tagName) {
      return "".concat(delimiterLeft, "/").concat(tagName).concat(delimiterRight);
    };
    var GenerateStringRegEx = function GenerateStringRegEx(delimiterRight) {
      return "[^".concat(delimiterRight, "]+");
    };
    var NUMBER_PARAM = '[-.0-9]+';
    var colorParameterList = ['[a-zA-Z]+',
    // 'white'
    '#[0-9abcdef]+',
    // '#FFFFFF'
    'rgba?\\(\s*[.0-9]+\s*(,\s*[.0-9]+\s*){2,3}\\)' // rgb(255,255,255), or rgba(255,255,255,1)
    ];
    var COLOR_PARAM = colorParameterList.join('|'); // '[a-z]+|#[0-9abcdef]+'
  
    var SetDelimiters = function SetDelimiters(delimiterLeft, delimiterRight) {
      if (delimiterRight === undefined) {
        var delimeters = delimiterLeft;
        delimiterLeft = delimeters[0];
        delimiterRight = delimeters[1];
      }
      if (DelimiterLeftSave === delimiterLeft && DelimiterRightSave === delimiterRight) {
        return false;
      }
      DelimiterLeftSave = delimiterLeft;
      DelimiterRightSave = delimiterRight;
      delimiterLeft = EscapeRegex(delimiterLeft);
      delimiterRight = EscapeRegex(delimiterRight);
      var STR_PARAM = GenerateStringRegEx(delimiterRight);
      var ESC = 'esc';
      var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
      var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);
      var RAW = 'raw';
      var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
      var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);
      var BLOD = 'b';
      var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
      var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);
      var ITALICS = 'i';
      var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
      var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);
      var WEIGHT = 'weight';
      var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
      var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);
      var SIZE = 'size';
      var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
      var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);
      var COLOR = 'color';
      var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
      var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);
      var UNDERLINE = 'u';
      var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
      var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
      var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
      var STRIKETHROUGH = 's';
      var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
      var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
      var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
      var SHADOW = 'shadow';
      var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
      var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
      var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);
      var STROKE = 'stroke';
      var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
      var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
      var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);
      var BGCOLOR = 'bgcolor';
      var BGCOLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BGCOLOR, COLOR_PARAM);
      var BGCOLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BGCOLOR);
      var OFFSETY = 'y';
      var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
      var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);
      var IMAGE = 'img';
      var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
      var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);
      var AREA = 'area';
      var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
      var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);
      var URL = 'url';
      var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL, STR_PARAM);
      var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL);
      var ALIGN = 'align';
      var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN, STR_PARAM);
      var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN);
      var ID = 'id';
      var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
      var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);
      TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, 'i');
      TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, 'i');
      TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, 'i');
      TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, 'i');
      TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, 'i');
      TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, 'i');
      TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, 'i');
      TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, 'i');
      TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, 'i');
      TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, 'i');
      TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, 'i');
      TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, 'i');
      TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, 'i');
      TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, 'i');
      TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, 'i');
      TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, 'i');
      TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, 'i');
      TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, 'i');
      TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, 'i');
      TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, 'i');
      TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, 'i');
      TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, 'i');
      TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, 'i');
      TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, 'i');
      TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, 'i');
      TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, 'i');
      TagRegexSave.RE_BGCOLOR_OPEN = new RegExp(BGCOLOR_OPEN, 'i');
      TagRegexSave.RE_BGCOLOR_CLOSE = new RegExp(BGCOLOR_CLOSE, 'i');
      TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, 'i');
      TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, 'i');
      TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, 'i');
      TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, 'i');
      TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, 'i');
      TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, 'i');
      TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, 'i');
      TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, 'i');
      TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, 'i');
      TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, 'i');
      TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, 'i');
      TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, 'i');
      TagRegexSave.RE_SPLITTEXT = new RegExp([RAW_OPEN, RAW_CLOSE, ESC_OPEN, ESC_CLOSE, BLOD_OPEN, BLOD_CLOSE, ITALICS_OPEN, ITALICS_CLOSE, WEIGHT_OPEN, WEIGHT_CLOSE, SIZE_OPEN, SIZE_CLOSE, COLOR_OPEN, COLOR_CLOSE, UNDERLINE_OPEN, UNDERLINE_OPENC, UNDERLINE_CLOSE, STRIKETHROUGH_OPEN, STRIKETHROUGH_OPENC, STRIKETHROUGH_CLOSE, SHADOW_OPEN, SHADOW_OPENC, SHADOW_CLOSE, STROKE_OPEN, STROKE_OPENC, STROKE_CLOSE, BGCOLOR_OPEN, BGCOLOR_CLOSE, OFFSETY_OPEN, OFFSETY_CLOSE, IMAGE_OPEN, IMAGE_CLOSE, AREA_OPEN, AREA_CLOSE, URL_OPEN, URL_CLOSE, ALIGN_OPEN, ALIGN_CLOSE, ID_OPEN, ID_CLOSE].join('|'), 'ig');
      return true;
    };
    var GetTagRegex = function GetTagRegex(delimiterLeft, delimiterRight) {
      if (delimiterLeft !== undefined) {
        SetDelimiters(delimiterLeft, delimiterRight);
      }
      return Object.assign({}, TagRegexSave);
    };
  
    var GetValue$3v = Phaser.Utils.Objects.GetValue;
    var Parser$2 = /*#__PURE__*/function () {
      function Parser(style) {
        _classCallCheck(this, Parser);
        var delimiters = GetValue$3v(style, 'delimiters', '[]');
        this.tagRegex = GetTagRegex(delimiters);
        this.delimiters = delimiters;
      }
      _createClass(Parser, [{
        key: "getStrokeThinkness",
        value: function getStrokeThinkness(defaultStyle, prop) {
          var strokeThickness;
          if (prop.hasOwnProperty('stroke')) {
            strokeThickness = defaultStyle.strokeThickness;
          } else {
            strokeThickness = 0;
          }
          return strokeThickness;
        }
      }, {
        key: "setDelimiters",
        value: function setDelimiters(delimiterLeft, delimiterRight) {
          if (SetDelimiters(delimiterLeft, delimiterRight)) {
            this.tagRegex = GetTagRegex();
          }
          return this;
        }
      }]);
      return Parser;
    }();
    var methods$E = {
      splitText: SplitText,
      tagTextToProp: TagTextToProp,
      propToContextStyle: PropToContextStyle,
      propToTagText: PropToTagText
    };
    Object.assign(Parser$2.prototype, methods$E);
  
    var BBCodeText = /*#__PURE__*/function (_Text) {
      _inherits(BBCodeText, _Text);
      function BBCodeText(scene, x, y, text, style) {
        _classCallCheck(this, BBCodeText);
        var parser = new Parser$2(style);
        return _callSuper(this, BBCodeText, [scene, x, y, text, style, 'rexBBCodeText', parser]);
      }
      _createClass(BBCodeText, [{
        key: "setDelimiters",
        value: function setDelimiters(delimiterLeft, delimiterRight) {
          this.parse.setDelimiters(delimiterLeft, delimiterRight);
          return this;
        }
      }]);
      return BBCodeText;
    }(Text);
  
    ObjectFactory.register('BBCodeText', function (x, y, text, style) {
      var gameObject = new BBCodeText(this.scene, x, y, text, style);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.BBCodeText', BBCodeText);
  
    var GETPROP_RESULT = {
      plainText: null,
      prevProp: null
    };
    var STYLE_RESULT = new TextStyle$1();
    var Parser$1 = /*#__PURE__*/function () {
      function Parser(tags) {
        _classCallCheck(this, Parser);
        if (tags === undefined) {
          tags = {};
        }
        this.tags = tags;
      }
      _createClass(Parser, [{
        key: "addTag",
        value: function addTag(name, prop) {
          this.tags[name] = prop;
        }
      }, {
        key: "getTag",
        value: function getTag(name) {
          return this.tags[name];
        }
      }, {
        key: "splitText",
        value: function splitText(text, mode) {
          var result = [];
          var charIdx = 0;
          while (true) {
            var regexResult = RE_SPLITTEXT.exec(text);
            if (!regexResult) {
              break;
            }
            var match = regexResult[0];
            var matchStart = RE_SPLITTEXT.lastIndex - match.length;
            if (charIdx < matchStart) {
              result.push(text.substring(charIdx, matchStart));
            }
            if (mode === undefined) {
              result.push(match);
            } else if (mode === 1) {
              // RAWTEXTONLY_MODE
              if (RE_CLASS_HEADER.test(match)) {
                var innerMatch = match.match(RE_CLASS);
                result.push(innerMatch[2]);
              } else if (RE_STYLE_HEADER.test(match)) {
                var innerMatch = match.match(RE_STYLE);
                result.push(innerMatch[2]);
              }
            }
            charIdx = RE_SPLITTEXT.lastIndex;
          }
          var totalLen = text.length;
          if (charIdx < totalLen) {
            // Push remainder string
            result.push(text.substring(charIdx, totalLen));
          }
          return result; // [text,...]         
        }
      }, {
        key: "tagTextToProp",
        value: function tagTextToProp(text, prevProp) {
          var plainText, propOut;
          if (RE_CLASS_HEADER.test(text)) {
            var innerMatch = text.match(RE_CLASS);
            if (innerMatch != null) {
              var name = innerMatch[1];
              var tags = this.tags;
              if (tags.hasOwnProperty(name)) {
                propOut = tags[name];
              } else {
                propOut = {};
              }
              propOut._class = name;
              plainText = innerMatch[2];
            }
          } else if (RE_STYLE_HEADER.test(text)) {
            var innerMatch = text.match(RE_STYLE);
            if (innerMatch != null) {
              var style = innerMatch[1];
              propOut = StyleToProp(style);
              propOut._style = style;
              plainText = innerMatch[2];
            }
          }
          if (plainText == null) {
            plainText = text;
          }
          if (propOut == null) {
            propOut = {};
          }
          var result = GETPROP_RESULT;
          result.plainText = plainText;
          result.prop = propOut;
          return result;
        }
      }, {
        key: "propToContextStyle",
        value: function propToContextStyle(defaultStyle, prop) {
          var result = STYLE_RESULT;
          if (!prop.hasOwnProperty('img')) {
            result.image = null;
            if (prop.hasOwnProperty('family') || prop.hasOwnProperty('fontFamily') || prop.hasOwnProperty('font-family')) {
              var family = prop.hasOwnProperty('family') ? prop.family : prop.hasOwnProperty('fontFamily') ? prop.fontFamily : prop['font-family'];
              result.fontFamily = family;
            } else {
              result.fontFamily = defaultStyle.fontFamily;
            }
            if (prop.hasOwnProperty('size') || prop.hasOwnProperty('fontSize') || prop.hasOwnProperty('font-size')) {
              var size = prop.hasOwnProperty('size') ? prop.size : prop.hasOwnProperty('fontSize') ? prop.fontSize : prop['font-size'];
              if (typeof size === 'number') {
                size = "".concat(size, "px");
              }
              result.fontSize = size;
            } else {
              result.fontSize = defaultStyle.fontSize;
            }
            if (prop.hasOwnProperty('style') || prop.hasOwnProperty('fontStyle') || prop.hasOwnProperty('font-style')) {
              var fontStyle = prop.hasOwnProperty('style') ? prop.style : prop.hasOwnProperty('fontStyle') ? prop.fontStyle : prop['font-style'];
              result.fontStyle = fontStyle;
            } else {
              result.fontStyle = defaultStyle.fontStyle;
            }
            if (prop.hasOwnProperty('color') || prop.hasOwnProperty('font-color')) {
              var color = prop.hasOwnProperty('color') ? prop.color : prop['font-color'];
              result.color = color;
            } else {
              result.color = defaultStyle.color;
            }
            if (prop.hasOwnProperty('stroke')) {
              var stroke = prop.stroke; // {color, thickness}
              result.stroke = stroke.hasOwnProperty('color') ? stroke.color : defaultStyle.stroke;
              result.strokeThickness = stroke.hasOwnProperty('thickness') ? stroke.thickness : defaultStyle.strokeThickness;
            } else {
              result.stroke = defaultStyle.stroke;
              result.strokeThickness = defaultStyle.strokeThickness;
            }
          } else {
            result.image = prop.img;
          }
          if (prop.hasOwnProperty('shadow')) {
            var shadow = prop.shadow; // {color, offsetX, offsetY, blur}
            result.shadowColor = shadow.hasOwnProperty('color') ? shadow.color : defaultStyle.shadowColor;
            result.shadowOffsetX = shadow.hasOwnProperty('offsetX') ? shadow.offsetX : defaultStyle.shadowOffsetX;
            result.shadowOffsetY = shadow.hasOwnProperty('offsetY') ? shadow.offsetY : defaultStyle.shadowOffsetY;
            result.shadowBlur = shadow.hasOwnProperty('blur') ? shadow.blur : defaultStyle.shadowBlur;
            result.shadowStroke = true;
            result.shadowFill = true;
          } else {
            result.shadowColor = defaultStyle.shadowColor;
            result.shadowOffsetX = defaultStyle.shadowOffsetX;
            result.shadowOffsetY = defaultStyle.shadowOffsetY;
            result.shadowBlur = defaultStyle.shadowBlur;
            result.shadowStroke = defaultStyle.shadowStroke;
            result.shadowFill = defaultStyle.shadowFill;
          }
          if (prop.hasOwnProperty('u') || prop.hasOwnProperty('underline')) {
            var u = prop.hasOwnProperty('u') ? prop.u : prop.underline; // {color, thickness, offset}
            result.underlineColor = u.hasOwnProperty('color') ? u.color : defaultStyle.underlineColor;
            result.underlineThickness = u.hasOwnProperty('thickness') ? u.thickness : defaultStyle.underlineThickness;
            result.underlineOffset = u.hasOwnProperty('offset') ? u.offset : defaultStyle.underlineOffset;
          } else {
            result.underlineColor = defaultStyle.underlineColor;
            result.underlineThickness = defaultStyle.underlineThickness;
            result.underlineOffset = defaultStyle.underlineOffset;
          }
          if (prop.hasOwnProperty('s') || prop.hasOwnProperty('strikethrough')) {
            var s = prop.hasOwnProperty('s') ? prop.s : prop.strikethrough; // {color, thickness, offset}
            result.strikethroughColor = s.hasOwnProperty('color') ? s.color : defaultStyle.strikethroughColor;
            result.strikethroughThickness = s.hasOwnProperty('thickness') ? s.thickness : defaultStyle.strikethroughThickness;
            result.strikethroughOffset = s.hasOwnProperty('offset') ? s.offset : defaultStyle.strikethroughOffset;
          } else {
            result.strikethroughColor = defaultStyle.strikethroughColor;
            result.strikethroughThickness = defaultStyle.strikethroughThickness;
            result.strikethroughOffset = defaultStyle.strikethroughOffset;
          }
          return result;
        }
      }, {
        key: "getStrokeThinkness",
        value: function getStrokeThinkness(defaultStyle, prop) {
          var strokeThinkness;
          if (prop.hasOwnProperty('stroke')) {
            var stroke = prop.stroke; // {color, thickness}           
            strokeThinkness = stroke.hasOwnProperty('thickness') ? stroke.thickness : defaultStyle.strokeThickness;
          } else {
            strokeThinkness = defaultStyle.strokeThickness;
          }
          return strokeThinkness;
        }
      }, {
        key: "propToTagText",
        value: function propToTagText(text, prop, prevProp) {
          if (prop.hasOwnProperty('_class')) {
            // class mode
            if (text === '') {
              if (this.isTextTag(prop._class)) {
                return '';
              }
            }
            return "<class='".concat(prop._class, "'>").concat(text, "</class>");
          } else if (prop.hasOwnProperty('_style')) {
            // class mode
            return "<style='".concat(prop._style, "'>").concat(text, "</style>");
          } else {
            return text;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.tags = undefined;
        }
      }, {
        key: "isTextTag",
        value: function isTextTag(tagName) {
          var tag = this.tags[tagName];
          if (tag) {
            return tag.img == null;
          } else {
            // tag not found
            return false;
          }
        }
      }]);
      return Parser;
    }();
    var StyleToProp = function StyleToProp(s) {
      s = s.split(";");
      var result = {},
        prop,
        k,
        v;
      for (var i = 0, slen = s.length; i < slen; i++) {
        prop = s[i].split(":");
        k = prop[0], v = prop[1];
        if (isEmpty(k) || isEmpty(v)) {
          continue;
        }
        switch (k) {
          case 'stroke':
            var params = v.split(' '); // stroke:blue 1px
            var len = params.length;
            v = {};
            if (len >= 1) {
              v.color = params[0];
            }
            if (len >= 2) {
              v.thickness = parseInt(params[1].replace('px', ''));
            }
            break;
          case 'shadow':
            var params = v.split(' '); // shadow:blue 2px 2px 2px
            var len = params.length;
            v = {};
            if (len >= 1) {
              v.color = params[0];
            }
            if (len >= 2) {
              v.offsetX = parseInt(params[1].replace('px', ''));
            }
            if (len >= 3) {
              v.offsetY = parseInt(params[2].replace('px', ''));
            }
            if (len >= 4) {
              v.blur = parseInt(params[3].replace('px', ''));
            }
            break;
          case 'u':
          case 'underline':
          case 's':
          case 'strikethrough':
            // underline:blue 3px -1px
            var params = v.split(' ');
            var len = params.length;
            v = {};
            if (len >= 1) {
              v.color = params[0];
            }
            if (len >= 2) {
              v.thickness = parseInt(params[1].replace('px', ''));
            }
            if (len >= 3) {
              v.offset = parseInt(params[2].replace('px', ''));
            }
            if (k === 'underline') {
              k = 'u';
            } else if (k === 'strikethrough') {
              k = 's';
            }
            break;
          case 'y':
            v = parseFloat(v);
            break;
        }
        result[k] = v;
      }
      return result;
    };
    var isEmpty = function isEmpty(s) {
      // Remove white spaces.
      s = s.replace(RE_SPACE, '');
      return s.length === 0;
    };
    var RE_SPLITTEXT = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g;
    var RE_CLASS_HEADER = /<\s*class=/i;
    var RE_CLASS = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/;
    var RE_STYLE_HEADER = /<\s*style=/i;
    var RE_STYLE = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/;
    var RE_SPACE = /^\s+|\s+$/;
  
    var GetValue$3u = Phaser.Utils.Objects.GetValue;
    var TagText = /*#__PURE__*/function (_Text) {
      _inherits(TagText, _Text);
      function TagText(scene, x, y, text, style) {
        _classCallCheck(this, TagText);
        var tags = GetValue$3u(style, 'tags', undefined);
        var parser = new Parser$1(tags);
        return _callSuper(this, TagText, [scene, x, y, text, style, 'rexTagText', parser]);
      }
      _createClass(TagText, [{
        key: "addTag",
        value: function addTag(name, prop) {
          this.parser.addTag(name, prop);
          return this.updateText(true);
        }
      }, {
        key: "addTags",
        value: function addTags(tags) {
          for (var name in tags) {
            this.parser.addTag(name, tags[name]);
          }
          return this.updateText(true);
        }
      }, {
        key: "getTag",
        value: function getTag(name) {
          return this.parser.getTag(name);
        }
      }, {
        key: "preDestroy",
        value: function preDestroy() {
          _get(_getPrototypeOf(TagText.prototype), "preDestroy", this).call(this);
          this.parser.destroy();
          this.parser = undefined;
        }
      }]);
      return TagText;
    }(Text);
  
    ObjectFactory.register('tagText', function (x, y, text, style) {
      var gameObject = new TagText(this.scene, x, y, text, style);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TagText', TagText);
  
    var GetValue$3t = Phaser.Utils.Objects.GetValue;
    var GetPadding$1 = function GetPadding(padding, key) {
      if (key === undefined) {
        return padding;
      }
      return padding[key];
    };
    var SetPadding$1 = function SetPadding(padding, key, value) {
      if (padding === undefined) {
        padding = {};
      }
      if (key === undefined) {
        key = 0;
      }
      var keyType = _typeof(key);
      if (keyType === 'string') {
        padding[key] = value;
      } else if (keyType === 'number') {
        padding.left = key;
        padding.right = key;
        padding.top = key;
        padding.bottom = key;
      } else {
        padding.left = GetValue$3t(key, 'left', 0);
        padding.right = GetValue$3t(key, 'right', 0);
        padding.top = GetValue$3t(key, 'top', 0);
        padding.bottom = GetValue$3t(key, 'bottom', 0);
      }
      return padding;
    };
  
    var Base$2 = /*#__PURE__*/function () {
      function Base(parent, type) {
        _classCallCheck(this, Base);
        this.setParent(parent);
        this.type = type;
        this.renderable = false;
        this.reset().setActive();
      }
      _createClass(Base, [{
        key: "destroy",
        value: function destroy() {
          this.parent.removeChild(this);
        }
      }, {
        key: "setParent",
        value: function setParent(parent) {
          this.parent = parent;
          return this;
        }
      }, {
        key: "scene",
        get: function get() {
          return this.parent.scene;
        }
      }, {
        key: "canvas",
        get: function get() {
          return this.parent ? this.parent.canvas : null;
        }
      }, {
        key: "context",
        get: function get() {
          return this.parent ? this.parent.context : null;
        }
      }, {
        key: "setDirty",
        value: function setDirty(dirty) {
          if (dirty && this.parent) {
            this.parent.dirty = true;
          }
          return this;
        }
      }, {
        key: "active",
        get: function get() {
          return this._active;
        },
        set: function set(value) {
          this.setDirty(this._active != value);
          this._active = value;
        }
      }, {
        key: "setActive",
        value: function setActive(active) {
          if (active === undefined) {
            active = true;
          }
          this.active = active;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          return this;
        }
  
        // Override
      }, {
        key: "onFree",
        value: function onFree() {
          this.reset().setParent();
        }
  
        // Override
      }, {
        key: "reset",
        value: function reset() {
          return this;
        }
  
        // Override
      }, {
        key: "render",
        value: function render() {}
  
        // Override
      }, {
        key: "contains",
        value: function contains(x, y) {
          return false;
        }
      }]);
      return Base;
    }();
    Object.assign(Base$2.prototype, DataMethods$2);
  
    var RenderMethods = {
      // Override
      renderContent: function renderContent() {},
      // Override
      render: function render() {
        if (!this.willRender) {
          return this;
        }
        var context = this.context;
        context.save();
        context.globalAlpha = this.alpha;
        if (this.toLocalPosition) {
          var x = this.drawX,
            y = this.drawY;
          if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
          }
          context.translate(x, y);
          context.scale(this.scaleX, this.scaleY);
          context.rotate(this.rotation);
        }
        if (this.drawBelowCallback) {
          this.drawBelowCallback(this);
        }
        this.renderContent();
        if (this.drawAboveCallback) {
          this.drawAboveCallback(this);
        }
        context.restore();
        return this;
      }
    };
  
    var RotateAround$8 = Phaser.Math.RotateAround;
    var CanvasPositionToBobPosition = function CanvasPositionToBobPosition(canvasX, canvasY, bob, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        if (globPoint$1 === undefined) {
          globPoint$1 = {};
        }
        out = globPoint$1;
      }
      out.x = (canvasX - bob.drawX) / bob.scaleX;
      out.y = (canvasY - bob.drawY) / bob.scaleY;
      if (bob.rotation !== 0) {
        RotateAround$8(out, 0, 0, -bob.rotation);
      }
      return out;
    };
    var globPoint$1;
  
    var Rectangle$5 = Phaser.Geom.Rectangle;
    var Contains$1 = function Contains(canvasX, canvasY) {
      if (this.width === 0 || this.height === 0) {
        return false;
      }
      var bobPosition = CanvasPositionToBobPosition(canvasX, canvasY, this, true);
      return GetBobBounds(this).contains(bobPosition.x, bobPosition.y);
    };
    var GetBobBounds = function GetBobBounds(bob) {
      if (bobBounds === undefined) {
        bobBounds = new Rectangle$5();
      }
      var x = bob.drawTLX,
        y = bob.drawTLY;
      bobBounds.setTo(x, y, bob.drawTRX - x, bob.drawBLY - y);
      return bobBounds;
    };
    var bobBounds;
  
    var RotateAround$7 = Phaser.Math.RotateAround;
    var BobPositionToCanvasPosition = function BobPositionToCanvasPosition(bob, bobX, bobY, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        if (globPoint === undefined) {
          globPoint = {};
        }
        out = globPoint;
      }
      out.x = bobX;
      out.y = bobY;
      if (bob.rotation !== 0) {
        RotateAround$7(out, 0, 0, bob.rotation);
      }
      out.x = out.x * bob.scaleX + bob.drawX;
      out.y = out.y * bob.scaleY + bob.drawY;
      return out;
    };
    var globPoint;
  
    var TransformMatrix$1 = Phaser.GameObjects.Components.TransformMatrix;
    var GameObjectLocalXYToWorldXY = function GameObjectLocalXYToWorldXY(gameObject, localX, localY, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globOut$2;
      }
      var px = localX - gameObject.width * gameObject.originX;
      var py = localY - gameObject.height * gameObject.originY;
      if (tempMatrix$2 === undefined) {
        tempMatrix$2 = new TransformMatrix$1();
        parentMatrix$1 = new TransformMatrix$1();
      }
      if (gameObject.parentContainer) {
        gameObject.getWorldTransformMatrix(tempMatrix$2, parentMatrix$1);
      } else {
        tempMatrix$2.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY);
      }
      tempMatrix$2.transformPoint(px, py, out);
      return out;
    };
    var tempMatrix$2, parentMatrix$1;
    var globOut$2 = {};
  
    var BobPositionToWorldPosition = function BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out) {
      var localXY = BobPositionToCanvasPosition(bob, bobX, bobY, true);
      var worldXY = GameObjectLocalXYToWorldXY(dynamicText, localXY.x, localXY.y, out);
      return worldXY;
    };
  
    var GetBobWorldPosition = function GetBobWorldPosition(dynamicText, bob, offsetX, offsetY, out) {
      if (typeof offsetX !== 'number') {
        out = offsetX;
        offsetX = 0;
        offsetY = 0;
      }
      var bobX = bob.drawCenterX + offsetX;
      var bobY = bob.drawCenterY + offsetY;
      return BobPositionToWorldPosition(dynamicText, bob, bobX, bobY, out);
    };
  
    var GetWorldPosition = function GetWorldPosition(offsetX, offsetY, out) {
      return GetBobWorldPosition(this.parent, this, offsetX, offsetY, out);
    };
  
    var Methods$i = {
      contains: Contains$1,
      getWorldPosition: GetWorldPosition
    };
    Object.assign(Methods$i, RenderMethods);
  
    var DegToRad$d = Phaser.Math.DegToRad;
    var RadToDeg$8 = Phaser.Math.RadToDeg;
    var GetValue$3s = Phaser.Utils.Objects.GetValue;
    var RenderBase = /*#__PURE__*/function (_Base) {
      _inherits(RenderBase, _Base);
      function RenderBase(parent, type) {
        var _this;
        _classCallCheck(this, RenderBase);
        _this = _callSuper(this, RenderBase, [parent, type]);
        _this.renderable = true;
        _this.scrollFactorX = 1;
        _this.scrollFactorY = 1;
        _this.toLocalPosition = true;
        _this.originX = 0;
        _this.offsetX = 0; // Override
        _this.offsetY = 0; // Override
        return _this;
      }
      _createClass(RenderBase, [{
        key: "visible",
        get: function get() {
          return this._visible;
        },
        set: function set(value) {
          this.setDirty(this._visible != value);
          this._visible = value;
        }
      }, {
        key: "setVisible",
        value: function setVisible(visible) {
          if (visible === undefined) {
            visible = true;
          }
          this.visible = visible;
          return this;
        }
      }, {
        key: "alpha",
        get: function get() {
          return this._alpha;
        },
        set: function set(value) {
          this.setDirty(this._alpha != value);
          this._alpha = value;
        }
      }, {
        key: "setAlpha",
        value: function setAlpha(alpha) {
          this.alpha = alpha;
          return this;
        }
      }, {
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this.setDirty(this._x != value);
          this._x = value;
        }
      }, {
        key: "setX",
        value: function setX(x) {
          this.x = x;
          return this;
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this.setDirty(this._y != value);
          this._y = value;
        }
      }, {
        key: "setY",
        value: function setY(y) {
          this.y = y;
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "setInitialPosition",
        value: function setInitialPosition(x, y) {
          this.x0 = x;
          this.y0 = y;
          return this;
        }
      }, {
        key: "setScrollFactorX",
        value: function setScrollFactorX(x) {
          this.scrollFactorX = x;
          return this;
        }
      }, {
        key: "setScrollFactorY",
        value: function setScrollFactorY(y) {
          this.scrollFactorY = y;
          return this;
        }
      }, {
        key: "setScrollFactor",
        value: function setScrollFactor(x, y) {
          if (y === undefined) {
            y = x;
          }
          this.scrollFactorX = x;
          this.scrollFactorY = y;
          return this;
        }
      }, {
        key: "rotation",
        get: function get() {
          return this._rotation;
        },
        set: function set(value) {
          this.setDirty(this._rotation != value);
          this._rotation = value;
        }
      }, {
        key: "setRotation",
        value: function setRotation(rotation) {
          this.rotation = rotation;
          return this;
        }
      }, {
        key: "angle",
        get: function get() {
          return RadToDeg$8(this._rotation);
        },
        set: function set(value) {
          this.rotation = DegToRad$d(value);
        }
      }, {
        key: "setAngle",
        value: function setAngle(angle) {
          this.angle = angle;
          return this;
        }
      }, {
        key: "scaleX",
        get: function get() {
          return this._scaleX;
        },
        set: function set(value) {
          this.setDirty(this._scaleX !== value);
          this._scaleX = value;
        }
      }, {
        key: "setScaleX",
        value: function setScaleX(scaleX) {
          this.scaleX = scaleX;
          return this;
        }
  
        // Override
      }, {
        key: "width",
        get: function get() {
          return 0;
        }
  
        // Override
        ,
        set: function set(value) {}
      }, {
        key: "setWidth",
        value: function setWidth(width, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.width = width;
          if (keepAspectRatio) {
            this.scaleY = this.scaleX;
          }
          return this;
        }
      }, {
        key: "leftSpace",
        get: function get() {
          return this._leftSpace;
        },
        set: function set(value) {
          this.setDirty(this._leftSpace !== value);
          this._leftSpace = value;
        }
      }, {
        key: "setLeftSpace",
        value: function setLeftSpace(value) {
          this.leftSpace = value;
          return this;
        }
      }, {
        key: "rightSpace",
        get: function get() {
          return this._rightSpace;
        },
        set: function set(value) {
          this.setDirty(this._rightSpace !== value);
          this._rightSpace = value;
        }
      }, {
        key: "setRightSpace",
        value: function setRightSpace(value) {
          this.rightSpace = value;
          return this;
        }
      }, {
        key: "outerWidth",
        get: function get() {
          return this.width + this.leftSpace + this.rightSpace;
        }
      }, {
        key: "scaleY",
        get: function get() {
          return this._scaleY;
        },
        set: function set(value) {
          this.setDirty(this._scaleY !== value);
          this._scaleY = value;
        }
      }, {
        key: "setScaleY",
        value: function setScaleY(scaleY) {
          this.scaleY = scaleY;
          return this;
        }
  
        // Override
      }, {
        key: "height",
        get: function get() {
          return 0;
        }
  
        // Override
        ,
        set: function set(value) {}
      }, {
        key: "setHeight",
        value: function setHeight(height, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.height = height;
          if (keepAspectRatio) {
            this.scaleX = this.scaleY;
          }
          return this;
        }
      }, {
        key: "setScale",
        value: function setScale(scaleX, scaleY) {
          if (scaleY === undefined) {
            scaleY = scaleX;
          }
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          return this;
        }
      }, {
        key: "setOrigin",
        value: function setOrigin(x) {
          this.originX = x;
          return this;
        }
      }, {
        key: "setAlign",
        value: function setAlign(align) {
          this.align = align;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          if (!o) {
            return this;
          }
          if (o.hasOwnProperty('x')) {
            this.setX(o.x);
          }
          if (o.hasOwnProperty('y')) {
            this.setY(o.y);
          }
          if (o.hasOwnProperty('rotation')) {
            this.setRotation(o.rotation);
          } else if (o.hasOwnProperty('angle')) {
            this.setAngle(o.angle);
          }
          if (o.hasOwnProperty('alpha')) {
            this.setAlpha(o.alpha);
          }
  
          // ScaleX, ScaleY
          var width = GetValue$3s(o, 'width', undefined);
          var height = GetValue$3s(o, 'height', undefined);
          var scaleX = GetValue$3s(o, 'scaleX', undefined);
          var scaleY = GetValue$3s(o, 'scaleY', undefined);
          if (width !== undefined) {
            if (height === undefined && scaleY === undefined) {
              this.setWidth(width, true);
            } else {
              this.setWidth(width);
            }
          } else if (scaleX !== undefined) {
            this.setScaleX(scaleX);
          }
          if (height !== undefined) {
            if (width === undefined && scaleX === undefined) {
              this.setHeight(height, true);
            } else {
              this.setHeight(height);
            }
          } else if (scaleY !== undefined) {
            this.setScaleY(scaleY);
          }
          if (o.hasOwnProperty('leftSpace')) {
            this.setLeftSpace(o.leftSpace);
          }
          if (o.hasOwnProperty('rightSpace')) {
            this.setRightSpace(o.rightSpace);
          }
          if (o.hasOwnProperty('align')) {
            this.setAlign(o.align);
          }
          return this;
        }
      }, {
        key: "setDrawBelowCallback",
        value: function setDrawBelowCallback(callback) {
          this.drawBelowCallback = callback;
          return this;
        }
      }, {
        key: "setDrawAboveCallback",
        value: function setDrawAboveCallback(callback) {
          this.drawAboveCallback = callback;
          return this;
        }
      }, {
        key: "reset",
        value: function reset() {
          this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback();
          return this;
        }
  
        // Override
      }, {
        key: "willRender",
        get: function get() {
          return this.visible && this.alpha > 0;
        }
      }, {
        key: "drawX",
        get: function get() {
          var x = this.x + this.leftSpace + this.offsetX - this.originX * this.width;
          return this.parent._textOX * this.scrollFactorX + x;
        }
      }, {
        key: "drawY",
        get: function get() {
          var y = this.y + this.offsetY;
          return this.parent._textOY * this.scrollFactorY + y;
        }
  
        // Override
      }, {
        key: "drawTLX",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawTLY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBLX",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBLY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawTRX",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawTRY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBRX",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBRY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawCenterX",
        get: function get() {
          return (this.drawTRX + this.drawTLX) / 2;
        }
      }, {
        key: "drawCenterY",
        get: function get() {
          return (this.drawBLY + this.drawTLY) / 2;
        }
      }]);
      return RenderBase;
    }(Base$2);
    Object.assign(RenderBase.prototype, Methods$i);
  
    var GetProperty = function GetProperty(name, config, defaultConfig) {
      if (config.hasOwnProperty(name)) {
        return config[name];
      } else {
        return defaultConfig[name];
      }
    };
  
    var GetValue$3r = Phaser.Utils.Objects.GetValue;
    var Background = /*#__PURE__*/function (_RenderBase) {
      _inherits(Background, _RenderBase);
      function Background(parent, config) {
        var _this;
        _classCallCheck(this, Background);
        _this = _callSuper(this, Background, [parent, 'background']);
        _this.setScrollFactor(0);
        _this.setColor(GetValue$3r(config, 'color', null), GetValue$3r(config, 'color2', null), GetValue$3r(config, 'horizontalGradient', true));
        _this.setStroke(GetValue$3r(config, 'stroke', null), GetValue$3r(config, 'strokeThickness', 2));
        _this.setCornerRadius(GetValue$3r(config, 'cornerRadius', 0), GetValue$3r(config, 'cornerIteration', null));
        return _this;
      }
      _createClass(Background, [{
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._color != value);
          this._color = value;
        }
      }, {
        key: "color2",
        get: function get() {
          return this._color2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._color2 != value);
          this._color2 = value;
        }
      }, {
        key: "horizontalGradient",
        get: function get() {
          return this._horizontalGradient;
        },
        set: function set(value) {
          this.setDirty(this._horizontalGradient != value);
          this._horizontalGradient = value;
        }
      }, {
        key: "setColor",
        value: function setColor(color, color2, isHorizontalGradient) {
          if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
          }
          this.color = color;
          this.color2 = color2;
          this.horizontalGradient = isHorizontalGradient;
          return this;
        }
      }, {
        key: "stroke",
        get: function get() {
          return this._stroke;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._stroke != value);
          this._stroke = value;
        }
      }, {
        key: "strokeThickness",
        get: function get() {
          return this._strokeThickness;
        },
        set: function set(value) {
          this.setDirty(this._strokeThickness != value);
          this._strokeThickness = value;
        }
      }, {
        key: "setStroke",
        value: function setStroke(color, lineWidth) {
          if (color != null) {
            if (lineWidth === undefined) {
              lineWidth = 2;
            }
          }
          this.stroke = color;
          this.strokeThickness = lineWidth;
          return this;
        }
      }, {
        key: "cornerRadius",
        get: function get() {
          return this._cornerRadius;
        },
        set: function set(value) {
          this.setDirty(this._cornerRadius != value);
          this._cornerRadius = value;
        }
      }, {
        key: "cornerIteration",
        get: function get() {
          return this._cornerIteration;
        },
        set: function set(value) {
          this.setDirty(this._cornerIteration != value);
          this._cornerIteration = value;
        }
      }, {
        key: "modifyStyle",
        value: function modifyStyle(o) {
          if (o.hasOwnProperty('color')) {
            this.setColor(o.color, GetProperty('color2', o, this), GetProperty('horizontalGradient', o, this));
          }
          if (o.hasOwnProperty('stroke')) {
            this.setStroke(o.stroke, GetProperty('strokeThickness', o, this));
          }
          if (o.hasOwnProperty('cornerRadius')) {
            this.setCornerRadius(o.cornerRadius, GetProperty('cornerIteration', o, this));
          }
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          _get(_getPrototypeOf(Background.prototype), "modifyPorperties", this).call(this, o);
          this.modifyStyle(o);
          return this;
        }
      }, {
        key: "setCornerRadius",
        value: function setCornerRadius(radius, iteration) {
          this.cornerRadius = radius;
          this.cornerIteration = iteration;
          return this;
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          DrawRoundRectangleBackground(this.parent, this.color, this.stroke, this.strokeThickness, this.cornerRadius, this.color2, this.horizontalGradient, this.cornerIteration);
        }
      }]);
      return Background;
    }(RenderBase);
  
    var GetValue$3q = Phaser.Utils.Objects.GetValue;
    var InnerBounds = /*#__PURE__*/function (_RenderBase) {
      _inherits(InnerBounds, _RenderBase);
      function InnerBounds(parent, config) {
        var _this;
        _classCallCheck(this, InnerBounds);
        _this = _callSuper(this, InnerBounds, [parent, 'innerbounds']);
        _this.setScrollFactor(0);
        _this.setColor(GetValue$3q(config, 'color', null), GetValue$3q(config, 'color2', null), GetValue$3q(config, 'horizontalGradient', true));
        _this.setStroke(GetValue$3q(config, 'stroke', null), GetValue$3q(config, 'strokeThickness', 2));
        return _this;
      }
      _createClass(InnerBounds, [{
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._color != value);
          this._color = value;
        }
      }, {
        key: "color2",
        get: function get() {
          return this._color2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._color2 != value);
          this._color2 = value;
        }
      }, {
        key: "horizontalGradient",
        get: function get() {
          return this._horizontalGradient;
        },
        set: function set(value) {
          this.setDirty(this._horizontalGradient != value);
          this._horizontalGradient = value;
        }
      }, {
        key: "setColor",
        value: function setColor(color, color2, isHorizontalGradient) {
          if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
          }
          this.color = color;
          this.color2 = color2;
          this.horizontalGradient = isHorizontalGradient;
          return this;
        }
      }, {
        key: "stroke",
        get: function get() {
          return this._stroke;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.setDirty(this._stroke != value);
          this._stroke = value;
        }
      }, {
        key: "strokeThickness",
        get: function get() {
          return this._strokeThickness;
        },
        set: function set(value) {
          this.setDirty(this._strokeThickness != value);
          this._strokeThickness = value;
        }
      }, {
        key: "setStroke",
        value: function setStroke(color, lineWidth) {
          if (color != null) {
            if (lineWidth === undefined) {
              lineWidth = 2;
            }
          }
          this.stroke = color;
          this.strokeThickness = lineWidth;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          _get(_getPrototypeOf(InnerBounds.prototype), "modifyPorperties", this).call(this, o);
          if (o.hasOwnProperty('color')) {
            this.setColor(o.color, GetValue$3q(o, 'color2', null), GetValue$3q(o, 'horizontalGradient', true));
          }
          if (o.hasOwnProperty('stroke')) {
            this.setStroke(o.stroke, GetValue$3q(o, 'strokeThickness', 2));
          }
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          var padding = this.parent.padding;
          var x = padding.left,
            y = padding.top,
            width = this.parent.width - padding.left - padding.right,
            height = this.parent.height - padding.top - padding.bottom;
          var context = this.context;
          if (this.color != null) {
            var fillStyle;
            if (this.color2 != null) {
              var grd;
              if (this.horizontalGradient) {
                grd = context.createLinearGradient(0, 0, width, 0);
              } else {
                grd = context.createLinearGradient(0, 0, 0, height);
              }
              grd.addColorStop(0, this.color);
              grd.addColorStop(1, this.color2);
              fillStyle = grd;
            } else {
              fillStyle = this.color;
            }
            context.fillStyle = fillStyle;
            context.fillRect(x, y, width, height);
          }
          if (this.stroke != null && this.strokeThickness > 0) {
            context.strokeStyle = this.stroke;
            context.lineWidth = this.strokeThickness;
            context.strokeRect(x, y, width, height);
          }
        }
      }]);
      return InnerBounds;
    }(RenderBase);
  
    var GetValue$3p = Phaser.Utils.Objects.GetValue;
    var TextStyle = /*#__PURE__*/function () {
      function TextStyle(parent, config) {
        _classCallCheck(this, TextStyle);
        this.parent = parent;
        this.set(config);
      }
      _createClass(TextStyle, [{
        key: "toJSON",
        value: function toJSON() {
          return {
            bold: this.bold,
            italic: this.italic,
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            color: this.color,
            stroke: this.stroke,
            strokeThickness: this.strokeThickness,
            shaodwColor: this.shadowColor,
            shadowBlur: this.shadowBlur,
            shadowOffsetX: this.shadowOffsetX,
            shadowOffsetY: this.shadowOffsetY,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            leftSpace: this.leftSpace,
            rightSpace: this.rightSpace,
            backgroundHeight: this.backgroundHeight,
            backgroundBottomY: this.backgroundBottomY,
            align: this.align
          };
        }
      }, {
        key: "set",
        value: function set(o) {
          this.setBold(GetValue$3p(o, 'bold', false));
          this.setItalic(GetValue$3p(o, 'italic', false));
          this.setFontSize(GetValue$3p(o, 'fontSize', '16px'));
          this.setFontFamily(GetValue$3p(o, 'fontFamily', 'Courier'));
          this.setColor(GetValue$3p(o, 'color', '#fff'));
          this.setStrokeStyle(GetValue$3p(o, 'stroke', null), GetValue$3p(o, 'strokeThickness', 0));
          this.setShadow(GetValue$3p(o, 'shadowColor', null), GetValue$3p(o, 'shadowOffsetX', 0), GetValue$3p(o, 'shadowOffsetY', 0), GetValue$3p(o, 'shadowBlur', 0));
          this.setOffset(GetValue$3p(o, 'offsetX', 0), GetValue$3p(o, 'offsetY', 0));
          this.setSpace(GetValue$3p(o, 'leftSpace', 0), GetValue$3p(o, 'rightSpace', 0));
          this.setAlign(GetValue$3p(o, 'align', undefined));
          this.setBackgroundColor(GetValue$3p(o, 'backgroundColor', null));
          this.setBackgroundHeight(GetValue$3p(o, 'backgroundHeight', undefined));
          this.setBackgroundBottomY(GetValue$3p(o, 'backgroundBottomY', undefined));
          return this;
        }
      }, {
        key: "modify",
        value: function modify(o) {
          if (o.hasOwnProperty('bold')) {
            this.setBold(o.bold);
          }
          if (o.hasOwnProperty('italic')) {
            this.setItalic(o.italic);
          }
          if (o.hasOwnProperty('fontSize')) {
            this.setFontSize(o.fontSize);
          }
          if (o.hasOwnProperty('fontFamily')) {
            this.setFontFamily(o.fontFamily);
          }
          if (o.hasOwnProperty('color')) {
            this.setColor(o.color);
          }
          if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
            this.setStrokeStyle(GetProperty('stroke', o, this), GetProperty('strokeThickness', o, this));
          }
          if (o.hasOwnProperty('shadowColor')) {
            this.setShadowColor(o.shadowColor);
          }
          if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
            this.setShadowOffset(GetProperty('shadowOffsetX', o, this), GetProperty('shadowOffsetY', o, this));
          }
          if (o.hasOwnProperty('shadowBlur')) {
            this.setShadowBlur(o.shaodwBlur);
          }
          if (o.hasOwnProperty('offsetX')) {
            this.setOffsetX(o.offsetX);
          }
          if (o.hasOwnProperty('offsetY')) {
            this.setOffsetY(o.offsetY);
          }
          if (o.hasOwnProperty('leftSpace')) {
            this.setLeftSpace(o.leftSpace);
          }
          if (o.hasOwnProperty('rightSpace')) {
            this.setRightSpace(o.rightSpace);
          }
          if (o.hasOwnProperty('align')) {
            this.setAlign(o.align);
          }
          if (o.hasOwnProperty('backgroundColor')) {
            this.setBackgroundColor(o.backgroundColor);
          }
          if (o.hasOwnProperty('backgroundHeight')) {
            this.setBackgroundHeight(o.backgroundHeight);
          }
          if (o.hasOwnProperty('backgroundBottomY')) {
            this.setBackgroundBottomY(o.backgroundBottomY);
          }
          return this;
        }
      }, {
        key: "setUpdateTextFlag",
        value: function setUpdateTextFlag() {
          if (this.parent) {
            this.parent.updateTextFlag = true;
          }
          return this;
        }
      }, {
        key: "clone",
        value: function clone() {
          return new TextStyle(null, this.toJSON());
        }
      }, {
        key: "copyFrom",
        value: function copyFrom(sourceTextStyle) {
          this.set(sourceTextStyle.toJSON());
          return this;
        }
      }, {
        key: "copyTo",
        value: function copyTo(targetTextStyle) {
          targetTextStyle.set(this.toJSON());
          return this;
        }
      }, {
        key: "setBold",
        value: function setBold(value) {
          if (value === undefined) {
            value = true;
          }
          this.bold = value;
          this.setUpdateTextFlag();
          return this;
        }
      }, {
        key: "setItalic",
        value: function setItalic(value) {
          if (value === undefined) {
            value = true;
          }
          this.italic = value;
          this.setUpdateTextFlag();
          return this;
        }
      }, {
        key: "fontStyle",
        get: function get() {
          if (this.bold && this.italic) {
            return 'bold italic';
          } else if (this.bold) {
            return 'bold';
          } else if (this.italic) {
            return 'italic';
          } else {
            return '';
          }
        }
      }, {
        key: "setFontSize",
        value: function setFontSize(fontSize) {
          if (typeof fontSize === 'number') {
            fontSize = "".concat(fontSize, "px");
          }
          this.fontSize = fontSize;
          this.setUpdateTextFlag();
          return this;
        }
      }, {
        key: "setFontFamily",
        value: function setFontFamily(fontFamily) {
          this.fontFamily = fontFamily;
          this.setUpdateTextFlag();
          return this;
        }
      }, {
        key: "font",
        get: function get() {
          return "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily);
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = GetStyle(color);
          return this;
        }
      }, {
        key: "hasFill",
        get: function get() {
          return this.color != null;
        }
      }, {
        key: "setStrokeStyle",
        value: function setStrokeStyle(stroke, strokeThickness) {
          this.stroke = GetStyle(stroke);
          if (strokeThickness !== undefined) {
            this.strokeThickness = strokeThickness;
          }
          return this;
        }
      }, {
        key: "setStrokeThickness",
        value: function setStrokeThickness(strokeThickness) {
          this.strokeThickness = strokeThickness;
          return this;
        }
      }, {
        key: "hasStroke",
        get: function get() {
          return this.stroke != null && this.strokeThickness > 0;
        }
      }, {
        key: "setShadowColor",
        value: function setShadowColor(color) {
          this.shadowColor = GetStyle(color);
          return this;
        }
      }, {
        key: "setShadowOffset",
        value: function setShadowOffset(offsetX, offsetY) {
          if (offsetX === undefined) {
            offsetX = 0;
          }
          if (offsetY === undefined) {
            offsetY = 0;
          }
          this.shadowOffsetX = offsetX;
          this.shadowOffsetY = offsetY;
          return this;
        }
      }, {
        key: "setShadowBlur",
        value: function setShadowBlur(blur) {
          if (blur === undefined) {
            blur = 0;
          }
          this.shaodwBlur = blur;
          return this;
        }
      }, {
        key: "setShadow",
        value: function setShadow(color, offsetX, offsetY, blur) {
          this.setShadowColor(color).setShadowOffset(offsetX, offsetY).setShadowBlur(blur);
          return this;
        }
      }, {
        key: "setBackgroundColor",
        value: function setBackgroundColor(color) {
          this.backgroundColor = GetStyle(color);
          return this;
        }
      }, {
        key: "hasBackgroundColor",
        get: function get() {
          return this.backgroundColor != null;
        }
      }, {
        key: "setBackgroundHeight",
        value: function setBackgroundHeight(height) {
          this.backgroundHeight = height;
          return this;
        }
      }, {
        key: "setBackgroundBottomY",
        value: function setBackgroundBottomY(y) {
          this.backgroundBottomY = y;
          return this;
        }
      }, {
        key: "setOffsetX",
        value: function setOffsetX(offsetX) {
          if (offsetX === undefined) {
            offsetX = 0;
          }
          this.offsetX = offsetX;
          return this;
        }
      }, {
        key: "setOffsetY",
        value: function setOffsetY(offsetY) {
          if (offsetY === undefined) {
            offsetY = 0;
          }
          this.offsetY = offsetY;
          return this;
        }
      }, {
        key: "setOffset",
        value: function setOffset(offsetX, offsetY) {
          this.setOffsetX(offsetX).setOffsetY(offsetY);
          return this;
        }
      }, {
        key: "setLeftSpace",
        value: function setLeftSpace(space) {
          if (space === undefined) {
            space = 0;
          }
          this.leftSpace = space;
          return this;
        }
      }, {
        key: "setRightSpace",
        value: function setRightSpace(space) {
          if (space === undefined) {
            space = 0;
          }
          this.rightSpace = space;
          return this;
        }
      }, {
        key: "setSpace",
        value: function setSpace(leftSpace, rightSpace) {
          this.setLeftSpace(leftSpace).setRightSpace(rightSpace);
          return this;
        }
      }, {
        key: "setAlign",
        value: function setAlign(align) {
          this.align = align;
          return this;
        }
      }, {
        key: "syncFont",
        value: function syncFont(context) {
          context.font = this.font;
          return this;
        }
      }, {
        key: "syncStyle",
        value: function syncStyle(context) {
          context.textBaseline = 'alphabetic';
          var hasFill = this.hasFill;
          var hasStroke = this.hasStroke;
          context.fillStyle = hasFill ? this.color : '#000';
          context.strokeStyle = hasStroke ? this.stroke : '#000';
          context.lineWidth = hasStroke ? this.strokeThickness : 0;
          context.lineCap = 'round';
          context.lineJoin = 'round';
          return this;
        }
      }, {
        key: "syncShadow",
        value: function syncShadow(context) {
          if (context.shadowColor != null) {
            context.shadowColor = this.shadowColor;
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowBlur = this.shadowBlur;
          } else {
            context.shadowColor = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowBlur = 0;
          }
        }
      }, {
        key: "getTextMetrics",
        value: function getTextMetrics(context, text) {
          this.syncFont(context).syncStyle(context);
          return context.measureText(text);
        }
      }]);
      return TextStyle;
    }();
  
    var SetFixedSize = function SetFixedSize(width, height) {
      if (width === undefined) {
        width = 0;
      }
      if (height === undefined) {
        height = 0;
      }
      if (this.fixedWidth === width && this.fixedHeight === height) {
        return this;
      }
      this.fixedWidth = width;
      this.fixedHeight = height;
      this.dirty = true; // -> this.updateTexture();
  
      this.setCanvasSize(width > 0 ? width : this.width, height > 0 ? height : this.height);
      return this;
    };
  
    var SetPadding = function SetPadding(key, value) {
      var padding = this.padding;
      var paddingLeft = padding.left,
        paddingRight = padding.right,
        paddingTop = padding.top,
        paddingBottom = padding.bottom;
      SetPadding$1(padding, key, value);
      this.dirty = this.dirty || paddingLeft != padding.left || paddingRight != padding.right || paddingTop != padding.top || paddingBottom != padding.bottom;
      return this;
    };
  
    var GetPadding = function GetPadding(key) {
      return GetPadding$1(this.padding, key);
    };
  
    var ModifyTextStyle = function ModifyTextStyle(style) {
      this.textStyle.modify(style);
      return this;
    };
  
    var ModifyDefaultTextStyle = function ModifyDefaultTextStyle(style) {
      this.defaultTextStyle.modify(style);
      return this;
    };
  
    var ResetTextStyle = function ResetTextStyle() {
      this.textStyle.copyFrom(this.defaultTextStyle);
      return this;
    };
  
    var SetTestString = function SetTestString(testString) {
      this.testString = testString;
      return this;
    };
  
    var RemoveItem$d = Phaser.Utils.Array.Remove;
    var RemoveChild$2 = function RemoveChild(child) {
      this.poolManager.free(child);
      RemoveItem$d(this.children, child);
      this.lastAppendedChildren.length = 0;
      this.lastOverChild = null;
      this.dirty = true;
      return this;
    };
  
    var RemoveChildren = function RemoveChildren() {
      this.poolManager.freeMultiple(this.children);
      this.children.length = 0;
      this.lastAppendedChildren.length = 0;
      this.lastOverChild = null;
      this.dirty = true;
      return this;
    };
  
    var RemoveItem$c = Phaser.Utils.Array.Remove;
    var PopChild = function PopChild(child) {
      RemoveItem$c(this.children, child);
      this.lastAppendedChildren.length = 0;
      this.lastOverChild = null;
      this.dirty = true;
      return this;
    };
  
    var ClearContent = function ClearContent() {
      this.setText();
      return this;
    };
  
    // const RemoveItem = Phaser.Utils.Array.Remove;
  
    var AddChild$3 = function AddChild(child, index) {
      var areChildren = Array.isArray(child);
  
      // Remove existed child(s)
      // RemoveItem(this.children, child);
  
      if (index === undefined || index === this.children.length) {
        if (areChildren) {
          var _this$children;
          (_this$children = this.children).push.apply(_this$children, _toConsumableArray(child));
        } else {
          this.children.push(child);
        }
      } else {
        if (areChildren) {
          var _this$children2;
          (_this$children2 = this.children).splice.apply(_this$children2, [index, 0].concat(_toConsumableArray(child)));
        } else {
          this.children.splice(index, 0, child);
        }
      }
      this.lastAppendedChildren.length = 0;
      if (areChildren) {
        var _this$lastAppendedChi;
        (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(child));
      } else {
        this.lastAppendedChildren.push(child);
      }
      return this;
    };
  
    var CharTypeName = 'text';
    var ImageTypeName = 'image';
    var DrawerTypeName = 'drawer';
    var SpaceTypeName = 'space';
    var CmdTypeName = 'command';
    var IsNewLineChar = function IsNewLineChar(bob) {
      return bob.type === CharTypeName && bob.text === '\n';
    };
    var IsPageBreakChar = function IsPageBreakChar(bob) {
      return bob.type === CharTypeName && bob.text === '\f';
    };
    var IsSpaceChar = function IsSpaceChar(bob) {
      return bob.type === CharTypeName && bob.text === ' ';
    };
    var IsChar = function IsChar(bob) {
      return bob.type === CharTypeName;
    };
    var IsCommand = function IsCommand(bob) {
      return bob.type === CmdTypeName;
    };
  
    var CharData = /*#__PURE__*/function (_RenderBase) {
      _inherits(CharData, _RenderBase);
      function CharData(parent, text, style) {
        var _this;
        _classCallCheck(this, CharData);
        _this = _callSuper(this, CharData, [parent, CharTypeName]);
        _this.updateTextFlag = false;
        _this.style = new TextStyle(_assertThisInitialized(_this), style);
        _this.setText(text);
        return _this;
      }
      _createClass(CharData, [{
        key: "autoRound",
        get: function get() {
          return this.parent.autoRound;
        }
      }, {
        key: "offsetX",
        get: function get() {
          return this.style.offsetX;
        },
        set: function set(value) {
          if (this.style) {
            this.style.offsetX = value;
          }
        }
      }, {
        key: "offsetY",
        get: function get() {
          return this.style.offsetY;
        },
        set: function set(value) {
          if (this.style) {
            this.style.offsetY = value;
          }
        }
      }, {
        key: "leftSpace",
        get: function get() {
          return this.style.leftSpace * this.scaleX;
        },
        set: function set(value) {
          if (this.style) {
            this.style.leftSpace = value;
          }
          _set(_getPrototypeOf(CharData.prototype), "leftSpace", value, this, true);
        }
      }, {
        key: "rightSpace",
        get: function get() {
          return this.style.rightSpace * this.scaleX;
        },
        set: function set(value) {
          if (this.style) {
            this.style.rightSpace = value;
          }
          _set(_getPrototypeOf(CharData.prototype), "rightSpace", value, this, true);
        }
      }, {
        key: "align",
        get: function get() {
          return this.style.align;
        },
        set: function set(value) {
          if (this.style) {
            this.style.align = value;
          }
        }
      }, {
        key: "modifyStyle",
        value: function modifyStyle(style) {
          this.setDirty(true);
          this.style.modify(style);
          if (this.updateTextFlag) {
            this.updateTextSize();
          }
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          if (!o) {
            return this;
          }
          this.modifyStyle(o);
          _get(_getPrototypeOf(CharData.prototype), "modifyPorperties", this).call(this, o);
          return this;
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this.setDirty(this.text != text);
          this.text = text;
          this.updateTextSize();
          return this;
        }
      }, {
        key: "updateTextSize",
        value: function updateTextSize() {
          var text = this.text;
          // Is new-line, page-break, or empty character
          if (text === '\n' || text === '\f' || text === '') {
            this.clearTextSize();
          } else {
            var metrics = this.style.getTextMetrics(this.context, this.text);
            this.textWidth = metrics.width;
            var ascent, descent;
            if ('actualBoundingBoxAscent' in metrics) {
              ascent = metrics.actualBoundingBoxAscent;
              descent = metrics.actualBoundingBoxDescent;
            } else {
              ascent = 0;
              descent = 0;
            }
            this.textHeight = ascent + descent;
            this.ascent = ascent;
            this.descent = descent;
          }
          this.updateTextFlag = false;
          return this;
        }
      }, {
        key: "clearTextSize",
        value: function clearTextSize() {
          this.textWidth = 0;
          this.textHeight = 0;
          this.ascent = 0;
          this.descent = 0;
          return this;
        }
      }, {
        key: "copyTextSize",
        value: function copyTextSize(child) {
          this.textWidth = child.textWidth;
          this.textHeight = child.textHeight;
          this.ascent = child.ascent;
          this.descent = child.descent;
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this.textWidth * this.scaleX;
        },
        set: function set(value) {
          if (this.textWidth > 0) {
            this.scaleX = value / this.textWidth;
          } else {
            this.scaleX = 1;
          }
        }
      }, {
        key: "height",
        get: function get() {
          return this.textHeight * this.scaleY;
        },
        set: function set(value) {
          if (this.textHeight > 0) {
            this.scaleY = value / this.textHeight;
          } else {
            this.scaleY = 1;
          }
        }
      }, {
        key: "willRender",
        get: function get() {
          if (this.textWidth === 0) {
            return false;
          }
          return _get(_getPrototypeOf(CharData.prototype), "willRender", this);
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          var context = this.context;
          var textStyle = this.style;
          if (textStyle.hasBackgroundColor) {
            context.fillStyle = textStyle.backgroundColor;
            var x = this.drawTLX;
            var width = this.drawTRX - x;
            var bottomY = textStyle.backgroundBottomY;
            if (bottomY == null) {
              bottomY = this.drawBLY;
            }
            var height = textStyle.backgroundHeight;
            if (height == null) {
              height = bottomY - this.drawTLY;
            }
            var y = bottomY - height;
            context.fillRect(x, y, width, height);
          }
          var hasFill = textStyle.hasFill,
            hasStroke = textStyle.hasStroke;
          if (!hasFill && !hasStroke) {
            return;
          }
          textStyle.syncFont(context).syncStyle(context);
          // textBaseline = 'alphabetic'
  
          if (hasStroke) {
            textStyle.syncShadow(context);
            context.strokeText(this.text, 0, 0);
          }
          if (hasFill) {
            textStyle.syncShadow(context);
            context.fillText(this.text, 0, 0);
          }
        }
      }, {
        key: "drawTLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawTLY",
        get: function get() {
          return -this.ascent;
        }
      }, {
        key: "drawBLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawBLY",
        get: function get() {
          return this.descent;
        }
      }, {
        key: "drawTRX",
        get: function get() {
          return this.textWidth + this.rightSpace;
        }
      }, {
        key: "drawTRY",
        get: function get() {
          return -this.ascent;
        }
      }, {
        key: "drawBRX",
        get: function get() {
          return this.textWidth + this.rightSpace;
        }
      }, {
        key: "drawBRY",
        get: function get() {
          return this.descent;
        }
      }]);
      return CharData;
    }(RenderBase);
  
    var CreateCharChild = function CreateCharChild(text, style) {
      if (style) {
        this.textStyle.modify(style);
      }
      var child = this.poolManager.allocate(CharTypeName);
      if (child === null) {
        child = new CharData(this,
        // parent
        text,
        // text
        this.textStyle) // style
        ;
      } else {
        child.setParent(this).setActive().modifyStyle(this.textStyle).setText(text);
      }
      return child;
    };
  
    var CreateCharChildren = function CreateCharChildren(text, style) {
      if (style) {
        this.textStyle.modify(style);
      }
      var children = [];
      for (var i = 0, cnt = text.length; i < cnt; i++) {
        var _char = text.charAt(i);
        var child = this.poolManager.allocate(CharTypeName);
        if (child === null) {
          child = new CharData(this,
          // parent
          _char,
          // text
          this.textStyle) // style
          ;
        } else {
          child.setParent(this).setActive().modifyStyle(this.textStyle).setText(_char);
        }
        // child.modifyPorperties(properties);  // Warning: Will modify text-style twice
  
        children.push(child);
      }
      return children;
    };
  
    var AppendText$1 = function AppendText(text, style) {
      var children = this.createCharChildren(text, style);
      this.addChild(children);
      return this;
    };
  
    var SetText$2 = function SetText(text, style) {
      if (text === undefined) {
        text = '';
      }
      this.removeChildren();
      AppendText$1.call(this, text, style); // this.appendText might be override
  
      this.dirty = true;
      return this;
    };
  
    var InsertText = function InsertText(index, text, style) {
      var children = this.createCharChildren(text, style);
      index = this.getCharChildIndex(index, true);
      this.addChild(children, index);
      return this;
    };
  
    var RemoveText = function RemoveText(index, length) {
      if (length === undefined) {
        length = 1;
      }
      for (var i = 0; i < length; i++) {
        var childIndex = this.getCharChildIndex(index, true);
        if (childIndex === undefined) {
          break;
        }
        this.removeChild(this.children[childIndex]);
      }
      return this;
    };
  
    var GetText = function GetText(activeOnly) {
      var text = '';
      this.forEachCharChild(function (child) {
        text += child.text;
      }, undefined, activeOnly);
      return text;
    };
  
    Phaser.Display.Canvas.CanvasPool;
    var ImageData = /*#__PURE__*/function (_RenderBase) {
      _inherits(ImageData, _RenderBase);
      function ImageData(parent, key, frame) {
        var _this;
        _classCallCheck(this, ImageData);
        _this = _callSuper(this, ImageData, [parent, ImageTypeName]);
        _this.setTexture(key, frame);
        _this.color = undefined;
        return _this;
      }
      _createClass(ImageData, [{
        key: "frameWidth",
        get: function get() {
          return this.frameObj ? this.frameObj.cutWidth : 0;
        }
      }, {
        key: "frameHeight",
        get: function get() {
          return this.frameObj ? this.frameObj.cutHeight : 0;
        }
      }, {
        key: "offsetY",
        get: function get() {
          return -this.height;
        },
        set: function set(value) {}
      }, {
        key: "key",
        get: function get() {
          return this._key;
        },
        set: function set(value) {
          this.setDirty(this._key != value);
          this._key = value;
        }
      }, {
        key: "frame",
        get: function get() {
          return this._frame;
        },
        set: function set(value) {
          this.setDirty(this._frame != value);
          this._frame = value;
        }
      }, {
        key: "setTexture",
        value: function setTexture(key, frame) {
          this.key = key;
          this.frame = frame;
          this.frameObj = this.scene.sys.textures.getFrame(key, frame);
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this.frameWidth * this.scaleX;
        },
        set: function set(value) {
          this.setDirty(this.width !== value);
          this.scaleX = value / this.frameWidth;
        }
      }, {
        key: "height",
        get: function get() {
          return this.frameHeight * this.scaleY;
        },
        set: function set(value) {
          this.setDirty(this.height !== value);
          this.scaleY = value / this.frameHeight;
        }
      }, {
        key: "setHeight",
        value: function setHeight(height, keepAspectRatio) {
          if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
          }
          this.height = height;
          if (keepAspectRatio) {
            this.scaleX = this.scaleY;
          }
          return this;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = color;
          return this;
        }
      }, {
        key: "modifyPorperties",
        value: function modifyPorperties(o) {
          if (o.hasOwnProperty('color')) {
            this.setColor(o.color);
          }
          _get(_getPrototypeOf(ImageData.prototype), "modifyPorperties", this).call(this, o);
          return this;
        }
      }, {
        key: "renderContent",
        value: function renderContent() {
          DrawFrameToCanvas(this.frameObj, this.canvas, 0, 0, this.frameWidth, this.frameHeight, this.color, false);
        }
      }, {
        key: "drawTLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawTLY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawBLY",
        get: function get() {
          return this.frameHeight;
        }
      }, {
        key: "drawTRX",
        get: function get() {
          return this.frameWidth + this.rightSpace;
        }
      }, {
        key: "drawTRY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBRX",
        get: function get() {
          return this.frameWidth + this.rightSpace;
        }
      }, {
        key: "drawBRY",
        get: function get() {
          return this.frameHeight;
        }
      }]);
      return ImageData;
    }(RenderBase);
  
    var CreateImageChild = function CreateImageChild(key, frame, properties) {
      var child = this.poolManager.allocate(ImageTypeName);
      if (child === null) {
        child = new ImageData(this,
        // parent
        key, frame);
      } else {
        child.setParent(this).setActive().setTexture(key, frame);
      }
      child.modifyPorperties(properties);
      return child;
    };
  
    var AppendImage = function AppendImage(key, frame, properties) {
      var child = this.createImageChild(key, frame, properties);
      this.addChild(child);
      return this;
    };
  
    var Drawer = /*#__PURE__*/function (_RenderBase) {
      _inherits(Drawer, _RenderBase);
      function Drawer(parent, renderCallback, width, height) {
        var _this;
        _classCallCheck(this, Drawer);
        _this = _callSuper(this, Drawer, [parent, DrawerTypeName]);
        _this.setRenderCallback(renderCallback);
        _this.setDrawerSize(width, height);
        return _this;
      }
      _createClass(Drawer, [{
        key: "setRenderCallback",
        value: function setRenderCallback(callback) {
          if (callback) {
            this.renderContent = callback.bind(this);
          } else {
            delete this.renderContent;
          }
          return this;
        }
      }, {
        key: "setDrawerSize",
        value: function setDrawerSize(width, height) {
          // Whole canvas
          if (width === true) {
            this.toLocalPosition = false;
            width = undefined;
            height = undefined;
          } else {
            this.toLocalPosition = true;
          }
          if (width === undefined) {
            width = 0;
          }
          if (height === undefined) {
            height = width;
          }
          this.drawerWidth = width;
          this.drawerHeight = height;
          return this;
        }
      }, {
        key: "onFree",
        value: function onFree() {
          _get(_getPrototypeOf(Drawer.prototype), "onFree", this).call(this);
          this.setRenderCallback();
        }
      }, {
        key: "width",
        get: function get() {
          return this.drawerWidth * this.scaleX;
        },
        set: function set(value) {
          this.setDirty(this.width !== value);
          this.scaleX = this.drawerWidth > 0 ? value / this.drawerWidth : 1;
        }
      }, {
        key: "height",
        get: function get() {
          return this.drawerHeight * this.scaleY;
        },
        set: function set(value) {
          this.setDirty(this.height !== value);
          this.scaleY = this.drawerHeight > 0 ? value / this.drawerHeight : 1;
        }
      }, {
        key: "offsetY",
        get: function get() {
          return -this.height;
        },
        set: function set(value) {}
      }, {
        key: "drawTLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawTLY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBLX",
        get: function get() {
          return -this.leftSpace;
        }
      }, {
        key: "drawBLY",
        get: function get() {
          return this.drawerHeight;
        }
      }, {
        key: "drawTRX",
        get: function get() {
          return this.drawerWidth + this.rightSpace;
        }
      }, {
        key: "drawTRY",
        get: function get() {
          return 0;
        }
      }, {
        key: "drawBRX",
        get: function get() {
          return this.drawerWidth + this.rightSpace;
        }
      }, {
        key: "drawBRY",
        get: function get() {
          return this.drawerHeight;
        }
      }]);
      return Drawer;
    }(RenderBase);
  
    var CreateDrawerChild = function CreateDrawerChild(renderCallback, width, height) {
      var child = this.poolManager.allocate(DrawerTypeName);
      if (child === null) {
        child = new Drawer(this,
        // parent
        renderCallback, width, height);
      } else {
        child.setParent(this).setActive().setRenderCallback(renderCallback).setDrawerSize(width, height);
      }
      return child;
    };
  
    var AppendDrawer = function AppendDrawer(renderCallback, width, height) {
      var child = this.createDrawerChild(renderCallback, width, height);
      this.addChild(child);
      return this;
    };
  
    var Space$1 = /*#__PURE__*/function (_RenderBase) {
      _inherits(Space, _RenderBase);
      function Space(parent, width) {
        var _this;
        _classCallCheck(this, Space);
        _this = _callSuper(this, Space, [parent, SpaceTypeName]);
        _this.setSpaceWidth(width);
        return _this;
      }
      _createClass(Space, [{
        key: "width",
        get: function get() {
          return this.spaceWidth * this.scaleX;
        },
        set: function set(value) {
          if (this.spaceWidth > 0) {
            this.scaleX = value / this.spaceWidth;
          } else {
            this.scaleX = 1;
          }
        }
      }, {
        key: "setSpaceWidth",
        value: function setSpaceWidth(width) {
          this.spaceWidth = width;
          return this;
        }
      }]);
      return Space;
    }(RenderBase);
  
    var CreateSpaceChild = function CreateSpaceChild(width) {
      var child = this.poolManager.allocate(SpaceTypeName);
      if (child === null) {
        child = new Space$1(this,
        // parent
        width);
      } else {
        child.setParent(this).setActive().setSpaceWidth(width);
      }
      return child;
    };
  
    var AppendSpace = function AppendSpace(width) {
      var child = this.createSpaceChild(width);
      this.addChild(child);
      return this;
    };
  
    var Command = /*#__PURE__*/function (_Base) {
      _inherits(Command, _Base);
      function Command(parent, name, callback, param, scope) {
        var _this;
        _classCallCheck(this, Command);
        _this = _callSuper(this, Command, [parent, CmdTypeName]);
        _this.setName(name).setParameter(param).setCallback(callback, scope);
        return _this;
      }
      _createClass(Command, [{
        key: "setName",
        value: function setName(name) {
          this.name = name;
          return this;
        }
      }, {
        key: "setParameter",
        value: function setParameter(param) {
          this.param = param;
          return this;
        }
      }, {
        key: "setCallback",
        value: function setCallback(callback, scope) {
          this.callback = callback;
          this.scope = scope;
          return this;
        }
      }, {
        key: "exec",
        value: function exec() {
          var result;
          if (this.scope) {
            result = this.callback.call(this.scope, this.param, this.name);
          } else {
            result = this.callback(this.param, this.name);
          }
          return result;
        }
      }, {
        key: "onFree",
        value: function onFree() {
          _get(_getPrototypeOf(Command.prototype), "onFree", this).call(this);
          this.setName().setCallback().setParameter();
        }
      }]);
      return Command;
    }(Base$2);
  
    var CreateCommandChild = function CreateCommandChild(name, callback, param, scope) {
      var child = this.poolManager.allocate(CmdTypeName);
      if (child === null) {
        child = new Command(this,
        // parent
        name, callback, param, scope);
      } else {
        child.setParent(this).setActive().setName(name).setCallback(callback, scope).setParameter(param);
      }
      return child;
    };
  
    var AppendCommand$3 = function AppendCommand(name, callback, param, scope) {
      var child = this.createCommandChild(name, callback, param, scope);
      this.addChild(child);
      return this;
    };
  
    var SetWrapConfig = function SetWrapConfig(config) {
      if (config === undefined) {
        config = {};
      } else if (_typeof(config) === 'object') {
        config = DeepClone(config);
      }
      this.wrapConfig = config;
      return this;
    };
  
    var CreateWrapResultData = function CreateWrapResultData(config) {
      var data = {
        callback: undefined,
        start: 0,
        // Next start index
        isLastPage: false,
        // Is last page
        maxLines: undefined,
        padding: undefined,
        letterSpacing: undefined,
        hAlign: undefined,
        vAlign: undefined,
        children: [],
        // Wrap result
        lines: [],
        // Wrap result in lines
  
        // WordWrap
        maxLineWidth: 0,
        linesHeight: 0,
        lineHeight: undefined,
        // VerticalWrap
        maxLineHeight: 0,
        linesWidth: 0,
        lineWidth: undefined
      };
      return Object.assign(data, config);
    };
  
    var WRAPMODE = {
      none: 0,
      word: 1,
      "char": 2,
      character: 2,
      mix: 3
    };
  
    var GetWord = function GetWord(children, startIndex, wrapMode, result) {
      if (result === undefined) {
        result = {
          word: [],
          width: 0
        };
      }
      result.word.length = 0;
      var isCharWrap = wrapMode === 2;
      var isMixWrap = wrapMode === 3;
      var isWordWrap = !isCharWrap && !isMixWrap;
      var endIndex = children.length;
      var currentIndex = startIndex;
      var word = result.word;
      var wordWidth = 0;
      var hasAnyASCIICharacter = false;
      while (currentIndex < endIndex) {
        var child = children[currentIndex];
        // Can't render (command child), put into output directly
        if (!child.renderable) {
          word.push(child);
          currentIndex++;
          continue;
        }
        var text = child.type === CharTypeName ? child.text : null;
        // Get image child, a new-line, or page-break
        if (text === null || text === '\n' || text === '\f') {
          if (currentIndex === startIndex) {
            // Single child
            word.push(child);
            wordWidth += child.outerWidth;
          }
          break;
        }
        if (isWordWrap) {
          word.push(child);
          wordWidth += child.outerWidth;
          if (text === ' ') {
            // Word is end with a space character
            break;
          }
          currentIndex++;
        } else if (isCharWrap) {
          // Word only contains 1 character
          word.push(child);
          wordWidth += child.outerWidth;
          // Flush this 1 character
          break;
        } else if (isMixWrap) {
          if (!IsASCIIString(text)) {
            if (!hasAnyASCIICharacter) {
              word.push(child);
              wordWidth += child.outerWidth;
  
              // Is next child a space character?
              var nextChild = children[currentIndex + 1];
              if (nextChild && nextChild.type === CharTypeName && nextChild.text === ' ') {
                word.push(nextChild);
                wordWidth += nextChild.outerWidth;
                // Include this space character
              }
              // Flush this 1 non-ascii character
              break;
            } else {
              // Flush remainder children (all ascii character), except current child
              break;
            }
          } else {
            word.push(child);
            wordWidth += child.outerWidth;
            if (text === ' ') {
              // Word is end with a space character
              break;
            }
            currentIndex++;
            hasAnyASCIICharacter = true;
            // Test next child until ...
          }
        }
      }
      result.width = wordWidth;
      return result;
    };
  
    var GetChildrenAlign = function GetChildrenAlign(children) {
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (child.align !== undefined) {
          return child.align;
        }
      }
      return undefined;
    };
  
    var OffsetChildren = function OffsetChildren(children, offsetX, offsetY) {
      if (offsetX === 0 && offsetY === 0) {
        return;
      }
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (!child.renderable) {
          continue;
        }
        child.x += offsetX;
        child.y += offsetY;
      }
    };
  
    var AlignLines$1 = function AlignLines(result, width, height) {
      var hAlign = result.hAlign,
        vAlign = result.vAlign,
        justifyPercentage = result.justifyPercentage;
      var lines = result.lines;
      var offsetX, offsetY;
      for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
        var line = lines[li];
        var lineWidth = line.width,
          children = line.children;
        var lineHAlign = GetChildrenAlign(children);
        if (lineHAlign === undefined) {
          lineHAlign = hAlign;
        }
        switch (lineHAlign) {
          case 0:
          case 'left':
            offsetX = 0;
            break;
          case 1: // center
          case 'center':
            var remainderWidth = width - lineWidth;
            offsetX = remainderWidth / 2;
            break;
          case 2: // right
          case 'right':
            var remainderWidth = width - lineWidth;
            offsetX = remainderWidth;
            break;
          case 3:
          case 'justify':
          case 'justify-left':
            var remainderWidth = width - lineWidth;
            var remainderPercentage = remainderWidth / width;
            if (remainderPercentage < justifyPercentage) {
              JustifyChildren(children, remainderWidth);
              offsetX = 0;
            } else {
              offsetX = 0;
            }
            break;
          case 4:
          case 'justify-center':
            var remainderWidth = width - lineWidth;
            var remainderPercentage = remainderWidth / width;
            if (remainderPercentage < justifyPercentage) {
              JustifyChildren(children, remainderWidth);
              offsetX = 0;
            } else {
              offsetX = remainderWidth / 2;
            }
            break;
          case 5:
          case 'justify-right':
            var remainderWidth = width - lineWidth;
            var remainderPercentage = remainderWidth / width;
            if (remainderPercentage < justifyPercentage) {
              JustifyChildren(children, remainderWidth);
              offsetX = 0;
            } else {
              offsetX = remainderWidth;
            }
            break;
          default:
            offsetX = 0;
            break;
        }
        var linesHeight = result.linesHeight;
        switch (vAlign) {
          case 1: // center
          case 'center':
            offsetY = (height - linesHeight) / 2;
            break;
          case 2: // bottom
          case 'bottom':
            offsetY = height - linesHeight;
            break;
          default:
            offsetY = 0;
            break;
        }
        OffsetChildren(children, offsetX, offsetY);
      }
    };
    var JustifyChildren = function JustifyChildren(children, remainderWidth) {
      var offset = remainderWidth / children.length;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (!child.renderable) {
          continue;
        }
        child.x += offset * i;
      }
    };
  
    var GetDefaultTextHeight = function GetDefaultTextHeight() {
      var metrics = this.defaultTextStyle.getTextMetrics(this.context, this.testString);
      var ascent, descent;
      if ('actualBoundingBoxAscent' in metrics) {
        ascent = metrics.actualBoundingBoxAscent;
        descent = metrics.actualBoundingBoxDescent;
      } else {
        ascent = 0;
        descent = 0;
      }
      Result.ascent = ascent;
      Result.descent = descent;
      Result.height = ascent + descent;
      return Result;
    };
    var Result = {};
  
    var GetValue$3o = Phaser.Utils.Objects.GetValue;
    var RunWordWrap$1 = function RunWordWrap(config) {
      // Parse parameters
      var startIndex = GetValue$3o(config, 'start', 0);
      SetPadding$1(this.wrapPadding, GetValue$3o(config, 'padding', 0));
      var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
      var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
  
      // Get lineHeight, maxLines
      var lineHeight = GetValue$3o(config, 'lineHeight');
      var ascent = GetValue$3o(config, 'ascent', lineHeight);
      var maxLines;
      if (lineHeight === undefined) {
        // Calculate lineHeight
        var useDefaultTextHeight = GetValue$3o(config, 'useDefaultTextHeight', false);
        maxLines = GetValue$3o(config, 'maxLines', 0);
        if (this.fixedHeight > 0 && !useDefaultTextHeight) {
          var innerHeight = this.fixedHeight - paddingVertical;
          if (maxLines > 0) {
            // Calculate lineHeight via maxLines, in fixedHeight mode
            lineHeight = innerHeight / maxLines;
          } else {
            var textHeightResult = GetDefaultTextHeight.call(this);
            lineHeight = textHeightResult.height;
            ascent = textHeightResult.ascent;
            // Calculate maxLines via (ascent, lineHeight), in fixedHeight mode
            maxLines = Math.floor((innerHeight - ascent) / lineHeight);
          }
        } else {
          var textHeightResult = GetDefaultTextHeight.call(this);
          lineHeight = textHeightResult.height;
          ascent = textHeightResult.ascent;
        }
      } else {
        // Calculate maxLines
        if (this.fixedHeight > 0) {
          // Calculate maxLines via lineHeight, in fixedHeight mode
          maxLines = GetValue$3o(config, 'maxLines');
          if (maxLines === undefined) {
            var innerHeight = this.fixedHeight - paddingVertical;
            maxLines = Math.floor(innerHeight / lineHeight);
          }
        } else {
          maxLines = GetValue$3o(config, 'maxLines', 0); // Default is show all lines
        }
      }
  
      // If ascent is undefined, assign to lineHeight
      if (ascent === undefined) {
        ascent = lineHeight;
      }
      var showAllLines = maxLines === 0;
      var wrapMode = GetValue$3o(config, 'wrapMode');
      if (wrapMode === undefined) {
        var charWrap = GetValue$3o(config, 'charWrap', false);
        wrapMode = charWrap ? 'char' : 'word';
      }
      if (typeof wrapMode === 'string') {
        wrapMode = WRAPMODE[wrapMode];
      }
  
      // Get wrapWidth
      var wrapWidth = GetValue$3o(config, 'wrapWidth', undefined);
      if (wrapWidth === undefined) {
        if (this.fixedWidth > 0) {
          wrapWidth = this.fixedWidth - paddingHorizontal;
        } else {
          wrapWidth = Infinity; // No word-wrap
          wrapMode = 0;
        }
      }
      var letterSpacing = GetValue$3o(config, 'letterSpacing', 0);
      var hAlign = GetValue$3o(config, 'hAlign', 0);
      var vAlign = GetValue$3o(config, 'vAlign', 0);
      var justifyPercentage = GetValue$3o(config, 'justifyPercentage', 0.25);
      var result = CreateWrapResultData({
        // Override properties
        callback: 'runWordWrap',
        start: startIndex,
        // Next start index
        padding: this.wrapPadding,
        letterSpacing: letterSpacing,
        maxLines: maxLines,
        hAlign: hAlign,
        vAlign: vAlign,
        justifyPercentage: justifyPercentage,
        // Specific properties
        ascent: ascent,
        lineHeight: lineHeight,
        wrapWidth: wrapWidth,
        wrapMode: wrapMode
      });
  
      // Set all children to inactive
      var children = this.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setActive(false);
      }
  
      // Layout children
      wrapWidth += letterSpacing;
      var startX = this.padding.left + this.wrapPadding.left,
        startY = this.padding.top + this.wrapPadding.top + ascent,
        // Start(baseline) from ascent, not 0
        x = startX,
        y = startY;
      var remainderWidth = wrapWidth,
        childIndex = startIndex,
        lastChildIndex = children.length;
      var resultChildren = result.children;
      var resultLines = result.lines,
        lastLine = [],
        lastLineWidth = 0,
        maxLineWidth = 0;
      var wordResult;
      var isPageBreakChar = false;
      while (childIndex < lastChildIndex) {
        wordResult = GetWord(children, childIndex, wrapMode, wordResult);
        var word = wordResult.word;
        var charCnt = word.length;
        var wordWidth = wordResult.width + charCnt * letterSpacing;
        childIndex += charCnt;
        // Next line
        var isNewLineChar = IsNewLineChar(word[0]);
        isPageBreakChar = IsPageBreakChar(word[0]);
        var isControlChar = isNewLineChar || isPageBreakChar;
        if (remainderWidth < wordWidth || isControlChar) {
          // Add to result
          if (isControlChar) {
            var _char = word[0];
            _char.setActive().setPosition(x, y);
            resultChildren.push(_char);
            lastLine.push(_char);
          }
  
          // Move cursor
          x = startX;
          y += lineHeight;
          remainderWidth = wrapWidth;
          resultLines.push({
            children: lastLine,
            width: lastLineWidth
          });
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          lastLineWidth = 0;
          lastLine = [];
          var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines; // Exceed maxLines
          if (isPageEnd) {
            break;
          } else if (isControlChar) {
            // Already add to result
            continue;
          }
        }
        remainderWidth -= wordWidth;
        lastLineWidth += wordWidth;
        for (var i = 0, cnt = word.length; i < cnt; i++) {
          var child = word[i];
          child.setActive();
          resultChildren.push(child);
          lastLine.push(child);
          if (child.renderable) {
            child.setPosition(x, y);
            x += child.outerWidth + letterSpacing;
          }
        }
      }
      if (lastLine.length > 0) {
        resultLines.push({
          children: lastLine,
          width: lastLineWidth
        });
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      }
      result.start += resultChildren.length;
      result.isLastPage = !isPageBreakChar && result.start === lastChildIndex;
      result.maxLineWidth = maxLineWidth;
      result.linesHeight = resultLines.length * lineHeight;
  
      // Calculate size of game object
      var width = this.fixedWidth > 0 ? this.fixedWidth : result.maxLineWidth + paddingHorizontal;
      var height = this.fixedHeight > 0 ? this.fixedHeight : result.linesHeight + paddingVertical;
  
      // Size might be changed after wrapping
      var innerWidth = width - paddingHorizontal;
      var innerHeight = height - paddingVertical;
      AlignLines$1(result, innerWidth, innerHeight);
  
      // Resize
      this.setCanvasSize(width, height);
  
      // Set initial position
      for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
        var child = resultChildren[i];
        if (!child.renderable) {
          continue;
        }
        child.x0 = child.x;
        child.y0 = child.y;
      }
      return result;
    };
  
    var Merge$4 = Phaser.Utils.Objects.Merge;
    var RunWordWrap = function RunWordWrap(config) {
      if (config === undefined) {
        config = {};
      }
      return RunWordWrap$1.call(this, Merge$4(config, this.wrapConfig));
    };
  
    var AlignLines = function AlignLines(result, width, height) {
      var hAlign = result.hAlign,
        vAlign = result.vAlign;
      var offsetX, offsetY;
      var rtl = result.rtl;
      var lines = result.lines,
        lineWidth = result.lineWidth,
        linesWidth = result.linesWidth;
      switch (hAlign) {
        case 1: // center
        case 'center':
          offsetX = (width - linesWidth) / 2;
          break;
        case 2: // right
        case 'right':
          offsetX = width - linesWidth;
          break;
        default:
          // left
          offsetX = 0;
          break;
      }
      if (rtl) {
        offsetX += lineWidth;
      }
      for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
        var line = lines[rtl ? lcnt - li - 1 : li];
        var children = line.children;
        var lineHeight = line.height;
        var lineVAlign = GetChildrenAlign(children);
        if (lineVAlign === undefined) {
          lineVAlign = vAlign;
        }
        switch (lineVAlign) {
          case 1: // center
          case 'center':
            offsetY = (height - lineHeight) / 2;
            break;
          case 2: // bottom
          case 'bottom':
            offsetY = height - lineHeight;
            break;
          default:
            // top
            offsetY = 0;
            break;
        }
        OffsetChildren(children, offsetX, offsetY);
        offsetX += lineWidth;
      }
    };
  
    var GetValue$3n = Phaser.Utils.Objects.GetValue;
    var RunVerticalWrap$1 = function RunVerticalWrap(config) {
      // Parse parameters
      var startIndex = GetValue$3n(config, 'start', 0);
      SetPadding$1(this.wrapPadding, GetValue$3n(config, 'padding', 0));
      var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
      var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
      var lineWidth = GetValue$3n(config, 'lineWidth', undefined);
      var maxLines;
      if (lineWidth === undefined) {
        // Calculate lineWidth via maxLines, in fixedWidth mode
        maxLines = GetValue$3n(config, 'maxLines', 0);
        if (this.fixedWidth > 0) {
          var innerWidth = this.fixedWidth - paddingHorizontal;
          lineWidth = innerWidth / maxLines;
        } else {
          lineWidth = 0;
        }
      } else {
        if (this.fixedWidth > 0) {
          // Calculate maxLines via lineWidth, in fixedWidth mode
          maxLines = GetValue$3n(config, 'maxLines', undefined);
          if (maxLines === undefined) {
            var innerWidth = this.fixedWidth - paddingHorizontal;
            maxLines = Math.floor(innerWidth / lineWidth) + 1;
          }
        } else {
          maxLines = GetValue$3n(config, 'maxLines', 0); // Default is show all lines
        }
      }
      var showAllLines = maxLines === 0;
  
      // Get fixedCharacterHeight
      var fixedCharacterHeight = GetValue$3n(config, 'fixedCharacterHeight', undefined);
      if (fixedCharacterHeight === undefined) {
        var charPerLine = GetValue$3n(config, 'charPerLine', undefined);
        if (charPerLine !== undefined) {
          var innerHeight = this.fixedHeight - paddingVertical;
          fixedCharacterHeight = Math.floor(innerHeight / charPerLine);
        }
      }
  
      // Get wrapHeight
      var wrapHeight = GetValue$3n(config, 'wrapHeight', undefined);
      if (wrapHeight === undefined) {
        if (this.fixedHeight > 0) {
          wrapHeight = this.fixedHeight - paddingVertical;
        } else {
          wrapHeight = Infinity; // No word-wrap
        }
      }
      var letterSpacing = GetValue$3n(config, 'letterSpacing', 0);
      var rtl = GetValue$3n(config, 'rtl', true);
      var hAlign = GetValue$3n(config, 'hAlign', rtl ? 2 : 0);
      var vAlign = GetValue$3n(config, 'vAlign', 0);
      var result = CreateWrapResultData({
        // Override properties
        callback: 'runVerticalWrap',
        start: startIndex,
        // Next start index
        padding: this.wrapPadding,
        letterSpacing: letterSpacing,
        maxLines: maxLines,
        hAlign: hAlign,
        vAlign: vAlign,
        // Specific properties
        lineWidth: lineWidth,
        fixedCharacterHeight: fixedCharacterHeight,
        wrapHeight: wrapHeight,
        rtl: rtl
      });
  
      // Set all children to active
      var children = this.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setActive(false);
      }
  
      // Layout children
      wrapHeight += letterSpacing;
      var startX = this.padding.left + this.wrapPadding.left,
        // Reset x of each character in AlignLines method
        startY = this.padding.top + this.wrapPadding.top,
        x = startX,
        y = startY;
      var remainderHeight = wrapHeight,
        childIndex = startIndex,
        lastChildIndex = children.length;
      var resultChildren = result.children;
      var resultLines = result.lines,
        lastLine = [],
        lastLineHeight = 0,
        maxLineHeight = 0;
      while (childIndex < lastChildIndex) {
        // Append non-typeable child directly
        var child = children[childIndex];
        childIndex++;
        if (!child.renderable) {
          child.setActive();
          resultChildren.push(child);
          lastLine.push(child);
          continue;
        }
        var childHeight = (fixedCharacterHeight !== undefined ? fixedCharacterHeight : child.height) + letterSpacing;
        // Next line
        var isNewLineChar = IsNewLineChar(child);
        var isPageBreakChar = IsPageBreakChar(child);
        var isControlChar = isNewLineChar || isPageBreakChar;
        if (remainderHeight < childHeight || isControlChar) {
          // Add to result
          if (isNewLineChar) {
            child.setActive().setPosition(x, y).setOrigin(0.5);
            resultChildren.push(child);
            lastLine.push(child);
          }
  
          // Move cursor
          x = startX;
          y = startY;
          remainderHeight = wrapHeight;
          resultLines.push({
            children: lastLine,
            height: lastLineHeight
          });
          maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
          lastLineHeight = 0;
          lastLine = [];
          var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines; // Exceed maxLines
          if (isPageEnd) {
            break;
          } else if (isControlChar) {
            // Already add to result                
            continue;
          }
        }
        remainderHeight -= childHeight;
        lastLineHeight += childHeight;
        child.setActive().setPosition(x, y).setOrigin(0.5);
        resultChildren.push(child);
        lastLine.push(child);
        y += childHeight;
      }
      if (lastLine.length > 0) {
        resultLines.push({
          children: lastLine,
          height: lastLineHeight
        });
        maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
      }
      result.start += resultChildren.length;
      result.isLastPage = result.start === lastChildIndex;
      result.maxLineHeight = maxLineHeight;
      result.linesWidth = resultLines.length * lineWidth;
  
      // Calculate size of game object
      var width = this.fixedWidth > 0 ? this.fixedWidth : result.linesWidth + paddingHorizontal;
      var height = this.fixedHeight > 0 ? this.fixedHeight : result.maxLineHeight + paddingVertical;
  
      // Size might be changed after wrapping
      var innerWidth = width - paddingHorizontal;
      var innerHeight = height - paddingVertical;
      AlignLines(result, innerWidth, innerHeight);
  
      // Resize
      this.setCanvasSize(width, height);
  
      // Set initial position
      for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
        var child = resultChildren[i];
        if (!child.renderable) {
          continue;
        }
        child.x0 = child.x;
        child.y0 = child.y;
      }
      return result;
    };
  
    var Merge$3 = Phaser.Utils.Objects.Merge;
    var RunVerticalWrap = function RunVerticalWrap(config) {
      if (config === undefined) {
        config = {};
      }
      return RunVerticalWrap$1.call(this, Merge$3(config, this.wrapConfig));
    };
  
    var GetValue$3m = Phaser.Utils.Objects.GetValue;
    var RunWrap = function RunWrap(config) {
      var wrapCallback = GetValue$3m(this.wrapConfig, 'callback');
      if (!wrapCallback) {
        wrapCallback = GetValue$3m(config, 'callback', this.runWordWrap);
      }
      if (typeof wrapCallback === 'string') {
        wrapCallback = this[wrapCallback];
      }
      return wrapCallback.call(this, config);
    };
  
    var SetAlignMethods = {
      setVAlign: function setVAlign(align) {
        this.wrapConfig.vAlign = align;
        return this;
      },
      setHAlign: function setHAlign(align) {
        this.wrapConfig.hAlign = align;
        return this;
      }
    };
  
    var SetTextOXYMethods$1 = {
      setTextOX: function setTextOX(ox) {
        if (ox === this._textOX) {
          return this;
        }
        this._textOX = ox;
        return this;
      },
      setTextOY: function setTextOY(oy) {
        if (oy === this._textOY) {
          return this;
        }
        this._textOY = oy;
        return this;
      },
      setTextOXY: function setTextOXY(ox, oy) {
        if (ox === this._textOX && oy === this._textOY) {
          return;
        }
        this._textOX = ox;
        this._textOY = oy;
        return this;
      },
      addTextOX: function addTextOX(incX) {
        this.setTextOX(this._textOX + incX);
        return this;
      },
      addTextOY: function addTextOY(incY) {
        this.setTextOY(this._textOY + incY);
        return this;
      },
      addTextOXY: function addTextOXY(incX, incY) {
        this.setTextOXY(this._textOX + incX, this._textOY + incY);
        return this;
      }
    };
  
    var RenderContent = function RenderContent() {
      this.clear();
      this.setCanvasSize(this.width, this.height);
      if (this.background.active) {
        this.background.render();
      }
      var child;
      for (var i = 0, cnt = this.children.length; i < cnt; i++) {
        child = this.children[i];
        if (child.active) {
          child.render();
        }
      }
      if (this.innerBounds.active) {
        this.innerBounds.render();
      }
    };
  
    var ForEachChild = function ForEachChild(callback, scope, activeOnly) {
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      var childIndex = 0;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        var isBreak;
        if (scope) {
          isBreak = callback.call(this, child, childIndex, children);
        } else {
          isBreak = callback(child, childIndex, children);
        }
        childIndex++;
        if (isBreak) {
          break;
        }
      }
      return this;
    };
  
    var ForEachRenderableChild = function ForEachRenderableChild(callback, scope, activeOnly) {
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      var childIndex = 0;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        if (child.renderable && !child.removed) {
          var isBreak;
          if (scope) {
            isBreak = callback.call(this, child, childIndex, children);
          } else {
            isBreak = callback(child, childIndex, children);
          }
          childIndex++;
          if (isBreak) {
            break;
          }
        }
      }
      return this;
    };
  
    var ForEachCharChild = function ForEachCharChild(callback, scope, activeOnly) {
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      var charIndex = 0;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        if (IsChar(child) && !child.removed) {
          var isBreak;
          if (scope) {
            isBreak = callback.call(this, child, charIndex, children);
          } else {
            isBreak = callback(child, charIndex, children);
          }
          charIndex++;
          if (isBreak) {
            break;
          }
        }
      }
      return this;
    };
  
    var GetChildren = function GetChildren() {
      return this.children;
    };
  
    var GetAll = Phaser.Utils.Array.GetAll;
    var GetActiveChildren = function GetActiveChildren() {
      return GetAll(this.children, 'active', true);
    };
  
    var GetCharChildren = function GetCharChildren(activeOnly, out) {
      if (out === undefined) {
        out = [];
      }
      this.forEachCharChild(function (child) {
        out.push(child);
      }, undefined, activeOnly);
      return out;
    };
  
    var GetLastAppendedChildren = function GetLastAppendedChildren() {
      return this.lastAppendedChildren;
    };
  
    var GetBobCenterPosition = function GetBobCenterPosition(bob, offsetX, offsetY, out) {
      if (typeof offsetX !== 'number') {
        out = offsetX;
        offsetX = 0;
        offsetY = 0;
      }
      var bobX = bob.drawCenterX + offsetX;
      var bobY = bob.drawCenterY + offsetY;
      return BobPositionToCanvasPosition(bob, bobX, bobY, out);
    };
  
    var GetDistance$1 = Phaser.Math.Distance.BetweenPointsSquared;
    var GetNearestChild = function GetNearestChild(canvasX, canvasY) {
      var pointA = {
        x: canvasX,
        y: canvasY
      };
      var minDistance = Infinity;
      var nearestChild = null;
      this.forEachRenderableChild(function (child) {
        var distance = GetDistance$1(pointA, GetBobCenterPosition(child, true));
        if (minDistance > distance) {
          minDistance = distance;
          nearestChild = child;
        }
      });
      return nearestChild;
    };
  
    var GetCharWorldPosition = function GetCharWorldPosition(child, offsetX, offsetY, out) {
      if (typeof child === 'number') {
        child = this.getCharChild(child, true);
      }
      return GetBobWorldPosition(this, child, offsetX, offsetY, out);
    };
  
    var SetToMinSize = function SetToMinSize() {
      var children = this.children;
      var maxX = 0,
        maxY = 0;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (!child.renderable || !child.active || !child.visible) {
          continue;
        }
        var x0 = child.x0 !== undefined ? child.x0 : child.x;
        var y0 = child.y0 !== undefined ? child.y0 : child.y;
        maxX = Math.max(maxX, x0);
        maxY = Math.max(maxY, y0);
      }
      var width = maxX + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
      var height = maxY + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
  
      // Ignore fixedWidth, and fixedHeight
      if (this.width !== width || this.height !== height) {
        this.dirty = true;
        this.setCanvasSize(width, height);
      }
      return this;
    };
  
    var GetCharChildIndex = function GetCharChildIndex(charIndex, activeOnly) {
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        if (IsChar(child) && !child.removed) {
          if (charIndex === 0) {
            return i;
          } else {
            charIndex--;
          }
        }
      }
      return undefined;
    };
  
    var GetCharChild = function GetCharChild(charIndex, activeOnly) {
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        if (IsChar(child) && !child.removed) {
          if (charIndex === 0) {
            return child;
          } else {
            charIndex--;
          }
        }
      }
      return undefined;
    };
  
    var GetCharIndex = function GetCharIndex(childIndex, activeOnly) {
      if (typeof childIndex !== 'number') {
        childIndex = this.children.indexOf(childIndex);
        if (childIndex < 0) {
          return null;
        }
      }
      if (activeOnly === undefined) {
        activeOnly = true;
      }
      var children = this.children;
      if (childIndex >= children.length) {
        childIndex = children.length;
      }
      var charIndex = 0;
      for (var i = 0; i < childIndex; i++) {
        var child = children[i];
        if (activeOnly && !child.active) {
          continue;
        }
        if (IsChar(child) && !child.removed) {
          charIndex++;
        }
      }
      return charIndex;
    };
  
    var SetChildrenInteractiveEnable = function SetChildrenInteractiveEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      if (this.childrenInteractiveEnable !== enable) {
        this.lastOverChild = null;
      }
      this.childrenInteractiveEnable = enable;
      return this;
    };
  
    var GetFirstChildContains = function GetFirstChildContains(children, x, y) {
      var children = children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (!child.active || !child.renderable) {
          continue;
        }
        if (child.contains(x, y)) {
          return child;
        }
      }
      return null;
    };
  
    var SetChildrenInteractive$1 = function SetChildrenInteractive() {
      this.on('pointerdown', OnPointerDown$1, this).on('pointerdown', OnPointerUp$1, this).on('pointermove', OnPointOverOut, this).on('pointerover', OnPointOverOut, this).on('pointerout', function (pointer, event) {
        OnPointOverOut.call(this, pointer, null, null, event);
      }, this);
      return this;
    };
    var OnPointerDown$1 = function OnPointerDown(pointer, localX, localY, event) {
      if (!this.childrenInteractiveEnable) {
        return;
      }
      var child = GetFirstChildContains(this.children, localX, localY);
      if (!child) {
        return;
      }
      this.emit('child.pointerdown', child, pointer, localX, localY, event);
    };
    var OnPointerUp$1 = function OnPointerUp(pointer, localX, localY, event) {
      if (!this.childrenInteractiveEnable) {
        return;
      }
      var child = GetFirstChildContains(this.children, localX, localY);
      if (!child) {
        return;
      }
      this.emit('child.pointerup', child, pointer, localX, localY, event);
    };
    var OnPointOverOut = function OnPointOverOut(pointer, localX, localY, event) {
      if (!this.childrenInteractiveEnable) {
        return;
      }
      if (localX === null) {
        // Case of pointerout
        if (this.lastOverChild !== null) {
          this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
          this.lastOverChild = null;
        }
        return;
      }
      var child = GetFirstChildContains(this.children, localX, localY);
      if (child === this.lastOverChild) {
        return;
      }
      if (this.lastOverChild !== null) {
        this.emit('child.pointerout', this.lastOverChild, pointer, localX, localY, event);
      }
      if (child !== null) {
        this.emit('child.pointerover', child, pointer, localX, localY, event);
      }
      this.lastOverChild = child;
    };
  
    var GameObject = Phaser.GameObjects.GameObject;
    var SetInteractive = function SetInteractive(hitArea, hitAreaCallback, dropZone) {
      var isInteractived = !!this.input;
      GameObject.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
      if (!isInteractived) {
        SetChildrenInteractive$1.call(this);
      }
      return this;
    };
  
    var BringToTop = Phaser.Utils.Array.BringToTop;
    var SendToBack = Phaser.Utils.Array.SendToBack;
    var MoveUp = Phaser.Utils.Array.MoveUp;
    var MoveDown = Phaser.Utils.Array.MoveDown;
    var MoveAbove = Phaser.Utils.Array.MoveAbove;
    var MoveBelow = Phaser.Utils.Array.MoveBelow;
    var MoveChildMethods = {
      moveChildToFist: function moveChildToFist(child) {
        SendToBack(this.children, child);
        return this;
      },
      moveChildToLast: function moveChildToLast(child) {
        BringToTop(this.children, child);
        return this;
      },
      movechildUp: function movechildUp(child) {
        MoveUp(this.children, child);
        return this;
      },
      movechildDown: function movechildDown(child) {
        MoveDown(this.children, child);
        return this;
      },
      movechildAbove: function movechildAbove(child, baseChild) {
        MoveAbove(this.children, child, baseChild);
        return this;
      },
      movechildBelow: function movechildBelow(child, baseChild) {
        MoveBelow(this.children, child, baseChild);
        return this;
      }
    };
  
    var BackgroundMethods = {
      setBackgroundColor: function setBackgroundColor(color, color2, isHorizontalGradient) {
        this.background.setColor(color, color2, isHorizontalGradient);
        return this;
      },
      setBackgroundStroke: function setBackgroundStroke(color, lineWidth) {
        this.background.setStroke(color, lineWidth);
        return this;
      },
      setBackgroundCornerRadius: function setBackgroundCornerRadius(radius, iteration) {
        this.background.setCornerRadius(radius, iteration);
        return this;
      }
    };
  
    var InnerBoundsMethods = {
      setInnerBoundsColor: function setInnerBoundsColor(color, color2, isHorizontalGradient) {
        this.innerBounds.setColor(color, color2, isHorizontalGradient);
        return this;
      },
      setInnerBoundsStroke: function setInnerBoundsStroke(color, lineWidth) {
        this.innerBounds.setStroke(color, lineWidth);
        return this;
      }
    };
  
    var Methods$h = {
      setFixedSize: SetFixedSize,
      setPadding: SetPadding,
      getPadding: GetPadding,
      modifyTextStyle: ModifyTextStyle,
      modifyDefaultTextStyle: ModifyDefaultTextStyle,
      resetTextStyle: ResetTextStyle,
      setTestString: SetTestString,
      removeChild: RemoveChild$2,
      removeChildren: RemoveChildren,
      popChild: PopChild,
      clearContent: ClearContent,
      addChild: AddChild$3,
      createCharChild: CreateCharChild,
      createCharChildren: CreateCharChildren,
      setText: SetText$2,
      appendText: AppendText$1,
      insertText: InsertText,
      removeText: RemoveText,
      getText: GetText,
      createImageChild: CreateImageChild,
      appendImage: AppendImage,
      createDrawerChild: CreateDrawerChild,
      appendDrawer: AppendDrawer,
      createSpaceChild: CreateSpaceChild,
      appendSpace: AppendSpace,
      createCommandChild: CreateCommandChild,
      appendCommand: AppendCommand$3,
      setWrapConfig: SetWrapConfig,
      runWordWrap: RunWordWrap,
      runVerticalWrap: RunVerticalWrap,
      runWrap: RunWrap,
      renderContent: RenderContent,
      forEachChild: ForEachChild,
      forEachRenderableChild: ForEachRenderableChild,
      forEachCharChild: ForEachCharChild,
      getChildren: GetChildren,
      getActiveChildren: GetActiveChildren,
      getCharChildren: GetCharChildren,
      getLastAppendedChildren: GetLastAppendedChildren,
      getNearestChild: GetNearestChild,
      getCharWorldPosition: GetCharWorldPosition,
      setToMinSize: SetToMinSize,
      getCharChildIndex: GetCharChildIndex,
      getCharChild: GetCharChild,
      getCharIndex: GetCharIndex,
      setChildrenInteractiveEnable: SetChildrenInteractiveEnable,
      setInteractive: SetInteractive
    };
    Object.assign(Methods$h, MoveChildMethods, BackgroundMethods, InnerBoundsMethods, SetAlignMethods, SetTextOXYMethods$1);
  
    var GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;
    var Pools = {};
    var PoolManager = /*#__PURE__*/function () {
      function PoolManager(config) {
        _classCallCheck(this, PoolManager);
        this.pools = GetFastValue$1(config, 'pools', Pools);
      }
      _createClass(PoolManager, [{
        key: "free",
        value: function free(bob) {
          if (!this.pools) {
            return this;
          }
          var bobType = bob.type;
          if (!this.pools.hasOwnProperty(bobType)) {
            this.pools[bobType] = new Stack();
          }
          this.pools[bobType].push(bob);
          bob.onFree();
          return this;
        }
      }, {
        key: "freeMultiple",
        value: function freeMultiple(arr) {
          if (!this.pools) {
            return this;
          }
          for (var i = 0, cnt = arr.length; i < cnt; i++) {
            this.free(arr[i]);
          }
          return this;
        }
      }, {
        key: "allocate",
        value: function allocate(bobType) {
          if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
            return null;
          }
          return this.pools[bobType].pop();
        }
      }]);
      return PoolManager;
    }();
  
    var IsPlainObject$M = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$3l = Phaser.Utils.Objects.GetValue;
    var DynamicText = /*#__PURE__*/function (_Canvas) {
      _inherits(DynamicText, _Canvas);
      function DynamicText(scene, x, y, fixedWidth, fixedHeight, config) {
        var _this;
        _classCallCheck(this, DynamicText);
        if (IsPlainObject$M(x)) {
          config = x;
          x = GetValue$3l(config, 'x', 0);
          y = GetValue$3l(config, 'y', 0);
          fixedWidth = GetValue$3l(config, 'width', 0);
          fixedHeight = GetValue$3l(config, 'height', 0);
        } else if (IsPlainObject$M(fixedWidth)) {
          config = fixedWidth;
          fixedWidth = GetValue$3l(config, 'width', 0);
          fixedHeight = GetValue$3l(config, 'height', 0);
        }
        var width = fixedWidth === 0 ? 1 : fixedWidth;
        var height = fixedHeight === 0 ? 1 : fixedHeight;
        _this = _callSuper(this, DynamicText, [scene, x, y, width, height]);
        _this.type = 'rexDynamicText';
        _this.autoRound = true;
        _this.padding = SetPadding$1();
        _this.wrapPadding = SetPadding$1();
        var textStyleConfig = GetValue$3l(config, 'style', undefined);
        _this.defaultTextStyle = new TextStyle(null, textStyleConfig);
        _this.textStyle = _this.defaultTextStyle.clone();
        _this.setTestString(GetValue$3l(config, 'testString', '|MÉqgy'));
        _this._textOX = 0;
        _this._textOY = 0;
        _this.background = new Background(_assertThisInitialized(_this), GetValue$3l(config, 'background', undefined));
        _this.innerBounds = new InnerBounds(_assertThisInitialized(_this), GetValue$3l(config, 'innerBounds', undefined));
        _this.children = [];
        _this.lastAppendedChildren = [];
        _this.lastOverChild = null;
        _this.poolManager = new PoolManager(config);
        _this.setFixedSize(fixedWidth, fixedHeight);
        _this.setPadding(GetValue$3l(config, 'padding', 0));
        _this.setWrapConfig(GetValue$3l(config, 'wrap', undefined));
        _this.setChildrenInteractiveEnable(GetValue$3l(config, 'childrenInteractive', false));
        var text = GetValue$3l(config, 'text', undefined);
        if (text) {
          _this.setText(text);
        }
        return _this;
      }
      _createClass(DynamicText, [{
        key: "updateTexture",
        value: function updateTexture() {
          this.renderContent();
          _get(_getPrototypeOf(DynamicText.prototype), "updateTexture", this).call(this);
          return this;
        }
      }, {
        key: "text",
        get: function get() {
          return this.getText(true);
        },
        set: function set(value) {
          this.setText(value);
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.setFixedSize(width, height);
          return this;
        }
      }, {
        key: "textOX",
        get: function get() {
          return this._textOX;
        },
        set: function set(value) {
          this.setTextOX(value);
        }
      }, {
        key: "textOY",
        get: function get() {
          return this._textOY;
        },
        set: function set(value) {
          this.setTextOY(value);
        }
      }]);
      return DynamicText;
    }(Canvas$1);
    Object.assign(DynamicText.prototype, Methods$h);
  
    ObjectFactory.register('dynamicText', function (x, y, width, height, config) {
      var gameObject = new DynamicText(this.scene, x, y, width, height, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.DynamicText', DynamicText);
  
    var EventEmitterMethods$1 = {
      setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
        if (EventEmitterClass === undefined) {
          EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
        }
        this._privateEE = eventEmitter === true || eventEmitter === undefined;
        this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
        return this;
      },
      destroyEventEmitter: function destroyEventEmitter() {
        if (this._eventEmitter && this._privateEE) {
          this._eventEmitter.shutdown();
        }
        return this;
      },
      getEventEmitter: function getEventEmitter() {
        return this._eventEmitter;
      },
      on: function on() {
        if (this._eventEmitter) {
          this._eventEmitter.on.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      once: function once() {
        if (this._eventEmitter) {
          this._eventEmitter.once.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      off: function off() {
        if (this._eventEmitter) {
          this._eventEmitter.off.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      emit: function emit(event) {
        if (this._eventEmitter && event) {
          this._eventEmitter.emit.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      addListener: function addListener() {
        if (this._eventEmitter) {
          this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      removeListener: function removeListener() {
        if (this._eventEmitter) {
          this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        if (this._eventEmitter) {
          this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      listenerCount: function listenerCount() {
        if (this._eventEmitter) {
          return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
        }
        return 0;
      },
      listeners: function listeners() {
        if (this._eventEmitter) {
          return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
        }
        return [];
      },
      eventNames: function eventNames() {
        if (this._eventEmitter) {
          return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
        }
        return [];
      }
    };
  
    var PropertyMethods$1 = {
      hasProperty: function hasProperty(property) {
        var gameObject = this.gameObject;
        if (gameObject.hasOwnProperty(property)) {
          return true;
        } else {
          var value = gameObject[property];
          return value !== undefined;
        }
      },
      getProperty: function getProperty(property) {
        return this.gameObject[property];
      },
      setProperty: function setProperty(property, value) {
        this.gameObject[property] = value;
        return this;
      },
      easeProperty: function easeProperty(config) {
        var property = config.property;
        var value = config.value;
        var duration = config.duration;
        var delay = config.delay;
        var ease = config.ease;
        var repeat = config.repeat;
        var isYoyo = config.yoyo;
        var isFrom = config.from;
        var onComplete = config.complete;
        var target = config.target;
        if (duration === undefined) {
          duration = 1000;
        }
        if (delay === undefined) {
          delay = 0;
        }
        if (ease === undefined) {
          ease = 'Linear';
        }
        if (repeat === undefined) {
          repeat = 0;
        }
        if (isYoyo === undefined) {
          isYoyo = false;
        }
        if (target === undefined) {
          target = this.gameObject;
        }
        if (isFrom) {
          var startValue = value;
          value = target[property];
          target[property] = startValue;
        }
        var config = {
          targets: target,
          duration: duration,
          delay: delay,
          ease: ease,
          repeat: repeat,
          yoyo: isYoyo,
          onComplete: onComplete
        };
        config[property] = value;
        this.addTweenTask(property, config);
        return this;
      },
      addTweenTask: function addTweenTask(name, config) {
        var tweenTasks = this.tweens;
        var tweenTask = tweenTasks[name];
        if (tweenTask) {
          tweenTask.remove();
        }
        var onComplete = config.onComplete;
        config.onComplete = function () {
          tweenTasks[name].remove();
          tweenTasks[name] = null;
          if (onComplete) {
            onComplete(config.targets, name);
          }
        };
        tweenTask = this.scene.tweens.add(config);
        tweenTask.timeScale = this.timeScale;
        tweenTasks[name] = tweenTask;
        return this;
      },
      getTweenTask: function getTweenTask(property) {
        return this.tweens[property];
      },
      freeTweens: function freeTweens() {
        var tweenTasks = this.tweens,
          tweenTask;
        for (var propName in tweenTasks) {
          tweenTask = tweenTasks[propName];
          if (tweenTask) {
            tweenTask.remove();
          }
          tweenTasks[propName] = null;
        }
        return this;
      }
    };
  
    var CallMethods$1 = {
      hasMethod: function hasMethod(methodName) {
        return typeof this.gameObject[methodName] === 'function';
      },
      call: function call(methodName) {
        if (!this.hasMethod(methodName)) {
          console.warn("[GameObjectManager] Game object '".concat(this.name, "' does not have method '").concat(methodName, "'"));
          return this;
        }
        var gameObject = this.gameObject;
        for (var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          parameters[_key - 1] = arguments[_key];
        }
        gameObject[methodName].apply(gameObject, parameters);
        return this;
      }
    };
  
    var DataMethods$1 = {
      hasData: function hasData(dataKey) {
        var gameObject = this.gameObject;
        return gameObject.data ? gameObject.data.has(dataKey) : false;
      },
      getData: function getData(dataKey) {
        return this.gameObject.getData(dataKey);
      },
      setData: function setData(dataKey, value) {
        this.gameObject.setData(dataKey, value);
        return this;
      }
    };
  
    var BobBase = /*#__PURE__*/function () {
      function BobBase(GOManager, gameObject, name) {
        _classCallCheck(this, BobBase);
        this.GOManager = GOManager;
        this.tweens = {};
        this.effects = {};
        this.setGO(gameObject, name);
      }
      _createClass(BobBase, [{
        key: "scene",
        get: function get() {
          return this.GOManager.scene;
        }
      }, {
        key: "timeScale",
        get: function get() {
          return this.GOManager.timeScale;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.freeGO();
          this.GOManager = undefined;
        }
      }, {
        key: "freeGO",
        value: function freeGO() {
          this.freeTweens();
          this.gameObject.bob = undefined;
          this.gameObject.destroy();
          this.gameObject = undefined;
          return this;
        }
      }, {
        key: "setGO",
        value: function setGO(gameObject, name) {
          gameObject.goName = name;
          gameObject.goType = this.GOManager.name;
          gameObject.bob = this;
          this.gameObject = gameObject;
          this.name = name;
          this.freeTweens();
          return this;
        }
      }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
          var tweenTasks = this.tweens;
          for (var key in tweenTasks) {
            var tweenTask = tweenTasks[key];
            if (tweenTask) {
              tweenTask.timeScale = timeScale;
            }
          }
          return this;
        }
      }]);
      return BobBase;
    }();
    Object.assign(BobBase.prototype, PropertyMethods$1, CallMethods$1, DataMethods$1);
  
    var IsEmpty = function IsEmpty(source) {
      for (var k in source) {
        return false;
      }
      return true;
    };
  
    var IsSingleBob = function IsSingleBob(name) {
      return name && name.charAt(0) !== '!';
    };
  
    var GetMethods = {
      has: function has(name) {
        return this.bobs.hasOwnProperty(name);
      },
      exists: function exists(name) {
        return this.bobs.hasOwnProperty(name);
      },
      get: function get(name, out) {
        if (IsSingleBob(name)) {
          return this.bobs[name];
        } else {
          if (out === undefined) {
            out = [];
          }
          if (name) {
            name = name.substring(1);
          }
          for (var key in this.bobs) {
            if (name && key === name) {
              continue;
            }
            out.push(this.bobs[key]);
          }
          return out;
        }
      },
      getFitst: function getFitst(excluded) {
        if (excluded && excluded.charAt(0) === '!') {
          excluded = excluded.substring(1);
        }
        for (var name in this.bobs) {
          if (excluded && excluded === name) {
            continue;
          }
          return this.bobs[name];
        }
        return null;
      },
      getGO: function getGO(name, out) {
        var bob = this.get(name);
        if (!bob) {
          return null;
        } else if (!Array.isArray(bob)) {
          return bob.gameObject;
        } else {
          if (out === undefined) {
            out = [];
          }
          var bobs = bob;
          bobs.forEach(function (bob) {
            out.push(bob.gameObject);
          });
          return out;
        }
      },
      forEachGO: function forEachGO(callback, scope) {
        for (var name in this.bobs) {
          var gameObject = this.bobs[name].gameObject;
          var stopLoop;
          if (scope) {
            stopLoop = callback.call(scope, gameObject, name, this);
          } else {
            stopLoop = callback(gameObject, name, this);
          }
          if (stopLoop) {
            break;
          }
        }
        return this;
      },
      getAllGO: function getAllGO(out) {
        if (out === undefined) {
          out = [];
        }
        for (var name in this.bobs) {
          var gameObject = this.bobs[name].gameObject;
          out.push(gameObject);
        }
        return out;
      }
    };
  
    var GetR = function GetR(colorInt) {
      return colorInt >> 16 & 0xff;
    };
    var GetG = function GetG(colorInt) {
      return colorInt >> 8 & 0xff;
    };
    var GetB = function GetB(colorInt) {
      return colorInt & 0xff;
    };
  
    var MaskR = ~(0xff << 16) & 0xffffff;
    var MaskG = ~(0xff << 8) & 0xffffff;
    var MaskB = ~0xff & 0xffffff;
    var SetR = function SetR(colorInt, r) {
      return (r & 0xff) << 16 | colorInt & MaskR;
    };
    var SetG = function SetG(colorInt, g) {
      return (g & 0xff) << 8 | colorInt & MaskG;
    };
    var SetB = function SetB(colorInt, b) {
      return b & 0xff | colorInt & MaskB;
    };
    var SetRGB = function SetRGB(colorInt, r, g, b) {
      return (r & 0xff) << 16 | (g & 0xff) << 8 | b & 0xff;
    };
  
    var AddTintRGBProperties = function AddTintRGBProperties(gameObject, tintRGB) {
      // Don't attach properties again
      if (gameObject.hasOwnProperty('tintR')) {
        return gameObject;
      }
      if (tintRGB === undefined) {
        tintRGB = 0xffffff;
      }
      var tintR = GetR(tintRGB);
      var tintG = GetG(tintRGB);
      var tintB = GetB(tintRGB);
  
      // Override tint property
      Object.defineProperty(gameObject, 'tint', {
        get: function get() {
          return tintRGB;
        },
        set: function set(value) {
          value = Math.floor(value) & 0xffffff;
          if (gameObject.setTint) {
            gameObject.setTint(value);
          }
          if (tintRGB !== value) {
            tintRGB = value;
            tintR = GetR(tintRGB);
            tintG = GetG(tintRGB);
            tintB = GetB(tintRGB);
            // gameObject.emit('_tintchange', value, tintR, tintG, tintB);
          }
        }
      });
      Object.defineProperty(gameObject, 'tintR', {
        get: function get() {
          return tintR;
        },
        set: function set(value) {
          value = Math.floor(value) & 0xff;
          if (tintR !== value) {
            tintR = value;
            gameObject.tint = SetR(tintRGB, value);
          }
        }
      });
      Object.defineProperty(gameObject, 'tintG', {
        get: function get() {
          return tintG;
        },
        set: function set(value) {
          value = Math.floor(value) & 0xff;
          if (tintG !== value) {
            tintG = value;
            gameObject.tint = SetG(tintRGB, value);
          }
        }
      });
      Object.defineProperty(gameObject, 'tintB', {
        get: function get() {
          return tintB;
        },
        set: function set(value) {
          value = Math.floor(value) & 0xff;
          if (tintB !== value) {
            tintB = value;
            gameObject.tint = SetB(tintRGB, value);
          }
        }
      });
      Object.defineProperty(gameObject, 'tintGray', {
        get: function get() {
          return Math.floor((tintR + tintG + tintB) / 3);
        },
        set: function set(value) {
          value = Math.floor(value) & 0xff;
          if (tintR !== value || tintG !== value || tintB !== value) {
            tintR = value;
            tintG = value;
            tintB = value;
            gameObject.tint = SetRGB(tintRGB, value, value, value);
          }
        }
      });
      gameObject.tint = tintRGB;
      return gameObject;
    };
  
    var EventEmitter$1 = Phaser.Events.EventEmitter;
    var MonitorViewport = function MonitorViewport(viewport) {
      // Don't monitor properties again
      if (viewport.events) {
        return viewport;
      }
      var events = new EventEmitter$1();
      var x = viewport.x;
      Object.defineProperty(viewport, 'x', {
        get: function get() {
          return x;
        },
        set: function set(value) {
          if (x !== value) {
            x = value;
            events.emit('update', viewport);
          }
        }
      });
      var y = viewport.y;
      Object.defineProperty(viewport, 'y', {
        get: function get() {
          return y;
        },
        set: function set(value) {
          if (y !== value) {
            y = value;
            events.emit('update', viewport);
          }
        }
      });
      var width = viewport.width;
      Object.defineProperty(viewport, 'width', {
        get: function get() {
          return width;
        },
        set: function set(value) {
          if (width !== value) {
            width = value;
            events.emit('update', viewport);
          }
        }
      });
      var height = viewport.height;
      Object.defineProperty(viewport, 'height', {
        get: function get() {
          return height;
        },
        set: function set(value) {
          if (height !== value) {
            height = value;
            events.emit('update', viewport);
          }
        }
      });
      viewport.events = events;
      return viewport;
    };
  
    var VPXYToXY = function VPXYToXY(vpx, vpy, vpxOffset, vpyOffset, viewport, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = GlobXY;
      }
      if (typeof vpxOffset !== 'number') {
        vpxOffset = 0;
        vpyOffset = 0;
      }
      out.x = viewport.x + viewport.width * vpx + vpxOffset;
      out.y = viewport.y + viewport.height * vpy + vpyOffset;
      return out;
    };
    var GlobXY = {};
  
    var AddViewportCoordinateProperties = function AddViewportCoordinateProperties(gameObject, viewport, vpx, vpy, vpxOffset, vpyOffset, transformCallback) {
      // Don't attach properties again
      if (gameObject.hasOwnProperty('vp')) {
        return gameObject;
      }
      if (typeof vpx === 'function') {
        transformCallback = vpx;
        vpx = undefined;
      }
      if (typeof vpxOffset === 'function') {
        transformCallback = vpxOffset;
        vpxOffset = undefined;
      }
      if (vpx === undefined) {
        vpx = 0.5;
      }
      if (vpy === undefined) {
        vpy = 0.5;
      }
      if (vpxOffset === undefined) {
        vpxOffset = 0;
      }
      if (vpyOffset === undefined) {
        vpyOffset = 0;
      }
      if (transformCallback === undefined) {
        transformCallback = VPXYToXY;
      }
      MonitorViewport(viewport);
      var events = viewport.events;
      gameObject.vp = viewport;
  
      // Set position of game object when view-port changed.
      var Transform = function Transform() {
        transformCallback(vpx, vpy, vpxOffset, vpyOffset, viewport, gameObject);
      };
      events.on('update', Transform);
      gameObject.once('destroy', function () {
        events.off('update', Transform);
        gameObject.vp = undefined;
      });
      Object.defineProperty(gameObject, 'vpx', {
        get: function get() {
          return vpx;
        },
        set: function set(value) {
          if (vpx !== value) {
            vpx = value;
            Transform();
          }
        }
      });
      Object.defineProperty(gameObject, 'vpy', {
        get: function get() {
          return vpy;
        },
        set: function set(value) {
          if (vpy !== value) {
            vpy = value;
            Transform();
          }
        }
      });
      Object.defineProperty(gameObject, 'vpxOffset', {
        get: function get() {
          return vpxOffset;
        },
        set: function set(value) {
          if (vpxOffset !== value) {
            vpxOffset = value;
            Transform();
          }
        }
      });
      Object.defineProperty(gameObject, 'vpyOffset', {
        get: function get() {
          return vpyOffset;
        },
        set: function set(value) {
          if (vpyOffset !== value) {
            vpyOffset = value;
            Transform();
          }
        }
      });
      Transform();
    };
  
    var GetFXFactory = function GetFXFactory(gameObject) {
      if (gameObject.preFX) {
        return gameObject.preFX;
      }
      if (gameObject.postFX) {
        return gameObject.postFX;
      }
      return null;
    };
  
    var AddClearEffectCallback = function AddClearEffectCallback(gameObject, effectSwitchName) {
      if (!gameObject._effectSwitchNames) {
        gameObject._effectSwitchNames = [];
        gameObject.clearAllEffects = function () {
          var effectSwitchNames = gameObject._effectSwitchNames;
          for (var i = 0, cnt = effectSwitchNames.length; i < cnt; i++) {
            gameObject[effectSwitchNames[i]] = null;
          }
          return gameObject;
        };
        gameObject.on('destroy', gameObject.clearAllEffects, gameObject);
      }
      gameObject._effectSwitchNames.push(effectSwitchName);
    };
  
    var AddBarrelProperties = function AddBarrelProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'barrel')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var barrel;
      Object.defineProperty(gameObject, 'barrel', {
        get: function get() {
          return barrel;
        },
        set: function set(value) {
          if (barrel === value) {
            return;
          }
          barrel = value;
          if (barrel === null || barrel === false) {
            if (gameObject._barrelEffect) {
              fxFactory.remove(gameObject._barrelEffect);
              gameObject._barrelEffect = undefined;
            }
          } else {
            if (!gameObject._barrelEffect) {
              gameObject._barrelEffect = fxFactory.addBarrel();
            }
            gameObject._barrelEffect.amount = barrel;
          }
        }
      });
      gameObject.barrel = null;
      AddClearEffectCallback(gameObject, 'barrel');
      return gameObject;
    };
  
    var AddColorMatrixEffectPropertiesBase = function AddColorMatrixEffectPropertiesBase(gameObject, effectName, inputMode) {
      // Don't attach properties again
      if (HasProperty(gameObject, effectName)) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var EffectInstancePropertyName = "_".concat(effectName, "Effect");
      var currentValue;
      Object.defineProperty(gameObject, effectName, {
        get: function get() {
          return currentValue;
        },
        set: function set(value) {
          if (currentValue === value) {
            return;
          }
          currentValue = value;
          if (currentValue === null || currentValue === false) {
            if (gameObject[EffectInstancePropertyName]) {
              fxFactory.remove(gameObject[EffectInstancePropertyName]);
              gameObject[EffectInstancePropertyName] = undefined;
            }
          } else {
            if (!gameObject[EffectInstancePropertyName]) {
              gameObject[EffectInstancePropertyName] = fxFactory.addColorMatrix();
            }
            var effectInstance = gameObject[EffectInstancePropertyName];
            effectInstance[effectName](inputMode === 1 ? value : undefined);
          }
        }
      });
      gameObject[effectName] = null;
      AddClearEffectCallback(gameObject, effectName);
      return gameObject;
    };
  
    var AddBlackWhiteProperties = function AddBlackWhiteProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'blackWhite');
      return gameObject;
    };
  
    var AddBloomProperties = function AddBloomProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'bloomColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var bloomColor,
        bloomOffsetX = 1,
        bloomOffsetY = 1,
        bloomBlurStrength = 1,
        bloomStrength = 1,
        bloomSteps = 4;
      Object.defineProperty(gameObject, 'bloomColor', {
        get: function get() {
          return bloomColor;
        },
        set: function set(value) {
          if (bloomColor === value) {
            return;
          }
          bloomColor = value;
          if (bloomColor === null || bloomColor === false) {
            if (gameObject._bloom) {
              fxFactory.remove(gameObject._bloom);
              gameObject._bloom = undefined;
              fxFactory.setPadding(0);
            }
          } else {
            if (!gameObject._bloom) {
              gameObject._bloom = fxFactory.addBloom(bloomColor, bloomOffsetX, bloomOffsetY, bloomBlurStrength, bloomStrength, bloomSteps);
              fxFactory.setPadding(Math.max(bloomOffsetX, bloomOffsetY) + 1);
            }
            gameObject._bloom.color = bloomColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'bloomOffsetX', {
        get: function get() {
          return bloomOffsetX;
        },
        set: function set(value) {
          if (bloomOffsetX === value) {
            return;
          }
          bloomOffsetX = value;
          if (gameObject._bloom) {
            var offset = Math.max(bloomOffsetX, bloomOffsetY);
            fxFactory.setPadding(offset + 1);
            gameObject._bloom.offsetX = bloomOffsetX;
          }
        }
      });
      Object.defineProperty(gameObject, 'bloomOffsetY', {
        get: function get() {
          return bloomOffsetY;
        },
        set: function set(value) {
          if (bloomOffsetY === value) {
            return;
          }
          bloomOffsetY = value;
          if (gameObject._bloom) {
            var offset = Math.max(bloomOffsetX, bloomOffsetY);
            fxFactory.setPadding(offset + 1);
            gameObject._bloom.offsetY = bloomOffsetY;
          }
        }
      });
      Object.defineProperty(gameObject, 'bloomBlurStrength', {
        get: function get() {
          return bloomBlurStrength;
        },
        set: function set(value) {
          if (bloomBlurStrength === value) {
            return;
          }
          bloomBlurStrength = value;
          if (gameObject._bloom) {
            gameObject._bloom.blurStrength = bloomBlurStrength;
          }
        }
      });
      Object.defineProperty(gameObject, 'bloomStrength', {
        get: function get() {
          return bloomStrength;
        },
        set: function set(value) {
          if (bloomStrength === value) {
            return;
          }
          bloomStrength = value;
          if (gameObject._bloom) {
            gameObject._bloom.strength = bloomStrength;
          }
        }
      });
      Object.defineProperty(gameObject, 'bloomSteps', {
        get: function get() {
          return bloomSteps;
        },
        set: function set(value) {
          if (bloomSteps === value) {
            return;
          }
          bloomSteps = value;
          if (gameObject._bloom) {
            gameObject._bloom.steps = bloomSteps;
          }
        }
      });
      gameObject.bloomColor = null;
      AddClearEffectCallback(gameObject, 'bloomColor');
      return gameObject;
    };
  
    var AddBlurProperties = function AddBlurProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'blurColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var blurColor,
        blurQuality = 0,
        blurX = 1,
        blurY = 1,
        blurStrength = 1,
        blurSteps = 4;
      Object.defineProperty(gameObject, 'blurColor', {
        get: function get() {
          return blurColor;
        },
        set: function set(value) {
          if (blurColor === value) {
            return;
          }
          blurColor = value;
          if (blurColor === null || blurColor === false) {
            if (gameObject._blur) {
              fxFactory.remove(gameObject._blur);
              gameObject._blur = undefined;
              fxFactory.setPadding(0);
            }
          } else {
            if (!gameObject._blur) {
              gameObject._blur = fxFactory.addBlur(blurQuality, blurX, blurY, blurStrength, blurColor, blurSteps);
              fxFactory.setPadding(Math.max(blurX, blurY) + 1);
            }
            gameObject._blur.color = blurColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'blurQuality', {
        get: function get() {
          return blurQuality;
        },
        set: function set(value) {
          if (blurQuality === value) {
            return;
          }
          blurQuality = value;
          if (gameObject._blur) {
            gameObject._blur.quality = blurQuality;
          }
        }
      });
      Object.defineProperty(gameObject, 'blurX', {
        get: function get() {
          return blurX;
        },
        set: function set(value) {
          if (blurX === value) {
            return;
          }
          blurX = value;
          if (gameObject._blur) {
            var offset = Math.max(blurX, blurY);
            fxFactory.setPadding(offset + 1);
            gameObject._blur.x = blurX;
          }
        }
      });
      Object.defineProperty(gameObject, 'blurY', {
        get: function get() {
          return blurY;
        },
        set: function set(value) {
          if (blurY === value) {
            return;
          }
          blurY = value;
          if (gameObject._blur) {
            var offset = Math.max(blurX, blurY);
            fxFactory.setPadding(offset + 1);
            gameObject._blur.y = blurY;
          }
        }
      });
      Object.defineProperty(gameObject, 'blurStrength', {
        get: function get() {
          return blurStrength;
        },
        set: function set(value) {
          if (blurStrength === value) {
            return;
          }
          blurStrength = value;
          if (gameObject._blur) {
            gameObject._blur.strength = blurStrength;
          }
        }
      });
      Object.defineProperty(gameObject, 'blurSteps', {
        get: function get() {
          return blurSteps;
        },
        set: function set(value) {
          if (blurSteps === value) {
            return;
          }
          blurSteps = value;
          if (gameObject._blur) {
            gameObject._blur.steps = blurSteps;
          }
        }
      });
      gameObject.blurColor = null;
      AddClearEffectCallback(gameObject, 'blurColor');
      return gameObject;
    };
  
    var AddBokehProperties = function AddBokehProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'bokehRadius')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var bokehRadius,
        bokehAmount = 1,
        bokehContrast = 0.2;
      Object.defineProperty(gameObject, 'bokehRadius', {
        get: function get() {
          return bokehRadius;
        },
        set: function set(value) {
          if (bokehRadius === value) {
            return;
          }
          bokehRadius = value;
          if (bokehRadius === null || bokehRadius === false) {
            if (gameObject._bokeh) {
              fxFactory.remove(gameObject._bokeh);
              gameObject._bokeh = undefined;
            }
          } else {
            if (!gameObject._bokeh) {
              gameObject._bokeh = fxFactory.addBokeh(bokehRadius, bokehAmount, bokehContrast);
            }
            gameObject._bokeh.radius = bokehRadius;
          }
        }
      });
      Object.defineProperty(gameObject, 'bokehAmount', {
        get: function get() {
          return bokehAmount;
        },
        set: function set(value) {
          if (bokehAmount === value) {
            return;
          }
          bokehAmount = value;
          if (gameObject._bokeh) {
            gameObject._bokeh.amount = bokehAmount;
          }
        }
      });
      Object.defineProperty(gameObject, 'bokehContrast', {
        get: function get() {
          return bokehContrast;
        },
        set: function set(value) {
          if (bokehContrast === value) {
            return;
          }
          bokehContrast = value;
          if (gameObject._bokeh) {
            gameObject._bokeh.contrast = bokehContrast;
          }
        }
      });
      gameObject.bokehRadius = null;
      AddClearEffectCallback(gameObject, 'bokehRadius');
      return gameObject;
    };
  
    var AddBrightnessProperties = function AddBrightnessProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'brightness', 1);
      return gameObject;
    };
  
    var AddBrownProperties = function AddBrownProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'brown');
      return gameObject;
    };
  
    var AddCircleProperties = function AddCircleProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'circleColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var circleColor,
        circleThickness = 8,
        circleBackgroundColor = 0x000000,
        circleBackgroundAlpha = 0.4,
        circleScale = 1,
        circleFeather = 0.005;
      Object.defineProperty(gameObject, 'circleColor', {
        get: function get() {
          return circleColor;
        },
        set: function set(value) {
          if (circleColor === value) {
            return;
          }
          circleColor = value;
          if (circleColor === null || circleColor === false) {
            if (gameObject._circle) {
              fxFactory.remove(gameObject._circle);
              gameObject._circle = undefined;
            }
          } else {
            if (!gameObject._circle) {
              gameObject._circle = fxFactory.addCircle(circleThickness, circleColor, circleBackgroundColor, circleScale, circleFeather);
              gameObject.circleBackgroundAlpha = circleBackgroundAlpha;
            }
            gameObject._circle.color = circleColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'circleThickness', {
        get: function get() {
          return circleThickness;
        },
        set: function set(value) {
          if (circleThickness === value) {
            return;
          }
          circleThickness = value;
          if (gameObject._circle) {
            gameObject._circle.thickness = circleThickness;
          }
        }
      });
      Object.defineProperty(gameObject, 'circleBackgroundColor', {
        get: function get() {
          return circleBackgroundColor;
        },
        set: function set(value) {
          if (circleBackgroundColor === value) {
            return;
          }
          circleBackgroundColor = value;
          if (gameObject._circle) {
            gameObject._circle.backgroundColor = circleBackgroundColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'circleBackgroundAlpha', {
        get: function get() {
          return circleBackgroundAlpha;
        },
        set: function set(value) {
          if (circleBackgroundAlpha === value) {
            return;
          }
          circleBackgroundAlpha = value;
          if (gameObject._circle) {
            gameObject._circle.glcolor2[3] = circleBackgroundAlpha;
          }
        }
      });
      Object.defineProperty(gameObject, 'circleScale', {
        get: function get() {
          return circleScale;
        },
        set: function set(value) {
          if (circleScale === value) {
            return;
          }
          circleScale = value;
          if (gameObject._circle) {
            gameObject._circle.scale = circleScale;
          }
        }
      });
      Object.defineProperty(gameObject, 'circleFeather', {
        get: function get() {
          return circleFeather;
        },
        set: function set(value) {
          if (circleFeather === value) {
            return;
          }
          circleFeather = value;
          if (gameObject._circle) {
            gameObject._circle.feather = circleFeather;
          }
        }
      });
      gameObject.circleColor = null;
      AddClearEffectCallback(gameObject, 'circleColor');
      return gameObject;
    };
  
    var AddContrastProperties = function AddContrastProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'contrast', 1);
      return gameObject;
    };
  
    var AddDesaturateProperties = function AddDesaturateProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'desaturate', 1);
      return gameObject;
    };
  
    var AddDesaturateLuminanceProperties = function AddDesaturateLuminanceProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'desaturateLuminance');
      return gameObject;
    };
  
    var AddDisplacementProperties = function AddDisplacementProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'displacementKey')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var displacementKey,
        displacementX = 0.005,
        displacementY = 0.005;
      Object.defineProperty(gameObject, 'displacementKey', {
        get: function get() {
          return displacementKey;
        },
        set: function set(value) {
          if (displacementKey === value) {
            return;
          }
          displacementKey = value;
          if (displacementKey === null || displacementKey === false) {
            if (gameObject._displacement) {
              fxFactory.remove(gameObject._displacement);
              gameObject._displacement = undefined;
            }
          } else {
            if (!gameObject._displacement) {
              gameObject._displacement = fxFactory.addDisplacement(displacementKey, displacementX, displacementY);
            }
            gameObject._displacement.setTexture(displacementKey);
          }
        }
      });
      Object.defineProperty(gameObject, 'displacementX', {
        get: function get() {
          return displacementX;
        },
        set: function set(value) {
          if (displacementX === value) {
            return;
          }
          displacementX = value;
          if (gameObject._displacement) {
            gameObject._displacement.x = displacementX;
          }
        }
      });
      Object.defineProperty(gameObject, 'displacementY', {
        get: function get() {
          return displacementY;
        },
        set: function set(value) {
          if (displacementY === value) {
            return;
          }
          displacementY = value;
          if (gameObject._displacement) {
            gameObject._displacement.y = displacementY;
          }
        }
      });
      gameObject.displacementKey = null;
      AddClearEffectCallback(gameObject, 'displacementKey');
      return gameObject;
    };
  
    var AddGlowProperties = function AddGlowProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'glowColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var glowColor,
        glowOuterStrength = 4,
        glowInnerStrength = 0;
      Object.defineProperty(gameObject, 'glowColor', {
        get: function get() {
          return glowColor;
        },
        set: function set(value) {
          if (glowColor === value) {
            return;
          }
          glowColor = value;
          if (glowColor === null || glowColor === false) {
            if (gameObject._glow) {
              fxFactory.remove(gameObject._glow);
              gameObject._glow = undefined;
              fxFactory.setPadding(0);
            }
          } else {
            if (!gameObject._glow) {
              gameObject._glow = fxFactory.addGlow(glowColor, glowOuterStrength, glowInnerStrength);
              fxFactory.setPadding(glowOuterStrength + 1);
            }
            gameObject._glow.color = glowColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'glowOuterStrength', {
        get: function get() {
          return glowOuterStrength;
        },
        set: function set(value) {
          if (glowOuterStrength === value) {
            return;
          }
          glowOuterStrength = value;
          if (gameObject._glow) {
            fxFactory.setPadding(glowOuterStrength + 1);
            gameObject._glow.outerStrength = glowOuterStrength;
          }
        }
      });
      Object.defineProperty(gameObject, 'glowInnerStrength', {
        get: function get() {
          return glowInnerStrength;
        },
        set: function set(value) {
          if (glowInnerStrength === value) {
            return;
          }
          glowInnerStrength = value;
          if (gameObject._glow) {
            gameObject._glow.innerStrength = glowInnerStrength;
          }
        }
      });
      gameObject.glowColor = null;
      AddClearEffectCallback(gameObject, 'glowColor');
      return gameObject;
    };
  
    var AddGradientProperties = function AddGradientProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'gradientColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var gradientColor1,
        gradientColor2,
        gradientAlpha = 0.5,
        gradientFromX = 0,
        gradientFromY = 0,
        gradientToX = 0,
        gradientToY = 1,
        gradientSize = 0;
      Object.defineProperty(gameObject, 'gradientColor', {
        get: function get() {
          return [gradientColor1, gradientColor2];
        },
        set: function set(value) {
          var color1, color2;
          if (value === null || value === false) {
            color1 = null;
            color2 = null;
          } else {
            color1 = value[0];
            color2 = value[1];
          }
          if (gradientColor1 === color1 && gradientColor2 === color2) {
            return;
          }
          gradientColor1 = color1;
          gradientColor2 = color2;
          if (gradientColor1 === null || gradientColor1 === false) {
            if (gameObject._gradient) {
              fxFactory.remove(gameObject._gradient);
              gameObject._gradient = undefined;
            }
          } else {
            if (!gameObject._gradient) {
              gameObject._gradient = fxFactory.addGradient(gradientColor1, gradientColor2, gradientAlpha, gradientFromX, gradientFromY, gradientToX, gradientToY, gradientSize);
            }
            gameObject._gradient.color1 = gradientColor1;
            gameObject._gradient.color2 = gradientColor2;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientColor1', {
        get: function get() {
          return gradientColor1;
        },
        set: function set(value) {
          if (value === null || value === false) {
            gameObject.gradientColor = value;
            return;
          }
          if (gradientColor1 === value) {
            return;
          }
          gradientColor1 = value;
          if (gameObject._gradient) {
            gameObject._gradient.color1 = gradientColor1;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientColor2', {
        get: function get() {
          return gradientColor2;
        },
        set: function set(value) {
          if (value === null || value === false) {
            gameObject.gradientColor = value;
            return;
          }
          if (gradientColor2 === value) {
            return;
          }
          gradientColor2 = value;
          if (gameObject._gradient) {
            gameObject._gradient.color2 = gradientColor2;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientAlpha', {
        get: function get() {
          return gradientAlpha;
        },
        set: function set(value) {
          if (gradientAlpha === value) {
            return;
          }
          gradientAlpha = value;
          if (gameObject._gradient) {
            gameObject._gradient.alpha = gradientAlpha;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientFromX', {
        get: function get() {
          return gradientFromX;
        },
        set: function set(value) {
          if (gradientFromX === value) {
            return;
          }
          gradientFromX = value;
          if (gameObject._gradient) {
            gameObject._gradient.fromX = gradientFromX;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientFromY', {
        get: function get() {
          return gradientFromY;
        },
        set: function set(value) {
          if (gradientFromY === value) {
            return;
          }
          gradientFromY = value;
          if (gameObject._gradient) {
            gameObject._gradient.fromY = gradientFromY;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientToX', {
        get: function get() {
          return gradientToX;
        },
        set: function set(value) {
          if (gradientToX === value) {
            return;
          }
          gradientToX = value;
          if (gameObject._gradient) {
            gameObject._gradient.toX = gradientToX;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientToY', {
        get: function get() {
          return gradientToY;
        },
        set: function set(value) {
          if (gradientToY === value) {
            return;
          }
          gradientToY = value;
          if (gameObject._gradient) {
            gameObject._gradient.toY = gradientToY;
          }
        }
      });
      Object.defineProperty(gameObject, 'gradientSize', {
        get: function get() {
          return gradientSize;
        },
        set: function set(value) {
          if (gradientSize === value) {
            return;
          }
          gradientSize = value;
          if (gameObject._gradient) {
            gameObject._gradient.size = gradientSize;
          }
        }
      });
      gameObject.gradientColor = null;
      AddClearEffectCallback(gameObject, 'gradientColor');
      return gameObject;
    };
  
    var AddGrayscaleProperties = function AddGrayscaleProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'grayscale', 1);
      return gameObject;
    };
  
    var AddHueProperties = function AddHueProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'hue', 1);
      return gameObject;
    };
  
    var AddKodachromeProperties = function AddKodachromeProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'kodachrome');
      return gameObject;
    };
  
    var AddLSDProperties = function AddLSDProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'lsd');
      return gameObject;
    };
  
    var AddNegativeProperties = function AddNegativeProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'negative');
      return gameObject;
    };
  
    var AddPixelateProperties = function AddPixelateProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'pixelate')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var pixelate;
      Object.defineProperty(gameObject, 'pixelate', {
        get: function get() {
          return pixelate;
        },
        set: function set(value) {
          if (pixelate === value) {
            return;
          }
          pixelate = value;
          if (pixelate === null || pixelate === false) {
            if (gameObject._pixelateEffect) {
              fxFactory.remove(gameObject._pixelateEffect);
              gameObject._pixelateEffect = undefined;
            }
          } else {
            if (!gameObject._pixelateEffect) {
              gameObject._pixelateEffect = fxFactory.addPixelate();
            }
            gameObject._pixelateEffect.amount = pixelate;
          }
        }
      });
      gameObject.pixelate = null;
      AddClearEffectCallback(gameObject, 'pixelate');
      return gameObject;
    };
  
    var AddPolaroidProperties = function AddPolaroidProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'polaroid');
      return gameObject;
    };
  
    var AddRevealProperties = function AddRevealProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'revealLeft')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var revealLeft,
        revealRight,
        revealUp,
        revealDown,
        revealWidth = 0.1;
      var ClearRevealFlags = function ClearRevealFlags() {
        revealLeft = null;
        revealRight = null;
        revealUp = null;
        revealDown = null;
      };
      var RemoveEffect = function RemoveEffect(gameObject) {
        if (gameObject._revealEffect) {
          fxFactory.remove(gameObject._revealEffect);
          gameObject._revealEffect = undefined;
        }
      };
      Object.defineProperty(gameObject, 'revealLeft', {
        get: function get() {
          return revealLeft;
        },
        set: function set(value) {
          if (revealLeft === value) {
            return;
          }
          ClearRevealFlags();
          revealLeft = value;
          if (revealLeft === null || revealLeft === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._revealEffect) {
              gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
            }
            gameObject._revealEffect.direction = 1;
            gameObject._revealEffect.axis = 0;
            gameObject._revealEffect.progress = revealLeft;
          }
        }
      });
      Object.defineProperty(gameObject, 'revealRight', {
        get: function get() {
          return revealRight;
        },
        set: function set(value) {
          if (revealRight === value) {
            return;
          }
          ClearRevealFlags();
          revealRight = value;
          if (revealRight === null || revealRight === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._revealEffect) {
              gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
            }
            gameObject._revealEffect.direction = 0;
            gameObject._revealEffect.axis = 0;
            gameObject._revealEffect.progress = revealRight;
          }
        }
      });
      Object.defineProperty(gameObject, 'revealUp', {
        get: function get() {
          return revealUp;
        },
        set: function set(value) {
          if (revealUp === value) {
            return;
          }
          ClearRevealFlags();
          revealUp = value;
          if (revealUp === null || revealUp === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._revealEffect) {
              gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
            }
            gameObject._revealEffect.direction = 1;
            gameObject._revealEffect.axis = 1;
            gameObject._revealEffect.progress = revealUp;
          }
        }
      });
      Object.defineProperty(gameObject, 'revealDown', {
        get: function get() {
          return revealDown;
        },
        set: function set(value) {
          if (revealDown === value) {
            return;
          }
          ClearRevealFlags();
          revealDown = value;
          if (revealDown === null || revealDown === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._revealEffect) {
              gameObject._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
            }
            gameObject._revealEffect.direction = 0;
            gameObject._revealEffect.axis = 1;
            gameObject._revealEffect.progress = revealDown;
          }
        }
      });
      Object.defineProperty(gameObject, 'revealWidth', {
        get: function get() {
          return revealWidth;
        },
        set: function set(value) {
          if (revealWidth === value) {
            return;
          }
          revealWidth = value;
          if (gameObject._revealEffect) {
            gameObject._revealEffect.wipeWidth = revealWidth;
          }
        }
      });
      gameObject.revealLeft = null;
      AddClearEffectCallback(gameObject, 'revealLeft');
      AddClearEffectCallback(gameObject, 'revealRight');
      AddClearEffectCallback(gameObject, 'revealUp');
      AddClearEffectCallback(gameObject, 'revealDown');
      return gameObject;
    };
  
    var AddSaturateProperties = function AddSaturateProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'saturate', 1);
      return gameObject;
    };
  
    var AddSepiaProperties = function AddSepiaProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'sepia');
      return gameObject;
    };
  
    var AddShadowProperties = function AddShadowProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'shadowColor')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var shadowColor,
        shadowX = 0,
        shadowY = 0,
        shadowDecay = 0.1,
        shadowPower = 1,
        shadowSamples = 6,
        shadowIntensity = 1;
      Object.defineProperty(gameObject, 'shadowColor', {
        get: function get() {
          return shadowColor;
        },
        set: function set(value) {
          if (shadowColor === value) {
            return;
          }
          shadowColor = value;
          if (shadowColor === null || shadowColor === false) {
            if (gameObject._shadow) {
              fxFactory.remove(gameObject._shadow);
              gameObject._shadow = undefined;
            }
          } else {
            if (!gameObject._shadow) {
              gameObject._shadow = fxFactory.addShadow(shadowX, shadowY, shadowDecay, shadowPower, shadowColor, shadowSamples, shadowIntensity);
            }
            gameObject._shadow.color = shadowColor;
          }
        }
      });
      Object.defineProperty(gameObject, 'shadowX', {
        get: function get() {
          return shadowX;
        },
        set: function set(value) {
          if (shadowX === value) {
            return;
          }
          shadowX = value;
          if (gameObject._shadow) {
            gameObject._shadow.x = shadowX;
          }
        }
      });
      Object.defineProperty(gameObject, 'shadowY', {
        get: function get() {
          return shadowY;
        },
        set: function set(value) {
          if (shadowY === value) {
            return;
          }
          shadowY = value;
          if (gameObject._shadow) {
            gameObject._shadow.y = shadowY;
          }
        }
      });
      Object.defineProperty(gameObject, 'decay', {
        get: function get() {
          return shadowDecay;
        },
        set: function set(value) {
          if (shadowDecay === value) {
            return;
          }
          shadowDecay = value;
          if (gameObject._shadow) {
            gameObject._shadow.decay = shadowDecay;
          }
        }
      });
      Object.defineProperty(gameObject, 'shadowPower', {
        get: function get() {
          return shadowPower;
        },
        set: function set(value) {
          if (shadowPower === value) {
            return;
          }
          shadowPower = value;
          if (gameObject._shadow) {
            gameObject._shadow.power = shadowPower;
          }
        }
      });
      Object.defineProperty(gameObject, 'shadowSamples', {
        get: function get() {
          return shadowSamples;
        },
        set: function set(value) {
          if (shadowSamples === value) {
            return;
          }
          shadowSamples = value;
          if (gameObject._shadow) {
            gameObject._shadow.samples = shadowSamples;
          }
        }
      });
      Object.defineProperty(gameObject, 'shadowIntensity', {
        get: function get() {
          return shadowIntensity;
        },
        set: function set(value) {
          if (shadowIntensity === value) {
            return;
          }
          shadowIntensity = value;
          if (gameObject._shadow) {
            gameObject._shadow.intensity = shadowIntensity;
          }
        }
      });
      gameObject.shadowColor = null;
      AddClearEffectCallback(gameObject, 'shadowColor');
      return gameObject;
    };
  
    var AddShiftToBGRProperties = function AddShiftToBGRProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'shiftToBGR');
      return gameObject;
    };
  
    var AddShineProperties = function AddShineProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'shineSpeed')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var shineSpeed,
        shineLineWidth = 0.5,
        shineGradient = 3;
      Object.defineProperty(gameObject, 'shineSpeed', {
        get: function get() {
          return shineSpeed;
        },
        set: function set(value) {
          if (shineSpeed === value) {
            return;
          }
          shineSpeed = value;
          if (shineSpeed === null || shineSpeed === false) {
            if (gameObject._shine) {
              fxFactory.remove(gameObject._shine);
              gameObject._shine = undefined;
            }
          } else {
            if (!gameObject._shine) {
              gameObject._shine = fxFactory.addShine(shineSpeed, shineLineWidth, shineGradient);
            }
            gameObject._shine.speed = shineSpeed;
          }
        }
      });
      Object.defineProperty(gameObject, 'shineLineWidth', {
        get: function get() {
          return shineLineWidth;
        },
        set: function set(value) {
          if (shineLineWidth === value) {
            return;
          }
          shineLineWidth = value;
          if (gameObject._shine) {
            gameObject._shine.lineWidth = shineLineWidth;
          }
        }
      });
      Object.defineProperty(gameObject, 'shineGradient', {
        get: function get() {
          return shineGradient;
        },
        set: function set(value) {
          if (shineGradient === value) {
            return;
          }
          shineGradient = value;
          if (gameObject._shine) {
            gameObject._shine.gradient = shineGradient;
          }
        }
      });
      gameObject.shineSpeed = null;
      AddClearEffectCallback(gameObject, 'shineSpeed');
      return gameObject;
    };
  
    var AddTechnicolorProperties = function AddTechnicolorProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'technicolor');
      return gameObject;
    };
  
    var AddTiltShiftProperties = function AddTiltShiftProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'tiltShiftRadius')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var tiltShiftRadius,
        tiltShiftAmount = 1,
        tiltShiftContrast = 0.2,
        tiltShiftBlurX = 1,
        tiltShiftBlurY = 1,
        tiltShiftStrength = 1;
      Object.defineProperty(gameObject, 'tiltShiftRadius', {
        get: function get() {
          return tiltShiftRadius;
        },
        set: function set(value) {
          if (tiltShiftRadius === value) {
            return;
          }
          tiltShiftRadius = value;
          if (tiltShiftRadius === null || tiltShiftRadius === false) {
            if (gameObject._tiltShift) {
              fxFactory.remove(gameObject._tiltShift);
              gameObject._tiltShift = undefined;
            }
          } else {
            if (!gameObject._tiltShift) {
              gameObject._tiltShift = fxFactory.addTiltShift(tiltShiftRadius, tiltShiftAmount, tiltShiftContrast, tiltShiftBlurX, tiltShiftBlurY, tiltShiftStrength);
            }
            gameObject._tiltShift.radius = tiltShiftRadius;
          }
        }
      });
      Object.defineProperty(gameObject, 'tiltShiftAmount', {
        get: function get() {
          return tiltShiftAmount;
        },
        set: function set(value) {
          if (tiltShiftAmount === value) {
            return;
          }
          tiltShiftAmount = value;
          if (gameObject._tiltShift) {
            gameObject._tiltShift.amount = tiltShiftAmount;
          }
        }
      });
      Object.defineProperty(gameObject, 'tiltShiftContrast', {
        get: function get() {
          return tiltShiftContrast;
        },
        set: function set(value) {
          if (tiltShiftContrast === value) {
            return;
          }
          tiltShiftContrast = value;
          if (gameObject._tiltShift) {
            gameObject._tiltShift.contrast = tiltShiftContrast;
          }
        }
      });
      Object.defineProperty(gameObject, 'tiltShiftBlurX', {
        get: function get() {
          return tiltShiftBlurX;
        },
        set: function set(value) {
          if (tiltShiftBlurX === value) {
            return;
          }
          tiltShiftBlurX = value;
          if (gameObject._tiltShift) {
            gameObject._tiltShift.blurX = tiltShiftBlurX;
          }
        }
      });
      Object.defineProperty(gameObject, 'tiltShiftBlurY', {
        get: function get() {
          return tiltShiftBlurY;
        },
        set: function set(value) {
          if (tiltShiftBlurY === value) {
            return;
          }
          tiltShiftBlurY = value;
          if (gameObject._tiltShift) {
            gameObject._tiltShift.blurY = tiltShiftBlurY;
          }
        }
      });
      Object.defineProperty(gameObject, 'tiltShiftStrength', {
        get: function get() {
          return tiltShiftStrength;
        },
        set: function set(value) {
          if (tiltShiftStrength === value) {
            return;
          }
          tiltShiftStrength = value;
          if (gameObject._tiltShift) {
            gameObject._tiltShift.strength = tiltShiftStrength;
          }
        }
      });
      gameObject.tiltShiftRadius = null;
      AddClearEffectCallback(gameObject, 'tiltShiftRadius');
      return gameObject;
    };
  
    var AddVignetteProperties = function AddVignetteProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'vignetteRadius')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var vignetteRadius,
        vignetteX = 0.5,
        vignetteY = 0.5,
        vignetteStrength = 0.5;
      Object.defineProperty(gameObject, 'vignetteRadius', {
        get: function get() {
          return vignetteRadius;
        },
        set: function set(value) {
          if (vignetteRadius === value) {
            return;
          }
          vignetteRadius = value;
          if (vignetteRadius === null || vignetteRadius === false) {
            if (gameObject._vignette) {
              fxFactory.remove(gameObject._vignette);
              gameObject._vignette = undefined;
            }
          } else {
            if (!gameObject._vignette) {
              gameObject._vignette = fxFactory.addVignette(vignetteX, vignetteY, vignetteRadius, vignetteStrength);
            }
            gameObject._vignette.radius = vignetteRadius;
          }
        }
      });
      Object.defineProperty(gameObject, 'vignetteX', {
        get: function get() {
          return vignetteX;
        },
        set: function set(value) {
          if (vignetteX === value) {
            return;
          }
          vignetteX = value;
          if (gameObject._vignette) {
            gameObject._vignette.x = vignetteX;
          }
        }
      });
      Object.defineProperty(gameObject, 'vignetteY', {
        get: function get() {
          return vignetteY;
        },
        set: function set(value) {
          if (vignetteY === value) {
            return;
          }
          vignetteY = value;
          if (gameObject._vignette) {
            gameObject._vignette.y = vignetteY;
          }
        }
      });
      Object.defineProperty(gameObject, 'vignetteStrength', {
        get: function get() {
          return vignetteStrength;
        },
        set: function set(value) {
          if (vignetteStrength === value) {
            return;
          }
          vignetteStrength = value;
          if (gameObject._vignette) {
            gameObject._vignette.strength = vignetteStrength;
          }
        }
      });
      gameObject.vignetteRadius = null;
      AddClearEffectCallback(gameObject, 'vignetteRadius');
      return gameObject;
    };
  
    var AddVintagePinholeProperties = function AddVintagePinholeProperties(gameObject) {
      AddColorMatrixEffectPropertiesBase(gameObject, 'vintagePinhole');
      return gameObject;
    };
  
    var AddWipeProperties = function AddWipeProperties(gameObject) {
      // Don't attach properties again
      if (HasProperty(gameObject, 'wipeLeft')) {
        return gameObject;
      }
      var fxFactory = GetFXFactory(gameObject);
      if (!fxFactory) {
        return gameObject;
      }
      var wipeLeft,
        wipeRight,
        wipeUp,
        wipeDown,
        wipeWidth = 0.1;
      var ClearWipeFlags = function ClearWipeFlags() {
        wipeLeft = null;
        wipeRight = null;
        wipeUp = null;
        wipeDown = null;
      };
      var RemoveEffect = function RemoveEffect(gameObject) {
        if (gameObject._wipeEffect) {
          fxFactory.remove(gameObject._wipeEffect);
          gameObject._wipeEffect = undefined;
        }
      };
      Object.defineProperty(gameObject, 'wipeLeft', {
        get: function get() {
          return wipeLeft;
        },
        set: function set(value) {
          if (wipeLeft === value) {
            return;
          }
          ClearWipeFlags();
          wipeLeft = value;
          if (wipeLeft === null || wipeLeft === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._wipeEffect) {
              gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
            }
            gameObject._wipeEffect.direction = 1;
            gameObject._wipeEffect.axis = 0;
            gameObject._wipeEffect.progress = wipeLeft;
          }
        }
      });
      Object.defineProperty(gameObject, 'wipeRight', {
        get: function get() {
          return wipeRight;
        },
        set: function set(value) {
          if (wipeRight === value) {
            return;
          }
          ClearWipeFlags();
          wipeRight = value;
          if (wipeRight === null || wipeRight === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._wipeEffect) {
              gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
            }
            gameObject._wipeEffect.direction = 0;
            gameObject._wipeEffect.axis = 0;
            gameObject._wipeEffect.progress = wipeRight;
          }
        }
      });
      Object.defineProperty(gameObject, 'wipeUp', {
        get: function get() {
          return wipeUp;
        },
        set: function set(value) {
          if (wipeUp === value) {
            return;
          }
          ClearWipeFlags();
          wipeUp = value;
          if (wipeUp === null || wipeUp === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._wipeEffect) {
              gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
            }
            gameObject._wipeEffect.direction = 1;
            gameObject._wipeEffect.axis = 1;
            gameObject._wipeEffect.progress = wipeUp;
          }
        }
      });
      Object.defineProperty(gameObject, 'wipeDown', {
        get: function get() {
          return wipeDown;
        },
        set: function set(value) {
          if (wipeDown === value) {
            return;
          }
          ClearWipeFlags();
          wipeDown = value;
          if (wipeDown === null || wipeDown === false) {
            RemoveEffect(gameObject);
          } else {
            if (!gameObject._wipeEffect) {
              gameObject._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
            }
            gameObject._wipeEffect.direction = 0;
            gameObject._wipeEffect.axis = 1;
            gameObject._wipeEffect.progress = wipeDown;
          }
        }
      });
      Object.defineProperty(gameObject, 'wipeWidth', {
        get: function get() {
          return wipeWidth;
        },
        set: function set(value) {
          if (wipeWidth === value) {
            return;
          }
          wipeWidth = value;
          if (gameObject._wipeEffect) {
            gameObject._wipeEffect.wipeWidth = wipeWidth;
          }
        }
      });
      gameObject.wipeLeft = null;
      AddClearEffectCallback(gameObject, 'wipeLeft');
      AddClearEffectCallback(gameObject, 'wipeRight');
      AddClearEffectCallback(gameObject, 'wipeUp');
      AddClearEffectCallback(gameObject, 'wipeDown');
      return gameObject;
    };
  
    var EffectMap = {
      barrel: AddBarrelProperties,
      blackWhite: AddBlackWhiteProperties,
      bloom: AddBloomProperties,
      blur: AddBlurProperties,
      bokeh: AddBokehProperties,
      brightness: AddBrightnessProperties,
      brown: AddBrownProperties,
      circle: AddCircleProperties,
      contrast: AddContrastProperties,
      desaturate: AddDesaturateProperties,
      desaturateLuminance: AddDesaturateLuminanceProperties,
      displacement: AddDisplacementProperties,
      glow: AddGlowProperties,
      gradient: AddGradientProperties,
      grayscale: AddGrayscaleProperties,
      hue: AddHueProperties,
      kodachrome: AddKodachromeProperties,
      lsd: AddLSDProperties,
      negative: AddNegativeProperties,
      pixelate: AddPixelateProperties,
      polaroid: AddPolaroidProperties,
      reveal: AddRevealProperties,
      saturate: AddSaturateProperties,
      sepia: AddSepiaProperties,
      shadow: AddShadowProperties,
      shiftToBGR: AddShiftToBGRProperties,
      shine: AddShineProperties,
      technicolor: AddTechnicolorProperties,
      tiltShift: AddTiltShiftProperties,
      vignette: AddVignetteProperties,
      vintagePinhole: AddVintagePinholeProperties,
      wipe: AddWipeProperties
    };
  
    var AddEffectProperties = function AddEffectProperties(gameObject, config) {
      if (config === undefined) {
        config = true;
      } else if (typeof config === 'string') {
        config = {
          config: true
        };
      } else if (Array.isArray(config)) {
        var nameList = config;
        var config = {};
        for (var i = 0, cnt = nameList.length; i < cnt; i++) {
          config[nameList[i]] = true;
        }
      }
      if (config === true) {
        // Enable all effect properties
        for (var name in EffectMap) {
          EffectMap[name](gameObject);
        }
      } else {
        for (var name in config) {
          if (config[name] && EffectMap[name]) {
            EffectMap[name](gameObject);
          }
        }
      }
      return gameObject;
    };
  
    var RemoveItem$b = Phaser.Utils.Array.Remove;
    var AddMethods$1 = {
      addGO: function addGO(name, gameObject) {
        this.remove(name, true);
        if (this.useTintFadeEffect(gameObject)) {
          AddTintRGBProperties(gameObject);
        }
        if (this.viewportCoordinateEnable) {
          AddViewportCoordinateProperties(gameObject, this.viewport);
        }
        if (this.effectPropertiesConfig) {
          AddEffectProperties(gameObject, this.effectPropertiesConfig);
        }
        gameObject.setName(name).once('destroy', function () {
          RemoveItem$b(this.removedGOs, gameObject);
          if (this.isEmpty) {
            this.emit('empty');
          }
        }, this);
        var bob = new this.BobClass(this, gameObject, name);
        this.bobs[name] = bob;
        return this;
      },
      add: function add(name) {
        var callback = this.createGameObjectCallback;
        var scope = this.createGameObjectScope;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var gameObject = callback.call.apply(callback, [scope, this.scene].concat(args));
        this.addGO(name, gameObject);
        if (this.gameObjectDepth != null) {
          // Not undefined, null
          gameObject.setDepth(this.gameObjectDepth);
        }
        var bob = this.get(name);
        this.fadeBob(bob, 0, 1);
        return this;
      }
    };
  
    var RemoveMethods$1 = {
      remove: function remove(name, ignoreFade) {
        var bobs = this.get(name);
        if (!bobs) {
          return this;
        } else if (!Array.isArray(bobs)) {
          bobs = [bobs];
        }
        var self = this;
        bobs.forEach(function (bob) {
          delete self.bobs[bob.name];
          var gameObject = bob.gameObject;
          self.removedGOs.push(gameObject);
          gameObject.setName();
          if (!ignoreFade) {
            self.fadeBob(bob,
            // bob
            undefined,
            // fromValue
            0,
            // toValue
            function () {
              // onComplete
              bob.destroy();
            });
          } else {
            bob.destroy();
          }
        });
        return this;
      },
      removeAll: function removeAll() {
        var bobs = this.bobs;
        for (var name in bobs) {
          this.remove(name);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        if (destroyChild === undefined) {
          destroyChild = true;
        }
        var bobs = this.bobs;
        for (var name in bobs) {
          if (destroyChild) {
            bobs[name].destroy();
          }
          delete bobs[name];
        }
        this.removedGOs.length = 0;
        return this;
      }
    };
  
    var PropertyMethods = {
      hasProperty: function hasProperty(name, property) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return false;
        }
        return bob.hasProperty(property);
      },
      getProperty: function getProperty(name, property) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return undefined;
        }
        return bob.getProperty(property);
      },
      isNumberProperty: function isNumberProperty(name, property) {
        var value = this.getProperty(name, property);
        return typeof value === 'number';
      },
      setProperty: function setProperty(name, property, value) {
        var bobs = this.get(name);
        if (!bobs) {
          return this;
        } else if (!Array.isArray(bobs)) {
          bobs = [bobs];
        }
        if (this.symbols && typeof value === 'string' && this.isNumberProperty(name, property)) {
          if (value in this.symbols) {
            value = this.symbols[value];
          } else {
            console.warn("Can't find symbol ".concat(value));
          }
        }
        bobs.forEach(function (bob) {
          bob.setProperty(property, value);
        });
        return this;
      },
      easeProperty: function easeProperty(name, config) {
        var bobs = this.get(name);
        if (!bobs) {
          return this;
        } else if (!Array.isArray(bobs)) {
          bobs = [bobs];
        }
        var value = config.value;
        var property = config.property;
        if (this.symbols && typeof value === 'string' && this.isNumberProperty(name, property) && value in this.symbols) {
          config.value = this.symbols[value];
        }
        bobs.forEach(function (bob) {
          bob.easeProperty(config);
        });
        return this;
      },
      hasTweenTask: function hasTweenTask(name, property) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return false;
        }
        return bob.tweens.hasOwnProperty(property);
      },
      getTweenTask: function getTweenTask(name, property) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return null;
        }
        return bob.tweens[property] || null;
      }
    };
  
    var CallMethods = {
      hasMethod: function hasMethod(name, methodName) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return false;
        }
        return bob.hasMethod(methodName);
      },
      call: function call(name, methodName) {
        for (var _len = arguments.length, parameters = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          parameters[_key - 2] = arguments[_key];
        }
        var bobs = this.get(name);
        if (!bobs) {
          return this;
        } else if (!Array.isArray(bobs)) {
          bobs = [bobs];
        }
        bobs.forEach(function (bob) {
          bob.call.apply(bob, [methodName].concat(parameters));
        });
        return this;
      }
    };
  
    var DataMethods = {
      hasData: function hasData(name, dataKey) {
        var bob = IsSingleBob(name) ? this.get(name) : this.getFitst(name);
        if (!bob) {
          return false;
        }
        return bob.hasData(dataKey);
      },
      getData: function getData(name, dataKey) {
        if (!this.has(name)) {
          return undefined;
        }
        return this.get(name).getData(dataKey);
      },
      setData: function setData(name, dataKey, value) {
        var bobs = this.get(name);
        if (!bobs) {
          return this;
        } else if (!Array.isArray(bobs)) {
          bobs = [bobs];
        }
        bobs.forEach(function (bob) {
          bob.setData(dataKey, value);
        });
        return this;
      }
    };
  
    var FadeTint = 0;
    var FadeAlpha = 1;
    var FadeRevealUp = 2;
    var FadeRevealDown = 3;
    var FadeRevealLeft = 4;
    var FadeRevealRight = 5;
    var FadeMode = {
      tint: FadeTint,
      alpha: FadeAlpha,
      revealUp: FadeRevealUp,
      revealDown: FadeRevealDown,
      revealLeft: FadeRevealLeft,
      revealRight: FadeRevealRight
    };
    var FadeMethods$1 = {
      setGOFadeMode: function setGOFadeMode(fadeMode) {
        if (typeof fadeMode === 'string') {
          fadeMode = FadeMode[fadeMode];
        }
        this.fadeMode = fadeMode;
        return this;
      },
      setGOFadeTime: function setGOFadeTime(time) {
        this.fadeTime = time;
        return this;
      },
      useTintFadeEffect: function useTintFadeEffect(gameObject) {
        return (this.fadeMode === undefined || this.fadeMode === FadeTint) && this.fadeTime > 0 && gameObject.setTint !== undefined;
      },
      useAlphaFadeEffect: function useAlphaFadeEffect(gameObject) {
        return (this.fadeMode === undefined || this.fadeMode === FadeAlpha) && this.fadeTime > 0 && gameObject.setAlpha !== undefined;
      },
      useRevealEffect: function useRevealEffect(gameObject) {
        return this.fadeMode >= FadeRevealUp && this.fadeMode <= FadeRevealRight && this.fadeTime > 0 && (gameObject.preFX || gameObject.postFX);
      },
      fadeBob: function fadeBob(bob, fromValue, toValue, onComplete) {
        var gameObject = bob.gameObject;
        if (this.useTintFadeEffect(gameObject)) {
          if (fromValue !== undefined) {
            bob.setProperty('tintGray', 255 * fromValue);
          }
          bob.easeProperty({
            property: 'tintGray',
            value: Math.floor(255 * toValue),
            duration: this.fadeTime,
            delay: 0,
            ease: 'Linear',
            repeat: 0,
            yoyo: false,
            from: false,
            complete: onComplete
          });
        } else if (this.useAlphaFadeEffect(gameObject)) {
          if (fromValue !== undefined) {
            bob.setProperty('alpha', fromValue);
          }
          bob.easeProperty({
            property: 'alpha',
            value: toValue,
            duration: this.fadeTime,
            delay: 0,
            ease: 'Linear',
            repeat: 0,
            yoyo: false,
            from: false,
            complete: onComplete
          });
        } else if (this.useRevealEffect(gameObject)) {
          AddEffectProperties(gameObject, 'reveal');
          var propertyName;
          switch (this.fadeMode) {
            case FadeRevealUp:
              propertyName = 'revealUp';
              break;
            case FadeRevealDown:
              propertyName = 'revealDown';
              break;
            case FadeRevealLeft:
              propertyName = 'revealLeft';
              break;
            case FadeRevealRight:
              propertyName = 'revealRight';
              break;
          }
          if (fromValue === undefined) {
            fromValue = 0;
          }
          gameObject[propertyName] = fromValue;
          bob.easeProperty({
            property: propertyName,
            value: toValue,
            duration: this.fadeTime,
            delay: 0,
            ease: 'Linear',
            repeat: 0,
            yoyo: false,
            from: false,
            complete: onComplete
          });
          bob.getTweenTask(propertyName).once('complete', function () {
            gameObject[propertyName] = null;
          });
        } else {
          if (onComplete) {
            onComplete(gameObject);
          }
        }
        return this;
      }
    };
  
    var GetDisplayWidth = function GetDisplayWidth(gameObject) {
      if (gameObject.displayWidth !== undefined) {
        return gameObject.displayWidth;
      } else {
        return gameObject.width;
      }
    };
    var GetDisplayHeight = function GetDisplayHeight(gameObject) {
      if (gameObject.displayHeight !== undefined) {
        return gameObject.displayHeight;
      } else {
        return gameObject.height;
      }
    };
  
    var Rectangle$4 = Phaser.Geom.Rectangle;
    var Vector2 = Phaser.Math.Vector2;
    var RotateAround$6 = Phaser.Math.RotateAround;
    var GetBounds = function GetBounds(gameObject, output) {
      if (output === undefined) {
        output = new Rectangle$4();
      } else if (output === true) {
        if (GlobRect$2 === undefined) {
          GlobRect$2 = new Rectangle$4();
        }
        output = GlobRect$2;
      }
      if (gameObject.getBounds) {
        return gameObject.getBounds(output);
      }
  
      //  We can use the output object to temporarily store the x/y coords in:
  
      var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
  
      // Instead of doing a check if parent container is
      // defined per corner we only do it once.
      if (gameObject.parentContainer) {
        var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
        GetTopLeft(gameObject, output);
        parentMatrix.transformPoint(output.x, output.y, output);
        TLx = output.x;
        TLy = output.y;
        GetTopRight(gameObject, output);
        parentMatrix.transformPoint(output.x, output.y, output);
        TRx = output.x;
        TRy = output.y;
        GetBottomLeft(gameObject, output);
        parentMatrix.transformPoint(output.x, output.y, output);
        BLx = output.x;
        BLy = output.y;
        GetBottomRight(gameObject, output);
        parentMatrix.transformPoint(output.x, output.y, output);
        BRx = output.x;
        BRy = output.y;
      } else {
        GetTopLeft(gameObject, output);
        TLx = output.x;
        TLy = output.y;
        GetTopRight(gameObject, output);
        TRx = output.x;
        TRy = output.y;
        GetBottomLeft(gameObject, output);
        BLx = output.x;
        BLy = output.y;
        GetBottomRight(gameObject, output);
        BRx = output.x;
        BRy = output.y;
      }
      output.x = Math.min(TLx, TRx, BLx, BRx);
      output.y = Math.min(TLy, TRy, BLy, BRy);
      output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
      output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
      return output;
    };
    var GlobRect$2 = undefined;
    var GetTopLeft = function GetTopLeft(gameObject, output, includeParent) {
      if (output === undefined) {
        output = new Vector2();
      } else if (output === true) {
        if (GlobVector === undefined) {
          GlobVector = new Vector2();
        }
        output = GlobVector;
      }
      if (gameObject.getTopLeft) {
        return gameObject.getTopLeft(output);
      }
      output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
      output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
      return PrepareBoundsOutput(gameObject, output, includeParent);
    };
    var GetTopRight = function GetTopRight(gameObject, output, includeParent) {
      if (output === undefined) {
        output = new Vector2();
      } else if (output === true) {
        if (GlobVector === undefined) {
          GlobVector = new Vector2();
        }
        output = GlobVector;
      }
      if (gameObject.getTopRight) {
        return gameObject.getTopRight(output);
      }
      output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
      output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
      return PrepareBoundsOutput(gameObject, output, includeParent);
    };
    var GetBottomLeft = function GetBottomLeft(gameObject, output, includeParent) {
      if (output === undefined) {
        output = new Vector2();
      } else if (output === true) {
        if (GlobVector === undefined) {
          GlobVector = new Vector2();
        }
        output = GlobVector;
      }
      if (gameObject.getBottomLeft) {
        return gameObject.getBottomLeft(output);
      }
      output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
      output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
      return PrepareBoundsOutput(gameObject, output, includeParent);
    };
    var GetBottomRight = function GetBottomRight(gameObject, output, includeParent) {
      if (output === undefined) {
        output = new Vector2();
      } else if (output === true) {
        if (GlobVector === undefined) {
          GlobVector = new Vector2();
        }
        output = GlobVector;
      }
      if (gameObject.getBottomRight) {
        return gameObject.getBottomRight(output);
      }
      output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
      output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
      return PrepareBoundsOutput(gameObject, output, includeParent);
    };
    var GetCenter = function GetCenter(gameObject, output, includeParent) {
      if (output === undefined) {
        output = new Vector2();
      } else if (output === true) {
        if (GlobVector === undefined) {
          GlobVector = new Vector2();
        }
        output = GlobVector;
      }
      var displayWidth = GetDisplayWidth(gameObject);
      var displayHeight = GetDisplayHeight(gameObject);
      output.x = gameObject.x + displayWidth * (0.5 - gameObject.originX);
      output.y = gameObject.y + displayHeight * (0.5 - gameObject.originY);
      return PrepareBoundsOutput(gameObject, output, includeParent);
    };
    var GlobVector = undefined;
    var PrepareBoundsOutput = function PrepareBoundsOutput(gameObject, output, includeParent) {
      if (includeParent === undefined) {
        includeParent = false;
      }
      if (gameObject.rotation !== 0) {
        RotateAround$6(output, gameObject.x, gameObject.y, gameObject.rotation);
      }
      if (includeParent && gameObject.parentContainer) {
        var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
        parentMatrix.transformPoint(output.x, output.y, output);
      }
      return output;
    };
  
    var GetValue$3k = Phaser.Utils.Objects.GetValue;
    var DrawBounds$2 = function DrawBounds(gameObjects, graphics, config) {
      var strokeColor, lineWidth, fillColor, fillAlpha, padding;
      if (typeof config === 'number') {
        strokeColor = config;
      } else {
        strokeColor = GetValue$3k(config, 'color');
        lineWidth = GetValue$3k(config, 'lineWidth');
        fillColor = GetValue$3k(config, 'fillColor');
        fillAlpha = GetValue$3k(config, 'fillAlpha', 1);
        padding = GetValue$3k(config, 'padding', 0);
      }
      if (Array.isArray(gameObjects)) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
        }
      } else {
        Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
      }
    };
    var Draw = function Draw(gameObject, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
      var canDrawBound = gameObject.getBounds || gameObject.width !== undefined && gameObject.height !== undefined;
      if (!canDrawBound) {
        return;
      }
      if (strokeColor === undefined) {
        strokeColor = 0xffffff;
      }
      if (lineWidth === undefined) {
        lineWidth = 1;
      }
      if (fillColor === undefined) {
        fillColor = null;
      }
      if (fillAlpha === undefined) {
        fillAlpha = 1;
      }
      if (padding === undefined) {
        padding = 0;
      }
      var p0 = GetTopLeft(gameObject, Points[0]);
      p0.x -= padding;
      p0.y -= padding;
      var p1 = GetTopRight(gameObject, Points[1]);
      p1.x += padding;
      p1.y -= padding;
      var p2 = GetBottomRight(gameObject, Points[2]);
      p2.x += padding;
      p2.y += padding;
      var p3 = GetBottomLeft(gameObject, Points[3]);
      p3.x -= padding;
      p3.y += padding;
      if (fillColor !== null) {
        graphics.fillStyle(fillColor, fillAlpha).fillPoints(Points, true, true);
      }
      if (strokeColor !== null) {
        graphics.lineStyle(lineWidth, strokeColor).strokePoints(Points, true, true);
      }
    };
    var Points = [{
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }];
  
    var DrawGameObjectsBounds = function DrawGameObjectsBounds(graphics, config) {
      this.forEachGO(function (gameObject) {
        if (gameObject.drawBounds) {
          gameObject.drawBounds(graphics, config);
        } else {
          DrawBounds$2(gameObject, graphics, config);
        }
      });
      return this;
    };
  
    var GetCameraByName = function GetCameraByName(scene, name) {
      var cameraManager = scene.cameras;
      var camera;
      if (name === undefined) {
        camera = cameraManager.main;
      } else {
        var cameraNameType = _typeof(name);
        switch (cameraNameType) {
          case 'string':
            camera = cameraManager.getCamera(name);
            break;
          case 'number':
            camera = cameraManager.cameras[name];
            break;
          default:
            camera = name;
            break;
        }
      }
      return camera;
    };
  
    var CameraMethods$1 = {
      setCamera: function setCamera(goName, cameraName) {
        var bob = this.get(goName);
        if (!bob) {
          return this;
        }
        var camera = GetCameraByName(this.scene, cameraName);
        if (!camera) {
          return this;
        }
        bob.gameObject.cameraFilter = 0xffffffff ^ camera.id;
        bob.camera = camera;
        return this;
      },
      getCamera: function getCamera(goName) {
        var bob = this.get(goName);
        if (!bob) {
          return null;
        }
        return bob.camera;
      }
    };
  
    var Methods$g = {
      drawGameObjectsBounds: DrawGameObjectsBounds
    };
    Object.assign(Methods$g, GetMethods, AddMethods$1, RemoveMethods$1, PropertyMethods, CallMethods, DataMethods, FadeMethods$1, CameraMethods$1);
  
    var CameraClass = Phaser.Cameras.Scene2D.BaseCamera;
    var IsCameraObject = function IsCameraObject(object) {
      return object instanceof CameraClass;
    };
  
    var Rectangle$3 = Phaser.Geom.Rectangle;
    var GetViewport = function GetViewport(scene, camera, out) {
      if (!IsCameraObject(camera)) {
        out = camera;
        camera = undefined;
      }
      if (out === undefined) {
        out = new Rectangle$3();
      } else if (out === true) {
        out = globRect;
      }
      if (camera) {
        return scene.scale.getViewPort(camera, out);
      } else {
        return scene.scale.getViewPort(out);
      }
    };
    var globRect = new Rectangle$3();
  
    var GetValue$3j = Phaser.Utils.Objects.GetValue;
    var GOManager = /*#__PURE__*/function () {
      function GOManager(scene, config) {
        _classCallCheck(this, GOManager);
        this.scene = scene;
        this.BobClass = GetValue$3j(config, 'BobClass', BobBase);
        this.setCreateGameObjectCallback(GetValue$3j(config, 'createGameObject'), GetValue$3j(config, 'createGameObjectScope'));
        this.setEventEmitter(GetValue$3j(config, 'eventEmitter', undefined));
        this.setGameObjectDepth(GetValue$3j(config, 'depth', undefined));
        var fadeConfig = GetValue$3j(config, 'fade', 500);
        if (typeof fadeConfig === 'number') {
          this.setGOFadeMode();
          this.setGOFadeTime(fadeConfig);
        } else {
          this.setGOFadeMode(GetValue$3j(fadeConfig, 'mode'));
          this.setGOFadeTime(GetValue$3j(fadeConfig, 'time', 500));
        }
        var viewportCoordinateConfig = GetValue$3j(config, 'viewportCoordinate', false);
        if (viewportCoordinateConfig !== false) {
          this.setViewportCoordinateEnable(GetValue$3j(config, 'enable', true));
          this.setViewport(GetValue$3j(viewportCoordinateConfig, 'viewport'));
        } else {
          this.setViewportCoordinateEnable(false);
        }
        var effectPropertiesConfig = GetValue$3j(config, 'effectProperties', false);
        this.setEffectPropertiesConfig(effectPropertiesConfig);
        this.setSymbols(GetValue$3j(config, 'symbols'));
        this.bobs = {};
        this.removedGOs = [];
        this._timeScale = 1;
        this.name = GetValue$3j(config, 'name');
      }
      _createClass(GOManager, [{
        key: "destroy",
        value: function destroy(fromScene) {
          this.clear(!fromScene);
          this.createGameObjectCallback = undefined;
          this.viewport = undefined;
          this.scene = undefined;
        }
      }, {
        key: "timeScale",
        get: function get() {
          return this._timeScale;
        },
        set: function set(timeScale) {
          if (this._timeScale === timeScale) {
            return;
          }
          this._timeScale = timeScale;
          var bobs = this.bobs;
          for (var name in bobs) {
            bobs[name].setTimeScale(timeScale);
          }
        }
      }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
          this.timeScale = timeScale;
          return this;
        }
      }, {
        key: "setCreateGameObjectCallback",
        value: function setCreateGameObjectCallback(callback, scope) {
          this.createGameObjectCallback = callback;
          this.createGameObjectScope = scope;
          return this;
        }
      }, {
        key: "setGameObjectDepth",
        value: function setGameObjectDepth(depth) {
          this.gameObjectDepth = depth;
          return this;
        }
      }, {
        key: "setViewportCoordinateEnable",
        value: function setViewportCoordinateEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.viewportCoordinateEnable = enable;
          return this;
        }
      }, {
        key: "setEffectPropertiesConfig",
        value: function setEffectPropertiesConfig(config) {
          if (config === undefined) {
            config = true;
          }
          this.effectPropertiesConfig = config;
          return this;
        }
      }, {
        key: "setViewport",
        value: function setViewport(viewport) {
          if (viewport === undefined) {
            viewport = GetViewport(this.scene, this.scene.cameras.main);
          }
          this.viewport = viewport;
          return this;
        }
      }, {
        key: "setSymbols",
        value: function setSymbols(symbols) {
          this.symbols = symbols;
          return this;
        }
      }, {
        key: "isEmpty",
        get: function get() {
          return IsEmpty(this.bobs) && this.removedGOs.length === 0;
        }
      }]);
      return GOManager;
    }();
    Object.assign(GOManager.prototype, EventEmitterMethods$1, Methods$g);
  
    var GameObjectClass = Phaser.GameObjects.GameObject;
    var IsGameObject = function IsGameObject(object) {
      return object instanceof GameObjectClass;
    };
  
    var LayerClass = Phaser.GameObjects.Layer;
    var IsLayerGameObject = function IsLayerGameObject(gameObject) {
      return gameObject instanceof LayerClass;
    };
  
    var GetLayer = function GetLayer(gameObject) {
      var layer = gameObject.displayList;
      if (!IsLayerGameObject(layer)) {
        return null;
      }
      return layer;
    };
  
    var SortGameObjectsByDepth = function SortGameObjectsByDepth(gameObjects, descending) {
      if (gameObjects.length <= 1) {
        return gameObjects;
      }
      if (descending === undefined) {
        descending = false;
      }
      var itemList;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var gameObject = gameObjects[i];
        if (gameObject.displayList) {
          // Inside a scene or a layer
          itemList = gameObject.displayList; // displayList
        } else if (gameObject.parentContainer) {
          // Inside a container
          itemList = gameObject.parentContainer.list; // array
        }
        if (itemList) {
          break;
        }
      }
      if (!itemList) {
        itemList = gameObject.scene.sys.displayList; // displayList
        // ??
      }
      if (itemList.depthSort) {
        // Is a displayList object
        itemList.depthSort();
        itemList = itemList.list;
        // itemList is an array now
      }
  
      // itemList is an array
      if (descending) {
        gameObjects.sort(function (childA, childB) {
          return itemList.indexOf(childB) - itemList.indexOf(childA);
        });
      } else {
        gameObjects.sort(function (childA, childB) {
          return itemList.indexOf(childA) - itemList.indexOf(childB);
        });
      }
      return gameObjects;
    };
  
    var LayerMethods = {
      getLayer: function getLayer(name) {
        return this.getGO(name);
      },
      getLayers: function getLayers(out) {
        if (out === undefined) {
          out = [];
        }
        this.forEachGO(function (gameObject) {
          out.push(gameObject);
        });
        SortGameObjectsByDepth(out, false);
        return out;
      },
      addToLayer: function addToLayer(name, gameObjects) {
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("[LayerManager] Can't get layer \"".concat(name, "\""));
          return;
        }
        if (!Array.isArray(gameObjects)) {
          gameObjects = [gameObjects];
        }
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          var gameObject = gameObjects[i];
          if (gameObject.isRexContainerLite) {
            gameObject.addToLayer(layer);
          } else {
            layer.add(gameObject);
          }
        }
        if (layer.scrollFactorX !== undefined) {
          gameObject.setScrollFactor(layer.scrollFactorX, layer.scrollFactorY);
        }
        return this;
      },
      removeFromLayer: function removeFromLayer(name, gameObject, addToScene) {
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("[LayerManager] Can't get layer \"".concat(name, "\""));
          return;
        }
        if (addToScene === undefined) {
          addToScene = true;
        }
        if (gameObject.isRexContainerLite) {
          gameObject.removeFromLayer(layer, addToScene);
        } else {
          layer.remove(gameObject);
          if (addToScene) {
            gameObject.addToDisplayList();
          }
        }
        return this;
      },
      clearLayer: function clearLayer(name, destroyChildren) {
        if (destroyChildren === undefined) {
          destroyChildren = true;
        }
        var layer = this.getGO(name);
        if (!layer) {
          console.warn("Can't get layer \"".concat(name, "\""));
          return;
        }
        if (destroyChildren) {
          var children = layer.getAll();
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            children[i].destroy();
          }
        } else {
          layer.removeAll();
        }
        return this;
      }
    };
  
    var ScrollFactorMethods = {
      setScrollFactor: function setScrollFactor(name, scrollFactorX, scrollFactorY) {
        if (scrollFactorY === undefined) {
          scrollFactorY = scrollFactorX;
        }
        var layer = this.getLayer(name);
        if (!layer) {
          return this;
        }
        layer.scrollFactorX = scrollFactorX;
        layer.scrollFactorY = scrollFactorY;
        var children = layer.getAll();
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].setScrollFactor(scrollFactorX, scrollFactorY);
        }
        return this;
      }
    };
  
    var ArrayUtils$1 = Phaser.Utils.Array;
    var BringMeToTop = function BringMeToTop() {
      var list;
      if (this.parentContainer) {
        list = this.parentContainer.list;
      } else if (this.displayList) {
        list = this.displayList.list;
      }
      if (!list) {
        return this;
      }
      ArrayUtils$1.BringToTop(list, this);
      return this;
    };
    var SendMeToBack = function SendMeToBack() {
      var list;
      if (this.parentContainer) {
        list = this.parentContainer.list;
      } else if (this.displayList) {
        list = this.displayList.list;
      }
      if (!list) {
        return this;
      }
      ArrayUtils$1.SendToBack(list, this);
      return this;
    };
    var MoveMyDepthBelow = function MoveMyDepthBelow(gameObject) {
      var list;
      if (gameObject.parentContainer) {
        list = gameObject.parentContainer.list;
        if (list.indexOf(this) === -1) {
          gameObject.parentContainer.add(this);
        }
      } else if (gameObject.displayList) {
        list = gameObject.displayList.list;
        if (list.indexOf(this) === -1) {
          gameObject.displayList.add(this);
        }
      }
      if (!list) {
        return this;
      }
      ArrayUtils$1.MoveBelow(list, this, gameObject);
      return this;
    };
    var MoveMyDepthAbove = function MoveMyDepthAbove(gameObject) {
      var list;
      if (gameObject.parentContainer) {
        list = gameObject.parentContainer.list;
        if (list.indexOf(this) === -1) {
          if (gameObject.isRexContainerLite) {
            gameObject.addToContainer(gameObject.parentContainer);
          } else {
            gameObject.parentContainer.add(gameObject);
          }
        }
      } else if (gameObject.displayList) {
        list = gameObject.displayList.list;
        if (list.indexOf(this) === -1) {
          if (gameObject.isRexContainerLite) {
            gameObject.addToLayer(gameObject.displayList);
          } else {
            gameObject.displayList.add(gameObject);
          }
        }
      }
      if (!list) {
        return this;
      }
      ArrayUtils$1.MoveAbove(list, this, gameObject);
      return this;
    };
    var DisplayListMethods = {
      bringMeToTop: BringMeToTop,
      sendMeToBack: SendMeToBack,
      moveMyDepthBelow: MoveMyDepthBelow,
      moveMyDepthAbove: MoveMyDepthAbove
    };
  
    var DepthMethods = {
      bringLayerToTop: function bringLayerToTop(layerName) {
        var layer = this.getLayer(layerName);
        if (!layer) {
          return this;
        }
        DisplayListMethods.bringMeToTop.call(layer);
        return this;
      },
      sendLayerToBack: function sendLayerToBack(layerName) {
        var layer = this.getLayer(layerName);
        if (!layer) {
          return this;
        }
        DisplayListMethods.sendMeToBack.call(layer);
        return this;
      },
      moveLayerBelow: function moveLayerBelow(layerName, baseLayerName) {
        if (layerName === baseLayerName) {
          return this;
        }
        var layer = this.getLayer(layerName);
        var baseLayer = this.getLayer(baseLayerName);
        if (!layer || !baseLayer) {
          return this;
        }
        DisplayListMethods.moveMyDepthBelow.call(layer, baseLayer);
        return this;
      },
      moveLayerAbove: function moveLayerAbove(layerName, baseLayerName) {
        if (layerName === baseLayerName) {
          return this;
        }
        var layer = this.getLayer(layerName);
        var baseLayer = this.getLayer(baseLayerName);
        if (!layer || !baseLayer) {
          return this;
        }
        DisplayListMethods.moveMyDepthAbove.call(layer, baseLayer);
        return this;
      }
    };
  
    var SetCamera = GOManager.prototype.setCamera;
    var CameraMethods = {
      setCamera: function setCamera(layerName, cameraName) {
        // Add a new camera if target camera is not existing
        var camera = GetCameraByName(this.scene, cameraName);
        if (!camera) {
          camera = this.scene.cameras.add(undefined, undefined, undefined, undefined, false, cameraName);
        }
        SetCamera.call(this, layerName, camera);
        return this;
      }
    };
  
    var methods$D = {};
    Object.assign(methods$D, LayerMethods, ScrollFactorMethods, DepthMethods, CameraMethods);
  
    var GetValue$3i = Phaser.Utils.Objects.GetValue;
    var LayerManager = /*#__PURE__*/function (_GOManager) {
      _inherits(LayerManager, _GOManager);
      function LayerManager(scene, config) {
        var _this;
        _classCallCheck(this, LayerManager);
        if (config === undefined) {
          config = {};
        } else if (Array.isArray(config)) {
          config = {
            layers: config
          };
        }
        if (!config.hasOwnProperty('fade')) {
          config.fade = 0;
        }
        config.viewportCoordinate = false;
        _this = _callSuper(this, LayerManager, [scene, config]);
        var rootLayer = GetValue$3i(config, 'rootLayer');
        _this.setRootLayer(rootLayer);
        var initLayers = GetValue$3i(config, 'layers');
        if (initLayers) {
          for (var i = 0, cnt = initLayers.length; i < cnt; i++) {
            var layerConfig = initLayers[i];
            if (typeof layerConfig === 'string') {
              _this.add(layerConfig);
            } else {
              var layerName = layerConfig.name;
              _this.add(layerName);
              var scrollFactor = layerConfig.scrollFactor;
              var scrollFactorX = GetValue$3i(layerConfig, 'scrollFactorX', scrollFactor);
              var scrollFactorY = GetValue$3i(layerConfig, 'scrollFactorY', scrollFactor);
              if (scrollFactorX !== undefined) {
                _this.setScrollFactor(layerName, scrollFactorX, scrollFactorY);
              }
              _this.setCamera(layerName, layerConfig.cameraName);
            }
          }
        }
        return _this;
      }
      _createClass(LayerManager, [{
        key: "setCreateGameObjectCallback",
        value: function setCreateGameObjectCallback(callback, scope) {
          if (!callback) {
            callback = CreateLayer;
          }
          _get(_getPrototypeOf(LayerManager.prototype), "setCreateGameObjectCallback", this).call(this, callback, scope);
          return this;
        }
      }, {
        key: "setRootLayer",
        value: function setRootLayer(rootLayer) {
          if (rootLayer === this.rootLayer) {
            return this;
          }
          var currentLayers = this.getAllGO();
          if (rootLayer) {
            rootLayer.add(currentLayers);
          } else {
            this.scene.displayList.add(currentLayers);
          }
          this.rootLayer = rootLayer;
          return this;
        }
  
        // Override
      }, {
        key: "addGO",
        value: function addGO(name, gameObject) {
          _get(_getPrototypeOf(LayerManager.prototype), "addGO", this).call(this, name, gameObject);
          gameObject.name = name;
          if (this.rootLayer) {
            this.rootLayer.add(gameObject);
          }
          return this;
        }
  
        // Override
      }, {
        key: "get",
        value: function get(name, out) {
          if (IsGameObject(name)) {
            var layer = GetLayer(name);
            if (!layer) {
              return undefined;
            }
            name = layer.name;
            if (!name) {
              return undefined;
            }
          }
          return _get(_getPrototypeOf(LayerManager.prototype), "get", this).call(this, name, out);
        }
      }]);
      return LayerManager;
    }(GOManager);
    var CreateLayer = function CreateLayer(scene, depth) {
      var layer = scene.add.layer();
      if (depth !== undefined) {
        layer.setDepth(depth);
      }
      return layer;
    };
    Object.assign(LayerManager.prototype, methods$D);
  
    var GetSoundManager = function GetSoundManager(game) {
      if (IsSceneObject(game)) {
        return game.sys.sound;
      }
      return game.sound;
    };
  
    var HasaAudio = function HasaAudio(key) {
      return this.sound.game.cache.audio.has(key);
    };
  
    var GetSceneObject = function GetSceneObject(object) {
      if (object == null || _typeof(object) !== 'object') {
        return null;
      } else if (IsSceneObject(object)) {
        // object = scene
        return object;
      } else if (object.scene && IsSceneObject(object.scene)) {
        // object = game object
        return object.scene;
      } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) {
        // parent = bob object
        return object.parent.scene;
      } else {
        return null;
      }
    };
  
    var GetValue$3h = Phaser.Utils.Objects.GetValue;
    var ComponentBase = /*#__PURE__*/function () {
      function ComponentBase(parent, config) {
        _classCallCheck(this, ComponentBase);
        this.setParent(parent); // gameObject, scene, or game
  
        this.isShutdown = false;
  
        // Event emitter, default is private event emitter
        this.setEventEmitter(GetValue$3h(config, 'eventEmitter', true));
  
        // Register callback of parent destroy event, also see `shutdown` method
        if (this.parent) {
          if (this.parent === this.scene) {
            // parent is a scene
            this.scene.sys.events.once('shutdown', this.onEnvDestroy, this);
          } else if (this.parent === this.game) {
            // parent is game
            this.game.events.once('shutdown', this.onEnvDestroy, this);
          } else if (this.parent.once) {
            // parent is game object or something else
            this.parent.once('destroy', this.onParentDestroy, this);
          }
  
          // bob object does not have event emitter
        }
      }
      _createClass(ComponentBase, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // parent might not be shutdown yet
          if (this.parent) {
            if (this.parent === this.scene) {
              // parent is a scene
              this.scene.sys.events.off('shutdown', this.onEnvDestroy, this);
            } else if (this.parent === this.game) {
              // parent is game
              this.game.events.off('shutdown', this.onEnvDestroy, this);
            } else if (this.parent.once) {
              // parent is game object or something else
              this.parent.off('destroy', this.onParentDestroy, this);
            }
  
            // bob object does not have event emitter
          }
          this.destroyEventEmitter();
          this.parent = undefined;
          this.scene = undefined;
          this.game = undefined;
          this.isShutdown = true;
        }
      }, {
        key: "destroy",
        value: function destroy(fromScene) {
          this.shutdown(fromScene);
        }
      }, {
        key: "onEnvDestroy",
        value: function onEnvDestroy() {
          this.destroy(true);
        }
      }, {
        key: "onParentDestroy",
        value: function onParentDestroy(parent, fromScene) {
          this.destroy(fromScene);
        }
      }, {
        key: "setParent",
        value: function setParent(parent) {
          this.parent = parent; // gameObject, scene, or game
  
          this.scene = GetSceneObject(parent);
          this.game = GetGame(parent);
          return this;
        }
      }]);
      return ComponentBase;
    }();
    Object.assign(ComponentBase.prototype, EventEmitterMethods$1);
  
    var GetValue$3g = Phaser.Utils.Objects.GetValue;
    var TickTask = /*#__PURE__*/function (_ComponentBase) {
      _inherits(TickTask, _ComponentBase);
      function TickTask(parent, config) {
        var _this;
        _classCallCheck(this, TickTask);
        _this = _callSuper(this, TickTask, [parent, config]);
        _this._isRunning = false;
        _this.isPaused = false;
        _this.tickingState = false;
        _this.setTickingMode(GetValue$3g(config, 'tickingMode', 1));
        // boot() later
        return _this;
      }
  
      // override
      _createClass(TickTask, [{
        key: "boot",
        value: function boot() {
          if (this.tickingMode === 2 && !this.tickingState) {
            this.startTicking();
          }
        }
  
        // override
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.stop();
          if (this.tickingState) {
            this.stopTicking();
          }
          _get(_getPrototypeOf(TickTask.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "setTickingMode",
        value: function setTickingMode(mode) {
          if (typeof mode === 'string') {
            mode = TICKINGMODE[mode];
          }
          this.tickingMode = mode;
        }
  
        // override
      }, {
        key: "startTicking",
        value: function startTicking() {
          this.tickingState = true;
        }
  
        // override
      }, {
        key: "stopTicking",
        value: function stopTicking() {
          this.tickingState = false;
        }
      }, {
        key: "isRunning",
        get: function get() {
          return this._isRunning;
        },
        set: function set(value) {
          if (this._isRunning === value) {
            return;
          }
          this._isRunning = value;
          if (this.tickingMode === 1 && value != this.tickingState) {
            if (value) {
              this.startTicking();
            } else {
              this.stopTicking();
            }
          }
        }
      }, {
        key: "start",
        value: function start() {
          this.isPaused = false;
          this.isRunning = true;
          return this;
        }
      }, {
        key: "pause",
        value: function pause() {
          // Only can ba paused in running state
          if (this.isRunning) {
            this.isPaused = true;
            this.isRunning = false;
          }
          return this;
        }
      }, {
        key: "resume",
        value: function resume() {
          // Only can ba resumed in paused state (paused from running state)
          if (this.isPaused) {
            this.isRunning = true;
          }
          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.isPaused = false;
          this.isRunning = false;
          return this;
        }
      }, {
        key: "complete",
        value: function complete() {
          this.isPaused = false;
          this.isRunning = false;
          this.emit('complete', this.parent, this);
        }
      }]);
      return TickTask;
    }(ComponentBase);
    var TICKINGMODE = {
      'no': 0,
      'lazy': 1,
      'always': 2
    };
  
    var GetValue$3f = Phaser.Utils.Objects.GetValue;
    var SceneUpdateTickTask = /*#__PURE__*/function (_TickTask) {
      _inherits(SceneUpdateTickTask, _TickTask);
      function SceneUpdateTickTask(parent, config) {
        var _this;
        _classCallCheck(this, SceneUpdateTickTask);
        _this = _callSuper(this, SceneUpdateTickTask, [parent, config]);
  
        // scene update : update, preupdate, postupdate, prerender, render
        // game update : step, poststep, 
  
        // If this.scene is not available, use game's 'step' event
        var defaultEventName = _this.scene ? 'update' : 'step';
        _this.tickEventName = GetValue$3f(config, 'tickEventName', defaultEventName);
        _this.isSceneTicker = !IsGameUpdateEvent(_this.tickEventName);
        return _this;
      }
      _createClass(SceneUpdateTickTask, [{
        key: "startTicking",
        value: function startTicking() {
          _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "startTicking", this).call(this);
          if (this.isSceneTicker) {
            this.scene.sys.events.on(this.tickEventName, this.update, this);
          } else {
            this.game.events.on(this.tickEventName, this.update, this);
          }
        }
      }, {
        key: "stopTicking",
        value: function stopTicking() {
          _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "stopTicking", this).call(this);
          if (this.isSceneTicker && this.scene) {
            // Scene might be destoryed
            this.scene.sys.events.off(this.tickEventName, this.update, this);
          } else if (this.game) {
            this.game.events.off(this.tickEventName, this.update, this);
          }
        }
  
        // update(time, delta) {
        //     
        // }
      }]);
      return SceneUpdateTickTask;
    }(TickTask);
    var IsGameUpdateEvent = function IsGameUpdateEvent(eventName) {
      return eventName === 'step' || eventName === 'poststep';
    };
  
    var GetValue$3e = Phaser.Utils.Objects.GetValue;
    var Clamp$f = Phaser.Math.Clamp;
    var Timer$1 = /*#__PURE__*/function () {
      function Timer(config) {
        _classCallCheck(this, Timer);
        this.resetFromJSON(config);
      }
      _createClass(Timer, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.state = GetValue$3e(o, 'state', IDLE$8);
          this.timeScale = GetValue$3e(o, 'timeScale', 1);
          this.delay = GetValue$3e(o, 'delay', 0);
          this.repeat = GetValue$3e(o, 'repeat', 0);
          this.repeatCounter = GetValue$3e(o, 'repeatCounter', 0);
          this.repeatDelay = GetValue$3e(o, 'repeatDelay', 0);
          this.duration = GetValue$3e(o, 'duration', 0);
          this.nowTime = GetValue$3e(o, 'nowTime', 0);
          this.justRestart = GetValue$3e(o, 'justRestart', false);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            state: this.state,
            timeScale: this.timeScale,
            delay: this.delay,
            repeat: this.repeat,
            repeatCounter: this.repeatCounter,
            repeatDelay: this.repeatDelay,
            duration: this.duration,
            nowTime: this.nowTime,
            justRestart: this.justRestart
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {}
      }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
          this.timeScale = timeScale;
          return this;
        }
      }, {
        key: "setDelay",
        value: function setDelay(delay) {
          if (delay === undefined) {
            delay = 0;
          }
          this.delay = delay;
          return this;
        }
      }, {
        key: "setDuration",
        value: function setDuration(duration) {
          this.duration = duration;
          return this;
        }
      }, {
        key: "setRepeat",
        value: function setRepeat(repeat) {
          this.repeat = repeat;
          return this;
        }
      }, {
        key: "setRepeatInfinity",
        value: function setRepeatInfinity() {
          this.repeat = -1;
          return this;
        }
      }, {
        key: "setRepeatDelay",
        value: function setRepeatDelay(repeatDelay) {
          this.repeatDelay = repeatDelay;
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          this.nowTime = this.delay > 0 ? -this.delay : 0;
          this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
          this.repeatCounter = 0;
          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.state = IDLE$8;
          return this;
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          if (this.state === IDLE$8 || this.state === DONE || delta === 0 || this.timeScale === 0) {
            return;
          }
          this.nowTime += delta * this.timeScale;
          this.justRestart = false;
          if (this.nowTime >= this.duration) {
            if (this.repeat === -1 || this.repeatCounter < this.repeat) {
              this.repeatCounter++;
              this.justRestart = true;
              this.nowTime -= this.duration;
              if (this.repeatDelay > 0) {
                this.nowTime -= this.repeatDelay;
                this.state = REPEATDELAY;
              }
            } else {
              this.nowTime = this.duration;
              this.state = DONE;
            }
          } else if (this.nowTime >= 0) {
            this.state = COUNTDOWN;
          }
        }
      }, {
        key: "t",
        get: function get() {
          var t;
          switch (this.state) {
            case IDLE$8:
            case DELAY:
            case REPEATDELAY:
              t = 0;
              break;
            case COUNTDOWN:
              t = this.nowTime / this.duration;
              break;
            case DONE:
              t = 1;
              break;
          }
          return Clamp$f(t, 0, 1);
        },
        set: function set(value) {
          value = Clamp$f(value, -1, 1);
          if (value < 0) {
            this.state = DELAY;
            this.nowTime = -this.delay * value;
          } else {
            this.state = COUNTDOWN;
            this.nowTime = this.duration * value;
            if (value === 1 && this.repeat !== 0) {
              this.repeatCounter++;
            }
          }
        }
      }, {
        key: "setT",
        value: function setT(t) {
          this.t = t;
          return this;
        }
      }, {
        key: "isIdle",
        get: function get() {
          return this.state === IDLE$8;
        }
      }, {
        key: "isDelay",
        get: function get() {
          return this.state === DELAY;
        }
      }, {
        key: "isCountDown",
        get: function get() {
          return this.state === COUNTDOWN;
        }
      }, {
        key: "isRunning",
        get: function get() {
          return this.state === DELAY || this.state === COUNTDOWN;
        }
      }, {
        key: "isDone",
        get: function get() {
          return this.state === DONE;
        }
      }, {
        key: "isOddIteration",
        get: function get() {
          return (this.repeatCounter & 1) === 1;
        }
      }, {
        key: "isEvenIteration",
        get: function get() {
          return (this.repeatCounter & 1) === 0;
        }
      }]);
      return Timer;
    }();
    var IDLE$8 = 0;
    var DELAY = 1;
    var COUNTDOWN = 2;
    var REPEATDELAY = 3;
    var DONE = -1;
  
    var TimerTickTask = /*#__PURE__*/function (_TickTask) {
      _inherits(TimerTickTask, _TickTask);
      function TimerTickTask(parent, config) {
        var _this;
        _classCallCheck(this, TimerTickTask);
        _this = _callSuper(this, TimerTickTask, [parent, config]);
        _this.timer = new Timer$1();
        // boot() later 
        return _this;
      }
  
      // override
      _createClass(TimerTickTask, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          _get(_getPrototypeOf(TimerTickTask.prototype), "shutdown", this).call(this, fromScene);
          this.timer.destroy();
          this.timer = undefined;
        }
      }, {
        key: "start",
        value: function start() {
          this.timer.start();
          _get(_getPrototypeOf(TimerTickTask.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.timer.stop();
          _get(_getPrototypeOf(TimerTickTask.prototype), "stop", this).call(this);
          return this;
        }
      }, {
        key: "complete",
        value: function complete() {
          this.timer.stop();
          _get(_getPrototypeOf(TimerTickTask.prototype), "complete", this).call(this);
          return this;
        }
      }]);
      return TimerTickTask;
    }(SceneUpdateTickTask);
  
    var GetValue$3d = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
    var GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;
    var EaseValueTaskBase = /*#__PURE__*/function (_TimerTask) {
      _inherits(EaseValueTaskBase, _TimerTask);
      function EaseValueTaskBase() {
        _classCallCheck(this, EaseValueTaskBase);
        return _callSuper(this, EaseValueTaskBase, arguments);
      }
      _createClass(EaseValueTaskBase, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.timer.resetFromJSON(GetValue$3d(o, 'timer'));
          this.setEnable(GetValue$3d(o, 'enable', true));
          this.setTarget(GetValue$3d(o, 'target', this.parent));
          this.setDelay(GetAdvancedValue$5(o, 'delay', 0));
          this.setDuration(GetAdvancedValue$5(o, 'duration', 1000));
          this.setEase(GetValue$3d(o, 'ease', 'Linear'));
          this.setRepeat(GetValue$3d(o, 'repeat', 0));
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e == undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "setTarget",
        value: function setTarget(target) {
          if (target === undefined) {
            target = this.parent;
          }
          this.target = target;
          return this;
        }
      }, {
        key: "setDelay",
        value: function setDelay(time) {
          this.delay = time;
          // Assign `this.timer.setRepeat(repeat)` manually
          return this;
        }
      }, {
        key: "setDuration",
        value: function setDuration(time) {
          this.duration = time;
          return this;
        }
      }, {
        key: "setRepeat",
        value: function setRepeat(repeat) {
          this.repeat = repeat;
          // Assign `this.timer.setRepeat(repeat)` manually
          return this;
        }
      }, {
        key: "setRepeatDelay",
        value: function setRepeatDelay(repeatDelay) {
          this.repeatDelay = repeatDelay;
          // Assign `this.timer.setRepeatDelay(repeatDelay)` manually
          return this;
        }
      }, {
        key: "setEase",
        value: function setEase(ease) {
          if (ease === undefined) {
            ease = 'Linear';
          }
          this.ease = ease;
          this.easeFn = GetEaseFunction(ease);
          return this;
        }
  
        // Override
      }, {
        key: "start",
        value: function start() {
          // Ignore start if timer is running, i.e. in DELAY, o RUN state
          if (this.timer.isRunning) {
            return this;
          }
          _get(_getPrototypeOf(EaseValueTaskBase.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "restart",
        value: function restart() {
          this.timer.stop();
          this.start.apply(this, arguments);
          return this;
        }
      }, {
        key: "stop",
        value: function stop(toEnd) {
          if (toEnd === undefined) {
            toEnd = false;
          }
          _get(_getPrototypeOf(EaseValueTaskBase.prototype), "stop", this).call(this);
          if (toEnd) {
            this.timer.setT(1);
            this.updateGameObject(this.target, this.timer);
            this.complete();
          }
          return this;
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          if (!this.isRunning || !this.enable || !this.parent.active) {
            return this;
          }
          var target = this.target,
            timer = this.timer;
          timer.update(time, delta);
  
          // isDelay, isCountDown, isDone
          if (!timer.isDelay) {
            this.updateGameObject(target, timer);
          }
          this.emit('update', target, this);
          if (timer.isDone) {
            this.complete();
          }
          return this;
        }
  
        // Override
      }, {
        key: "updateGameObject",
        value: function updateGameObject(target, timer) {}
      }]);
      return EaseValueTaskBase;
    }(TimerTickTask);
  
    var SoundObjectClass = Phaser.Sound.BaseSound;
    var IsSoundObject = function IsSoundObject(object) {
      return object instanceof SoundObjectClass;
    };
  
    var GetValue$3c = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
    var Linear$d = Phaser.Math.Linear;
    var Fade$3 = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(Fade, _EaseValueTaskBase);
      function Fade(scene, sound, config) {
        var _this;
        _classCallCheck(this, Fade);
        if (IsSoundObject(scene)) {
          config = sound;
          sound = scene;
          scene = undefined;
        }
        sound.active = true;
        sound.scene = scene;
        sound.game = sound.manager.game;
        _this = _callSuper(this, Fade, [sound, config]);
        // this.parent = parent
        // this.timer
  
        _this.volume = {};
        _this.resetFromJSON(config);
        return _this;
      }
      _createClass(Fade, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);
          this.setMode(GetValue$3c(o, 'mode', 0));
          this.setEnable(GetValue$3c(o, 'enable', true));
          this.setVolumeRange(GetAdvancedValue$4(o, 'volume.start', this.parent.volume), GetAdvancedValue$4(o, 'volume.end', 0));
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = MODE$4[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setVolumeRange",
        value: function setVolumeRange(start, end) {
          this.volume.start = start;
          this.volume.end = end;
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.timer.isRunning) {
            return this;
          }
          this.parent.setVolume(this.volume.start);
          this.timer.setDelay(this.delay).setDuration(this.duration);
          _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(parent, timer) {
          parent.volume = Linear$d(this.volume.start, this.volume.end, timer.t);
        }
      }, {
        key: "complete",
        value: function complete() {
          _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);
          switch (this.mode) {
            case 1:
              this.parent.stop();
              break;
            case 2:
              this.parent.stop();
              this.parent.destroy();
              break;
          }
          return this;
        }
      }]);
      return Fade;
    }(EaseValueTaskBase);
    var MODE$4 = {
      stop: 1,
      destroy: 2
    };
  
    var FadeIn$1 = function FadeIn(scene, sound, duration, endVolume, startVolume) {
      if (IsSoundObject(scene)) {
        startVolume = endVolume;
        endVolume = duration;
        duration = sound;
        sound = scene;
        scene = undefined;
      }
      if (endVolume === undefined) {
        endVolume = 1;
      }
      if (startVolume === undefined) {
        startVolume = 0;
      }
      var config = {
        mode: 0,
        volume: {
          start: startVolume,
          end: endVolume
        },
        duration: duration
      };
  
      // create sound instance by key
      if (typeof sound === 'string') {
        sound = scene.sys.sound.add(sound);
      }
      var fade;
      if (sound.hasOwnProperty('_fade')) {
        fade = sound._fade;
        fade.stop().resetFromJSON(config);
      } else {
        fade = new Fade$3(scene, sound, config);
        sound._fade = fade;
      }
      fade.start();
      if (!sound.isPlaying) {
        sound.setVolume(startVolume).play();
      }
      return sound;
    };
  
    var FadeOut = function FadeOut(scene, sound, duration, destroy) {
      if (IsSoundObject(scene)) {
        destroy = duration;
        duration = sound;
        sound = scene;
        scene = undefined;
      }
      if (destroy === undefined) {
        destroy = true;
      }
      var config = {
        mode: destroy ? 2 : 1,
        // 1: stop, 2: destroy
        volume: {
          start: sound.volume,
          end: 0
        },
        duration: duration
      };
      var fade;
      if (sound.hasOwnProperty('_fade')) {
        fade = sound._fade;
        fade.stop().resetFromJSON(config);
      } else {
        fade = new Fade$3(scene, sound, config);
        sound._fade = fade;
      }
      fade.start();
      if (!sound.isPlaying) {
        sound.play();
      }
      return sound;
    };
  
    var GetValue$3b = Phaser.Utils.Objects.GetValue;
    var BackgroundMusicMethods = {
      setBackgroundMusicLoop: function setBackgroundMusicLoop(value) {
        if (value === undefined) {
          value = true;
        }
        this.backgroundMusicLoop = value;
        return this;
      },
      setBackgroundMusicFadeTime: function setBackgroundMusicFadeTime(time) {
        this.backgroundMusicFadeTime = time;
        return this;
      },
      getBackgroundMusic: function getBackgroundMusic() {
        return this.backgroundMusic;
      },
      // Internal method
      setCurrentBackgroundMusic: function setCurrentBackgroundMusic(music) {
        this.backgroundMusic = music;
        if (music) {
          music.once('complete', function () {
            if (this.backgroundMusic === music) {
              this.backgroundMusic.destroy();
              this.backgroundMusic = undefined;
            }
          }, this).once('destroy', function () {
            if (this.backgroundMusic === music) {
              this.backgroundMusic = undefined;
            }
          }, this);
          if (!music.isPlaying) {
            music.play();
          }
        }
        return this;
      },
      playBackgroundMusic: function playBackgroundMusic(key, config) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
  
        // Don't re-play the same background music
        if (this.backgroundMusic && this.backgroundMusic.key === key) {
          return this;
        }
        this.stopBackgroundMusic(); // Stop previous background music
  
        var music = this.sound.add(key, {
          loop: GetValue$3b(config, 'loop', this.backgroundMusicLoop),
          mute: GetValue$3b(config, 'mute', this.backgroundMusicMute),
          volume: GetValue$3b(config, 'volume', this.backgroundMusicVolume),
          detune: GetValue$3b(config, 'detune', 0),
          rate: GetValue$3b(config, 'rate', 1)
        });
        this.setCurrentBackgroundMusic(music);
  
        // Fade volume
        if (this.backgroundMusicFadeTime > 0) {
          this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
        }
        return this;
      },
      pauseBackgroundMusic: function pauseBackgroundMusic() {
        if (this.backgroundMusic) {
          this.backgroundMusic.pause();
        }
        return this;
      },
      resumeBackgroundMusic: function resumeBackgroundMusic() {
        if (this.backgroundMusic) {
          this.backgroundMusic.resume();
        }
        return this;
      },
      stopBackgroundMusic: function stopBackgroundMusic() {
        if (this.backgroundMusic) {
          if (this.backgroundMusicFadeTime > 0) {
            this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);
          } else {
            this.backgroundMusic.stop();
            this.backgroundMusic.destroy();
            this.backgroundMusic = undefined;
          }
        }
        return this;
      },
      fadeInBackgroundMusic: function fadeInBackgroundMusic(time) {
        if (this.backgroundMusic) {
          FadeIn$1(this.backgroundMusic, time, this.backgroundMusicVolume, 0);
        }
        return this;
      },
      fadeOutBackgroundMusic: function fadeOutBackgroundMusic(time, isStopped) {
        if (this.backgroundMusic) {
          FadeOut(this.backgroundMusic, time, isStopped);
        }
        return this;
      },
      crossFadeBackgroundMusic: function crossFadeBackgroundMusic(key, time) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
        var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
        this.backgroundMusicFadeTime = 0;
        this.fadeOutBackgroundMusic(time, true).playBackgroundMusic(key).fadeInBackgroundMusic(time);
        this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;
        return this;
      },
      setBackgroundMusicMute: function setBackgroundMusicMute(mute) {
        if (mute === undefined) {
          mute = true;
        }
        this.backgroundMusicMute = mute;
        return this;
      },
      setBackgroundMusicVolume: function setBackgroundMusicVolume(volume) {
        this.backgroundMusicVolume = volume;
        return this;
      },
      setBackgroundMusicRate: function setBackgroundMusicRate(rate) {
        if (this.backgroundMusic) {
          this.backgroundMusic.setRate(rate);
        }
        return this;
      },
      setBackgroundMusicDetune: function setBackgroundMusicDetune(detune) {
        if (this.backgroundMusic) {
          this.backgroundMusic.setDetune(detune);
        }
        return this;
      }
    };
  
    var GetValue$3a = Phaser.Utils.Objects.GetValue;
    var BackgroundMusic2Methods = {
      setBackgroundMusic2Loop: function setBackgroundMusic2Loop(value) {
        if (value === undefined) {
          value = true;
        }
        this.backgroundMusic2Loop = value;
        return this;
      },
      setBackgroundMusic2FadeTime: function setBackgroundMusic2FadeTime(time) {
        this.backgroundMusic2FadeTime = time;
        return this;
      },
      getBackgroundMusic2: function getBackgroundMusic2() {
        return this.backgroundMusic2;
      },
      // Internal method
      setCurrentBackgroundMusic2: function setCurrentBackgroundMusic2(music) {
        this.backgroundMusic2 = music;
        if (music) {
          music.once('complete', function () {
            if (this.backgroundMusic2 === music) {
              this.backgroundMusic2.destroy();
              this.backgroundMusic2 = undefined;
            }
          }, this).once('destroy', function () {
            if (this.backgroundMusic2 === music) {
              this.backgroundMusic2 = undefined;
            }
          }, this);
          if (!music.isPlaying) {
            music.play();
          }
        }
        return this;
      },
      playBackgroundMusic2: function playBackgroundMusic2(key, config) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
  
        // Don't re-play the same background music
        if (this.backgroundMusic2 && this.backgroundMusic2.key === key) {
          return this;
        }
        this.stopBackgroundMusic2(); // Stop previous background music
  
        var music = this.sound.add(key, {
          loop: GetValue$3a(config, 'loop', this.backgroundMusicLoop),
          mute: GetValue$3a(config, 'mute', this.backgroundMusic2Mute),
          volume: GetValue$3a(config, 'volume', this.backgroundMusic2Volume),
          detune: GetValue$3a(config, 'detune', 0),
          rate: GetValue$3a(config, 'rate', 1)
        });
        this.setCurrentBackgroundMusic2(music);
  
        // Fade volume
        if (this.backgroundMusic2FadeTime > 0) {
          this.fadeInBackgroundMusic2(this.backgroundMusic2FadeTime);
        }
        return this;
      },
      pauseBackgroundMusic2: function pauseBackgroundMusic2() {
        if (this.backgroundMusic2) {
          this.backgroundMusic2.pause();
        }
        return this;
      },
      resumeBackgroundMusic2: function resumeBackgroundMusic2() {
        if (this.backgroundMusic2) {
          this.backgroundMusic2.resume();
        }
        return this;
      },
      stopBackgroundMusic2: function stopBackgroundMusic2() {
        if (this.backgroundMusic2) {
          if (this.backgroundMusic2FadeTime > 0) {
            this.fadeOutBackgroundMusic2(this.backgroundMusic2FadeTime, true);
          } else {
            this.backgroundMusic2.stop();
            this.backgroundMusic2.destroy();
            this.backgroundMusic2 = undefined;
          }
        }
        return this;
      },
      fadeInBackgroundMusic2: function fadeInBackgroundMusic2(time) {
        if (this.backgroundMusic2) {
          FadeIn$1(this.backgroundMusic2, time, this.backgroundMusic2Volume, 0);
        }
        return this;
      },
      fadeOutBackgroundMusic2: function fadeOutBackgroundMusic2(time, isStopped) {
        if (this.backgroundMusic2) {
          FadeOut(this.backgroundMusic2, time, isStopped);
        }
        return this;
      },
      crossFadeBackgroundMusic2: function crossFadeBackgroundMusic2(key, time) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
        var backgroundMusic2FadeTimeSave = this.backgroundMusic2FadeTime;
        this.backgroundMusic2FadeTime = 0;
        this.fadeOutBackgroundMusic2(time, true).playBackgroundMusic2(key).fadeInBackgroundMusic2(time);
        this.backgroundMusic2FadeTime = backgroundMusic2FadeTimeSave;
        return this;
      },
      setBackgroundMusic2Mute: function setBackgroundMusic2Mute(mute) {
        if (mute === undefined) {
          mute = true;
        }
        this.backgroundMusic2Mute = mute;
        return this;
      },
      setBackgroundMusic2Volume: function setBackgroundMusic2Volume(volume) {
        this.backgroundMusic2Volume = volume;
        return this;
      },
      setBackgroundMusic2Rate: function setBackgroundMusic2Rate(rate) {
        if (this.backgroundMusic2) {
          this.backgroundMusic2.setRate(rate);
        }
        return this;
      },
      setBackgroundMusic2Detune: function setBackgroundMusic2Detune(detune) {
        if (this.backgroundMusic2) {
          this.backgroundMusic2.setDetune(detune);
        }
        return this;
      }
    };
  
    var RemoveItem$a = Phaser.Utils.Array.Remove;
    var GetValue$39 = Phaser.Utils.Objects.GetValue;
    var SoundEffectsMethods = {
      getSoundEffects: function getSoundEffects() {
        return this.soundEffects;
      },
      getLastSoundEffect: function getLastSoundEffect() {
        return this.soundEffects[this.soundEffects.length - 1];
      },
      playSoundEffect: function playSoundEffect(key, config) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
        var music = this.sound.add(key, {
          mute: GetValue$39(config, 'mute', this.soundEffectsMute),
          volume: GetValue$39(config, 'volume', this.soundEffectsVolume),
          detune: GetValue$39(config, 'detune', 0),
          rate: GetValue$39(config, 'rate', 1)
        });
        this.soundEffects.push(music);
        music.once('complete', function () {
          music.destroy();
  
          // SoundManager has been destroyed
          if (!this.sound) {
            return;
          }
          RemoveItem$a(this.soundEffects, music);
        }, this).once('destroy', function () {
          // SoundManager has been destroyed
          if (!this.sound) {
            return;
          }
          RemoveItem$a(this.soundEffects, music);
        }, this).play();
        return this;
      },
      stopAllSoundEffects: function stopAllSoundEffects() {
        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
          var soundEffect = this.soundEffects[i];
          soundEffect.stop();
          soundEffect.destroy();
        }
        return this;
      },
      fadeInSoundEffect: function fadeInSoundEffect(time) {
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
          FadeIn$1(soundEffect, time, this.soundEffectsVolume, 0);
        }
        return this;
      },
      fadeOutSoundEffect: function fadeOutSoundEffect(time, isStopped) {
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
          FadeOut(soundEffect, time, isStopped);
        }
        return this;
      },
      fadeOutAllSoundEffects: function fadeOutAllSoundEffects(time, isStopped) {
        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
          FadeOut(this.soundEffects[i], time, isStopped);
        }
        return this;
      },
      setSoundEffectMute: function setSoundEffectMute(mute, lastSoundEffect) {
        if (mute === undefined) {
          mute = true;
        }
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        if (lastSoundEffect) {
          // Set volume of last sound effect
          var soundEffect = this.getLastSoundEffect();
          if (soundEffect) {
            soundEffect.setMute(mute);
          }
        } else {
          // Set volume of all sound effects
          this.soundEffectsMute = mute;
        }
        return this;
      },
      setSoundEffectVolume: function setSoundEffectVolume(volume, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        if (lastSoundEffect) {
          // Set volume of last sound effect
          var soundEffect = this.getLastSoundEffect();
          if (soundEffect) {
            soundEffect.setVolume(volume);
          }
        } else {
          // Set volume of all sound effects
          this.soundEffectsVolume = volume;
        }
        return this;
      },
      setSoundEffectDetune: function setSoundEffectDetune(detune, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        var soundEffects;
        if (lastSoundEffect) {
          soundEffects = [this.getLastSoundEffect()];
        } else {
          soundEffects = this.soundEffects;
        }
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setDetune(detune);
        }
        return this;
      },
      setSoundEffectRate: function setSoundEffectRate(rate, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        var soundEffects;
        if (lastSoundEffect) {
          soundEffects = [this.getLastSoundEffect()];
        } else {
          soundEffects = this.soundEffects;
        }
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setRate(rate);
        }
        return this;
      }
    };
  
    var RemoveItem$9 = Phaser.Utils.Array.Remove;
    var GetValue$38 = Phaser.Utils.Objects.GetValue;
    var SoundEffects2Methods = {
      getSoundEffects2: function getSoundEffects2() {
        return this.soundEffects2;
      },
      getLastSoundEffect2: function getLastSoundEffect2() {
        return this.soundEffects2[this.soundEffects2.length - 1];
      },
      playSoundEffect2: function playSoundEffect2(key, config) {
        if (!this.hasAudio(key)) {
          console.error("[Sound manager] Audio key'".concat(key, "' is not existed"));
          return this;
        }
        var music = this.sound.add(key, {
          mute: GetValue$38(config, 'mute', this.soundEffects2Mute),
          volume: GetValue$38(config, 'volume', this.soundEffects2Volume),
          detune: GetValue$38(config, 'detune', 0),
          rate: GetValue$38(config, 'rate', 1)
        });
        this.soundEffects2.push(music);
        music.once('complete', function () {
          music.destroy();
  
          // SoundManager has been destroyed
          if (!this.sound) {
            return;
          }
          RemoveItem$9(this.soundEffects2, music);
        }, this).once('destroy', function () {
          // SoundManager has been destroyed
          if (!this.sound) {
            return;
          }
          RemoveItem$9(this.soundEffects2, music);
        }, this).play();
        return this;
      },
      stopAllSoundEffects2: function stopAllSoundEffects2() {
        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
          var soundEffect = this.soundEffects[i];
          soundEffect.stop();
          soundEffect.destroy();
        }
        return this;
      },
      fadeInSoundEffect2: function fadeInSoundEffect2(time) {
        var soundEffect = this.getLastSoundEffect2();
        if (soundEffect) {
          FadeIn$1(soundEffect, time, this.soundEffects2Volume, 0);
        }
        return this;
      },
      fadeOutSoundEffect2: function fadeOutSoundEffect2(time, isStopped) {
        var soundEffect = this.getLastSoundEffect2();
        if (soundEffect) {
          FadeOut(soundEffect, time, isStopped);
        }
        return this;
      },
      fadeOutAllSoundEffects2: function fadeOutAllSoundEffects2(time, isStopped) {
        for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
          FadeOut(this.soundEffects2[i], time, isStopped);
        }
        return this;
      },
      setSoundEffect2Mute: function setSoundEffect2Mute(mute, lastSoundEffect) {
        if (mute === undefined) {
          mute = true;
        }
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        if (lastSoundEffect) {
          // Set volume of last sound effect
          var soundEffect = this.getLastSoundEffect2();
          if (soundEffect) {
            soundEffect.setMute(mute);
          }
        } else {
          // Set volume of all sound effects
          this.soundEffects2Mute = mute;
        }
        return this;
      },
      setSoundEffect2Volume: function setSoundEffect2Volume(volume, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        if (lastSoundEffect) {
          // Set volume of last sound effect
          var soundEffect = this.getLastSoundEffect2();
          if (soundEffect) {
            soundEffect.setVolume(volume);
          }
        } else {
          // Set volume of all sound effects
          this.soundEffects2Volume = volume;
        }
        return this;
      },
      setSoundEffect2Detune: function setSoundEffect2Detune(detune, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        var soundEffects;
        if (lastSoundEffect) {
          soundEffects = [this.getLastSoundEffect2()];
        } else {
          soundEffects = this.soundEffects2;
        }
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setDetune(detune);
        }
        return this;
      },
      setSoundEffect2Rate: function setSoundEffect2Rate(rate, lastSoundEffect) {
        if (lastSoundEffect === undefined) {
          lastSoundEffect = false;
        }
        var soundEffects;
        if (lastSoundEffect) {
          soundEffects = [this.getLastSoundEffect2()];
        } else {
          soundEffects = this.soundEffects2;
        }
        for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
          soundEffects[i].setRate(rate);
        }
        return this;
      }
    };
  
    var Methods$f = {
      hasAudio: HasaAudio
    };
    Object.assign(Methods$f, BackgroundMusicMethods, BackgroundMusic2Methods, SoundEffectsMethods, SoundEffects2Methods);
  
    var GetValue$37 = Phaser.Utils.Objects.GetValue;
    var SoundManager = /*#__PURE__*/function () {
      function SoundManager(game, config) {
        _classCallCheck(this, SoundManager);
        this.sound = GetSoundManager(game);
  
        // Background music will be (fade out)destroyed when play next one.
        this.backgroundMusic = undefined;
        this._backgroundMusicVolume = GetValue$37(config, 'bgm.volume', 1);
        this._backgroundMusicMute = GetValue$37(config, 'bgm.mute', false);
        this.setBackgroundMusicLoop(GetValue$37(config, 'bgm.loop', true));
        this.setBackgroundMusicFadeTime(GetValue$37(config, 'bgm.fade', 500));
        this.backgroundMusic2 = undefined;
        this._backgroundMusic2Volume = GetValue$37(config, 'bgm2.volume', 1);
        this._backgroundMusic2Mute = GetValue$37(config, 'bgm2.mute', false);
        this.setBackgroundMusic2Loop(GetValue$37(config, 'bgm2.loop', true));
        this.setBackgroundMusic2FadeTime(GetValue$37(config, 'bgm2.fade', 500));
  
        // Sound effect will be destroyed when completed
        this.soundEffects = [];
        this._soundEffectsVolume = GetValue$37(config, 'soundEffect.volume', 1);
        this.soundEffects2 = [];
        this._soundEffects2Volume = GetValue$37(config, 'soundEffect2.volume', 1);
        var initialBackgroundMusic = GetValue$37(config, 'bgm.initial', undefined);
        if (initialBackgroundMusic) {
          this.setCurrentBackgroundMusic(initialBackgroundMusic);
        }
        var initialBackgroundMusic2 = GetValue$37(config, 'bgm2.initial', undefined);
        if (initialBackgroundMusic2) {
          this.setCurrentBackgroundMusic2(initialBackgroundMusic2);
        }
      }
      _createClass(SoundManager, [{
        key: "destroy",
        value: function destroy() {
          if (this.backgroundMusic) {
            this.backgroundMusic.destroy();
          }
          this.backgroundMusic = undefined;
          if (this.backgroundMusic2) {
            this.backgroundMusic2.destroy();
          }
          this.backgroundMusic2 = undefined;
          if (this.soundEffects.length) {
            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
              this.soundEffects[i].destroy();
            }
          }
          this.soundEffects.length = 0;
          if (this.soundEffects2.length) {
            for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
              this.soundEffects2[i].destroy();
            }
          }
          this.soundEffects2.length = 0;
          this.sound = undefined;
          return this;
        }
  
        // backgroundMusic
        // mute
      }, {
        key: "backgroundMusicMute",
        get: function get() {
          return this._backgroundMusicMute;
        },
        set: function set(value) {
          this._backgroundMusicMute = value;
          if (this.backgroundMusic) {
            this.backgroundMusic.setMute(mute);
          }
        }
  
        // volume
      }, {
        key: "backgroundMusicVolume",
        get: function get() {
          return this._backgroundMusicVolume;
        },
        set: function set(value) {
          this._backgroundMusicVolume = value;
          if (this.backgroundMusic) {
            this.backgroundMusic.setVolume(value);
          }
        }
  
        // backgroundMusic2
        // mute
      }, {
        key: "backgroundMusic2Mute",
        get: function get() {
          return this._backgroundMusic2Mute;
        },
        set: function set(value) {
          this._backgroundMusic2Mute = value;
          if (this.backgroundMusic2) {
            this.backgroundMusic2.setMute(mute);
          }
        }
  
        // volume
      }, {
        key: "backgroundMusic2Volume",
        get: function get() {
          return this._backgroundMusic2Volume;
        },
        set: function set(value) {
          this._backgroundMusic2Volume = value;
          if (this.backgroundMusic2) {
            this.backgroundMusic2.setVolume(value);
          }
        }
  
        // soundEffects
        // mute
      }, {
        key: "soundEffectsMute",
        get: function get() {
          return this._soundEffectsMute;
        },
        set: function set(value) {
          this._soundEffectsMute = value;
          var soundEffects = this.soundEffects;
          for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
            soundEffects[i].setMute(value);
          }
        }
  
        // volume
      }, {
        key: "soundEffectsVolume",
        get: function get() {
          return this._soundEffectsVolume;
        },
        set: function set(value) {
          this._soundEffectsVolume = value;
          var soundEffects = this.soundEffects;
          for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
            soundEffects[i].setVolume(value);
          }
        }
  
        // soundEffects2
        // mute
      }, {
        key: "soundEffects2Mute",
        get: function get() {
          return this._soundEffects2Mute;
        },
        set: function set(value) {
          this._soundEffects2Mute = value;
          var soundEffects = this.soundEffects;
          for (var i = 0, cnt = soundEffects2.length; i < cnt; i++) {
            soundEffects[i].setMute(value);
          }
        }
  
        // volume
      }, {
        key: "soundEffects2Volume",
        get: function get() {
          return this._soundEffects2Volume;
        },
        set: function set(value) {
          this._soundEffects2Volume = value;
          var soundEffects = this.soundEffects2;
          for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
            soundEffects[i].setVolume(value);
          }
        }
      }]);
      return SoundManager;
    }();
    Object.assign(SoundManager.prototype, Methods$f);
  
    var GetValue$36 = Phaser.Utils.Objects.GetValue;
    var BaseClock = /*#__PURE__*/function (_TickTask) {
      _inherits(BaseClock, _TickTask);
      function BaseClock(parent, config) {
        var _this;
        _classCallCheck(this, BaseClock);
        _this = _callSuper(this, BaseClock, [parent, config]);
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(BaseClock, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.isRunning = GetValue$36(o, 'isRunning', false);
          this.timeScale = GetValue$36(o, 'timeScale', 1);
          this.now = GetValue$36(o, 'now', 0);
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            isRunning: this.isRunning,
            timeScale: this.timeScale,
            now: this.now,
            tickingMode: this.tickingMode
          };
        }
  
        // Override
        // startTicking() { }
  
        // Override
        // stopTicking() {}
      }, {
        key: "start",
        value: function start(startAt) {
          if (startAt === undefined) {
            startAt = 0;
          }
          this.delta = 0;
          this.now = startAt;
          _get(_getPrototypeOf(BaseClock.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "seek",
        value: function seek(time) {
          this.now = time;
          return this;
        }
      }, {
        key: "setTimeScale",
        value: function setTimeScale(value) {
          this.timeScale = value;
          return this;
        }
      }, {
        key: "tick",
        value: function tick(delta) {
          delta *= this.timeScale;
          this.now += delta;
          this.delta = delta;
          this.emit('update', this.now, this.delta);
          return this;
        }
      }]);
      return BaseClock;
    }(TickTask);
  
    var Clock = /*#__PURE__*/function (_BaseClock) {
      _inherits(Clock, _BaseClock);
      function Clock() {
        _classCallCheck(this, Clock);
        return _callSuper(this, Clock, arguments);
      }
      _createClass(Clock, [{
        key: "startTicking",
        value: function startTicking() {
          _get(_getPrototypeOf(Clock.prototype), "startTicking", this).call(this);
          this.scene.sys.events.on('update', this.update, this);
        }
      }, {
        key: "stopTicking",
        value: function stopTicking() {
          _get(_getPrototypeOf(Clock.prototype), "stopTicking", this).call(this);
          if (this.scene) {
            // Scene might be destoryed
            this.scene.sys.events.off('update', this.update, this);
          }
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          if (!this.isRunning || this.timeScale === 0) {
            return this;
          }
          this.tick(delta);
          return this;
        }
      }]);
      return Clock;
    }(BaseClock);
  
    var Yoyo$1 = function Yoyo(t, threshold) {
      if (threshold === undefined) {
        threshold = 0.5;
      }
      if (t <= threshold) {
        t = t / threshold;
      } else {
        t = 1 - (t - threshold) / (1 - threshold);
      }
      return t;
    };
  
    var Clamp$e = Phaser.Math.Clamp;
    var Timer = /*#__PURE__*/function () {
      function Timer(timeline, config) {
        _classCallCheck(this, Timer);
        this.setTimeline(timeline).reset(config);
      }
      _createClass(Timer, [{
        key: "setTimeline",
        value: function setTimeline(timeline) {
          this.timeline = timeline;
          return this;
        }
      }, {
        key: "setName",
        value: function setName(name) {
          this.name = name;
          return this;
        }
      }, {
        key: "setCallbacks",
        value: function setCallbacks(target, onStart, onProgress, onComplete) {
          this.target = target;
          this.onStart = onStart;
          this.onProgress = onProgress;
          this.onComplete = onComplete;
          return this;
        }
      }, {
        key: "setDuration",
        value: function setDuration(duration, yoyo) {
          if (yoyo === undefined) {
            yoyo = false;
          }
          this.duration = duration;
          this.remainder = duration;
          this.t = 0;
          this.yoyo = yoyo;
          return this;
        }
      }, {
        key: "setPaused",
        value: function setPaused(state) {
          this.isPaused = state;
          return this;
        }
      }, {
        key: "pause",
        value: function pause() {
          this.isPaused = true;
          return this;
        }
      }, {
        key: "resume",
        value: function resume() {
          this.isPaused = false;
          return this;
        }
      }, {
        key: "setRemoved",
        value: function setRemoved(state) {
          this.removed = state;
          return this;
        }
      }, {
        key: "remove",
        value: function remove() {
          this.removed = true;
          return this;
        }
      }, {
        key: "seek",
        value: function seek(t) {
          this.remainder = this.duration * (1 - t);
          return this;
        }
      }, {
        key: "reset",
        value: function reset(o) {
          this.setName(o.name).setDuration(o.duration, o.yoyo).setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete).setPaused(false).setRemoved(false);
          return this;
        }
      }, {
        key: "onFree",
        value: function onFree() {
          this.setTimeline().setCallbacks();
        }
      }, {
        key: "getProgress",
        value: function getProgress() {
          var value = 1 - this.remainder / this.duration;
          value = Clamp$e(value, 0, 1);
          if (this.yoyo) {
            value = Yoyo$1(value);
          }
          return value;
        }
      }, {
        key: "setProgress",
        value: function setProgress(value) {
          value = Clamp$e(value, 0, 1);
          this.remainder = this.duration * (1 - value);
        }
      }, {
        key: "runCallback",
        value: function runCallback(callback) {
          if (!callback) {
            return;
          }
          callback(this.target, this.t, this);
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          if (this.removed) {
            return true;
          } else if (this.isPaused) {
            return false;
          }
          this.remainder -= delta;
          this.t = this.getProgress();
          this.runCallback(this.onProgress);
          var isCompleted = this.remainder <= 0;
          if (isCompleted) {
            this.runCallback(this.onComplete);
          }
          return isCompleted;
        }
      }]);
      return Timer;
    }();
  
    var TimerPool$1 = /*#__PURE__*/function (_Pool) {
      _inherits(TimerPool, _Pool);
      function TimerPool() {
        _classCallCheck(this, TimerPool);
        return _callSuper(this, TimerPool, arguments);
      }
      _createClass(TimerPool, [{
        key: "allocate",
        value: function allocate() {
          return this.pop();
        }
      }, {
        key: "free",
        value: function free(timer) {
          timer.onFree();
          this.push(timer);
        }
      }, {
        key: "freeMultiple",
        value: function freeMultiple(arr) {
          for (var i = 0, cnt = arr.length; i < cnt; i++) {
            this.free(arr[i]);
          }
          return this;
        }
      }]);
      return TimerPool;
    }(Stack);
  
    var GetValue$35 = Phaser.Utils.Objects.GetValue;
    var TimerPool = new TimerPool$1();
    var Timeline = /*#__PURE__*/function (_Clock) {
      _inherits(Timeline, _Clock);
      function Timeline(parent, config) {
        var _this;
        _classCallCheck(this, Timeline);
        _this = _callSuper(this, Timeline, [parent, config]);
        _this.addedTimers = [];
        _this.timers = [];
        _this.timerPool = GetValue$35(config, 'pool', TimerPool);
        return _this;
      }
      _createClass(Timeline, [{
        key: "shutdown",
        value: function shutdown() {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers);
          this.timerPool = undefined;
          this.addedTimers = undefined;
          this.timers = undefined;
          _get(_getPrototypeOf(Timeline.prototype), "shutdown", this).call(this);
        }
      }, {
        key: "addTimer",
        value: function addTimer(config) {
          var timer = this.timerPool.allocate();
          if (!timer) {
            timer = new Timer(this, config);
          } else {
            timer.setTimeline(this).reset(config);
          }
          this.addedTimers.push(timer);
          timer.runCallback(timer.onStart);
          if (!this.isRunning) {
            this.start();
          }
          return timer;
        }
      }, {
        key: "delayCall",
        value: function delayCall(delay, callback, args, scope) {
          var timer = this.addTimer({
            duration: delay,
            onComplete: function onComplete(target, t, timer) {
              if (args === undefined) {
                args = [];
              }
              args.push(timer);
              callback.apply(scope, args);
            }
          });
          return timer;
        }
      }, {
        key: "delayEvent",
        value: function delayEvent(delay, eventName) {
          this.removeDelayEvent(eventName);
          // Clear existed event
  
          var timer = this.delayCall(delay, function () {
            this.removeDelayEvent(eventName); // Clear this timer
            this.emit(eventName);
          }, [], this);
          this.once("_remove.".concat(eventName), function () {
            timer.remove();
            timer = undefined;
          });
          return this;
        }
      }, {
        key: "removeDelayEvent",
        value: function removeDelayEvent(eventName) {
          this.emit("_remove.".concat(eventName));
          return this;
        }
      }, {
        key: "getTimers",
        value: function getTimers(name) {
          var timers = [];
          var timerQueues = [this.addedTimers, this.timers];
          for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
            var timerQueue = timerQueues[ti];
            for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
              var timer = timerQueue[i];
              if (timer.name === name) {
                timers.push(timer);
              }
            }
          }
          return timers;
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          var _this$timers;
          _get(_getPrototypeOf(Timeline.prototype), "update", this).call(this, time, delta);
          if (!this.isRunning) {
            return;
          }
          (_this$timers = this.timers).push.apply(_this$timers, _toConsumableArray(this.addedTimers));
          this.addedTimers.length = 0;
          var pendingTimers = [];
          for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
            var timer = this.timers[i];
            var isStopped = timer.update(this.now, this.delta);
            if (isStopped) {
              this.timerPool.free(timer); // Free timer
            } else {
              pendingTimers.push(timer); // Add to timer queue
            }
          }
          this.timers = pendingTimers;
          if (this.timers.length === 0 && this.addedTimers.length === 0) {
            this.complete(); // Emit 'complete' event
          }
        }
      }]);
      return Timeline;
    }(Clock);
  
    var WaitCompleteEvent = '_wait.complete';
    var RemoveWaitEvents = '_remove.wait';
  
    var PreUpdateDelayCall = function PreUpdateDelayCall(gameObject, delay, callback, scope, args) {
      // Invoke callback under scene's 'preupdate' event
      var scene = GetSceneObject(gameObject);
      var timer = scene.time.delayedCall(delay, function () {
        scene.sys.events.once('preupdate', function () {
          callback.call(scope, args);
        });
      });
      return timer;
    };
  
    var WaitEvent$1 = /*#__PURE__*/function () {
      function WaitEvent(parent) {
        _classCallCheck(this, WaitEvent);
        if (!parent) {
          this.setEventEmitter(true);
          parent = this;
        }
        this.parent = parent;
        this.waitId = 0;
  
        // Override it
        this.waitCompleteEventName = WaitCompleteEvent;
        this.removeWaitEventsEventName = RemoveWaitEvents;
      }
      _createClass(WaitEvent, [{
        key: "destroy",
        value: function destroy() {
          this.removeWaitEvents();
          this.clearWaitCompleteCallbacks();
          this.parent = null;
        }
  
        // Emit completeEvent (default value is 'complete') when eventEmitter firing eventName
      }, {
        key: "waitEvent",
        value: function waitEvent(eventEmitter, eventName, completeNextTick) {
          var callback = this.getWaitCompleteTriggerCallback(completeNextTick);
          eventEmitter.once(eventName, callback, this);
          // Once completeEvent firing, remove pending eventName from eventEmitter
          this.parent.once(this.removeWaitEventsEventName, function () {
            eventEmitter.off(eventName, callback, this);
          });
          // All pending eventName from eventEmitter will be removed at last
          return this.parent;
        }
      }, {
        key: "getWaitCompleteTriggerCallback",
        value: function getWaitCompleteTriggerCallback(completeNextTick) {
          if (completeNextTick === undefined) {
            completeNextTick = true;
          }
          var waitId = this.waitId;
          var self = this;
          var completeCallback = function completeCallback() {
            if (waitId < self.waitId) {
              return;
            }
            self.waitId++;
            self.removeWaitEvents();
            self.parent.emit(self.waitCompleteEventName);
          };
          if (completeNextTick) {
            var completeCallbackNextTick = function completeCallbackNextTick() {
              PreUpdateDelayCall(self.parent, 0, completeCallback);
            };
            return completeCallbackNextTick;
          } else {
            return completeCallback;
          }
        }
      }, {
        key: "removeWaitEvents",
        value: function removeWaitEvents() {
          this.parent.emit(this.removeWaitEventsEventName);
          return this;
        }
      }, {
        key: "addWaitCompleteCallback",
        value: function addWaitCompleteCallback(callback, scope) {
          this.parent.on(this.waitCompleteEventName, callback, scope);
          return this;
        }
      }, {
        key: "clearWaitCompleteCallbacks",
        value: function clearWaitCompleteCallbacks() {
          this.parent.off(this.waitCompleteEventName);
          return this;
        }
      }]);
      return WaitEvent;
    }();
    Object.assign(WaitEvent$1.prototype, EventEmitterMethods$1);
  
    var WaitTimeMethods = {
      waitTime: function waitTime(duration) {
        var timeline = this.parent.timeline;
        timeline.delayEvent(duration, 'delay');
  
        // Clear delay event on timeline manually
        this.parent.once(this.removeWaitEventsEventName, function () {
          timeline.removeDelayEvent('delay');
        });
        return this.waitEvent(timeline, 'delay');
      }
    };
  
    var Split = function Split(s, delimiter) {
      var regexString = "(?<!\\\\)\\".concat(delimiter);
      var escapeString = "\\".concat(delimiter);
      return s.split(new RegExp(regexString, 'g')).map(function (s) {
        return s.replace(escapeString, delimiter);
      });
    };
  
    var WaitInputMethods = {
      setClickTarget: function setClickTarget(target) {
        this.clickTarget = target;
        if (!target) {
          this.touchEE = null;
        } else if (IsSceneObject(target)) {
          this.touchEE = target.input;
        } else {
          // Assume that target is a gameObject
          this.touchEE = target.setInteractive();
        }
        return this;
      },
      clearClickTarget: function clearClickTarget() {
        this.setClickTarget();
        return this;
      },
      setClickShortcutKeys: function setClickShortcutKeys(keys) {
        this.clickShortcutKeys = keys;
        return this;
      },
      clearClickShortcutKeys: function clearClickShortcutKeys() {
        this.setShortcutKeys();
        return this;
      },
      waitClick: function waitClick() {
        var touchEE = this.touchEE;
        var clickShortcutKeys = this.clickShortcutKeys;
        if (touchEE || clickShortcutKeys) {
          if (touchEE) {
            this.waitEvent(touchEE, 'pointerdown');
          }
          if (clickShortcutKeys) {
            this.waitKeyDown(clickShortcutKeys);
          }
        } else {
          this.waitTime(0);
        }
        return this;
      },
      waitKeyDown: function waitKeyDown(key) {
        var eventEmitter = this.scene.input.keyboard;
        if (typeof key === 'string') {
          if (key.indexOf('|') === -1) {
            return this.waitEvent(eventEmitter, "keydown-".concat(key.toUpperCase()));
          } else {
            var keys = Split(key, '|');
            for (var i = 0, cnt = keys.length; i < cnt; i++) {
              this.waitEvent(eventEmitter, "keydown-".concat(keys[i].toUpperCase()));
            }
            return this.parent;
          }
        } else {
          return this.waitEvent(eventEmitter, 'keydown');
        }
      }
    };
  
    var WaitGameObjectMethods = {
      waitGameObjectTweenComplete: function waitGameObjectTweenComplete(goType, name, property) {
        var tweenTask = this.parent.getGameObjectTweenTask(goType, name, property);
        if (tweenTask) {
          return this.waitEvent(tweenTask, 'complete');
        }
        return this.waitTime(0);
      },
      waitGameObjectDataFlag: function waitGameObjectDataFlag(goType, name, dataKey, trueFlag) {
        var gameObject = this.parent.getGameObject(goType, name);
        if (!gameObject) {
          return this.waitTime(0);
        }
        if (gameObject.getData(dataKey) === trueFlag) {
          return this.waitTime(0);
        }
        var eventName = "changedata-".concat(dataKey);
        var callback = function callback(gameObject, value, previousValue) {
          value = !!value;
          if (value === trueFlag) {
            gameObject.emit('_dataFlagMatch');
          }
        };
        gameObject.on(eventName, callback);
        // Clear changedata event on gameobject manually
        this.parent.once(this.removeWaitEventsEventName, function () {
          gameObject.off(eventName, callback);
        });
        return this.waitEvent(gameObject, '_dataFlagMatch');
      },
      waitGameObjectDestroy: function waitGameObjectDestroy(goType, name) {
        var gameObject = this.parent.getGameObject(goType, name);
        if (!gameObject) {
          return this.waitTime(0);
        }
        return this.waitEvent(gameObject, 'destroy');
      },
      waitGameObjectManagerEmpty: function waitGameObjectManagerEmpty(goType) {
        if (goType) {
          var gameObjectManager = this.parent.getGameObjectManager(goType);
          if (!gameObjectManager) {
            return this.waitTime(0);
          }
          return this.waitEvent(gameObjectManager, 'empty');
        } else {
          var gameObjectManagers = this.parent.gameObjectManagers;
          var hasAnyWaitEvent = false;
          for (var name in gameObjectManagers) {
            hasAnyWaitEvent = true;
            this.waitEvent(gameObjectManagers[name], 'empty');
          }
          if (!hasAnyWaitEvent) {
            return this.waitTime(0);
          }
          return this.parent;
        }
      }
    };
  
    var WaitCameraMethods = {
      setCameraTarget: function setCameraTarget(camera) {
        this.cameraTarget = camera;
        return this;
      },
      clearCameraTarget: function clearCameraTarget() {
        this.setCameraTarget();
        return this;
      },
      waitCameraEffectComplete: function waitCameraEffectComplete(effectName, cameraName) {
        var camera;
        if (cameraName) {
          camera = this.scene.cameras.getCamera(cameraName);
        } else {
          camera = this.cameraTarget;
        }
        if (!camera) {
          return this.waitTime(0);
        }
        var effect, completeEventName;
        switch (effectName) {
          case 'camera.fadein':
            effect = camera.fadeEffect;
            completeEventName = 'camerafadeincomplete';
            break;
          case 'camera.fadeout':
            effect = camera.fadeEffect;
            completeEventName = 'camerafadeoutcomplete';
            break;
          case 'camera.flash':
            effect = camera.flashEffect;
            completeEventName = 'cameraflashcomplete';
            break;
          case 'camera.shake':
            effect = camera.shakeEffect;
            completeEventName = 'camerashakecomplete';
            break;
          case 'camera.zoom':
            effect = camera.zoomEffect;
            completeEventName = 'camerazoomcomplete';
            break;
          case 'camera.rotate':
            effect = camera.rotateToEffect;
            completeEventName = 'camerarotatecomplete';
            break;
          case 'camera.scroll':
            effect = camera.panEffect;
            completeEventName = 'camerapancomplete';
            break;
        }
        if (!effect.isRunning) {
          return this.waitTime(0);
        }
        return this.waitEvent(camera, completeEventName);
      }
    };
  
    var WaitMusicMethods = {
      waitSoundEffectComplete: function waitSoundEffectComplete() {
        if (!this.parent.soundManager) {
          return this.waitTime(0);
        }
        var music = this.parent.soundManager.getLastSoundEffect();
        if (!music) {
          return this.waitTime(0);
        }
        return this.waitEvent(music, 'complete');
      },
      waitSoundEffect2Complete: function waitSoundEffect2Complete() {
        if (!this.parent.soundManager) {
          return this.waitTime(0);
        }
        var music = this.parent.soundManager.getLastSoundEffect2();
        if (!music) {
          return this.waitTime(0);
        }
        return this.waitEvent(music, 'complete');
      },
      waitBackgroundMusicComplete: function waitBackgroundMusicComplete() {
        if (!this.parent.soundManager) {
          return this.waitTime(0);
        }
        var music = this.parent.soundManager.getBackgroundMusic();
        if (!music) {
          return this.waitTime(0);
        }
        return this.waitEvent(music, 'complete');
      },
      waitBackgroundMusic2Complete: function waitBackgroundMusic2Complete() {
        if (!this.parent.soundManager) {
          return this.waitTime(0);
        }
        var music = this.parent.soundManager.getBackgroundMusic2();
        if (!music) {
          return this.waitTime(0);
        }
        return this.waitEvent(music, 'complete');
      }
    };
  
    var WaitAny$1 = function WaitAny(config) {
      if (!config) {
        return this.waitTime(0);
      }
      var hasAnyWaitEvent = false;
      for (var name in config) {
        switch (name) {
          case 'time':
            hasAnyWaitEvent = true;
            this.waitTime(config.time);
            break;
          case 'click':
            hasAnyWaitEvent = true;
            this.waitClick();
            break;
          case 'key':
            hasAnyWaitEvent = true;
            this.waitKeyDown(config.key);
            break;
          case 'bgm':
            hasAnyWaitEvent = true;
            this.waitBackgroundMusicComplete();
            break;
          case 'bgm2':
            hasAnyWaitEvent = true;
            this.waitBackgroundMusic2Complete();
            break;
          case 'se':
            hasAnyWaitEvent = true;
            this.waitSoundEffectComplete();
            break;
          case 'se2':
            hasAnyWaitEvent = true;
            this.waitSoundEffect2Complete();
            break;
          case 'camera':
            hasAnyWaitEvent = true;
            this.waitCameraEffectComplete("camera.".concat(config.camera.toLowerCase()), config.cameraName);
            break;
          default:
            var names = name.split('.');
            if (names.length === 2) {
              // GONAME.destroy, GONAME.PROPNAME, GONAME.DATAKEY, GONAME.EVTNAME
  
              var gameObjectName = names[0];
              var propName = names[1];
              var gameObjectManager = this.parent.getGameObjectManager(undefined, gameObjectName);
              if (!gameObjectManager) {
                continue;
              }
  
              // GONAME.destroy
              if (propName === 'destroy') {
                return this.waitGameObjectDestroy(undefined, gameObjectName);
              }
  
              // GONAME.PROPNAME (tween.complete)
              var value = gameObjectManager.getProperty(gameObjectName, propName);
              if (typeof value === 'number') {
                hasAnyWaitEvent = true;
                this.waitGameObjectTweenComplete(undefined, gameObjectName, propName);
                continue;
              }
  
              // GONAME.DATAKEY (boolean)
              var dataKey = propName;
              var matchFalseFlag = dataKey.startsWith('!');
              if (matchFalseFlag) {
                dataKey = dataKey.substring(1);
              }
              if (gameObjectManager.hasData(gameObjectName, propName)) {
                hasAnyWaitEvent = true;
                this.waitGameObjectDataFlag(undefined, gameObjectName, dataKey, !matchFalseFlag);
                continue;
              }
  
              // GONAME.EVTNAME
              this.waitEvent(gameObject, propName);
              continue;
            } else if (names.length === 1) ;
            break;
        }
      }
      if (!hasAnyWaitEvent) {
        this.waitTime(0);
      }
      return this.parent;
    };
  
    var methods$C = {
      waitAny: WaitAny$1
    };
    Object.assign(methods$C, WaitTimeMethods, WaitInputMethods, WaitGameObjectMethods, WaitCameraMethods, WaitMusicMethods);
  
    var WaitEventManager = /*#__PURE__*/function (_WaitEvent) {
      _inherits(WaitEventManager, _WaitEvent);
      function WaitEventManager(parent, config) {
        var _this;
        _classCallCheck(this, WaitEventManager);
        _this = _callSuper(this, WaitEventManager, [parent]);
        _this.waitCompleteEventName = GetValue$3G(config, 'completeEventName', _this.waitCompleteEventName);
        _this.setClickTarget(GetValue$3G(config, 'clickTarget', _this.scene));
        _this.setClickShortcutKeys(GetValue$3G(config, 'clickShortcutKeys', undefined));
        _this.setCameraTarget(GetValue$3G(config, 'camera', _this.scene.cameras.main));
        return _this;
      }
      _createClass(WaitEventManager, [{
        key: "clickTarget",
        get: function get() {
          return this.parent.clickTarget;
        },
        set: function set(value) {
          this.parent.clickTarget = value;
        }
      }, {
        key: "clickShortcutKeys",
        get: function get() {
          return this.parent.clickShortcutKeys;
        },
        set: function set(value) {
          this.parent.clickShortcutKeys = value;
        }
      }, {
        key: "cameraTarget",
        get: function get() {
          return this.parent.cameraTarget;
        },
        set: function set(value) {
          this.parent.cameraTarget = value;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.clearClickTarget();
          this.clearClickShortcutKeys();
          this.clearCameraTarget();
          _get(_getPrototypeOf(WaitEventManager.prototype), "destroy", this).call(this);
        }
      }, {
        key: "scene",
        get: function get() {
          return this.parent.managersScene;
        }
      }]);
      return WaitEventManager;
    }(WaitEvent$1);
    Object.assign(WaitEventManager.prototype, methods$C);
  
    var GetValue$34 = Phaser.Utils.Objects.GetValue;
    var InitManagers = function InitManagers(scene, config) {
      this.clickTarget = undefined;
      this.clickShortcutKeys = undefined;
      this.cameraTarget = undefined;
      this.managersScene = scene;
      this.gameObjectManagers = {};
      var layerNames = GetValue$34(config, 'layers', false);
      if (layerNames !== false) {
        var layerManager = new LayerManager(scene, {
          name: 'LAYER',
          layers: layerNames,
          rootLayer: GetValue$34(config, 'rootLayer', undefined),
          depth: GetValue$34(config, 'layerDepth', undefined)
        });
        this.addGameObjectManager(layerManager);
        this.layerManager = layerManager;
      }
      var soundManagerConfig = GetValue$34(config, 'sounds');
      if (soundManagerConfig !== false) {
        this.soundManager = new SoundManager(scene, soundManagerConfig);
      }
      this.timeline = new Timeline(this);
      this.waitEventManager = new WaitEventManager(this, config);
      return this;
    };
  
    var SetTimeScale = function SetTimeScale(value) {
      this.timeline.timeScale = value;
      for (var name in this.gameObjectManagers) {
        this.gameObjectManagers[name].setTimeScale(value);
      }
      return this;
    };
  
    var GetTimeScale = function GetTimeScale() {
      return this.timeline.timeScale;
    };
  
    var DestroyManagers = function DestroyManagers(fromScene) {
      this.waitEventManager.destroy();
      this.waitEventManager = undefined;
  
      // Destroy layerManager at last
      delete this.gameObjectManagers.layer;
      for (var name in this.gameObjectManagers) {
        this.gameObjectManagers[name].destroy(fromScene);
        delete this.gameObjectManagers[name];
      }
      if (this.layerManager) {
        this.layerManager.destroy(fromScene);
        this.layerManager = undefined;
      }
      if (this.soundManager) {
        this.soundManager.destroy();
        this.soundManager = undefined;
      }
      if (this.timeline) {
        this.timeline.destroy();
        this.timeline = undefined;
      }
      this.clickTarget = undefined;
      this.clickShortcutKeys = undefined;
      this.cameraTarget = undefined;
      this.managersScene = undefined;
    };
  
    var GameObjectManagerMethods$1 = {
      addGameObjectManager: function addGameObjectManager(config, GameObjectManagerClass) {
        var gameobjectManager;
        if (config instanceof GOManager) {
          gameobjectManager = config;
        } else if (typeof config === 'string') {
          gameobjectManager = GameObjectManagerClass;
          gameobjectManager.name = config;
        } else {
          if (config === undefined) {
            config = {};
          }
          if (GameObjectManagerClass === undefined) {
            GameObjectManagerClass = GOManager;
          }
          if (!config.createGameObjectScope) {
            config.createGameObjectScope = this;
          }
          gameobjectManager = new GameObjectManagerClass(this.managersScene, config);
        }
        this.gameObjectManagers[gameobjectManager.name] = gameobjectManager;
        return this;
      },
      getGameObjectManager: function getGameObjectManager(managerName, gameObjectName) {
        if (managerName) {
          var manager = this.gameObjectManagers[managerName];
          return manager;
        } else {
          if (gameObjectName && gameObjectName.charAt(0) === '!') {
            gameObjectName = gameObjectName.substring(1);
          }
          for (var managerName in this.gameObjectManagers) {
            var manager = this.gameObjectManagers[managerName];
            if (manager.has(gameObjectName)) {
              return manager;
            }
          }
        }
      },
      getGameObjectManagerNames: function getGameObjectManagerNames() {
        var names = [];
        for (var name in this.gameObjectManagers) {
          names.push(name);
        }
        return names;
      },
      getGameObjectManagerName: function getGameObjectManagerName(gameObjectName) {
        var gameObjectManager = this.getGameObjectManager(undefined, gameObjectName);
        if (!gameObjectManager) {
          return undefined;
        }
        return gameObjectManager.name;
      },
      hasGameObjectMananger: function hasGameObjectMananger(managerName) {
        return managerName in this.gameObjectManagers;
      }
    };
  
    var GameObjectMethods = {
      createGameObject: function createGameObject(goType, name) {
        var _this$getGameObjectMa;
        for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          params[_key - 2] = arguments[_key];
        }
        (_this$getGameObjectMa = this.getGameObjectManager(goType, name)).add.apply(_this$getGameObjectMa, [name].concat(params));
        return this;
      },
      destroyGameObject: function destroyGameObject(goType, name) {
        var gameObjectManager = this.getGameObjectManager(goType, name);
        if (name === undefined) {
          gameObjectManager.removeAll();
        } else {
          gameObjectManager.remove(name);
        }
        return this;
      },
      hasGameObject: function hasGameObject(goType, name) {
        return !!this.getGameObjectManager(goType, name);
      },
      callGameObjectMethod: function callGameObjectMethod(goType, name, methodName) {
        var _this$getGameObjectMa2;
        for (var _len2 = arguments.length, params = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          params[_key2 - 3] = arguments[_key2];
        }
        (_this$getGameObjectMa2 = this.getGameObjectManager(goType, name)).call.apply(_this$getGameObjectMa2, [name, methodName].concat(params));
        return this;
      },
      setGameObjectProperty: function setGameObjectProperty(goType, name, prop, value) {
        this.getGameObjectManager(goType, name).setProperty(name, prop, value);
        return this;
      },
      easeGameObjectProperty: function easeGameObjectProperty(goType, name, config) {
        this.getGameObjectManager(goType, name).easeProperty(name, config);
        return this;
      },
      getGameObjectTweenTask: function getGameObjectTweenTask(goType, name, property) {
        return this.getGameObjectManager(goType, name).getTweenTask(name, property);
      },
      getGameObject: function getGameObject(goType, name, out) {
        var gameobjectManager = this.getGameObjectManager(goType, name);
        if (!gameobjectManager) {
          return out;
        }
        if (typeof name === 'string') {
          return gameobjectManager.getGO(name);
        } else {
          if (out === undefined) {
            out = [];
          }
          var names = name;
          if (names === undefined) {
            names = Object.keys(gameobjectManager.bobs);
          }
          var isArrayOutput = Array.isArray(out);
          for (var i = 0, cnt = names.length; i < cnt; i++) {
            name = names[i];
            var gameObject = gameobjectManager.getGO(name);
            if (!gameObject) {
              continue;
            }
            if (isArrayOutput) {
              out.push(gameObject);
            } else {
              out[name] = gameObject;
            }
          }
          return out;
        }
      },
      addGameObject: function addGameObject(goType, name, gameObject) {
        var gameobjectManager = this.getGameObjectManager(goType, name);
        if (typeof name === 'string') {
          gameobjectManager.addGO(name, gameObject);
        } else {
          var names = name;
          for (name in names) {
            gameobjectManager.addGO(name, names[name]);
          }
        }
        return this;
      },
      drawGameObjectsBounds: function drawGameObjectsBounds(goTypes, graphics, config) {
        if (goTypes instanceof Phaser.GameObjects.Graphics) {
          config = graphics;
          graphics = goTypes;
          goTypes = undefined;
        }
        if (goTypes === undefined) {
          goTypes = this.getGameObjectManagerNames();
        }
        if (!Array.isArray(goTypes)) {
          goTypes = [goTypes];
        }
        for (var i = 0, cnt = goTypes.length; i < cnt; i++) {
          this.getGameObjectManager(goTypes[i]).drawGameObjectsBounds(graphics, config);
        }
        return this;
      }
    };
  
    var Extend = function Extend(BaseClass) {
      var Managers = /*#__PURE__*/function (_BaseClass) {
        _inherits(Managers, _BaseClass);
        function Managers() {
          _classCallCheck(this, Managers);
          return _callSuper(this, Managers, arguments);
        }
        return _createClass(Managers);
      }(BaseClass);
      var Methods = {
        initManagers: InitManagers,
        setTimeScale: SetTimeScale,
        getTimeScale: GetTimeScale,
        destroyManagers: DestroyManagers
      };
      Object.assign(Managers.prototype, Methods, GameObjectManagerMethods$1, GameObjectMethods);
      return Managers;
    };
  
    function getDefaultExportFromCjs (x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }
  
    var eventemitter3 = {exports: {}};
  
    (function (module) {
  
        var has = Object.prototype.hasOwnProperty
          , prefix = '~';
  
        /**
         * Constructor to create a storage for our `EE` objects.
         * An `Events` instance is a plain object whose properties are event names.
         *
         * @constructor
         * @private
         */
        function Events() {}
  
        //
        // We try to not inherit from `Object.prototype`. In some engines creating an
        // instance in this way is faster than calling `Object.create(null)` directly.
        // If `Object.create(null)` is not supported we prefix the event names with a
        // character to make sure that the built-in object properties are not
        // overridden or used as an attack vector.
        //
        if (Object.create) {
          Events.prototype = Object.create(null);
  
          //
          // This hack is needed because the `__proto__` property is still inherited in
          // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
          //
          if (!new Events().__proto__) prefix = false;
        }
  
        /**
         * Representation of a single event listener.
         *
         * @param {Function} fn The listener function.
         * @param {*} context The context to invoke the listener with.
         * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
         * @constructor
         * @private
         */
        function EE(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
  
        /**
         * Add a listener for a given event.
         *
         * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
         * @param {(String|Symbol)} event The event name.
         * @param {Function} fn The listener function.
         * @param {*} context The context to invoke the listener with.
         * @param {Boolean} once Specify if the listener is a one-time listener.
         * @returns {EventEmitter}
         * @private
         */
        function addListener(emitter, event, fn, context, once) {
          if (typeof fn !== 'function') {
            throw new TypeError('The listener must be a function');
          }
  
          var listener = new EE(fn, context || emitter, once)
            , evt = prefix ? prefix + event : event;
  
          if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
          else emitter._events[evt] = [emitter._events[evt], listener];
  
          return emitter;
        }
  
        /**
         * Clear event by name.
         *
         * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
         * @param {(String|Symbol)} evt The Event name.
         * @private
         */
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0) emitter._events = new Events();
          else delete emitter._events[evt];
        }
  
        /**
         * Minimal `EventEmitter` interface that is molded against the Node.js
         * `EventEmitter` interface.
         *
         * @constructor
         * @public
         */
        function EventEmitter() {
          this._events = new Events();
          this._eventsCount = 0;
        }
  
        /**
         * Return an array listing the events for which the emitter has registered
         * listeners.
         *
         * @returns {Array}
         * @public
         */
        EventEmitter.prototype.eventNames = function eventNames() {
          var names = []
            , events
            , name;
  
          if (this._eventsCount === 0) return names;
  
          for (name in (events = this._events)) {
            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
          }
  
          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
          }
  
          return names;
        };
  
        /**
         * Return the listeners registered for a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @returns {Array} The registered listeners.
         * @public
         */
        EventEmitter.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event
            , handlers = this._events[evt];
  
          if (!handlers) return [];
          if (handlers.fn) return [handlers.fn];
  
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
          }
  
          return ee;
        };
  
        /**
         * Return the number of listeners listening to a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @returns {Number} The number of listeners.
         * @public
         */
        EventEmitter.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event
            , listeners = this._events[evt];
  
          if (!listeners) return 0;
          if (listeners.fn) return 1;
          return listeners.length;
        };
  
        /**
         * Calls each of the listeners registered for a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @returns {Boolean} `true` if the event had listeners, else `false`.
         * @public
         */
        EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
  
          if (!this._events[evt]) return false;
  
          var listeners = this._events[evt]
            , len = arguments.length
            , args
            , i;
  
          if (listeners.fn) {
            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
            switch (len) {
              case 1: return listeners.fn.call(listeners.context), true;
              case 2: return listeners.fn.call(listeners.context, a1), true;
              case 3: return listeners.fn.call(listeners.context, a1, a2), true;
              case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
  
            for (i = 1, args = new Array(len -1); i < len; i++) {
              args[i - 1] = arguments[i];
            }
  
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length
              , j;
  
            for (i = 0; i < length; i++) {
              if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
              switch (len) {
                case 1: listeners[i].fn.call(listeners[i].context); break;
                case 2: listeners[i].fn.call(listeners[i].context, a1); break;
                case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
                case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
                default:
                  if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
  
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
  
          return true;
        };
  
        /**
         * Add a listener for a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @param {Function} fn The listener function.
         * @param {*} [context=this] The context to invoke the listener with.
         * @returns {EventEmitter} `this`.
         * @public
         */
        EventEmitter.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
  
        /**
         * Add a one-time listener for a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @param {Function} fn The listener function.
         * @param {*} [context=this] The context to invoke the listener with.
         * @returns {EventEmitter} `this`.
         * @public
         */
        EventEmitter.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
  
        /**
         * Remove the listeners of a given event.
         *
         * @param {(String|Symbol)} event The event name.
         * @param {Function} fn Only remove the listeners that match this function.
         * @param {*} context Only remove the listeners that have this context.
         * @param {Boolean} once Only remove one-time listeners.
         * @returns {EventEmitter} `this`.
         * @public
         */
        EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
  
          if (!this._events[evt]) return this;
          if (!fn) {
            clearEvent(this, evt);
            return this;
          }
  
          var listeners = this._events[evt];
  
          if (listeners.fn) {
            if (
              listeners.fn === fn &&
              (!once || listeners.once) &&
              (!context || listeners.context === context)
            ) {
              clearEvent(this, evt);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (
                listeners[i].fn !== fn ||
                (once && !listeners[i].once) ||
                (context && listeners[i].context !== context)
              ) {
                events.push(listeners[i]);
              }
            }
  
            //
            // Reset the array, or remove it completely if we have no more listeners.
            //
            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
            else clearEvent(this, evt);
          }
  
          return this;
        };
  
        /**
         * Remove all listeners, or those of the specified event.
         *
         * @param {(String|Symbol)} [event] The event name.
         * @returns {EventEmitter} `this`.
         * @public
         */
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
  
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt]) clearEvent(this, evt);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
  
          return this;
        };
  
        //
        // Alias methods names because people roll like that.
        //
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
        //
        // Expose the prefix.
        //
        EventEmitter.prefixed = prefix;
  
        //
        // Allow `EventEmitter` to be imported as module namespace.
        //
        EventEmitter.EventEmitter = EventEmitter;
  
        //
        // Expose the module.
        //
        {
          module.exports = EventEmitter;
        } 
    } (eventemitter3));
  
    var eventemitter3Exports = eventemitter3.exports;
    var EE = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);
  
    var EventEmitter = /*#__PURE__*/function (_EE) {
      _inherits(EventEmitter, _EE);
      function EventEmitter() {
        _classCallCheck(this, EventEmitter);
        return _callSuper(this, EventEmitter, arguments);
      }
      _createClass(EventEmitter, [{
        key: "shutdown",
        value: function shutdown() {
          this.removeAllListeners();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.removeAllListeners();
        }
      }]);
      return EventEmitter;
    }(EE);
  
    var EventEmitterMethods = {
      setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
        if (EventEmitterClass === undefined) {
          EventEmitterClass = EventEmitter;
        }
        this._privateEE = eventEmitter === true || eventEmitter === undefined;
        this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
        return this;
      },
      destroyEventEmitter: function destroyEventEmitter() {
        if (this._eventEmitter && this._privateEE) {
          this._eventEmitter.shutdown();
        }
        return this;
      },
      getEventEmitter: function getEventEmitter() {
        return this._eventEmitter;
      },
      on: function on() {
        if (this._eventEmitter) {
          this._eventEmitter.on.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      once: function once() {
        if (this._eventEmitter) {
          this._eventEmitter.once.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      off: function off() {
        if (this._eventEmitter) {
          this._eventEmitter.off.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      emit: function emit(event) {
        if (this._eventEmitter && event) {
          this._eventEmitter.emit.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      addListener: function addListener() {
        if (this._eventEmitter) {
          this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      removeListener: function removeListener() {
        if (this._eventEmitter) {
          this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        if (this._eventEmitter) {
          this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
        }
        return this;
      },
      listenerCount: function listenerCount() {
        if (this._eventEmitter) {
          return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
        }
        return 0;
      },
      listeners: function listeners() {
        if (this._eventEmitter) {
          return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
        }
        return [];
      },
      eventNames: function eventNames() {
        if (this._eventEmitter) {
          return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
        }
        return [];
      }
    };
  
    var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
    var HEX = /^0x[0-9A-F]+$/i;
    var TypeConvert = function TypeConvert(s) {
      if (typeof s !== 'string') {
        return s;
      }
      if (s === '') {
        s = null;
      } else if (FLOAT.test(s)) {
        s = parseFloat(s);
      } else if (HEX.test(s)) {
        s = parseInt(s, 16);
      } else {
        switch (s) {
          case 'false':
            s = false;
            break;
          case 'true':
            s = true;
            break;
          case 'null':
            s = null;
            break;
          case 'undefined':
            s = undefined;
            break;
        }
      }
      return s;
    };
  
    var BracketParser$1 = /*#__PURE__*/function () {
      function BracketParser(config) {
        _classCallCheck(this, BracketParser);
        // Event emitter
        this.setEventEmitter(GetValue$3G(config, 'eventEmitter', undefined));
  
        // Value convert
        this.setValueConverter(GetValue$3G(config, 'valueConvert', true));
        // Loop
        this.setLoopEnable(GetValue$3G(config, 'loop', false));
  
        // Brackets and generate regex
        this.setMultipleLinesTagEnable(GetValue$3G(config, 'multipleLinesTag', false));
        var delimiters = GetValue$3G(config, 'delimiters', '<>');
        this.setDelimiters(delimiters[0], delimiters[1]);
  
        // Translate tagName callback
        this.setTranslateTagNameCallback(GetValue$3G(config, 'translateTagNameCallback'));
        this.isRunning = false;
        this.isPaused = false;
        this.skipEventFlag = false;
        this.justCompleted = false;
        this.lastTagStart = null;
        this.lastTagEnd = null;
        this.lastContent = null;
      }
      _createClass(BracketParser, [{
        key: "shutdown",
        value: function shutdown() {
          this.destroyEventEmitter();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.shutdown();
        }
      }, {
        key: "setMultipleLinesTagEnable",
        value: function setMultipleLinesTagEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.multipleLinesTagEnable = enable;
          return this;
        }
  
        // Override
      }, {
        key: "setDelimiters",
        value: function setDelimiters(delimiterLeft, delimiterRight) {
          if (delimiterRight === undefined) {
            delimiterRight = delimiterLeft[1];
            delimiterLeft = delimiterLeft[0];
          }
          this.delimiterLeft = delimiterLeft;
          this.delimiterRight = delimiterRight;
          delimiterLeft = EscapeRegex(this.delimiterLeft);
          delimiterRight = EscapeRegex(this.delimiterRight);
          var flag = this.multipleLinesTagEnable ? 'gs' : 'gi';
          this.reSplit = RegExp("".concat(delimiterLeft, "(.+?)").concat(delimiterRight), flag);
          return this;
        }
      }, {
        key: "setTranslateTagNameCallback",
        value: function setTranslateTagNameCallback(callback) {
          this.translateTagNameCallback = callback;
          return this;
        }
      }, {
        key: "setValueConverter",
        value: function setValueConverter(converter) {
          if (converter === true) {
            converter = TypeConvert;
          } else if (!converter) {
            converter = BypassValueConverter;
          }
          this.valueConverter = converter;
          return this;
        }
      }, {
        key: "setLoopEnable",
        value: function setLoopEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.loopEnable = enable;
          return this;
        }
      }, {
        key: "setSource",
        value: function setSource(source) {
          this.source = source;
          return this;
        }
      }, {
        key: "resetIndex",
        value: function resetIndex(index) {
          if (index === undefined) {
            index = 0;
          }
          this.progressIndex = index;
          this.reSplit.lastIndex = index;
          this.lastTagStart = null;
          this.lastTagEnd = null;
          this.lastContent = null;
          this.justCompleted = false;
          this.isRunning = false;
          return this;
        }
      }, {
        key: "start",
        value: function start(source) {
          this.setSource(source).restart();
          return this;
        }
      }, {
        key: "restart",
        value: function restart() {
          this.resetIndex().next();
        }
      }, {
        key: "next",
        value: function next() {
          if (this.isPaused) {
            this.onResume();
          }
  
          // Don't re-enter this method
          if (this.isRunning) {
            return this;
          }
          this.isRunning = true;
          if (this.justCompleted) {
            this.isRunning = false;
            return this;
          }
          if (this.reSplit.lastIndex === 0) {
            this.onStart();
          }
          var text = this.source,
            lastIndex = text.length;
          this.reSplit.lastIndex = this.progressIndex;
          while (true) {
            var regexResult = this.reSplit.exec(text);
            // No tag found, complete
            if (!regexResult) {
              if (this.progressIndex < lastIndex) {
                this.onContent(text.substring(this.progressIndex, lastIndex));
                // Might pause here
                if (this.isPaused) {
                  this.progressIndex = lastIndex;
                  break;
                }
              }
              this.onComplete();
              this.isRunning = false;
              return;
            }
            var matchEnd = this.reSplit.lastIndex;
            var matchStart = matchEnd - regexResult[0].length;
  
            // Process content between previous tag and current tag            
            if (this.progressIndex < matchStart) {
              this.onContent(text.substring(this.progressIndex, matchStart));
              // Might pause here
              if (this.isPaused) {
                this.progressIndex = matchStart;
                break;
              }
            }
  
            // Process current tag
            this.lastTagSource = regexResult[0];
            this.onTag(regexResult[1]);
            this.lastTagSource = undefined;
            this.progressIndex = matchEnd;
            // Might pause here
            if (this.isPaused) {
              break;
            }
          }
          this.isRunning = false;
          return this;
        }
      }, {
        key: "skipEvent",
        value: function skipEvent() {
          this.skipEventFlag = true;
          return this;
        }
      }, {
        key: "pause",
        value: function pause() {
          if (!this.isPaused) {
            this.onPause();
          }
          return this;
        }
      }, {
        key: "pauseUntilEvent",
        value: function pauseUntilEvent(eventEmitter, eventName) {
          if (this.isPaused) {
            return this;
          }
          this.pause();
          eventEmitter.once(eventName, function () {
            this.next();
          }, this);
          return this;
        }
      }, {
        key: "onContent",
        value: function onContent(content) {
          this.skipEventFlag = false;
          this.emit('content', content);
          this.lastContent = content;
        }
  
        // Override
      }, {
        key: "onTag",
        value: function onTag(tagContent) {}
      }, {
        key: "onStart",
        value: function onStart() {
          this.isRunning = true;
          this.emit('start', this);
        }
      }, {
        key: "onComplete",
        value: function onComplete() {
          this.isRunning = false;
          this.justCompleted = true;
          this.emit('complete', this);
          if (this.loopEnable) {
            this.resetIndex();
          }
        }
      }, {
        key: "onPause",
        value: function onPause() {
          this.isPaused = true;
          this.emit('pause', this);
        }
      }, {
        key: "onResume",
        value: function onResume() {
          this.isPaused = false;
          this.emit('resume', this);
        }
      }]);
      return BracketParser;
    }();
    var BypassValueConverter = function BypassValueConverter(s) {
      return s;
    };
    Object.assign(BracketParser$1.prototype, EventEmitterMethods);
  
    var StringToValues = function StringToValues(text, valueConverter, delimiter) {
      if (text == null) {
        return [];
      }
      if (valueConverter === undefined) {
        valueConverter = TypeConvert;
      }
      if (delimiter === undefined) {
        delimiter = ',';
      }
      var values = text.split(delimiter);
      for (var i = 0, cnt = values.length; i < cnt; i++) {
        values[i] = valueConverter(values[i]);
      }
      return values;
    };
  
    var BracketParser = /*#__PURE__*/function (_BracketParserBase) {
      _inherits(BracketParser, _BracketParserBase);
      function BracketParser(config) {
        var _this;
        _classCallCheck(this, BracketParser);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('multipleLinesTag')) {
          config.multipleLinesTag = false;
        }
        _this = _callSuper(this, BracketParser, [config]);
  
        // Parameters for regex
        _this.setTagExpression(GetValue$3G(config, 'regex.tag', undefined));
        _this.setValueExpression(GetValue$3G(config, 'regex.value', undefined));
        // Brackets and generate regex
        var delimiters = GetValue$3G(config, 'delimiters', '<>');
        _this.setDelimiters(delimiters[0], delimiters[1]);
        return _this;
      }
      _createClass(BracketParser, [{
        key: "setTagExpression",
        value: function setTagExpression(express) {
          if (!express) {
            express = DefaultTokenExpression;
          }
          this.tagExpression = express;
          return this;
        }
      }, {
        key: "setValueExpression",
        value: function setValueExpression(express) {
          if (!express) {
            express = DefaultTokenExpression;
          }
          this.valueExpression = express;
          return this;
        }
      }, {
        key: "setDelimiters",
        value: function setDelimiters(delimiterLeft, delimiterRight) {
          _get(_getPrototypeOf(BracketParser.prototype), "setDelimiters", this).call(this, delimiterLeft, delimiterRight);
          var tag = "(".concat(this.tagExpression, ")(=(").concat(this.valueExpression, "))?");
          this.reTag = RegExp(tag, 'i');
          if (this.tagExpression !== DefaultTokenExpression || this.valueExpression !== DefaultTokenExpression) {
            var startTagExpression = "".concat(this.tagExpression, "(=").concat(this.valueExpression, ")?");
            var endTagExpression = "/".concat(this.tagExpression);
            delimiterLeft = EscapeRegex(this.delimiterLeft);
            delimiterRight = EscapeRegex(this.delimiterRight);
            var flag = this.multipleLinesTagEnable ? 'gs' : 'gi';
            this.reSplit = RegExp("".concat(delimiterLeft, "((").concat(startTagExpression, ")|(").concat(endTagExpression, "))").concat(delimiterRight), flag);
          }
          return this;
        }
      }, {
        key: "onTag",
        value: function onTag(tagContent) {
          var regexResult = tagContent.match(this.reTag);
          var tagName = regexResult[1];
          var isEndTag = tagName.charAt(0) === '/';
          if (isEndTag) {
            tagName = tagName.substring(1, tagName.length);
          }
          if (this.translateTagNameCallback) {
            tagName = this.translateTagNameCallback(tagName);
          }
          this.skipEventFlag = false;
          if (!isEndTag) {
            var values = StringToValues(regexResult[3], this.valueConverter);
            this.emit.apply(this, ["+".concat(tagName)].concat(_toConsumableArray(values)));
            if (!this.skipEventFlag) {
              this.emit.apply(this, ['+', tagName].concat(_toConsumableArray(values)));
            }
            this.lastTagStart = tagName;
          } else {
            this.emit("-".concat(tagName));
            if (!this.skipEventFlag) {
              this.emit('-', tagName);
            }
            this.lastTagEnd = tagName;
          }
        }
      }]);
      return BracketParser;
    }(BracketParser$1);
    var DefaultTokenExpression = "[^=]+";
  
    var OnParseColorTag = function OnParseColorTag(textPlayer, parser, config) {
      var tagName = 'color';
      var defaultColor;
      parser.on('start', function () {
        defaultColor = textPlayer.textStyle.color;
      }).on("+".concat(tagName), function (color) {
        textPlayer.textStyle.setColor(color);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setColor(defaultColor);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setColor(defaultColor);
      });
    };
  
    var OnParseStrokeColorTag = function OnParseStrokeColorTag(textPlayer, parser, config) {
      var tagName = 'stroke';
      var defaultStroke;
      parser.on('start', function () {
        defaultStroke = textPlayer.textStyle.stroke;
        textPlayer.textStyle.setStrokeStyle(null);
      }).on("+".concat(tagName), function (color) {
        if (color === undefined) {
          color = defaultStroke;
        }
        textPlayer.textStyle.setStrokeStyle(color);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setStrokeStyle(null);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setStrokeStyle(defaultStroke);
      });
    };
  
    var OnParseBoldTag = function OnParseBoldTag(textPlayer, parser, config) {
      var tagName = 'b';
      parser.on('start', function () {
        textPlayer.textStyle.setBold(false);
      }).on("+".concat(tagName), function () {
        textPlayer.textStyle.setBold(true);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setBold(false);
        parser.skipEvent();
      });
    };
  
    var OnParseItalicTag = function OnParseItalicTag(textPlayer, parser, config) {
      var tagName = 'i';
      parser.on('start', function () {
        textPlayer.textStyle.setItalic(false);
      }).on("+".concat(tagName), function () {
        textPlayer.textStyle.setItalic(true);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setItalic(false);
        parser.skipEvent();
      });
    };
  
    var OnParseFontSizeTag = function OnParseFontSizeTag(textPlayer, parser, config) {
      var tagName = 'size';
      var defaultFontSize;
      parser.on('start', function () {
        defaultFontSize = textPlayer.textStyle.fontSize;
      }).on("+".concat(tagName), function (fontSize) {
        textPlayer.textStyle.setFontSize(fontSize);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setFontSize(defaultFontSize);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setFontSize(defaultFontSize);
      });
    };
  
    var OnParseOffsetYTag = function OnParseOffsetYTag(textPlayer, parser, config) {
      var tagName = 'y';
      var defaultOffsetY;
      parser.on('start', function () {
        defaultOffsetY = textPlayer.textStyle.offsetY;
        textPlayer.textStyle.setOffsetY(0);
      }).on("+".concat(tagName), function (y) {
        if (y === undefined) {
          y = defaultOffsetY;
        }
        textPlayer.textStyle.setOffsetY(y);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setOffsetY(0);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setOffsetY(0);
      });
    };
  
    var OnParseOffsetXTag = function OnParseOffsetXTag(textPlayer, parser, config) {
      var tagName = 'x';
      var defaultOffsetX;
      parser.on('start', function () {
        defaultOffsetX = textPlayer.textStyle.offsetY;
        textPlayer.textStyle.setOffsetX(0);
      }).on("+".concat(tagName), function (y) {
        if (y === undefined) {
          y = defaultOffsetX;
        }
        textPlayer.textStyle.setOffsetX(y);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setOffsetX(0);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setOffsetX(0);
      });
    };
  
    var OnParseLeftSpaceTag = function OnParseLeftSpaceTag(textPlayer, parser, config) {
      var tagName = 'left';
      var defaultLeftSpace;
      parser.on('start', function () {
        defaultLeftSpace = textPlayer.textStyle.leftSpace;
        textPlayer.textStyle.setLeftSpace(0);
      }).on("+".concat(tagName), function (space) {
        if (space === undefined) {
          space = defaultLeftSpace;
        }
        textPlayer.textStyle.setLeftSpace(space);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setLeftSpace(0);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setLeftSpace(0);
      });
    };
  
    var OnParseRightSpaceTag = function OnParseRightSpaceTag(textPlayer, parser, config) {
      var tagName = 'right';
      var defaultRightSpace;
      parser.on('start', function () {
        defaultRightSpace = textPlayer.textStyle.rightSpace;
        textPlayer.textStyle.setRightSpace(0);
      }).on("+".concat(tagName), function (space) {
        if (space === undefined) {
          space = defaultRightSpace;
        }
        textPlayer.textStyle.setRightSpace(space);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setRightSpace(0);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setRightSpace(0);
      });
    };
  
    var OnParseShadowColorTag = function OnParseShadowColorTag(textPlayer, parser, config) {
      var tagName = 'shadow';
      var defaultShadowColor;
      parser.on('start', function () {
        defaultShadowColor = textPlayer.textStyle.shadowColor;
        textPlayer.textStyle.setShadowColor(null);
      }).on("+".concat(tagName), function (color) {
        if (color === undefined) {
          color = defaultShadowColor;
        }
        textPlayer.textStyle.setShadowColor(color);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setShadowColor(null);
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setShadowColor(defaultShadowColor);
      });
    };
  
    var OnParseAlignTag = function OnParseAlignTag(textPlayer, parser, config) {
      var tagName = 'align';
      parser.on("+".concat(tagName), function (align) {
        textPlayer.textStyle.setAlign(align);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        textPlayer.textStyle.setAlign();
        parser.skipEvent();
      }).on('complete', function () {
        textPlayer.textStyle.setAlign();
      });
    };
  
    var OnParseImageTag$1 = function OnParseImageTag(textPlayer, parser, config) {
      var tagName = 'img';
      parser.on("+".concat(tagName), function (name) {
        var imgData = textPlayer.imageManager.get(name);
        if (imgData) {
          AppendImage.call(textPlayer, imgData.key, imgData.frame, {
            width: imgData.width,
            hieght: imgData.height,
            leftSpace: imgData.left,
            rightSpace: imgData.right,
            color: imgData.tintFill ? textPlayer.textStyle.color : undefined
          });
        }
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
  
    var OnParseImageTag = function OnParseImageTag(textPlayer, parser, config) {
      var tagName = 'space';
      parser.on("+".concat(tagName), function (width) {
        AppendSpace.call(textPlayer, width);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
  
    var OnParseTypingSpeedTag = function OnParseTypingSpeedTag(textPlayer, parser, config) {
      var tagName = 'speed';
      parser.on("+".concat(tagName), function (speed) {
        AppendCommand$2(textPlayer, speed);
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        AppendCommand$2(textPlayer, undefined);
        parser.skipEvent();
      });
    };
    var SetTypingSpeed = function SetTypingSpeed(speed) {
      this.typeWriter.setTypingSpeed(speed); // this: textPlayer
    };
    var AppendCommand$2 = function AppendCommand(textPlayer, speed) {
      AppendCommand$3.call(textPlayer, 'speed',
      // name
      SetTypingSpeed,
      // callback
      speed,
      // params
      textPlayer // scope
      );
    };
  
    var OnParsePlaySoundEffectTag = function OnParsePlaySoundEffectTag(textPlayer, parser, config) {
      var tagName = 'se';
      parser.on("+".concat(tagName), function (name, fadeInTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlaySoundEffect,
        // callback
        [name, fadeInTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2';
      parser.on("+".concat(tagName), function (name, fadeInTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlaySoundEffect2,
        // callback
        [name, fadeInTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var PlaySoundEffect = function PlaySoundEffect(params) {
      if (this.skipSoundEffect) {
        return;
      }
      var name = params[0];
      var fadeInTime = params[1];
      this.soundManager.playSoundEffect(name); // this: textPlayer
      if (fadeInTime) {
        this.soundManager.fadeInSoundEffect(fadeInTime);
      }
    };
    var PlaySoundEffect2 = function PlaySoundEffect2(params) {
      if (this.skipSoundEffect) {
        return;
      }
      var name = params[0];
      var fadeInTime = params[1];
      this.soundManager.playSoundEffect2(name); // this: textPlayer
      if (fadeInTime) {
        this.soundManager.fadeInSoundEffect2(fadeInTime);
      }
    };
  
    var OnParseFadeInSoundEffectTag = function OnParseFadeInSoundEffectTag(textPlayer, parser, config) {
      var tagName = 'se.fadein';
      parser.on("+".concat(tagName), function (time) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeInSoundEffect,
        // callback
        time,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2.fadein';
      parser.on("+".concat(tagName), function (time) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeInSoundEffect2,
        // callback
        time,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var FadeInSoundEffect = function FadeInSoundEffect(time) {
      // this: textPlayer
      this.soundManager.fadeInSoundEffect(time);
    };
    var FadeInSoundEffect2 = function FadeInSoundEffect2(time) {
      // this: textPlayer
      this.soundManager.fadeInSoundEffect2(time);
    };
  
    var OnParseFadeOutSoundEffectTag = function OnParseFadeOutSoundEffectTag(textPlayer, parser, config) {
      var tagName = 'se.fadeout';
      parser.on("+".concat(tagName), function (time, isStopped) {
        isStopped = isStopped === 'stop';
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeOutSoundEffect,
        // callback
        [time, isStopped],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2.fadeout';
      parser.on("+".concat(tagName), function (time, isStopped) {
        isStopped = isStopped === 'stop';
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeOutSoundEffect2,
        // callback
        [time, isStopped],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var FadeOutSoundEffect = function FadeOutSoundEffect(params) {
      var _this$soundManager;
      // this: textPlayer
      (_this$soundManager = this.soundManager).fadeOutSoundEffect.apply(_this$soundManager, _toConsumableArray(params));
    };
    var FadeOutSoundEffect2 = function FadeOutSoundEffect2(params) {
      var _this$soundManager2;
      // this: textPlayer
      (_this$soundManager2 = this.soundManager).fadeOutSoundEffect2.apply(_this$soundManager2, _toConsumableArray(params));
    };
  
    var OnParseSetSoundEffectVolumeTag = function OnParseSetSoundEffectVolumeTag(textPlayer, parser, config) {
      var tagName = 'se.volume';
      parser.on("+".concat(tagName), function (volume) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffectVolume,
        // callback
        volume,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2.volume';
      parser.on("+".concat(tagName), function (volume) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffectVolume2,
        // callback
        volume,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var SetSoundEffectVolume = function SetSoundEffectVolume(volume) {
      // this: textPlayer
      this.soundManager.setSoundEffectVolume(volume, true);
    };
    var SetSoundEffectVolume2 = function SetSoundEffectVolume2(volume) {
      // this: textPlayer
      this.soundManager.setSoundEffectVolume2(volume, true);
    };
  
    var OnParseSetSoundEffectMuteTag = function OnParseSetSoundEffectMuteTag(textPlayer, parser, config) {
      var tagName = 'se.mute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffectMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2.mute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffect2Mute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se.unmute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffectUnMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'se2.unmute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetSoundEffect2UnMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var SetSoundEffectMute = function SetSoundEffectMute() {
      // this: textPlayer
      this.soundManager.setSoundEffectMute(true);
    };
    var SetSoundEffect2Mute = function SetSoundEffect2Mute() {
      // this: textPlayer
      this.soundManager.setSoundEffect2Mute(true);
    };
    var SetSoundEffectUnMute = function SetSoundEffectUnMute() {
      // this: textPlayer
      this.soundManager.setSoundEffectMute(false);
    };
    var SetSoundEffect2UnMute = function SetSoundEffect2UnMute() {
      // this: textPlayer
      this.soundManager.setSoundEffect2Mute(false);
    };
  
    var OnParsePlayBackgroundMusicTag = function OnParsePlayBackgroundMusicTag(textPlayer, parser, config) {
      var tagName = 'bgm';
      parser.on("+".concat(tagName), function (name, fadeInTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayBackgroundMusic,
        // callback
        [name, fadeInTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, 'bgm.stop',
        // name
        StopBackgroundMusic,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
      var tagName = 'bgm2';
      parser.on("+".concat(tagName), function (name, fadeInTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayBackgroundMusic2,
        // callback
        [name, fadeInTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, 'bgm2.stop',
        // name
        StopBackgroundMusic2,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayBackgroundMusic = function PlayBackgroundMusic(params) {
      var name = params[0];
      var fadeInTime = params[1];
  
      // this: textPlayer
      this.soundManager.playBackgroundMusic(name);
      if (fadeInTime) {
        this.soundManager.fadeInBackgroundMusic(fadeInTime);
      }
    };
    var StopBackgroundMusic = function StopBackgroundMusic() {
      // this: textPlayer
      this.soundManager.stopBackgroundMusic();
    };
    var PlayBackgroundMusic2 = function PlayBackgroundMusic2(params) {
      var name = params[0];
      var fadeInTime = params[1];
  
      // this: textPlayer
      this.soundManager.playBackgroundMusic2(name);
      if (fadeInTime) {
        this.soundManager.fadeInBackgroundMusic2(fadeInTime);
      }
    };
    var StopBackgroundMusic2 = function StopBackgroundMusic2() {
      // this: textPlayer
      this.soundManager.stopBackgroundMusic2();
    };
  
    var OnParseFadeInBackgroundMusicTag = function OnParseFadeInBackgroundMusicTag(textPlayer, parser, config) {
      var tagName = 'bgm.fadein';
      parser.on("+".concat(tagName), function (time) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeInBackgroundMusic,
        // callback
        time,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.fadein';
      parser.on("+".concat(tagName), function (time) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeInBackgroundMusic2,
        // callback
        time,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var FadeInBackgroundMusic = function FadeInBackgroundMusic(time) {
      // this: textPlayer
      this.soundManager.fadeInBackgroundMusic(time);
    };
    var FadeInBackgroundMusic2 = function FadeInBackgroundMusic2(time) {
      // this: textPlayer
      this.soundManager.fadeInBackgroundMusic2(time);
    };
  
    var OnParseFadeOutBackgroundMusicTag = function OnParseFadeOutBackgroundMusicTag(textPlayer, parser, config) {
      var tagName = 'bgm.fadeout';
      parser.on("+".concat(tagName), function (time, isStopped) {
        isStopped = isStopped === 'stop';
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeOutBackgroundMusic,
        // callback
        [time, isStopped],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.fadeout';
      parser.on("+".concat(tagName), function (time, isStopped) {
        isStopped = isStopped === 'stop';
        AppendCommand$3.call(textPlayer, tagName,
        // name
        FadeOutBackgroundMusic2,
        // callback
        [time, isStopped],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var FadeOutBackgroundMusic = function FadeOutBackgroundMusic(params) {
      var _this$soundManager;
      // this: textPlayer
      (_this$soundManager = this.soundManager).fadeOutBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
    };
    var FadeOutBackgroundMusic2 = function FadeOutBackgroundMusic2(params) {
      var _this$soundManager2;
      // this: textPlayer
      (_this$soundManager2 = this.soundManager).fadeOutBackgroundMusic2.apply(_this$soundManager2, _toConsumableArray(params));
    };
  
    var OnParseCrossFadeBackgroundMusicTag = function OnParseCrossFadeBackgroundMusicTag(textPlayer, parser, config) {
      var tagName = 'bgm.cross';
      parser.on("+".concat(tagName), function (name, fadeTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        CrossFadeBackgroundMusic,
        // callback
        [name, fadeTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.cross';
      parser.on("+".concat(tagName), function (name, fadeTime) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        CrossFadeBackgroundMusic2,
        // callback
        [name, fadeTime],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var CrossFadeBackgroundMusic = function CrossFadeBackgroundMusic(params) {
      var _this$soundManager;
      // this: textPlayer
      (_this$soundManager = this.soundManager).crossFadeBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
    };
    var CrossFadeBackgroundMusic2 = function CrossFadeBackgroundMusic2(params) {
      var _this$soundManager2;
      // this: textPlayer
      (_this$soundManager2 = this.soundManager).crossFadeBackgroundMusic2.apply(_this$soundManager2, _toConsumableArray(params));
    };
  
    var OnParsePauseBackgroundMusicTag = function OnParsePauseBackgroundMusicTag(textPlayer, parser, config) {
      var tagName = 'bgm.pause';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PauseBackgroundMusic,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, 'bgm.resume',
        // name
        ResumeBackgroundMusic,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
      var tagName = 'bgm2.pause';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PauseBackgroundMusic2,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, 'bgm2.resume',
        // name
        ResumeBackgroundMusic2,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PauseBackgroundMusic = function PauseBackgroundMusic() {
      // this: textPlayer
      this.soundManager.pauseBackgroundMusic();
    };
    var ResumeBackgroundMusic = function ResumeBackgroundMusic() {
      // this: textPlayer
      this.soundManager.resumeBackgroundMusic();
    };
    var PauseBackgroundMusic2 = function PauseBackgroundMusic2() {
      // this: textPlayer
      this.soundManager.pauseBackgroundMusic2();
    };
    var ResumeBackgroundMusic2 = function ResumeBackgroundMusic2() {
      // this: textPlayer
      this.soundManager.resumeBackgroundMusic2();
    };
  
    var OnParseSetBackgroundMusicVolumeTag = function OnParseSetBackgroundMusicVolumeTag(textPlayer, parser, config) {
      var tagName = 'bgm.volume';
      parser.on("+".concat(tagName), function (volume) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusicVolume,
        // callback
        volume,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.volume';
      parser.on("+".concat(tagName), function (volume) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusicVolume2,
        // callback
        volume,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var SetBackgroundMusicVolume = function SetBackgroundMusicVolume(volume) {
      // this: textPlayer
      this.soundManager.setBackgroundMusicVolume(volume);
    };
    var SetBackgroundMusicVolume2 = function SetBackgroundMusicVolume2(volume) {
      // this: textPlayer
      this.soundManager.setBackgroundMusicVolume2(volume);
    };
  
    var OnParseSetBackgroundMusicMuteTag = function OnParseSetBackgroundMusicMuteTag(textPlayer, parser, config) {
      var tagName = 'bgm.mute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusicMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.mute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusic2Mute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm.unmute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusicUnMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
      var tagName = 'bgm2.unmute';
      parser.on("+".concat(tagName), function () {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        SetBackgroundMusic2UnMute,
        // callback
        undefined,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
    var SetBackgroundMusicMute = function SetBackgroundMusicMute() {
      // this: textPlayer
      this.soundManager.setBackgroundMusicMute(true);
    };
    var SetBackgroundMusic2Mute = function SetBackgroundMusic2Mute() {
      // this: textPlayer
      this.soundManager.setBackgroundMusic2Mute(true);
    };
    var SetBackgroundMusicUnMute = function SetBackgroundMusicUnMute() {
      // this: textPlayer
      this.soundManager.setBackgroundMusicMute(false);
    };
    var SetBackgroundMusic2UnMute = function SetBackgroundMusic2UnMute() {
      // this: textPlayer
      this.soundManager.setBackgroundMusic2Mute(false);
    };
  
    var OnParseFadeInCameraTag = function OnParseFadeInCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.fadein';
      parser.on("+".concat(tagName), function (duration, red, green, blue) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayFadeInEffect,
        // callback
        [duration, red, green, blue],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayFadeInEffect = function PlayFadeInEffect(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).fadeIn.apply(_this$cameraTarget, _toConsumableArray(params));
    };
  
    var OnParseFadeOutCameraTag = function OnParseFadeOutCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.fadeout';
      parser.on("+".concat(tagName), function (duration, red, green, blue) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayFadeOutEffect,
        // callback
        [duration, red, green, blue],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayFadeOutEffect = function PlayFadeOutEffect(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).fadeOut.apply(_this$cameraTarget, _toConsumableArray(params));
    };
  
    var OnParseShakeCameraTag = function OnParseShakeCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.shake';
      parser.on("+".concat(tagName), function (duration, intensity) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayShakeEffect,
        // callback
        [duration, intensity],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayShakeEffect = function PlayShakeEffect(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).shake.apply(_this$cameraTarget, _toConsumableArray(params));
    };
  
    var OnParseFlashCameraTag = function OnParseFlashCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.flash';
      parser.on("+".concat(tagName), function (duration, red, green, blue) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        PlayFlashEffect,
        // callback
        [duration, red, green, blue],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayFlashEffect = function PlayFlashEffect(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).flash.apply(_this$cameraTarget, _toConsumableArray(params));
    };
  
    var OnParseZoomCameraTag = function OnParseZoomCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.zoom';
      parser.on("+".concat(tagName), function (value) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        Zoom,
        // callback
        value,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
        AppendCommand$3.call(textPlayer, 'camera.zoom.to',
        // name
        ZoomTo,
        // callback
        [value, duration, ease],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var Zoom = function Zoom(value) {
      // this: textPlayer
      this.cameraTarget.setZoom(value);
    };
    var ZoomTo = function ZoomTo(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).zoomTo.apply(_this$cameraTarget, _toConsumableArray(params));
    };
  
    var DegToRad$c = Phaser.Math.DegToRad;
    var OnParseRotateCameraTag = function OnParseRotateCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.rotate';
      parser.on("+".concat(tagName), function (value) {
        value = DegToRad$c(value);
        AppendCommand$3.call(textPlayer, tagName,
        // name
        Rotate$1,
        // callback
        value,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
        value = DegToRad$c(value);
        AppendCommand$3.call(textPlayer, 'camera.rotate.to',
        // name
        RotateTo,
        // callback
        [value, duration, ease],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var Rotate$1 = function Rotate(value) {
      // this: textPlayer
      this.cameraTarget.setRotation(value);
    };
    var RotateTo = function RotateTo(params) {
      var value = params[0];
      var duration = params[1];
      var ease = params[2];
  
      // this: textPlayer
      this.cameraTarget.rotateTo(value, false, duration, ease);
    };
  
    var OnParseScrollCameraTag = function OnParseScrollCameraTag(textPlayer, parser, config) {
      var tagName = 'camera.scroll';
      parser.on("+".concat(tagName), function (x, y) {
        AppendCommand$3.call(textPlayer, tagName,
        // name
        Scroll,
        // callback
        [x, y],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on("+".concat(tagName, ".to"), function (x, y, duration, ease) {
        AppendCommand$3.call(textPlayer, 'camera.scroll.to',
        // name
        ScrollTo,
        // callback
        [x, y, duration, ease],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var Scroll = function Scroll(params) {
      var _this$cameraTarget;
      // this: textPlayer
      (_this$cameraTarget = this.cameraTarget).setScroll.apply(_this$cameraTarget, _toConsumableArray(params));
    };
    var ScrollTo = function ScrollTo(params) {
      var x = params[0];
      var y = params[1];
      var duration = params[2];
      var ease = params[3];
  
      // this: textPlayer
      var camera = this.cameraTarget;
      var xSave = camera.scrollX;
      var ySave = camera.scrollY;
      camera.setScroll(x, y);
      x += camera.centerX;
      y += camera.centerY;
      camera.setScroll(xSave, ySave);
  
      // x,y in pan() is the centerX, centerY
      camera.pan(x, y, duration, ease);
    };
  
    var OnParseWaitTag = function OnParseWaitTag(textPlayer, parser, config) {
      var tagWait = 'wait';
      var tagClick = 'click';
      parser.on("+".concat(tagWait), function (name) {
        AppendCommand$1(textPlayer, name);
        parser.skipEvent();
      }).on("-".concat(tagWait), function () {
        parser.skipEvent();
      }).on("+".concat(tagClick), function () {
        // Equal to [wait=click]
        AppendCommand$1(textPlayer, 'click');
        parser.skipEvent();
      }).on("-".concat(tagClick), function () {
        // Equal to [/wait]
        parser.skipEvent();
      });
    };
    var Wait$2 = function Wait(name) {
      this.typeWriter.wait(name); // this: textPlayer
    };
    var AppendCommand$1 = function AppendCommand(textPlayer, name) {
      AppendCommand$3.call(textPlayer, 'wait',
      // name
      Wait$2,
      // callback
      name,
      // params
      textPlayer // scope
      );
    };
  
    var OnParseNewLineTag = function OnParseNewLineTag(textPlayer, parser, config) {
      var tagName = 'r';
      parser.on("+".concat(tagName), function () {
        AppendText$1.call(textPlayer, '\n');
        parser.skipEvent();
      }).on("-".concat(tagName), function () {
        parser.skipEvent();
      });
    };
  
    var OnParsePageBreakTag = function OnParsePageBreakTag(textPlayer, parser, config) {
      var tagNames = ['pagebreak', 'pb'];
      for (var i = 0, cnt = tagNames.length; i < cnt; i++) {
        var tagName = tagNames[i];
        parser.on("+".concat(tagName), function () {
          AppendText$1.call(textPlayer, '\f');
          parser.skipEvent();
        }).on("-".concat(tagName), function () {
          parser.skipEvent();
        });
      }
    };
  
    var OnParseContentOff = function OnParseContentOff(textPlayer, parser, config) {
      var tagName = 'content.off';
      parser.on("+".concat(tagName), function () {
        parser.setContentOutputEnable(false);
        parser.skipEvent();
      });
    };
  
    var OnParseContentOn = function OnParseContentOn(textPlayer, parser, config) {
      var tagName = 'content.on';
      parser.on("+".concat(tagName), function () {
        parser.setContentOutputEnable();
        parser.skipEvent();
      });
    };
  
    var OnParseContent = function OnParseContent(textPlayer, parser, config) {
      parser.on('content', function (content) {
        if (parser.contentOutputEnable) {
          AppendText$1.call(textPlayer, content);
        } else {
          var startTag = "+".concat(parser.lastTagStart);
          textPlayer.emit("parser.".concat(startTag, "#content"), parser, content);
        }
      });
    };
  
    var OnParseCustomTag = function OnParseCustomTag(textPlayer, parser, config) {
      parser.on('start', function () {
        textPlayer.emit('parser.start', parser);
      }).on('+', function (tagName) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
        var startTag = "+".concat(tagName);
        for (var _len = arguments.length, value = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          value[_key - 1] = arguments[_key];
        }
        var param = value;
        textPlayer.emit.apply(textPlayer, ["parser.".concat(startTag), parser].concat(value, [param]));
        AppendCommand(textPlayer, startTag, param);
      }).on('-', function (tagName) {
        if (parser.skipEventFlag) {
          return;
        }
        var endTag = "-".concat(tagName);
        var param = [];
        textPlayer.emit("parser.".concat(endTag), parser, param);
        AppendCommand(textPlayer, endTag, param);
      }).on('complete', function () {
        textPlayer.emit('parser.complete', parser);
      });
    };
    var FireEvent$1 = function FireEvent(param, tagName) {
      var eventName = "tag.".concat(tagName);
      // this: textPlayer
      if (param == null) {
        this.emit(eventName);
      } else {
        this.emit.apply(this, [eventName].concat(_toConsumableArray(param)));
      }
    };
    var AppendCommand = function AppendCommand(textPlayer, name, param) {
      AppendCommand$3.call(textPlayer, name,
      // name
      FireEvent$1,
      // callback
      param,
      // params
      textPlayer // scope
      );
    };
  
    var ParseCallbacks$2 = [OnParseColorTag, OnParseStrokeColorTag, OnParseBoldTag, OnParseItalicTag, OnParseFontSizeTag, OnParseShadowColorTag, OnParseAlignTag, OnParseOffsetYTag, OnParseOffsetXTag, OnParseLeftSpaceTag, OnParseRightSpaceTag, OnParseImageTag$1, OnParseImageTag, OnParseTypingSpeedTag, OnParsePlaySoundEffectTag, OnParseFadeInSoundEffectTag, OnParseFadeOutSoundEffectTag, OnParseSetSoundEffectVolumeTag, OnParseSetSoundEffectMuteTag, OnParsePlayBackgroundMusicTag, OnParseFadeInBackgroundMusicTag, OnParseFadeOutBackgroundMusicTag, OnParseCrossFadeBackgroundMusicTag, OnParsePauseBackgroundMusicTag, OnParseSetBackgroundMusicVolumeTag, OnParseSetBackgroundMusicMuteTag, OnParseFadeInCameraTag, OnParseFadeOutCameraTag, OnParseShakeCameraTag, OnParseFlashCameraTag, OnParseZoomCameraTag, OnParseRotateCameraTag, OnParseScrollCameraTag, OnParseWaitTag, OnParseNewLineTag, OnParsePageBreakTag, OnParseContentOff, OnParseContentOn, OnParseContent, OnParseCustomTag];
    var AddParseCallbacks = function AddParseCallbacks(textPlayer, parser, config) {
      for (var i = 0, cnt = ParseCallbacks$2.length; i < cnt; i++) {
        ParseCallbacks$2[i](textPlayer, parser, config);
      }
    };
  
    /*
    Skip line
    - An empty line, only has space
    - A comment line, start with commentLineStart ('//')
    */
  
    var PreProcess = function PreProcess(parser, source) {
      var comentLineStart = parser.commentLineStart;
      var lines = source.split('\n');
      for (var i = 0, cnt = lines.length; i < cnt; i++) {
        var line = lines[i];
        if (line === '') ; else if (line.trim().length === 0) {
          // An empty line, only has space
          lines[i] = '';
        } else if (comentLineStart && line.startsWith(comentLineStart)) {
          // A comment line, start with commentLineStart ('//')
          lines[i] = '';
        }
      }
      // Use [r] to put \n
      return lines.join('');
    };
  
    var GetValue$33 = Phaser.Utils.Objects.GetValue;
    var Parser = /*#__PURE__*/function (_BracketParser) {
      _inherits(Parser, _BracketParser);
      function Parser(textPlayer, config) {
        var _this;
        _classCallCheck(this, Parser);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('delimiters')) {
          config.delimiters = '[]';
        }
        _this = _callSuper(this, Parser, [config]);
        AddParseCallbacks(textPlayer, _assertThisInitialized(_this), config);
        _this.setCommentLineStartSymbol(GetValue$33(config, 'comment', '//'));
        _this.setContentOutputEnable();
        return _this;
      }
      _createClass(Parser, [{
        key: "setCommentLineStartSymbol",
        value: function setCommentLineStartSymbol(symbol) {
          this.commentLineStart = symbol;
          return this;
        }
      }, {
        key: "setContentOutputEnable",
        value: function setContentOutputEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.contentOutputEnable = enable;
          return this;
        }
      }, {
        key: "start",
        value: function start(source) {
          _get(_getPrototypeOf(Parser.prototype), "start", this).call(this, PreProcess(this, source));
          return this;
        }
      }]);
      return Parser;
    }(BracketParser);
  
    var TypingSpeedMethods$1 = {
      setDefaultTypingSpeed: function setDefaultTypingSpeed(speed) {
        this.defaultSpeed = speed;
        return this;
      },
      setTypingSpeed: function setTypingSpeed(speed) {
        if (speed === undefined) {
          speed = this.defaultSpeed;
        }
        this.speed = speed;
        return this;
      }
    };
  
    // Internal events
  
    var PageFadeOutCompleteEvent = 'page.fadeout';
    var StopPlayEvent = '_remove.play';
    var ClearEvents$1 = [PageFadeOutCompleteEvent, StopPlayEvent];
  
    var FadeOutPage = function FadeOutPage() {
      if (!this.fadeOutPageCallback || !this.children) {
        this.emit(PageFadeOutCompleteEvent);
        return this;
      }
      var renderableChildren = this.children.filter(function (child) {
        return child.renderable;
      });
      var waitObject = this.fadeOutPageCallback(renderableChildren, this.fadeOutPageDuration);
      if (!waitObject) {
        this.emit(PageFadeOutCompleteEvent);
      } else if (waitObject.once) {
        waitObject.once('complete', function () {
          this.emit(PageFadeOutCompleteEvent);
        }, this);
      } else if (waitObject.then) {
        var self = this;
        waitObject.then(function () {
          self.emit(PageFadeOutCompleteEvent);
        });
      } else {
        this.emit(PageFadeOutCompleteEvent);
      }
      return this;
    };
  
    var WaitEvent = function WaitEvent(eventEmitter, eventName) {
      return new Promise(function (resolve, reject) {
        eventEmitter.once(eventName, function () {
          resolve();
        });
      });
    };
    var WaitComplete = function WaitComplete(eventEmitter) {
      return WaitEvent(eventEmitter, 'complete');
    };
  
    var Start = function Start(children) {
      this.children = children;
      this.index = 0;
      this.isPageTyping = true;
      if (this.onTypeStart) {
        this.onTypeStart(children);
      }
      this.typing();
      return WaitComplete(this); // Promise
    };
  
    var TypingDelayTimerType = 'delay';
    var TypingAnimationTimerType = 'anim';
  
    var Typing = function Typing(offsetTime) {
      if (offsetTime === undefined) {
        offsetTime = 0;
      }
      var delay = 0;
      this.inTypingProcessLoop = true;
      while (this.inTypingProcessLoop) {
        var child = this.getNextChild();
        if (!child) {
          if (this.timeline.isRunning) {
            // Wait until last animationConfig is end
            this.timeline.once('complete', function () {
              this.isPageTyping = false;
              this.emit('complete');
            }, this);
          } else {
            this.isPageTyping = false;
            this.emit('complete');
          }
          break; // Leave this typing loop
        }
        if (child.renderable) {
          // Typing this char
          var animationConfig = this.animationConfig;
          if (animationConfig.duration > 0) {
            var animationTimer = this.timeline.addTimer({
              name: TypingAnimationTimerType,
              target: child,
              duration: animationConfig.duration,
              yoyo: animationConfig.yoyo,
              onStart: animationConfig.onStart,
              onProgress: animationConfig.onProgress,
              onComplete: animationConfig.onComplete
            });
            if (this.skipTypingAnimation) {
              animationTimer.seek(1);
            }
          } else {
            // No animationConfig, only invoke onStart callback
            if (animationConfig.onStart) {
              animationConfig.onStart(child, 0);
            }
          }
  
          // Set to min size
          if (this.minSizeEnable) {
            this.textPlayer.setToMinSize();
          }
          this.textPlayer.emit('typing', child);
          var nextChild = this.nextChild;
          if (nextChild) {
            if (this.skipSpaceEnable && IsSpaceChar(nextChild)) ; else {
              delay += this.speed + offsetTime;
              offsetTime = 0;
              if (delay > 0) {
                // Process next character later
                this.typingTimer = this.timeline.addTimer({
                  name: TypingDelayTimerType,
                  target: this,
                  duration: delay,
                  onComplete: function onComplete(target, t, timer) {
                    target.typingTimer = undefined;
                    Typing.call(target, timer.remainder);
                  }
                });
                break; // Leave this typing loop     
              }
            }
          }
          // Process next child
        } else if (IsCommand(child)) {
          child.exec();
          // Process next child
        }
      }
  
      // Set to min size
      if (this.minSizeEnable) {
        this.textPlayer.setToMinSize();
      }
      this.inTypingProcessLoop = false;
    };
  
    var Pause = function Pause() {
      // Pause typing timer and animation progresses
      this.timeline.pause();
      return this;
    };
  
    var Resume = function Resume() {
      // Resume typing timer and animation progresses
      this.timeline.resume();
      return this;
    };
  
    var PauseTyping$1 = function PauseTyping() {
      // Already in typingPaused state
      if (this.isTypingPaused) {
        return this;
      }
      if (this.typingTimer) {
        // Pause when typing timer is counting
        this.typingTimer.pause();
        this.isTypingPaused = true;
      } else if (this.inTypingProcessLoop) {
        // Pause in loop of typing(), by tag
        this.inTypingProcessLoop = false;
        this.isTypingPaused = true;
      }
      return this;
    };
  
    var ResumeTyping$1 = function ResumeTyping(offsetTime) {
      // Already not in typingPaused state
      if (!this.isTypingPaused) {
        return this;
      }
      if (offsetTime === undefined) {
        offsetTime = 0;
      }
      if (this.typingTimer) {
        // Pause when typing timer is paused
        this.isTypingPaused = false;
        this.typingTimer.resume();
        this.typingTimer.remainder += offsetTime;
      } else if (this.isTypingPaused) {
        // Resume paused by tag
        this.isTypingPaused = false;
        this.typing(offsetTime);
      }
      return this;
    };
  
    var IsWaitCameraEffect = function IsWaitCameraEffect(name) {
      switch (name) {
        case 'camera.fadein':
        case 'camera.fadeout':
        case 'camera.flash':
        case 'camera.shake':
        case 'camera.zoom':
        case 'camera.rotate':
        case 'camera.scroll':
          return true;
        default:
          return false;
      }
    };
  
    var IsWaitGameObject = function IsWaitGameObject(textPlayer, name) {
      var names = name.split('.');
      return textPlayer.gameObjectManagers.hasOwnProperty(names[0]);
    };
    var WaitGameObject = function WaitGameObject(textPlayer, tag, callback, scope) {
      var waitEventManager = textPlayer.waitEventManager;
      var tags = tag.split('.');
      var goType = tags[0];
      var gameObjectManager = textPlayer.getGameObjectManager(goType);
      var waitEventName = "wait.".concat(goType);
      switch (tags.length) {
        case 1:
          // 'goType' : wait all sprites has beeen destroyed
          waitEventManager.waitGameObjectManagerEmpty(goType);
          textPlayer.emit(waitEventName);
          return;
        case 2:
          // 'goType.name' : wait goType.name has been destroyed
          var name = tags[1];
          waitEventManager.waitGameObjectDestroy(goType, name);
          textPlayer.emit(waitEventName, name);
          return;
        case 3:
          // 'goType.name.prop' : wait ease goType.name.prop has been completed
          var name = tags[1],
            prop = tags[2];
          var value = gameObjectManager.getProperty(name, prop);
          // Can start tween task for a number property
          if (typeof value === 'number') {
            waitEventManager.waitGameObjectTweenComplete(goType, name, prop);
            textPlayer.emit(waitEventName, name, prop);
            return;
          }
          var dataKey = prop;
          var matchFalseFlag = dataKey.startsWith('!');
          if (matchFalseFlag) {
            dataKey = dataKey.substring(1);
          }
          // Wait until flag is true/false
          if (gameObjectManager.hasData(name, dataKey)) {
            waitEventManager.waitGameObjectDataFlag(goType, name, dataKey, !matchFalseFlag);
            textPlayer.emit(waitEventName, name, dataKey);
            return;
          } else {
            waitEventManager.waitTime(0);
            return;
          }
      }
    };
  
    var KeyCodes = Phaser.Input.Keyboard.KeyCodes;
    var WaitAny = function WaitAny(textPlayer, names, callback, scope) {
      var waitEventManager = textPlayer.waitEventManager;
      waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
      if (typeof names === 'string' && names.length > 1 && names.indexOf('|') !== -1) {
        names = names.split('|');
      } else {
        names = [names];
      }
      for (var i = 0, cnt = names.length; i < cnt; i++) {
        var name = names[i];
        if (name == null || name === 'wait') {
          // Wait event
          var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
          textPlayer.emit('wait', waitCompleteTriggerCallback);
        } else if (typeof name === 'number' || !isNaN(name)) {
          // A number, or a number string
          var time = parseFloat(name);
          waitEventManager.waitTime(time);
          textPlayer.emit('wait.time', time);
        } else if (name === 'click') {
          // 'click'
          waitEventManager.waitClick();
          textPlayer.emit('wait.click');
        } else if (name === 'se') {
          waitEventManager.waitSoundEffectComplete();
          var music = textPlayer.soundManager.getLastSoundEffect();
          textPlayer.emit('wait.music', music);
        } else if (name === 'se2') {
          waitEventManager.waitSoundEffect2Complete();
          var music = textPlayer.soundManager.getLastSoundEffect2();
          textPlayer.emit('wait.music', music);
        } else if (name === 'bgm') {
          waitEventManager.waitBackgroundMusicComplete();
          var music = textPlayer.soundManager.getBackgroundMusic();
          textPlayer.emit('wait.music', music);
        } else if (name === 'bgm2') {
          waitEventManager.waitBackgroundMusic2Complete();
          var music = textPlayer.soundManager.getBackgroundMusic2();
          textPlayer.emit('wait.music', music);
        } else if (KeyCodes.hasOwnProperty(name.toUpperCase())) {
          waitEventManager.waitKeyDown(name);
          textPlayer.emit('wait.keydown', name);
        } else if (IsWaitCameraEffect(name)) {
          waitEventManager.waitCameraEffectComplete(name);
          textPlayer.emit('wait.camera', name);
        } else if (IsWaitGameObject(textPlayer, name)) {
          WaitGameObject(textPlayer, name);
        } else {
          var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
          textPlayer.emit("wait.".concat(name), waitCompleteTriggerCallback);
        }
      }
    };
  
    var Wait$1 = function Wait(name) {
      // Already in typingPaused state, or ignore any wait
      if (this.ignoreWait) {
        return this;
      }
      this.pauseTyping();
      WaitAny(this.textPlayer, name, this.resumeTyping, this);
      return this;
    };
  
    var SetIgnoreWait$1 = function SetIgnoreWait(value) {
      if (value === undefined) {
        value = true;
      }
      this.ignoreWait = value;
      return this;
    };
  
    var SetSkipSpaceEnable = function SetSkipSpaceEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.skipSpaceEnable = enable;
      return this;
    };
  
    var SetSkipTypingAnimation = function SetSkipTypingAnimation(value) {
      if (value === undefined) {
        value = true;
      }
      this.skipTypingAnimation = value;
      if (value) {
        // Skip current playing typing-animation
        var timers = this.timeline.getTimers(TypingAnimationTimerType);
        for (var i = 0, cnt = timers.length; i < cnt; i++) {
          timers[i].seek(1);
        }
      }
      return this;
    };
  
    var SetSkipSoundEffect = function SetSkipSoundEffect(value) {
      if (value === undefined) {
        value = true;
      }
      this.skipSoundEffect = value;
      if (value) {
        var soundManager = this.textPlayer._soundManager;
        if (soundManager) {
          soundManager.fadeOutAllSoundEffects(100, true);
        }
      }
      return this;
    };
  
    var SkipCurrentTypingDelay = function SkipCurrentTypingDelay() {
      if (this.typingTimer) {
        this.typingTimer.seek(1);
      }
      return this;
    };
  
    var Methods$e = {
      fadeOutPage: FadeOutPage,
      start: Start,
      typing: Typing,
      pause: Pause,
      resume: Resume,
      pauseTyping: PauseTyping$1,
      resumeTyping: ResumeTyping$1,
      wait: Wait$1,
      setIgnoreWait: SetIgnoreWait$1,
      setSkipSpaceEnable: SetSkipSpaceEnable,
      setSkipTypingAnimation: SetSkipTypingAnimation,
      setSkipSoundEffect: SetSkipSoundEffect,
      skipCurrentTypingDelay: SkipCurrentTypingDelay
    };
    Object.assign(Methods$e, TypingSpeedMethods$1);
  
    var GetValue$32 = Phaser.Utils.Objects.GetValue;
    var TypeWriter = /*#__PURE__*/function () {
      function TypeWriter(textPlayer, config) {
        _classCallCheck(this, TypeWriter);
        this.setEventEmitter();
        this.textPlayer = textPlayer;
        this.isPageTyping = false;
        this.typingTimer = undefined; // Typing delay
        this.pauseTypingTimer = undefined; // Wait time
        this.inTypingProcessLoop = false; // Used in this.typing()
        this.isTypingPaused = false; // Used in this.wait(), this.pauseTyping(), this.resumeTyping()
        this.setIgnoreWait(false);
        this.setSkipTypingAnimation(false);
        this.setTypingStartCallback(GetValue$32(config, 'onTypingStart', SetChildrenInvisible));
        this.setDefaultTypingSpeed(GetValue$32(config, 'speed', 250));
        this.setTypingSpeed();
        this.setSkipSpaceEnable(GetValue$32(config, 'skipSpace', false));
        this.setAnimationConfig(GetValue$32(config, 'animation', undefined));
        this.setMinSizeEnable(GetValue$32(config, 'minSizeEnable', false));
        this.setFadeOutPageCallback(GetValue$32(config, 'fadeOutPage'));
      }
      _createClass(TypeWriter, [{
        key: "destroy",
        value: function destroy() {
          this.destroyEventEmitter();
          this.textPlayer = undefined;
          this.typingTimer = undefined;
          this.pauseTypingTimer = undefined;
          this.onTypeStart = undefined;
          this.animationConfig = undefined;
        }
      }, {
        key: "timeline",
        get: function get() {
          return this.textPlayer.timeline;
        }
      }, {
        key: "setTypingStartCallback",
        value: function setTypingStartCallback(callback) {
          this.onTypeStart = callback;
          return this;
        }
      }, {
        key: "setAnimationConfig",
        value: function setAnimationConfig(config) {
          if (!config) {
            config = {};
          }
          if (!config.hasOwnProperty('duration')) {
            config.duration = 0;
          }
          if (!config.hasOwnProperty('onStart')) {
            // Apply default onStart callback
            config.onStart = SetChildVisible;
          }
          this.animationConfig = config;
          return this;
        }
      }, {
        key: "setFadeOutPageCallback",
        value: function setFadeOutPageCallback(callback) {
          this.fadeOutPageCallback = callback;
          return this;
        }
      }, {
        key: "setMinSizeEnable",
        value: function setMinSizeEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.minSizeEnable = enable;
          return this;
        }
      }, {
        key: "getNextChild",
        value: function getNextChild() {
          var child = this.nextChild;
          this.index = Math.min(this.index + 1, this.children.length); // Point to next child
          this._nextChild = undefined;
          return child;
        }
      }, {
        key: "nextChild",
        get: function get() {
          if (!this._nextChild) {
            this._nextChild = this.children[this.index];
          }
          return this._nextChild;
        }
      }]);
      return TypeWriter;
    }();
    var SetChildVisible = function SetChildVisible(child) {
      if (child.setVisible) {
        child.setVisible();
      }
    };
    var SetChildrenInvisible = function SetChildrenInvisible(children) {
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (child.setVisible) {
          child.setVisible(false);
        }
      }
    };
    Object.assign(TypeWriter.prototype, EventEmitterMethods$1, Methods$e);
  
    var SpriteBob = /*#__PURE__*/function (_BobBase) {
      _inherits(SpriteBob, _BobBase);
      function SpriteBob() {
        _classCallCheck(this, SpriteBob);
        return _callSuper(this, SpriteBob, arguments);
      }
      _createClass(SpriteBob, [{
        key: "playAnimation",
        value: function playAnimation(key) {
          this.gameObject.anims.timeScale = this.timeScale;
          this.gameObject.play(key);
          return this;
        }
      }, {
        key: "stopAnimation",
        value: function stopAnimation() {
          this.gameObject.stop();
          return this;
        }
      }, {
        key: "chainAnimation",
        value: function chainAnimation(keys) {
          this.gameObject.chain(keys);
          return this;
        }
      }, {
        key: "pauseAnimation",
        value: function pauseAnimation() {
          this.gameObject.anims.pause();
          return this;
        }
      }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
          _get(_getPrototypeOf(SpriteBob.prototype), "setTimeScale", this).call(this, timeScale);
          if (this.gameObject.anims) {
            this.gameObject.anims.timeScale = timeScale;
          }
          return this;
        }
      }]);
      return SpriteBob;
    }(BobBase);
  
    var AnimationMethods = {
      playAnimation: function playAnimation(name, key) {
        if (!this.has(name)) {
          this.add(name);
        }
        this.get(name).playAnimation(key);
        return this;
      },
      stopAnimation: function stopAnimation(name) {
        if (!this.has(name)) {
          return this;
        }
        this.get(name).stopAnimation();
        return this;
      },
      chainAnimation: function chainAnimation(name, keys) {
        if (!this.has(name)) {
          return this;
        }
        this.get(name).chainAnimation(keys);
        return this;
      },
      pauseAnimation: function pauseAnimation(name) {
        if (!this.has(name)) {
          return this;
        }
        this.get(name).pauseAnimation();
        return this;
      }
    };
  
    var Methods$d = {};
    Object.assign(Methods$d, AnimationMethods);
  
    var SpriteManager = /*#__PURE__*/function (_GOManager) {
      _inherits(SpriteManager, _GOManager);
      function SpriteManager(scene, config) {
        _classCallCheck(this, SpriteManager);
        if (config === undefined) {
          config = {};
        }
        config.BobClass = SpriteBob;
        return _callSuper(this, SpriteManager, [scene, config]);
      }
      _createClass(SpriteManager, [{
        key: "setCreateGameObjectCallback",
        value: function setCreateGameObjectCallback(callback, scope) {
          if (!callback || callback === 'sprite') {
            callback = CreateSprite;
          } else if (callback === 'image') {
            callback = CreateImage$1;
          }
          _get(_getPrototypeOf(SpriteManager.prototype), "setCreateGameObjectCallback", this).call(this, callback, scope);
          return this;
        }
      }]);
      return SpriteManager;
    }(GOManager);
    var CreateSprite = function CreateSprite(scene, textureKey, frameName) {
      if (typeof frameName !== 'string' && typeof frameName !== 'number') {
        frameName = undefined;
      }
      return scene.add.sprite(0, 0, textureKey, frameName);
    };
    var CreateImage$1 = function CreateImage(scene, textureKey, frameName) {
      if (typeof frameName !== 'string' && typeof frameName !== 'number') {
        frameName = undefined;
      }
      return scene.add.image(0, 0, textureKey, frameName);
    };
    Object.assign(SpriteManager.prototype, Methods$d);
  
    var IsPlayAnimationTag = function IsPlayAnimationTag(tags, goType) {
      // goType.name.play
      return tags.length === 3 && tags[0] === goType && tags[2] === 'play';
    };
    var IsStopAnimationTag = function IsStopAnimationTag(tags, goType) {
      // goType.name.stop
      return tags.length === 3 && tags[0] === goType && tags[2] === 'stop';
    };
    var OnParsePlayAnimationTag = function OnParsePlayAnimationTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on('+', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.play=key], or [goType.name.play=key0,key1,...]
        var tags = tag.split('.');
        var name;
        if (IsPlayAnimationTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          keys[_key - 1] = arguments[_key];
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".play"),
        // name
        PlayAnimation,
        // callback
        [goType, name, keys],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on('+', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.stop]
        var tags = tag.split('.');
        var name;
        if (IsStopAnimationTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".stop"),
        // name
        StopAnimation,
        // callback
        [goType, name],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on('-', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [/goType.name.play]
        var tags = tag.split('.');
        var name;
        if (IsPlayAnimationTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".stop"),
        // name
        StopAnimation,
        // callback
        [goType, name],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PlayAnimation = function PlayAnimation(params) {
      var goType, name, keys;
      var _params = _slicedToArray(params, 3);
      goType = _params[0];
      name = _params[1];
      keys = _params[2];
      var key = keys.shift();
  
      // this: textPlayer
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.playAnimation(name, key);
      if (keys.length > 0) {
        gameObjectManager.chainAnimation(name, keys);
      }
    };
    var StopAnimation = function StopAnimation(params) {
      var goType, args;
      // this: textPlayer
      var _params2 = _toArray(params);
      goType = _params2[0];
      args = _params2.slice(1);
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.stopAnimation.apply(gameObjectManager, _toConsumableArray(args));
    };
  
    var IsPauseAnimationTag = function IsPauseAnimationTag(tags, goType) {
      // goType.name.pause 
      return tags.length === 3 && tags[0] === goType && tags[2] === 'pause';
    };
    var OnParsePauseAnimationTag = function OnParsePauseAnimationTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on('+', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.pause=key]
        var tags = tag.split('.');
        var name;
        if (IsPauseAnimationTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".pause"),
        // name
        PauseAnimation,
        // callback
        [goType, name],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var PauseAnimation = function PauseAnimation(params) {
      var goType, args;
      // this: textPlayer
      var _params = _toArray(params);
      goType = _params[0];
      args = _params.slice(1);
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.pauseAnimation.apply(gameObjectManager, _toConsumableArray(args));
    };
  
    var IsChainAnimationTag = function IsChainAnimationTag(tags, goType) {
      // goType.name.chain 
      return tags.length === 3 && tags[0] === goType && tags[2] === 'chain';
    };
    var OnParseChainAnimationTag = function OnParseChainAnimationTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on('+', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.chain=key]
        var tags = tag.split('.');
        var name;
        if (IsChainAnimationTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        var keys = Array.prototype.slice.call(arguments, 1);
        AppendCommand$3.call(textPlayer, "".concat(goType, ".chain"),
        // name
        ChainAnimation,
        // callback
        [goType, name, keys],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var ChainAnimation = function ChainAnimation(params) {
      var goType, args;
      // this: textPlayer
      var _params = _toArray(params);
      goType = _params[0];
      args = _params.slice(1);
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.chainAnimation.apply(gameObjectManager, _toConsumableArray(args));
    };
  
    var ParseCallbacks$1 = [OnParsePlayAnimationTag, OnParsePauseAnimationTag, OnParseChainAnimationTag];
    var AddSpriteManager = function AddSpriteManager(config) {
      if (config === undefined) {
        config = {};
      }
      config.name = 'sprite';
      config.parseCallbacks = ParseCallbacks$1;
      this.addGameObjectManager(config, SpriteManager);
    };
  
    var IsAddGameObjectTag = function IsAddGameObjectTag(tags, goType) {
      // goType.name
      return tags.length === 2 && tags[0] === goType;
    };
    var OnParseAddGameObjectTag = function OnParseAddGameObjectTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on('+', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name=key,frame], or [goType.name]
        var tags = tag.split('.');
        var name;
        if (IsAddGameObjectTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".add"),
        // name
        AddGameObject, // callback
        [goType, name].concat(args),
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      }).on('-', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [/goType.name]
        var tags = tag.split('.');
        var name;
        if (IsAddGameObjectTag(tags, goType)) {
          name = tags[1];
        } else {
          return;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".remove"),
        // name
        RemoveGameObject,
        // callback
        [goType, name],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var AddGameObject = function AddGameObject(params) {
      var goType, args;
      // this: textPlayer
      var _params = _toArray(params);
      goType = _params[0];
      args = _params.slice(1);
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.add.apply(gameObjectManager, _toConsumableArray(args));
    };
    var RemoveGameObject = function RemoveGameObject(params) {
      var goType, args;
      // this: textPlayer
      var _params2 = _toArray(params);
      goType = _params2[0];
      args = _params2.slice(1);
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.remove.apply(gameObjectManager, _toConsumableArray(args));
    };
  
    var OnParseRemoveAllGameObjectsTag = function OnParseRemoveAllGameObjectsTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on('-', function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [/goType]
        if (tag === goType) ; else {
          return;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".removeall"),
        // name
        RemoveAllSprites,
        // callback
        goType,
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var RemoveAllSprites = function RemoveAllSprites(goType) {
      // this: textPlayer
      var gameObjectManager = this.getGameObjectManager(goType);
      gameObjectManager.removeAll();
    };
  
    var IsPropTag = function IsPropTag(tags, goType) {
      // goType.name.prop
      return tags.length === 3 && tags[0] === goType;
    };
    var OnParseCallGameObjectMethodTag = function OnParseCallGameObjectMethodTag(textPlayer, parser, config) {
      var goType = config.name;
      parser.on("+", function (tag) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.methodName=value0,value1,value2...]
        // [goType.name.prop=value]
        var tags = tag.split('.');
        var name, prop;
        if (IsPropTag(tags, goType)) {
          name = tags[1];
          prop = tags[2];
        } else {
          return;
        }
        for (var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          parameters[_key - 1] = arguments[_key];
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".call"),
        // name
        CallMethod, // callback
        [goType, name, prop].concat(parameters),
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var CallMethod = function CallMethod(params) {
      var goType, name, prop, args;
      // this: textPlayer
      var _params = _toArray(params);
      goType = _params[0];
      name = _params[1];
      prop = _params[2];
      args = _params.slice(3);
      var eventName = "".concat(goType, ".").concat(prop);
      this.emit.apply(this, [eventName, name].concat(_toConsumableArray(args)));
      if (this.listenerCount(eventName) > 0) {
        return;
      }
      var gameObjectManager = this.getGameObjectManager(goType);
      if (gameObjectManager.hasMethod(name, prop)) {
        // Is method
        gameObjectManager.call.apply(gameObjectManager, [name, prop].concat(_toConsumableArray(args)));
      } else {
        // Is property
        gameObjectManager.setProperty(name, prop, args[0]);
      }
    };
  
    var EaseMode = {
      to: true,
      yoyo: true,
      from: true,
      toLeft: true,
      toRight: true,
      toUp: true,
      toDown: true,
      yoyoLeft: true,
      yoyoRight: true,
      yoyoUp: true,
      yoyoDown: true,
      fromLeft: true,
      fromRight: true,
      fromUp: true,
      fromDown: true
    };
    var IsEasePropertyTag = function IsEasePropertyTag(tags, goType) {
      // goType.name.prop.to
      return tags.length === 4 && tags[0] === goType && EaseMode[tags[3]];
    };
    var OnParseEaseGameObjectPropertyTag = function OnParseEaseGameObjectPropertyTag(textPlayer, parser, config) {
      var goType = config.name;
      textPlayer.getGameObjectManager(goType);
      parser.on("+", function (tag, value, duration, ease, repeat) {
        if (parser.skipEventFlag) {
          // Has been processed before
          return;
        }
  
        // [goType.name.prop.to=value,duration]
        // [goType.name.prop.to=value,duration,ease,repeat]
        // [goType.name.prop.to=value,duration,repeat]
        var tags = tag.split('.');
        var name, property, easeMode;
        if (IsEasePropertyTag(tags, goType)) {
          name = tags[1];
          property = tags[2];
          easeMode = tags[3];
        } else {
          return;
        }
        if (typeof ease === 'number') {
          repeat = ease;
          ease = undefined;
        }
        AppendCommand$3.call(textPlayer, "".concat(goType, ".ease"),
        // name
        EaseProperty,
        // callback
        [goType, name, property, value, duration, ease, repeat, easeMode],
        // params
        textPlayer // scope
        );
        parser.skipEvent();
      });
    };
    var EaseProperty = function EaseProperty(params) {
      var goType, name, property, value, duration, ease, repeat, easeMode;
      // this: textPlayer
      var _params = _slicedToArray(params, 8);
      goType = _params[0];
      name = _params[1];
      property = _params[2];
      value = _params[3];
      duration = _params[4];
      ease = _params[5];
      repeat = _params[6];
      easeMode = _params[7];
      var gameObjectManager = this.getGameObjectManager(goType);
      var currentValue = gameObjectManager.getProperty(name, property);
      // Only can tween number property
      if (typeof currentValue !== 'number') {
        return;
      }
      if (easeMode.endsWith('Left') || easeMode.endsWith('Up')) {
        if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
          value = currentValue - value;
        } else if (easeMode.startsWith('from')) {
          gameObjectManager.setProperty(name, property, currentValue - value);
          value = currentValue;
        }
      } else if (easeMode.endsWith('Right') || easeMode.endsWith('Down')) {
        if (easeMode.startsWith('to') || easeMode.startsWith('yoyo')) {
          value = currentValue + value;
        } else if (easeMode.startsWith('from')) {
          gameObjectManager.setProperty(name, property, currentValue + value);
          value = currentValue;
        }
      } else if (easeMode === 'from') {
        gameObjectManager.setProperty(name, property, value);
        value = currentValue;
      }
      var isYoyo = easeMode.startsWith('yoyo');
      gameObjectManager.easeProperty(name, property, value, duration, ease, repeat, isYoyo);
    };
  
    var ParseCallbacks = [OnParseAddGameObjectTag, OnParseRemoveAllGameObjectsTag, OnParseCallGameObjectMethodTag, OnParseEaseGameObjectPropertyTag];
    var AddGameObjectManager = GameObjectManagerMethods$1.addGameObjectManager;
    var GameObjectManagerMethods = {
      addGameObjectManager: function addGameObjectManager(config, GameObjectManagerClass) {
        config = config ? Clone$2(config) : {};
        var name = config.name;
        if (!name) {
          console.warn("[TextPlayer] Parameter 'name' is required in addGameObjectManager(config) method");
        }
        var defaultLayer = config.defaultLayer;
        var createGameObject = config.createGameObject;
        var layerManager = this.layerManager;
        config.createGameObject = function (scene) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var gameObject = createGameObject.call.apply(createGameObject, [this, scene].concat(args));
          // this: config.createGameObjectScope
  
          if (defaultLayer && layerManager) {
            layerManager.addToLayer(defaultLayer, gameObject);
          }
          return gameObject;
        };
        AddGameObjectManager.call(this, config, GameObjectManagerClass);
  
        // Register parse callbacks
        var customParseCallbacks = config.parseCallbacks;
        if (!customParseCallbacks) {
          customParseCallbacks = ParseCallbacks;
        } else {
          customParseCallbacks = [].concat(_toConsumableArray(customParseCallbacks), ParseCallbacks);
        }
        for (var i = 0, cnt = customParseCallbacks.length; i < cnt; i++) {
          customParseCallbacks[i](this, this.parser, config);
        }
        return this;
      }
    };
  
    var SetClickTarget = function SetClickTarget(target) {
      this.waitEventManager.setClickTarget(target);
      return this;
    };
  
    var SetCameraTarget = function SetCameraTarget(camera) {
      this.waitEventManager.setCameraTarget(camera);
      return this;
    };
  
    var SetNextPageInput = function SetNextPageInput(input) {
      var textPlayer = this;
      if (!input) {
        this.nextPageInput = null;
      } else if (typeof input === 'function') {
        this.nextPageInput = function (callback, scope) {
          var waitEventManager = textPlayer.waitEventManager;
          waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
          var waitCompleteTriggerCallback = waitEventManager.getWaitCompleteTriggerCallback();
          input.call(textPlayer, waitCompleteTriggerCallback);
        };
      } else {
        this.nextPageInput = function (callback, scope) {
          WaitAny(textPlayer, input, callback, scope);
        };
      }
    };
  
    var AddImage = function AddImage(key, config) {
      this.imageManager.add(key, config);
      return this;
    };
  
    var PlayMethods = {
      play: function play(content) {
        if (this.isPlaying) {
          return this;
        }
        this.removeChildren();
        this.parser.start(content); // Parse bbcode-content
  
        this.isPlaying = true;
        this.once('complete', function () {
          this.isPlaying = false;
        }, this);
        this.lastWrapResult = undefined;
        this.typingNextPage();
        return this;
      },
      playPromise: function playPromise(content) {
        var promise = WaitComplete(this);
        this.play(content);
        return promise;
      }
    };
  
    var TypingNextPage = function TypingNextPage() {
      if (!this.isPlaying || this.isPageTyping) {
        return this;
      }
      this.typeWriter.once(PageFadeOutCompleteEvent, _TypingNextPage, this).fadeOutPage();
      return this;
    };
    var _TypingNextPage = function _TypingNextPage() {
      var result = this.runWrap(this.lastWrapResult);
      this.lastWrapResult = result;
      this.emit('page.start');
      var OnTypingPageComplete = function OnTypingPageComplete() {
        this.emit(StopPlayEvent); // Clear registed StopPlayEvent
        if (result.isLastPage) {
          this.emit('complete');
        } else {
          this.emit('page.complete');
          if (this.ignoreNextPageInput) {
            TypingNextPage.call(this);
          } else if (this.nextPageInput) {
            this.nextPageInput(TypingNextPage, this);
          } else ;
        }
      };
  
      // Remove event when typing pages has been canceled
      this.once(StopPlayEvent, function () {
        this.typeWriter.off('complete', OnTypingPageComplete, this);
      }, this);
      this.typeWriter.once('complete', OnTypingPageComplete, this).start(result.children);
    };
  
    var PauseMethods = {
      pause: function pause() {
        // Pause typing, typing timer and animation progresses
        this.timeline.pause();
        return this;
      },
      pauseTyping: function pauseTyping() {
        // Pause typing
        this.typeWriter.pauseTyping();
        return this;
      }
    };
  
    var ResumeMethods = {
      resume: function resume() {
        // Resume typing timer, animation progresses and typing
        this.timeline.resume();
        return this;
      },
      resumeTyping: function resumeTyping(offsetTime) {
        // Resume typing
        this.typeWriter.resumeTyping(offsetTime);
        return this;
      }
    };
  
    var Wait = function Wait(name) {
      this.typeWriter.wait(name);
      return this;
    };
  
    var TypingSpeedMethods = {
      setDefaultTypingSpeed: function setDefaultTypingSpeed(speed) {
        this.defaultTypingSpeed = speed;
        return this;
      },
      setTypingSpeed: function setTypingSpeed(speed) {
        this.typingSpeed = speed;
        return this;
      }
    };
  
    var SetIgnoreWait = function SetIgnoreWait(value) {
      this.typeWriter.setIgnoreWait(value);
      return this;
    };
  
    var SetIgnoreNextPageInput = function SetIgnoreNextPageInput(enable) {
      if (enable === undefined) {
        enable = true;
      }
      this.ignoreNextPageInput = enable;
      return this;
    };
  
    var ShowPage = function ShowPage() {
      // Only can work after playing, and before processing last child
      if (!this.isPlaying || !this.isPageTyping) {
        return this;
      }
  
      // Save parameters
      var typingSpeedSave = this.typeWriter.speed;
      var ignoreWaitSave = this.typeWriter.ignoreWait;
      var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
      var skipSoundEffectSave = this.typeWriter.skipSoundEffect;
      this.typeWriter.once('complete', function () {
        // Recover parameters
        this.typeWriter.setTypingSpeed(typingSpeedSave).setIgnoreWait(ignoreWaitSave).setSkipTypingAnimation(skipTypingAnimationSave).setSkipSoundEffect(skipSoundEffectSave);
      }, this).setTypingSpeed(0).skipCurrentTypingDelay().setIgnoreWait(true).setSkipTypingAnimation(true).setSkipSoundEffect(true);
      return this;
    };
  
    var SpriteMethods = {
      getSprite: function getSprite(name) {
        return this.getGameObject('sprite', name);
      },
      addSprite: function addSprite(name, gameObject) {
        this.addGameObject('sprite', name, gameObject);
        return this;
      }
    };
  
    var ContentMethods = {
      setContentOutputEnable: function setContentOutputEnable(enable) {
        this.parser.setContentOutputEnable(enable);
        return this;
      },
      setContentCallback: function setContentCallback(callback, scope) {
        this.contentCallback = callback;
        this.contentCallbackScope = scope;
        return this;
      }
    };
  
    var Methods$c = {
      setClickTarget: SetClickTarget,
      setCameraTarget: SetCameraTarget,
      setNextPageInput: SetNextPageInput,
      addImage: AddImage,
      typingNextPage: TypingNextPage,
      wait: Wait,
      setIgnoreWait: SetIgnoreWait,
      setIgnoreNextPageInput: SetIgnoreNextPageInput,
      showPage: ShowPage
    };
    Object.assign(Methods$c, GameObjectManagerMethods, PlayMethods, PauseMethods, ResumeMethods, TypingSpeedMethods, SpriteMethods, ContentMethods);
  
    var ClearEvents = function ClearEvents(textPlayer) {
      for (var i = 0, cnt = ClearEvents$1.length; i < cnt; i++) {
        textPlayer.emit(ClearEvents$1[i]);
      }
    };
  
    var IsPlainObject$L = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$31 = Phaser.Utils.Objects.GetValue;
    var TextPlayer = /*#__PURE__*/function (_Extend) {
      _inherits(TextPlayer, _Extend);
      function TextPlayer(scene, x, y, fixedWidth, fixedHeight, config) {
        var _this;
        _classCallCheck(this, TextPlayer);
        if (IsPlainObject$L(x)) {
          config = x;
        } else if (IsPlainObject$L(fixedWidth)) {
          config = fixedWidth;
        }
        if (config === undefined) {
          config = {};
        }
  
        // Don't set text in DynamicText's constructor
        var content = config.text;
        delete config.text;
        _this = _callSuper(this, TextPlayer, [scene, x, y, fixedWidth, fixedHeight, config]);
        _this.type = 'rexTextPlayer';
        _this.initManagers(scene, config);
        _this.parser = new Parser(_assertThisInitialized(_this), GetValue$31(config, 'parser', undefined));
        _this.typeWriter = new TypeWriter(_assertThisInitialized(_this), GetValue$31(config, 'typing', undefined));
        _this._imageManager = undefined;
        var imageData = GetValue$31(config, 'images', undefined);
        if (imageData) {
          _this.addImage(imageData);
        }
        var spriteManagerConfig = GetValue$31(config, 'sprites');
        if (spriteManagerConfig !== false && spriteManagerConfig !== null) {
          AddSpriteManager.call(_assertThisInitialized(_this), spriteManagerConfig);
        }
        _this.setIgnoreNextPageInput(GetValue$31(config, 'ignoreNextPageInput', false));
        _this.setNextPageInput(GetValue$31(config, 'nextPageInput', null));
        _this.isPlaying = false;
        if (content) {
          _this.play(content);
        }
        return _this;
      }
      _createClass(TextPlayer, [{
        key: "imageManager",
        get: function get() {
          if (this._imageManager === undefined) {
            this._imageManager = new ImageManager(this.scene);
          }
          return this._imageManager;
        }
      }, {
        key: "spriteManager",
        get: function get() {
          return this.getGameObjectManager('sprite');
        }
      }, {
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          ClearEvents(this);
          this.parser.destroy();
          this.parser = undefined;
          this.typeWriter.destroy(fromScene);
          this.typeWriter = undefined;
          if (this._imageManager) {
            this._imageManager.destroy(fromScene);
          }
          this._imageManager = undefined;
          this.destroyManagers(fromScene);
          _get(_getPrototypeOf(TextPlayer.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "isPageTyping",
        get: function get() {
          return this.typeWriter.isPageTyping;
        }
      }, {
        key: "defaultTypingSpeed",
        get: function get() {
          return this.typeWriter.defaultTypingSpeed;
        },
        set: function set(speed) {
          this.typeWriter.setDefaultTypingSpeed(speed);
        }
      }, {
        key: "typingSpeed",
        get: function get() {
          return this.typeWriter.speed;
        },
        set: function set(speed) {
          this.typeWriter.setTypingSpeed(speed);
        }
      }, {
        key: "timeScale",
        get: function get() {
          return this.getTimeScale();
        },
        set: function set(value) {
          this.setTimeScale(value);
        }
      }]);
      return TextPlayer;
    }(Extend(DynamicText));
    Object.assign(TextPlayer.prototype, Methods$c);
  
    ObjectFactory.register('textPlayer', function (x, y, width, height, config) {
      var gameObject = new TextPlayer(this.scene, x, y, width, height, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TextPlayer', TextPlayer);
  
    var ElementProperties$1 = {
      maxLength: ['maxLength', undefined],
      minLength: ['minLength', undefined],
      readOnly: ['readOnly', false]
    };
    var StyleProperties$1 = {
      direction: ['direction', undefined]
    };
  
    var CopyProperty = function CopyProperty(from, to, key) {
      if (typeof key === 'string') {
        if (from.hasOwnProperty(key)) {
          to[key] = from[key];
        }
      } else {
        var keys = key;
        if (Array.isArray(keys)) {
          for (var i = 0, cnt = keys.length; i < cnt; i++) {
            CopyProperty(from, to, keys[i]);
          }
        } else {
          for (var key in keys) {
            CopyProperty(from, to, key);
          }
        }
      }
    };
  
    var CopyElementConfig = function CopyElementConfig(from) {
      if (from === undefined) {
        from = {};
      }
      var to = {};
      CopyProperty(from, to, 'inputType');
      CopyProperty(from, to, 'type');
      CopyProperty(from, to, 'style');
      CopyProperty(from, to, StyleProperties$1);
      CopyProperty(from, to, ElementProperties$1);
      return to;
    };
  
    var IsPointerInHitArea = function IsPointerInHitArea(gameObject, pointer, preTest, postTest) {
      if (pointer) {
        if (preTest && !preTest(gameObject, pointer)) {
          return false;
        }
        if (!HitTest(gameObject, pointer)) {
          return false;
        }
        if (postTest && !postTest(gameObject, pointer)) {
          return false;
        }
        return true;
      } else {
        var inputManager = gameObject.scene.input.manager;
        var pointersTotal = inputManager.pointersTotal;
        var pointers = inputManager.pointers,
          pointer;
        for (var i = 0; i < pointersTotal; i++) {
          pointer = pointers[i];
          if (preTest && !preTest(gameObject, pointer)) {
            continue;
          }
          if (!HitTest(gameObject, pointer)) {
            continue;
          }
          if (postTest && !postTest(gameObject, pointer)) {
            continue;
          }
          return true;
        }
        return false;
      }
    };
    var HitTest = function HitTest(gameObject, pointer) {
      var scene = gameObject.scene;
      var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
      var inputManager = scene.input.manager;
      var gameObjects = [gameObject];
      for (var i = 0, len = cameras.length; i < len; i++) {
        inputManager.hitTest(pointer, gameObjects, cameras[i], HitTestResult);
        if (HitTestResult.length > 0) {
          HitTestResult.length = 0;
          return true;
        }
      }
      HitTestResult.length = 0;
      return false;
    };
    var HitTestResult = [];
  
    var LastOpenedEditor$1 = undefined;
    var SetLastOpenedEditor$1 = function SetLastOpenedEditor(editor) {
      if (editor === LastOpenedEditor$1) {
        return;
      }
      if (LastOpenedEditor$1 !== undefined) {
        LastOpenedEditor$1.close();
      }
      LastOpenedEditor$1 = editor;
    };
    var CloseLastOpenEditor$1 = function CloseLastOpenEditor(editor) {
      if (editor !== LastOpenedEditor$1) {
        return;
      }
  
      // Don't call `LastOpenedEditor.close()`
      LastOpenedEditor$1 = undefined;
    };
  
    var GetValue$30 = Phaser.Utils.Objects.GetValue;
    var SetProperties = function SetProperties(properties, config, out) {
      if (out === undefined) {
        out = {};
      }
      var property, value;
      for (var key in properties) {
        property = properties[key]; // [propName, defaultValue]
        value = GetValue$30(config, key, property[1]);
        if (value !== undefined) {
          out[property[0]] = value;
        }
      }
      return out;
    };
  
    var StopPropagationTouchEvents = function StopPropagationTouchEvents(element) {
      // Don't propagate touch/mouse events to parent(game canvas)
      element.addEventListener('touchstart', callback, false);
      element.addEventListener('touchmove', callback, false);
      element.addEventListener('touchend', callback, false);
      element.addEventListener('mousedown', callback, false);
      element.addEventListener('mouseup', callback, false);
      element.addEventListener('mousemove', callback, false);
    };
    var callback = function callback(e) {
      e.stopPropagation();
    };
  
    var EnterClose = function EnterClose() {
      this.close();
      this.emit('keydown-ENTER', this.parent, this);
      return this;
    };
  
    var OnOpen = function OnOpen() {
      this.isOpened = true;
      this.initText();
      if (this.enterCloseEnable) {
        this.scene.input.keyboard.once('keydown-ENTER', EnterClose, this);
      }
  
      // There is no cursor-position-change event, 
      // so updating cursor position every tick
      this.scene.sys.events.on('postupdate', this.updateText, this);
      if (this.clickOutSideTarget) {
        MoveMyDepthAbove.call(this.clickOutSideTarget, this.parent);
        MoveMyDepthBelow.call(this.clickOutSideTarget, this.parent);
        this.clickOutSideTarget.setInteractive().on('pointerdown', this.onClickOutside, this);
      } else {
        this.scene.input.on('pointerdown', this.onClickOutside, this);
      }
      if (this.onOpenCallback) {
        this.onOpenCallback(this.parent, this);
      }
      this.emit('open', this);
    };
  
    var RemoveElement = function RemoveElement(element) {
      if (!element) {
        return;
      }
      var parentElement = element.parentElement;
      if (parentElement) {
        parentElement.removeChild(element);
      }
    };
  
    var OnClose = function OnClose() {
      this.isOpened = false;
      this.updateText();
      this.scene.sys.events.off('postupdate', this.updateText, this);
      if (this.clickOutSideTarget) {
        this.clickOutSideTarget.disableInteractive().off('pointerdown', this.onClickOutside, this);
      } else {
        this.scene.input.off('pointerdown', this.onClickOutside, this);
      }
      if (this.onCloseCallback) {
        this.onCloseCallback(this.parent, this);
      }
  
      // Remove input text element when closing editor
      RemoveElement(this.node);
      this.node = undefined;
      this.emit('close', this);
    };
  
    var GetValue$2$ = Phaser.Utils.Objects.GetValue;
    var CreateElement = function CreateElement(parent, config) {
      var element;
      var textType = GetValue$2$(config, 'inputType', undefined);
      if (textType === undefined) {
        textType = GetValue$2$(config, 'type', 'text');
      }
      if (textType === 'textarea') {
        element = document.createElement('textarea');
        element.style.resize = 'none';
      } else {
        element = document.createElement('input');
        element.type = textType;
      }
      var style = GetValue$2$(config, 'style', undefined);
      // Apply other style properties
      var elementStyle = element.style;
      SetProperties(StyleProperties$1, style, elementStyle);
      // Set style
      elementStyle.position = 'absolute';
      elementStyle.opacity = 0;
      elementStyle.pointerEvents = 'none';
      elementStyle.zIndex = 0;
      // hide native blue text cursor on iOS
      elementStyle.transform = 'scale(0)';
      SetProperties(ElementProperties$1, config, element);
  
      // Don't propagate touch/mouse events to parent(game canvas)
      StopPropagationTouchEvents(element);
  
      // Attach element to fullscreenTarget in full screen mode
      var scaleManager = parent.scene.sys.scale;
      var parentElement = scaleManager.isFullscreen ? scaleManager.fullscreenTarget : document.body;
      parentElement.appendChild(element);
  
      // open() -> 'focus' -> OnOpen
      element.addEventListener('focus', function (e) {
        OnOpen.call(parent);
      });
  
      // close() -> 'blur' -> OnClose
      element.addEventListener('blur', function (e) {
        OnClose.call(parent);
      });
      return element;
    };
  
    var Open$2 = function Open() {
      // Already opened
      if (this.isOpened) {
        return this;
      }
      // Read only
      if (this.readOnly) {
        return this;
      }
      SetLastOpenedEditor$1(this);
      if (!this.node) {
        // Create input text element when opening editor
        this.node = CreateElement(this, this.nodeConfig);
        // Register 'focus', 'blur' events
      }
      this.setFocus();
  
      // 'focus' event -> OnOpen
  
      return this;
    };
  
    var Close$1 = function Close() {
      // Already closed
      if (!this.isOpened) {
        return this;
      }
      CloseLastOpenEditor$1(this);
      this.setBlur();
  
      // 'blur' event -> OnOpen
  
      return this;
    };
  
    var Methods$b = {
      open: Open$2,
      close: Close$1
    };
  
    var GetValue$2_ = Phaser.Utils.Objects.GetValue;
    var HiddenTextEditBase = /*#__PURE__*/function (_ComponentBase) {
      _inherits(HiddenTextEditBase, _ComponentBase);
      function HiddenTextEditBase(gameObject, config) {
        var _this;
        _classCallCheck(this, HiddenTextEditBase);
        _this = _callSuper(this, HiddenTextEditBase, [gameObject]);
        // this.parent = gameObject;
  
        var textType = GetValue$2_(config, 'inputType', undefined);
        if (textType === undefined) {
          textType = GetValue$2_(config, 'type', 'text');
        }
        _this.setEnterCloseEnable(GetValue$2_(config, 'enterClose', textType !== 'textarea'));
        var onOpen = GetValue$2_(config, 'onOpen', undefined);
        if (!onOpen) {
          onOpen = GetValue$2_(config, 'onFocus', undefined);
        }
        _this.onOpenCallback = onOpen;
        _this.clickOutSideTarget = GetValue$2_(config, 'clickOutSideTarget', undefined);
        var onClose = GetValue$2_(config, 'onClose', undefined);
        if (!onClose) {
          onClose = GetValue$2_(config, 'onBlur', undefined);
        }
        _this.onCloseCallback = onClose;
        _this.onUpdateCallback = GetValue$2_(config, 'onUpdate', undefined);
        _this.isOpened = false;
        gameObject.on('pointerdown', function () {
          this.open();
        }, _assertThisInitialized(_this)).setInteractive();
        _this.nodeConfig = CopyElementConfig(config);
        // Create/remove input text element when opening/closing editor
        _this.node = undefined;
        return _this;
      }
      _createClass(HiddenTextEditBase, [{
        key: "destroy",
        value: function destroy() {
          // this.parent.off('pointerdown', this.open, this);
  
          this.close();
          if (this.clickOutSideTarget) {
            this.clickOutSideTarget.destroy();
          }
          _get(_getPrototypeOf(HiddenTextEditBase.prototype), "destroy", this).call(this);
        }
      }, {
        key: "onClickOutside",
        value: function onClickOutside(pointer) {
          if (!IsPointerInHitArea(this.parent, pointer)) {
            this.close();
          }
        }
      }, {
        key: "setEnterCloseEnable",
        value: function setEnterCloseEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.enterCloseEnable = enable;
          return this;
        }
  
        // Override
      }, {
        key: "initText",
        value: function initText() {}
  
        // Override, invoking under 'postupdate' event of scene
      }, {
        key: "updateText",
        value: function updateText() {}
  
        // Copy from InputText class
      }, {
        key: "text",
        get: function get() {
          if (!this.node) {
            return '';
          }
          return this.node.value;
        },
        set: function set(value) {
          if (!this.node) {
            return;
          }
          this.node.value = value;
        }
      }, {
        key: "setText",
        value: function setText(value) {
          // Override
          this.text = value;
          return this;
        }
      }, {
        key: "maxLength",
        get: function get() {
          return this.nodeConfig.maxLength;
        },
        set: function set(value) {
          this.nodeConfig.maxLength = value;
          if (this.node) {
            this.node.maxLength = value;
          }
        }
      }, {
        key: "setMaxLength",
        value: function setMaxLength(value) {
          this.maxLength = value;
          return this;
        }
      }, {
        key: "minLength",
        get: function get() {
          return this.nodeConfig.minLength;
        },
        set: function set(value) {
          this.nodeConfig.minLength = value;
          if (this.node) {
            this.node.minLength = value;
          }
        }
      }, {
        key: "setMinLength",
        value: function setMinLength(value) {
          this.minLength = value;
          return this;
        }
      }, {
        key: "placeholder",
        get: function get() {
          return this.node.placeholder;
        },
        set: function set(value) {
          if (!this.node) {
            return;
          }
          this.node.placeholder = value;
        }
      }, {
        key: "setPlaceholder",
        value: function setPlaceholder(value) {
          this.placeholder = value;
          return this;
        }
      }, {
        key: "selectText",
        value: function selectText(selectionStart, selectionEnd) {
          if (!this.node) {
            return this;
          }
          if (selectionStart === undefined) {
            this.node.select();
          } else {
            this.node.setSelectionRange(selectionStart, selectionEnd);
          }
          return this;
        }
      }, {
        key: "selectAll",
        value: function selectAll() {
          this.selectText();
          return this;
        }
      }, {
        key: "selectionStart",
        get: function get() {
          if (!this.node) {
            return 0;
          }
          return this.node.selectionStart;
        }
      }, {
        key: "selectionEnd",
        get: function get() {
          if (!this.node) {
            return 0;
          }
          return this.node.selectionEnd;
        }
      }, {
        key: "selectedText",
        get: function get() {
          if (!this.node) {
            return '';
          }
          var node = this.node;
          return node.value.substring(node.selectionStart, node.selectionEnd);
        }
      }, {
        key: "cursorPosition",
        get: function get() {
          if (!this.node) {
            return 0;
          }
          return this.node.selectionStart;
        },
        set: function set(value) {
          if (!this.node) {
            return;
          }
          this.node.setSelectionRange(value, value);
        }
      }, {
        key: "setCursorPosition",
        value: function setCursorPosition(value) {
          if (value === undefined) {
            value = this.text.length;
          } else if (value < 0) {
            value = this.text.length + value;
          }
          this.cursorPosition = value;
          return this;
        }
      }, {
        key: "tooltip",
        get: function get() {
          if (!this.node) {
            return '';
          }
          return this.node.title;
        },
        set: function set(value) {
          if (!this.node) {
            return this;
          }
          this.node.title = value;
        }
      }, {
        key: "setTooltip",
        value: function setTooltip(value) {
          this.tooltip = value;
          return this;
        }
      }, {
        key: "setTextChangedCallback",
        value: function setTextChangedCallback(callback) {
          this.onTextChanged = callback;
          return this;
        }
      }, {
        key: "readOnly",
        get: function get() {
          return this.nodeConfig.readOnly;
        },
        set: function set(value) {
          this.nodeConfig.readOnly = value;
          if (this.node) {
            this.node.readOnly = value;
          }
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(value) {
          if (value === undefined) {
            value = true;
          }
          this.readOnly = value;
          return this;
        }
      }, {
        key: "spellCheck",
        get: function get() {
          if (!this.node) {
            return '';
          }
          return this.node.spellcheck;
        },
        set: function set(value) {
          if (!this.node) {
            return;
          }
          this.node.spellcheck = value;
        }
      }, {
        key: "setSpellCheck",
        value: function setSpellCheck(value) {
          this.spellCheck = value;
          return this;
        }
      }, {
        key: "fontColor",
        get: function get() {
          if (!this.node) {
            return undefined;
          }
          return this.node.style.color;
        },
        set: function set(value) {
          if (!this.node) {
            return;
          }
          this.node.style.color = value;
        }
      }, {
        key: "setFontColor",
        value: function setFontColor(value) {
          this.fontColor = value;
          return this;
        }
      }, {
        key: "setStyle",
        value: function setStyle(key, value) {
          if (!this.node) {
            return this;
          }
          this.node.style[key] = value;
          return this;
        }
      }, {
        key: "getStyle",
        value: function getStyle(key) {
          if (!this.node) {
            return undefined;
          }
          return this.node.style[key];
        }
      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          if (!this.node) {
            return this;
          }
          this.node.scrollTop = this.node.scrollHeight;
          return this;
        }
      }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
          if (!this.node) {
            return this;
          }
          if (enabled === undefined) {
            enabled = true;
          }
          this.node.disabled = !enabled;
          return this;
        }
      }, {
        key: "setBlur",
        value: function setBlur() {
          if (!this.node) {
            return this;
          }
          this.node.blur();
          return this;
        }
      }, {
        key: "setFocus",
        value: function setFocus() {
          if (!this.node) {
            return this;
          }
          this.node.focus();
          return this;
        }
      }, {
        key: "isFocused",
        get: function get() {
          return this.isOpened;
        }
      }]);
      return HiddenTextEditBase;
    }(ComponentBase);
    Object.assign(HiddenTextEditBase.prototype, Methods$b);
  
    var NumberInputUpdateCallback = function NumberInputUpdateCallback(text, textObject, hiddenInputText) {
      text = text.replace(' ', '');
      var previousText = hiddenInputText.previousText;
      if (text === previousText) {
        return text;
      }
      if (isNaN(text)) {
        // Enter a NaN character, back to previous text
        hiddenInputText.emit('nan', text, hiddenInputText);
        text = previousText;
        var cursorPosition = hiddenInputText.cursorPosition - 1;
        hiddenInputText.setText(text);
        hiddenInputText.setCursorPosition(cursorPosition);
      } else {
        // New number text, update previous texr
        hiddenInputText.previousText = text;
      }
      return text;
    };
  
    var SelectRange = function SelectRange(hiddenTextEdit) {
      var textObject = hiddenTextEdit.parent;
      // var text = textObject.text;
      var selectionStart = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionStart : null;
      var selectionEnd = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionEnd : null;
      var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
      var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
      if (prevSelectionStart === selectionStart && prevSelectionEnd === selectionEnd) {
        return;
      }
      var min, max;
      if (prevSelectionStart === null) {
        min = selectionStart;
        max = selectionEnd;
      } else if (selectionStart === null) {
        min = prevSelectionStart;
        max = prevSelectionEnd;
      } else {
        min = Math.min(prevSelectionStart, selectionStart);
        max = Math.max(prevSelectionEnd, selectionEnd);
      }
      for (var i = min; i < max; i++) {
        var inPrevSelectionRange;
        if (prevSelectionStart === null) {
          inPrevSelectionRange = false;
        } else {
          inPrevSelectionRange = i >= prevSelectionStart && i < prevSelectionEnd;
        }
        var inSelectionRange;
        if (selectionStart === null) {
          inSelectionRange = false;
        } else {
          inSelectionRange = i >= selectionStart && i < selectionEnd;
        }
        if (inPrevSelectionRange === inSelectionRange) {
          continue;
        }
        var child = textObject.getCharChild(i);
        if (child) {
          var eventName = inPrevSelectionRange ? 'cursorout' : 'cursorin';
          textObject.emit(eventName, child, i, textObject);
        }
      }
      hiddenTextEdit.prevSelectionStart = selectionStart;
      hiddenTextEdit.prevSelectionEnd = selectionEnd;
    };
  
    var ScrollToBob = function ScrollToBob(bob) {
      var textObject = bob.parent;
      var textObjectLeftX = 0,
        textObjectRightX = textObject.width,
        textObjectTopY = 0,
        textObjectBottomY = textObject.height;
      var childX = bob.drawX,
        childY = bob.drawY;
      var childLeftX = childX + bob.drawTLX,
        childRightX = childX + bob.drawTRX,
        childTopY = childY + bob.drawTLY,
        childBottomY = childY + bob.drawBLY;
      var dx;
      if (childLeftX < textObjectLeftX) {
        dx = textObjectLeftX - childLeftX;
      } else if (childRightX > textObjectRightX) {
        dx = textObjectRightX - childRightX;
      } else {
        dx = 0;
      }
      var dy;
      if (childTopY < textObjectTopY) {
        dy = textObjectTopY - childTopY;
      } else if (childBottomY > textObjectBottomY) {
        dy = textObjectBottomY - childBottomY;
      } else {
        dy = 0;
      }
      textObject._textOX += dx;
      textObject._textOY += dy;
    };
  
    var MoveCursor = function MoveCursor(hiddenTextEdit) {
      var textObject = hiddenTextEdit.parent;
      var text = textObject.text;
      var cursorPosition = hiddenTextEdit.cursorPosition;
      if (hiddenTextEdit.prevCursorPosition === cursorPosition) {
        return;
      }
      if (hiddenTextEdit.prevCursorPosition !== null) {
        if (hiddenTextEdit.prevCursorPosition > text.length) {
          hiddenTextEdit.prevCursorPosition = null;
        }
      }
      if (hiddenTextEdit.prevCursorPosition !== null) {
        var child = textObject.getCharChild(hiddenTextEdit.prevCursorPosition);
        if (child) {
          // Rollback size of new line child
          if (child.text === '\n') {
            child.clearTextSize();
          }
          textObject.emit('cursorout', child, hiddenTextEdit.prevCursorPosition, textObject);
        }
      }
      if (cursorPosition != null) {
        var child = textObject.getCharChild(cursorPosition);
        if (child) {
          // Display new line child
          if (child.text === '\n') {
            child.copyTextSize(textObject.lastInsertCursor);
          }
          ScrollToBob(child);
          textObject.emit('cursorin', child, cursorPosition, textObject);
        }
      }
      textObject.emit('movecursor', cursorPosition, hiddenTextEdit.prevCursorPosition, textObject);
      hiddenTextEdit.prevCursorPosition = cursorPosition;
    };
  
    var ClearSelectRange = function ClearSelectRange(hiddenTextEdit) {
      var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
      if (prevSelectionStart === null) {
        return;
      }
      var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
      var textObject = hiddenTextEdit.parent;
      for (var i = prevSelectionStart; i < prevSelectionEnd; i++) {
        var child = textObject.getCharChild(i);
        if (child) {
          textObject.emit('cursorout', child, i, textObject);
        }
      }
      hiddenTextEdit.prevSelectionStart = null;
      hiddenTextEdit.prevSelectionEnd = null;
    };
  
    var ClearCursor = function ClearCursor(hiddenTextEdit) {
      var prevCursorPosition = hiddenTextEdit.prevCursorPosition;
      if (prevCursorPosition === null) {
        return;
      }
      var textObject = hiddenTextEdit.parent;
      var child = textObject.getCharChild(prevCursorPosition);
      if (child) {
        textObject.emit('cursorout', child, prevCursorPosition, textObject);
      }
      hiddenTextEdit.prevCursorPosition = null;
    };
  
    var GetValue$2Z = Phaser.Utils.Objects.GetValue;
    var HiddenTextEdit$1 = /*#__PURE__*/function (_HiddenTextEditBase) {
      _inherits(HiddenTextEdit, _HiddenTextEditBase);
      function HiddenTextEdit(gameObject, config) {
        var _this;
        _classCallCheck(this, HiddenTextEdit);
        _this = _callSuper(this, HiddenTextEdit, [gameObject, config]);
        // this.parent = gameObject;
  
        _this.setSelectAllWhenFocusEnable(GetValue$2Z(config, 'selectAll', false));
        _this.cursorMoveStartIndex = null;
        _this.prevCursorPosition = null;
        _this.prevSelectionStart = null;
        _this.prevSelectionEnd = null;
        _this.firstClickAfterOpen = false;
        gameObject
        // Open editor by 'pointerdown' event
        // Then set cursor position to nearest char
        .on('pointerdown', function (pointer, localX, localY, event) {
          var child = gameObject.getNearestChild(localX, localY);
          var charIndex = gameObject.getCharIndex(child);
          if (!this.selectAllWhenFocus || !this.firstClickAfterOpen) {
            this.setCursorPosition(charIndex);
          }
          this.cursorMoveStartIndex = charIndex;
          this.firstClickAfterOpen = false;
        }, _assertThisInitialized(_this)).on('pointermove', function (pointer, localX, localY, event) {
          if (!pointer.isDown) {
            return;
          }
          var child = gameObject.getNearestChild(localX, localY);
          var charIndex = gameObject.getCharIndex(child);
          if (this.cursorMoveStartIndex < charIndex) {
            this.selectText(this.cursorMoveStartIndex, charIndex + 1);
          } else {
            this.selectText(charIndex, this.cursorMoveStartIndex + 1);
          }
        }, _assertThisInitialized(_this));
        _this.on('open', function () {
          if (this.selectAllWhenFocus) {
            this.selectAll();
          }
          this.firstClickAfterOpen = true;
          gameObject.emit('open');
        }, _assertThisInitialized(_this)).on('close', function () {
          // Route 'close' event
          gameObject.emit('close');
        }).on('keydown-ENTER', function () {
          // Route 'keydown-ENTER' event
          gameObject.emit('keydown-ENTER');
        });
        return _this;
      }
      _createClass(HiddenTextEdit, [{
        key: "initText",
        value: function initText() {
          var textObject = this.parent;
          this.prevCursorPosition = null;
          this.setText(textObject.text);
          return this;
        }
      }, {
        key: "updateText",
        value: function updateText() {
          var textObject = this.parent;
          var text = this.text;
          if (this.onUpdateCallback) {
            var newText = this.onUpdateCallback(text, textObject, this);
            if (newText != null) {
              text = newText;
            }
          }
          if (textObject.text !== text) {
            textObject.setText(text);
          }
          if (this.isOpened) {
            if (this.selectionStart !== this.selectionEnd) {
              ClearCursor(this);
              SelectRange(this);
            } else {
              ClearSelectRange(this);
              MoveCursor(this);
            }
          } else {
            ClearSelectRange(this);
            ClearCursor(this);
          }
          return this;
        }
      }, {
        key: "setNumberInput",
        value: function setNumberInput() {
          this.onUpdateCallback = NumberInputUpdateCallback;
          return this;
        }
      }, {
        key: "setSelectAllWhenFocusEnable",
        value: function setSelectAllWhenFocusEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.selectAllWhenFocus = enable;
          return this;
        }
      }]);
      return HiddenTextEdit;
    }(HiddenTextEditBase);
  
    var GetValue$2Y = Phaser.Utils.Objects.GetValue;
    var PropertiesList = ['inputType', 'onOpen', 'clickOutSideTarget', 'onFocus', 'onClose', 'onBlur', 'onUpdate', 'enterClose', 'readOnly', 'maxLength', 'minLength', 'selectAll'];
    var CreateHiddenTextEdit = function CreateHiddenTextEdit(parent, parentConfig) {
      var config = GetValue$2Y(parentConfig, 'edit');
      if (config === undefined) {
        config = {};
      }
      CopyProperty(parentConfig, config, PropertiesList);
      return new HiddenTextEdit$1(parent, config);
    };
  
    var HasValue = function HasValue(source, key) {
      if (!source || typeof source === 'number') {
        return false;
      } else if (source.hasOwnProperty(key)) {
        return true;
      } else if (key.indexOf('.') !== -1) {
        var keys = key.split('.');
        var parent = source;
  
        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++) {
          if (parent.hasOwnProperty(keys[i])) {
            parent = parent[keys[i]];
          } else {
            //  Can't go any further
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };
  
    var GetRootGameObject = function GetRootGameObject(gameObject) {
      if (gameObject.parentContainer) {
        // At a container
        return GetRootGameObject(gameObject.parentContainer);
      }
      var layer = GetLayer(gameObject);
      if (layer) {
        // At a layer
        return GetRootGameObject(layer);
      }
      return gameObject;
    };
  
    var GetFirstRenderCamera = function GetFirstRenderCamera(gameObject) {
      var cameraFilter = GetRootGameObject(gameObject).cameraFilter;
      var cameras = gameObject.scene.sys.cameras.cameras;
      var camera, isCameraIgnore;
      for (var i = 0, cnt = cameras.length; i < cnt; i++) {
        camera = cameras[i];
        isCameraIgnore = (cameraFilter & camera.id) > 0;
        if (!isCameraIgnore) {
          return camera;
        }
      }
      return null;
    };
  
    var FullWindow = /*#__PURE__*/function (_ComponentBase) {
      _inherits(FullWindow, _ComponentBase);
      function FullWindow(gameObject, config) {
        var _this;
        _classCallCheck(this, FullWindow);
        _this = _callSuper(this, FullWindow, [gameObject]);
        // this.parent = gameObject;
  
        _this.targetCamera = undefined;
        _this.boot();
        return _this;
      }
      _createClass(FullWindow, [{
        key: "boot",
        value: function boot() {
          this.scene.sys.events.on('prerender', this.resize, this);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (!this.scene) {
            return;
          }
          this.scene.sys.events.off('prerender', this.resize, this);
          _get(_getPrototypeOf(FullWindow.prototype), "destroy", this).call(this);
        }
      }, {
        key: "resize",
        value: function resize() {
          var scene = this.scene;
          var gameObject = this.parent;
          var camera = GetFirstRenderCamera(gameObject);
          if (!camera) {
            return;
          }
          gameObject.setScrollFactor(0).setOrigin(0.5);
          var gameSize = scene.sys.scale.gameSize;
          var gameWidth = gameSize.width,
            gameHeight = gameSize.height,
            scale = 1 / camera.zoom;
  
          // Origin is fixed to (0.5,0.5)
          var x = gameWidth / 2,
            y = gameHeight / 2;
          var width = gameWidth * scale,
            height = gameHeight * scale;
          if (gameObject.x !== x || gameObject.y !== y) {
            gameObject.setPosition(x, y);
          }
          if (gameObject.width !== width || gameObject.height !== height) {
            gameObject.setSize(width, height);
          }
        }
      }]);
      return FullWindow;
    }(ComponentBase);
  
    var Zone$2 = Phaser.GameObjects.Zone;
    var FullWindowRectangle$1 = /*#__PURE__*/function (_Zone) {
      _inherits(FullWindowRectangle, _Zone);
      function FullWindowRectangle(scene) {
        var _this;
        _classCallCheck(this, FullWindowRectangle);
        _this = _callSuper(this, FullWindowRectangle, [scene, 0, 0, 2, 2]);
        _this.fullWindow = new FullWindow(_assertThisInitialized(_this));
        return _this;
      }
      return _createClass(FullWindowRectangle);
    }(Zone$2);
  
    var InjectDefaultConfig = function InjectDefaultConfig(scene, config) {
      var isSingleLineMode = !config.textArea;
      if (!HasValue(config, 'wrap.vAlign')) {
        var defaultValue = isSingleLineMode ? 'center' : 'top';
        SetValue(config, 'wrap.vAlign', defaultValue);
      }
      if (!HasValue(config, 'wrap.wrapMode')) {
        SetValue(config, 'wrap.wrapMode', 'char');
      }
      if (!HasValue(config, 'wrap.maxLines')) {
        var defaultValue = isSingleLineMode ? 1 : undefined;
        SetValue(config, 'wrap.maxLines', defaultValue);
      }
      if (isSingleLineMode) {
        SetValue(config, 'wrap.wrapWidth', Infinity);
      }
      if (!HasValue(config, 'wrap.useDefaultTextHeight')) {
        SetValue(config, 'wrap.useDefaultTextHeight', true);
      }
      if (!config.edit) {
        config.edit = {};
      }
      if (!HasValue(config.edit, 'inputType')) {
        var defaultValue = isSingleLineMode ? 'text' : 'textarea';
        SetValue(config.edit, 'inputType', defaultValue);
      }
      if (config.clickOutSideTarget === true) {
        var clickOutSideTarget = new FullWindowRectangle$1(scene);
        scene.add.existing(clickOutSideTarget);
        config.clickOutSideTarget = clickOutSideTarget;
      }
      return config;
    };
  
    var ExtractByPrefix = function ExtractByPrefix(obj, prefix, delimiter, out) {
      if (delimiter === undefined) {
        delimiter = '.';
      }
      if (out === undefined) {
        out = {};
      }
      if (!obj) {
        return out;
      }
      if (prefix in obj) {
        return Object.assign(out, obj[prefix]);
      }
      prefix += delimiter;
      for (var key in obj) {
        if (!key.startsWith(prefix)) {
          continue;
        }
        out[key.replace(prefix, '')] = obj[key];
      }
      return out;
    };
  
    var GetPartialData = function GetPartialData(obj, keys, out) {
      if (out === undefined) {
        out = {};
      }
      if (Array.isArray(keys)) {
        var key;
        for (var i = 0, cnt = keys.length; i < cnt; i++) {
          key = keys[i];
          out[key] = obj[key];
        }
      } else {
        for (var key in keys) {
          out[key] = obj[key];
        }
      }
      return out;
    };
  
    var IsKeyValueEqual = function IsKeyValueEqual(objA, objB) {
      for (var key in objA) {
        if (!(key in objB)) {
          return false;
        }
        if (objA[key] !== objB[key]) {
          return false;
        }
      }
      for (var key in objB) {
        if (!(key in objA)) {
          return false;
        }
      }
      return true;
    };
  
    var RegisterCursorStyle = function RegisterCursorStyle(cursorStyle) {
      if (IsEmpty(cursorStyle)) {
        return;
      }
      this.setCursorStyle(cursorStyle).on('cursorin', function (child) {
        var cursorStyle = this.cursorStyle;
        var styleSave = GetPartialData(child.style, cursorStyle);
        if (IsKeyValueEqual(cursorStyle, styleSave)) {
          return;
        }
        child.styleSave = styleSave;
        child.modifyStyle(cursorStyle);
      }, this).on('cursorout', function (child) {
        if (!child.styleSave) {
          return;
        }
        child.modifyStyle(child.styleSave);
        child.styleSave = undefined;
      }, this);
    };
  
    var RegisterFocusStyle = function RegisterFocusStyle(focusStyle) {
      if (IsEmpty(focusStyle)) {
        return;
      }
      this.setFocusStyle(focusStyle).on('open', function () {
        var child = this.background;
        var focusStyle = this.focusStyle;
        var styleSave = GetPartialData(child, focusStyle);
        if (IsKeyValueEqual(focusStyle, styleSave)) {
          return;
        }
        child.styleSave = styleSave;
        child.modifyStyle(focusStyle);
      }, this).on('close', function () {
        var child = this.background;
        if (!child.styleSave) {
          return;
        }
        child.modifyStyle(child.styleSave);
        child.styleSave = undefined;
      }, this);
    };
  
    var CreateInsertCursorChild = function CreateInsertCursorChild(textObject) {
      var child = textObject.createCharChild('|'); // Use '|' to update render size
      child.text = ''; // Render empty string ''
  
      return child;
    };
  
    function Diff() {}
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        this.options = options;
        var self = this;
        function done(value) {
          if (callback) {
            setTimeout(function () {
              callback(undefined, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
  
        // Allow subclasses to massage the input prior to running
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
          oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        if (options.maxEditLength) {
          maxEditLength = Math.min(maxEditLength, options.maxEditLength);
        }
        var bestPath = [{
          newPos: -1,
          components: []
        }];
  
        // Seed editLength = 0, i.e. the content starts with the same values
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          // Identity per the equality and tokenizer
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
  
        // Main worker method. checks all permutations of a given edit length for acceptance.
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;
            var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath - 1] = undefined;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              // If this path is a terminal then prune
              bestPath[diagonalPath] = undefined;
              continue;
            }
  
            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, undefined, true);
            } else {
              basePath = addPath; // No need to clone, we've pulled it from the list
              basePath.newPos++;
              self.pushComponent(basePath.components, true, undefined);
            }
            _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
  
            // If we have hit the end of both strings, then we are done
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            } else {
              // Otherwise track this path as a potential candidate and continue.
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
  
        // Performs the length of edit iteration. Is a bit fugly as this has to support the
        // sync and async mode which is never fun. Loops over execEditLength until a value
        // is produced, or until the edit length exceeds options.maxEditLength (if given),
        // in which case it will return undefined.
        if (callback) {
          (function exec() {
            setTimeout(function () {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length - 1] = {
            count: last.count + 1,
            added: added,
            removed: removed
          };
        } else {
          components.push({
            count: 1,
            added: added,
            removed: removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split('');
      },
      join: function join(chars) {
        return chars.join('');
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function (value, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value.length ? oldValue : value;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
  
          // Common case
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
  
          // Reverse add and remove so removes are output first to match common convention
          // The diffing algorithm is tied to add then remove output and this is the simplest
          // route to get the desired output with minimal overhead.
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
  
      // Special case handle for when one terminal is ignored (i.e. whitespace).
      // For this case we merge the terminal into the prior string and drop the change.
      // This is only available for string mode.
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
  
    var characterDiff = new Diff();
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
  
    // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
    //
    // Ranges and exceptions:
    // Latin-1 Supplement, 0080–00FF
    //  - U+00D7  × Multiplication sign
    //  - U+00F7  ÷ Division sign
    // Latin Extended-A, 0100–017F
    // Latin Extended-B, 0180–024F
    // IPA Extensions, 0250–02AF
    // Spacing Modifier Letters, 02B0–02FF
    //  - U+02C7  ˇ &#711;  Caron
    //  - U+02D8  ˘ &#728;  Breve
    //  - U+02D9  ˙ &#729;  Dot Above
    //  - U+02DA  ˚ &#730;  Ring Above
    //  - U+02DB  ˛ &#731;  Ogonek
    //  - U+02DC  ˜ &#732;  Small Tilde
    //  - U+02DD  ˝ &#733;  Double Acute Accent
    // Latin Extended Additional, 1E00–1EFF
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new Diff();
    wordDiff.equals = function (left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function (value) {
      // All whitespace symbols except newline group into one token, each newline - in separate token
      var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  
      // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
      for (var i = 0; i < tokens.length - 1; i++) {
        // If we have an empty string in the next field and we have only word chars before and after, merge
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
  
    var lineDiff = new Diff();
    lineDiff.tokenize = function (value) {
      var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/);
  
      // Ignore the final empty token that occurs if the string ends with a new line
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
  
      // Merge the content and line separators into single tokens
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
  
    var sentenceDiff = new Diff();
    sentenceDiff.tokenize = function (value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
  
    var cssDiff = new Diff();
    cssDiff.tokenize = function (value) {
      return value.split(/([{}:;,]|\s+)/);
    };
  
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new Diff();
    // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function (value) {
      var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
          return typeof v === 'undefined' ? undefinedReplacement : v;
        } : _this$options$stringi;
      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
    };
    jsonDiff.equals = function (left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
    };
  
    // This function handles the presence of circular references by bailing out when encountering an
    // object that is already on the "stack" of items being processed. Accepts an optional replacer
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (_typeof(obj) === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [],
          _key;
        for (_key in obj) {
          /* istanbul ignore else */
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  
    var arrayDiff = new Diff();
    arrayDiff.tokenize = function (value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function (value) {
      return value;
    };
  
    var RemoveItem$8 = Phaser.Utils.Array.Remove;
    var SetText$1 = function SetText(textObject, newText) {
      var text = textObject.text;
      if (newText === text) {
        return;
      }
      if (text == null) {
        text = '';
      }
  
      // textObject.setText(newText);
  
      // Remove lastInsertCursor directly 
      RemoveItem$8(textObject.children, textObject.lastInsertCursor);
      if (newText === '') {
        textObject.removeChildren();
      } else {
        var results = diffChars(text, newText);
        var charIndex = 0;
        for (var i = 0, cnt = results.length; i < cnt; i++) {
          var result = results[i];
          if (result.removed) {
            // Remove character at charIndex
            textObject.removeText(charIndex, result.count);
          } else if (result.added) {
            textObject.insertText(charIndex, result.value);
            charIndex += result.count;
          } else {
            charIndex += result.count;
          }
        }
      }
  
      // Push back lastInsertCursor directly
      textObject.children.push(textObject.lastInsertCursor);
      textObject.runWrap();
      textObject.emit('textchange', newText, textObject);
    };
  
    var SetTextOXYMethods = {
      setTextOYByPercentage: function setTextOYByPercentage(percentage) {
        this.setTextOY(-this.textVisibleHeight * percentage);
        return this;
      },
      getTextOYPercentage: function getTextOYPercentage() {
        var textVisibleHeight = this.textVisibleHeight;
        if (textVisibleHeight === 0) {
          return 0;
        }
        return this._textOY / -textVisibleHeight;
      },
      setTextOXByPercentage: function setTextOXByPercentage(percentage) {
        this.setTextOX(-this.textVisibleWidth * percentage);
        return this;
      },
      getTextOXPercentage: function getTextOXPercentage() {
        var textVisibleWidth = this.textVisibleWidth;
        if (textVisibleWidth === 0) {
          return 0;
        }
        return this._textOX / -textVisibleWidth;
      }
    };
  
    var IsPlainObject$K = Phaser.Utils.Objects.IsPlainObject;
    var CanvasInput = /*#__PURE__*/function (_DynamicText) {
      _inherits(CanvasInput, _DynamicText);
      function CanvasInput(scene, x, y, fixedWidth, fixedHeight, config) {
        var _this;
        _classCallCheck(this, CanvasInput);
        if (IsPlainObject$K(x)) {
          config = x;
        } else if (IsPlainObject$K(fixedWidth)) {
          config = fixedWidth;
        }
        if (config === undefined) {
          config = {};
        }
        InjectDefaultConfig(scene, config);
  
        // Set text later
        var text = config.text;
        if (text) {
          delete config.text;
        }
        var focusStyle = ExtractByPrefix(config.background, 'focus');
        var cursorStyle = ExtractByPrefix(config.style, 'cursor');
        _this = _callSuper(this, CanvasInput, [scene, x, y, fixedWidth, fixedHeight, config]);
        _this.type = 'rexCanvasInput';
  
        // readonly
        _this.contentWidth = undefined;
        _this.contentHeight = undefined;
        _this.lineHeight = undefined;
        _this.linesCount = undefined;
        _this._text;
        _this.textEdit = CreateHiddenTextEdit(_assertThisInitialized(_this), config);
        if (config.focusStyle) {
          Object.assign(focusStyle, config.focusStyle);
        }
        RegisterFocusStyle.call(_assertThisInitialized(_this), focusStyle);
        if (config.cursorStyle) {
          Object.assign(cursorStyle, config.cursorStyle);
        }
        RegisterCursorStyle.call(_assertThisInitialized(_this), cursorStyle);
        var addCharCallback = config.onAddChar;
        if (addCharCallback) {
          _this.on('addchar', addCharCallback);
        }
        var cursorOutCallback = config.onCursorOut;
        if (cursorOutCallback) {
          _this.on('cursorout', cursorOutCallback);
        }
        var cursorInCallback = config.onCursorIn;
        if (cursorInCallback) {
          _this.on('cursorin', cursorInCallback);
        }
        var moveCursorCallback = config.onMoveCursor;
        if (moveCursorCallback) {
          _this.on('movecursor', moveCursorCallback);
        }
        _this.setParseTextCallback(config.parseTextCallback);
        _this.lastInsertCursor = CreateInsertCursorChild(_assertThisInitialized(_this));
        if (!text) {
          text = '';
        }
        _this.setText(text);
        return _this;
      }
      _createClass(CanvasInput, [{
        key: "addChild",
        value: function addChild(child, index) {
          _get(_getPrototypeOf(CanvasInput.prototype), "addChild", this).call(this, child, index);
          if (Array.isArray(child)) {
            var children = child;
            for (var i = 0, cnt = children.length; i < cnt; i++) {
              var child = children[i];
              if (IsChar(child)) {
                this.emit('addchar', child, index + i, this);
              }
            }
          } else {
            if (IsChar(child)) {
              this.emit('addchar', child, index, this);
            }
          }
          return this;
        }
      }, {
        key: "text",
        get: function get() {
          return this._text;
        },
        set: function set(value) {
          if (value == null) {
            value = '';
          } else {
            value = value.toString();
          }
          if (this._text === value) {
            return;
          }
          SetText$1(this, value);
          this._text = value;
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this.text = text;
          return this;
        }
      }, {
        key: "appendText",
        value: function appendText(text) {
          this.setText(this.text + text);
          return this;
        }
      }, {
        key: "runWrap",
        value: function runWrap(config) {
          var result = _get(_getPrototypeOf(CanvasInput.prototype), "runWrap", this).call(this, config);
          // Save content size
          this.contentWidth = result.maxLineWidth;
          this.contentHeight = result.linesHeight;
          this.lineHeight = result.lineHeight;
          this.linesCount = result.lines.length;
          return result;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          if (this.width === width && this.height === height) {
            return this;
          }
          _get(_getPrototypeOf(CanvasInput.prototype), "setSize", this).call(this, width, height);
  
          // Run wrap again since fixedWidth and fixedHeight are changed
          this.runWrap();
          return this;
        }
      }, {
        key: "displayText",
        get: function get() {
          return this.text;
        },
        set: function set(value) {
          this.text = value;
        }
      }, {
        key: "setDisplayText",
        value: function setDisplayText(value) {
          this.displayText = value;
          return this;
        }
      }, {
        key: "inputText",
        get: function get() {
          return this.textEdit.text;
        },
        set: function set(value) {
          this.textEdit.text = value;
        }
      }, {
        key: "setInputText",
        value: function setInputText(value) {
          this.inputText = value;
          return this;
        }
      }, {
        key: "setParseTextCallback",
        value: function setParseTextCallback(callback) {
          if (!callback) {
            callback = DefaultParseTextCallback;
          }
          this.parseTextCallback = callback;
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          return this.parseTextCallback(this.text);
        },
        set: function set(value) {
          this.setText(value);
        }
      }, {
        key: "getValue",
        value: function getValue() {
          return this.value;
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "readOnly",
        get: function get() {
          return this.textEdit.readOnly;
        },
        set: function set(value) {
          this.textEdit.readOnly = value;
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(value) {
          this.textEdit.setReadOnly(value);
          return this;
        }
      }, {
        key: "open",
        value: function open(onCloseCallback) {
          if (onCloseCallback) {
            this.textEdit.once('close', onCloseCallback);
          }
          this.textEdit.open();
          return this;
        }
      }, {
        key: "close",
        value: function close() {
          this.textEdit.close();
          return this;
        }
      }, {
        key: "isOpened",
        get: function get() {
          return this.textEdit.isOpened;
        }
      }, {
        key: "setFocusStyle",
        value: function setFocusStyle(style) {
          this.focusStyle = style;
          return this;
        }
      }, {
        key: "setCursorStyle",
        value: function setCursorStyle(style) {
          this.cursorStyle = style;
          return this;
        }
      }, {
        key: "setNumberInput",
        value: function setNumberInput() {
          this.textEdit.setNumberInput().setSelectAllWhenFocusEnable();
          this.parseTextCallback = Number;
          return this;
        }
      }, {
        key: "maxLength",
        get: function get() {
          return this.textEdit.maxLength;
        },
        set: function set(value) {
          this.textEdit.maxLength = value;
        }
      }, {
        key: "setMaxLength",
        value: function setMaxLength(value) {
          this.maxLength = value;
          return this;
        }
      }, {
        key: "minLength",
        get: function get() {
          return this.textEdit.minLength;
        },
        set: function set(value) {
          this.textEdit.minLength = value;
        }
      }, {
        key: "setMinLength",
        value: function setMinLength(value) {
          this.minLength = value;
          return this;
        }
      }, {
        key: "topTextOY",
        get: function get() {
          return 0;
        }
      }, {
        key: "bottomTextOY",
        get: function get() {
          return -this.tableVisibleHeight;
        }
      }, {
        key: "leftTextOX",
        get: function get() {
          return 0;
        }
      }, {
        key: "rightTextOX",
        get: function get() {
          return -this.textVisibleWidth;
        }
      }, {
        key: "textVisibleHeight",
        get: function get() {
          var h = this.contentHeight - this.height;
          if (h < 0) {
            h = 0;
          }
          return h;
        }
      }, {
        key: "textVisibleWidth",
        get: function get() {
          var w = this.contentWidth - this.width;
          if (w < 0) {
            w = 0;
          }
          return w;
        }
      }, {
        key: "t",
        get: function get() {
          return this.getTextOYPercentage();
        },
        set: function set(value) {
          this.setTextOYByPercentage(value).updateTexture();
        }
      }, {
        key: "s",
        get: function get() {
          return this.getTextOXPercentage();
        },
        set: function set(value) {
          this.setTextOXByPercentage(value).updateTexture();
        }
      }]);
      return CanvasInput;
    }(DynamicText);
    var DefaultParseTextCallback = function DefaultParseTextCallback(text) {
      return text;
    };
    Object.assign(CanvasInput.prototype, SetTextOXYMethods);
  
    ObjectFactory.register('canvasInput', function (x, y, fixedWidth, fixedHeight, config) {
      var gameObject = new CanvasInput(this.scene, x, y, fixedWidth, fixedHeight, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CanvasInput', CanvasInput);
  
    var GetTickDelta = function GetTickDelta(game) {
      return GetGame(game).loop.delta;
    };
  
    var GetValue$2X = Phaser.Utils.Objects.GetValue;
    var Wrap$2 = Phaser.Math.Wrap;
    var HiddenTextEdit = /*#__PURE__*/function (_HiddenTextEditBase) {
      _inherits(HiddenTextEdit, _HiddenTextEditBase);
      function HiddenTextEdit(gameObject, config) {
        var _this;
        _classCallCheck(this, HiddenTextEdit);
        if (config === undefined) {
          config = {};
        }
        if (config.onUpdate === 'number') {
          config.onUpdate = NumberInputUpdateCallback;
        }
        _this = _callSuper(this, HiddenTextEdit, [gameObject, config]);
        // this.parent = gameObject;
  
        _this.setCursor(GetValue$2X(config, 'cursor', '|'));
        _this.setCursorFlashDuration(GetValue$2X(config, 'cursorFlashDuration', 1000));
        _this.cursorFlashTimer = 0;
        return _this;
      }
      _createClass(HiddenTextEdit, [{
        key: "initText",
        value: function initText() {
          this.cursorFlashTimer = 0;
          this.prevCursorPosition = undefined;
          this.setText(this.parent.text);
          this.setCursorPosition();
          return this;
        }
      }, {
        key: "updateText",
        value: function updateText() {
          var textObject = this.parent;
          var text = this.text;
          if (this.onUpdateCallback) {
            var newText = this.onUpdateCallback(text, textObject, this);
            if (newText != null) {
              text = newText;
            }
          }
          if (this.isOpened && this.hasCursor) {
            // Insert Cursor
            var cursorPosition = this.cursorPosition;
            text = text.substring(0, cursorPosition) + this.cursor + text.substring(cursorPosition);
            if (this.prevCursorPosition !== cursorPosition) {
              // console.log(cursorPosition);
              this.prevCursorPosition = cursorPosition;
            }
          }
          if (textObject.text !== text) {
            textObject.setText(text);
            this.emit('textchange', text, textObject, this);
          }
          return this;
        }
      }, {
        key: "setCursor",
        value: function setCursor(s) {
          this._cursor = s;
          this.hasCursor = s && s !== '';
          return s;
        }
      }, {
        key: "setCursorFlashDuration",
        value: function setCursorFlashDuration(duration) {
          this.cursorFlashDuration = duration;
          return this;
        }
      }, {
        key: "cursor",
        get: function get() {
          if (!this._isFocused) {
            return this._cursor;
          }
  
          // Flash Cursor
          var cursor;
          if (this.cursorFlashTimer < this.cursorFlashDuration / 2) {
            cursor = this._cursor;
          } else {
            cursor = ' ';
          }
          var timerValue = this.cursorFlashTimer + GetTickDelta(this.scene);
          this.cursorFlashTimer = Wrap$2(timerValue, 0, this.cursorFlashDuration);
          return cursor;
        }
      }]);
      return HiddenTextEdit;
    }(HiddenTextEditBase);
  
    ObjectFactory.register('hiddenEdit', function (textObject, config) {
      var gameObject = new HiddenTextEdit(textObject, config);
      // Note: Don't add this game object into scene
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.HiddenEdit', HiddenTextEdit);
  
    var GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;
    var WebGLRenderer = function WebGLRenderer(renderer, src, camera, parentMatrix) {
      src.updateData();
      camera.addToRenderList(src);
      var pipeline = renderer.pipelines.set(src.pipeline);
      var result = GetCalcMatrix(src, camera, parentMatrix);
      var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var alpha = camera.alpha * src.alpha;
      renderer.pipelines.preBatch(src);
      var shapes = src.geom,
        shape;
      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shape = shapes[i];
        if (shape.visible) {
          shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
        }
      }
      renderer.pipelines.postBatch(src);
    };
  
    var SetTransform = Phaser.Renderer.Canvas.SetTransform;
    var CanvasRenderer = function CanvasRenderer(renderer, src, camera, parentMatrix) {
      src.updateData();
      camera.addToRenderList(src);
      var ctx = renderer.currentContext;
      if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;
        var shapes = src.geom,
          shape;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
          shape = shapes[i];
          if (shape.visible) {
            shape.canvasRender(ctx, dx, dy);
          }
        }
  
        //  Restore the context saved in SetTransform
        ctx.restore();
      }
    };
  
    var Render = {
      renderWebGL: WebGLRenderer,
      renderCanvas: CanvasRenderer
    };
  
    var Shape = Phaser.GameObjects.Shape;
    var RemoveItem$7 = Phaser.Utils.Array.Remove;
    var BaseShapes = /*#__PURE__*/function (_Shape) {
      _inherits(BaseShapes, _Shape);
      function BaseShapes(scene, x, y, width, height) {
        var _this;
        _classCallCheck(this, BaseShapes);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 2;
        }
        if (height === undefined) {
          height = width;
        }
        _this = _callSuper(this, BaseShapes, [scene, 'rexShapes', []]);
        _this._width = -1;
        _this._height = -1;
        _this.dirty = true;
        _this.isSizeChanged = true;
        _this.shapes = {};
        _this.setPosition(x, y);
        _this.setSize(width, height);
        _this.updateDisplayOrigin();
        return _this;
      }
      _createClass(BaseShapes, [{
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this.setSize(value, this._height);
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this.setSize(this._width, value);
        }
      }, {
        key: "setDirty",
        value: function setDirty(value) {
          if (value === undefined) {
            value = true;
          }
          this.dirty = value;
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.isSizeChanged = this.isSizeChanged || this._width !== width || this._height !== height;
          this.dirty = this.dirty || this.isSizeChanged;
          this._width = width;
          this._height = height;
          this.updateDisplayOrigin();
          var input = this.input;
          if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
          }
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          this.setSize(width, height);
          return this;
        }
      }, {
        key: "fillColor",
        get: function get() {
          return this._fillColor;
        },
        set: function set(value) {
          this.setFillStyle(value, this._fillAlpha);
        }
      }, {
        key: "fillAlpha",
        get: function get() {
          return this._fillAlpha;
        },
        set: function set(value) {
          this.setFillStyle(this._fillColor, value);
        }
      }, {
        key: "setFillStyle",
        value: function setFillStyle(color, alpha) {
          if (alpha === undefined) {
            alpha = 1;
          }
          this.dirty = this.dirty || this.fillColor !== color || this.fillAlpha !== alpha;
          this._fillColor = color;
          this._fillAlpha = alpha;
          return this;
        }
      }, {
        key: "lineWidth",
        get: function get() {
          return this._lineWidth;
        },
        set: function set(value) {
          this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
        }
      }, {
        key: "strokeColor",
        get: function get() {
          return this._strokeColor;
        },
        set: function set(value) {
          this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
        }
      }, {
        key: "strokeAlpha",
        get: function get() {
          return this._strokeAlpha;
        },
        set: function set(value) {
          this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
        }
      }, {
        key: "setStrokeStyle",
        value: function setStrokeStyle(lineWidth, color, alpha) {
          if (alpha === undefined) {
            alpha = 1;
          }
          this.dirty = this.dirty || this.lineWidth !== lineWidth || this.strokeColor !== color || this.strokeAlpha !== alpha;
          this._lineWidth = lineWidth;
          this._strokeColor = color;
          this._strokeAlpha = alpha;
          return this;
        }
      }, {
        key: "updateShapes",
        value: function updateShapes() {}
      }, {
        key: "updateData",
        value: function updateData() {
          if (!this.dirty) {
            return this;
          }
          this.updateShapes();
          var shapes = this.geom;
          for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            var shape = shapes[i];
            if (shape.dirty) {
              shape.updateData();
            }
          }
          this.isSizeChanged = false;
          this.dirty = false;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.geom.length = 0;
          Clear$1(this.shapes);
          return this;
        }
      }, {
        key: "getShape",
        value: function getShape(name) {
          return this.shapes[name];
        }
      }, {
        key: "getShapes",
        value: function getShapes() {
          return this.geom;
        }
      }, {
        key: "addShape",
        value: function addShape(shape) {
          this.geom.push(shape);
          var name = shape.name;
          if (name) {
            this.shapes[name] = shape;
          }
          this.dirty = true;
          return this;
        }
      }, {
        key: "deleteShape",
        value: function deleteShape(name) {
          var shape = this.getShape(name);
          if (shape) {
            delete this.shapes[name];
            RemoveItem$7(this.geom, shape);
          }
          return this;
        }
      }]);
      return BaseShapes;
    }(Shape);
    Object.assign(BaseShapes.prototype, Render);
  
    var StyleMethods$2 = {
      setBoxFillStyle: function setBoxFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.boxFillColor !== color || this.boxFillAlpha !== alpha;
        this.boxFillColor = color;
        this.boxFillAlpha = alpha;
        return this;
      },
      setUncheckedBoxFillStyle: function setUncheckedBoxFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.uncheckedBoxFillColor !== color || this.uncheckedBoxFillAlpha !== alpha;
        this.uncheckedBoxFillColor = color;
        this.uncheckedBoxFillAlpha = alpha;
        return this;
      },
      setBoxStrokeStyle: function setBoxStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.boxLineWidth !== lineWidth || this.boxStrokeColor !== color || this.boxStrokeAlpha !== alpha;
        this.boxLineWidth = lineWidth;
        this.boxStrokeColor = color;
        this.boxStrokeAlpha = alpha;
        return this;
      },
      setUncheckedBoxStrokeStyle: function setUncheckedBoxStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.uncheckedBoxLineWidth !== lineWidth || this.uncheckedBoxStrokeColor !== color || this.uncheckedBoxStrokeAlpha !== alpha;
        this.uncheckedBoxLineWidth = lineWidth;
        this.uncheckedBoxStrokeColor = color;
        this.uncheckedBoxStrokeAlpha = alpha;
        return this;
      },
      setCheckerStyle: function setCheckerStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.checkerColor !== color || this.checkAlpha !== alpha;
        this.checkerColor = color;
        this.checkAlpha = alpha;
        return this;
      },
      setBoxShape: function setBoxShape(isCircleShape) {
        if (isCircleShape === undefined) {
          isCircleShape = false;
        }
        if (this.isCircleShape === isCircleShape) {
          return this;
        }
        this.isCircleShape = isCircleShape;
        this.isSizeChanged = true;
        this.dirty = true;
        return this;
      }
    };
  
    var SizeMethods$1 = {
      setBoxSize: function setBoxSize(size) {
        this.dirty = this.dirty || this.boxSize !== size;
        this.boxSize = size;
        return this;
      },
      setCheckerSize: function setCheckerSize(size) {
        this.dirty = this.dirty || this.checkerSize !== size;
        this.checkerSize = size;
        return this;
      }
    };
  
    var FillStyle = function FillStyle(color, alpha) {
      if (color == null) {
        this.isFilled = false;
      } else {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.isFilled = true;
        this.fillColor = color;
        this.fillAlpha = alpha;
      }
      return this;
    };
    var LineStyle = function LineStyle(lineWidth, color, alpha) {
      if (lineWidth == null || color == null) {
        this.isStroked = false;
      } else {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.isStroked = true;
        this.lineWidth = lineWidth;
        this.strokeColor = color;
        this.strokeAlpha = alpha;
      }
      return this;
    };
    var StyleMethods$1 = {
      fillStyle: FillStyle,
      lineStyle: LineStyle
    };
  
    var BaseGeom = /*#__PURE__*/function () {
      function BaseGeom() {
        _classCallCheck(this, BaseGeom);
        this.name = undefined;
        this.dirty = true;
        this.visible = true;
        this.data = undefined;
        this.isFilled = false;
        this.fillColor = undefined;
        this.fillAlpha = 1;
        this.isStroked = false;
        this.lineWidth = 1;
        this.strokeColor = undefined;
        this.strokeAlpha = 1;
      }
      _createClass(BaseGeom, [{
        key: "setName",
        value: function setName(name) {
          this.name = name;
          return this;
        }
      }, {
        key: "setVisible",
        value: function setVisible(visible) {
          if (visible === undefined) {
            visible = true;
          }
          this.visible = visible;
          return this;
        }
      }, {
        key: "reset",
        value: function reset() {
          this.setVisible().fillStyle().lineStyle();
          return this;
        }
      }, {
        key: "webglRender",
        value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {}
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy) {}
      }, {
        key: "updateData",
        value: function updateData() {
          this.dirty = false;
        }
      }]);
      return BaseGeom;
    }();
    Object.assign(BaseGeom.prototype, StyleMethods$1, DataMethods$2);
  
    var Earcut = Phaser.Geom.Polygon.Earcut;
    var PathBase = /*#__PURE__*/function (_BaseGeom) {
      _inherits(PathBase, _BaseGeom);
      function PathBase() {
        var _this;
        _classCallCheck(this, PathBase);
        _this = _callSuper(this, PathBase);
        _this.pathData = [];
        _this.pathIndexes = [];
        _this.closePath = false;
        return _this;
      }
      _createClass(PathBase, [{
        key: "updateData",
        value: function updateData() {
          this.pathIndexes = Earcut(this.pathData);
          _get(_getPrototypeOf(PathBase.prototype), "updateData", this).call(this);
          return this;
        }
      }, {
        key: "webglRender",
        value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
          if (this.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
          }
          if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
          }
        }
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy) {
          var path = this.pathData;
          var pathLength = path.length - 1;
          var px1 = path[0] - dx;
          var py1 = path[1] - dy;
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          if (!this.closePath) {
            pathLength -= 2;
          }
          for (var i = 2; i < pathLength; i += 2) {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;
            ctx.lineTo(px2, py2);
          }
          if (this.closePath) {
            ctx.closePath();
          }
          if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
          }
          if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
          }
        }
      }]);
      return PathBase;
    }(BaseGeom);
  
    var DegToRad$b = Phaser.Math.DegToRad;
    var Arc = /*#__PURE__*/function (_PathBase) {
      _inherits(Arc, _PathBase);
      function Arc(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
        var _this;
        _classCallCheck(this, Arc);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (radiusX === undefined) {
          radiusX = 0;
        }
        if (radiusY === undefined) {
          radiusY = 0;
        }
        if (startAngle === undefined) {
          startAngle = 0;
        }
        if (endAngle === undefined) {
          endAngle = 360;
        }
        if (anticlockwise === undefined) {
          anticlockwise = false;
        }
        if (pie === undefined) {
          pie = false;
        }
        _this = _callSuper(this, Arc);
        _this.setCenterPosition(x, y);
        _this.setRadius(radiusX, radiusY);
        _this.setAngle(startAngle, endAngle, anticlockwise);
        _this.setPie(pie);
        _this.setIterations(32);
        return _this;
      }
      _createClass(Arc, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x !== value;
          this._x = value;
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y !== value;
          this._y = value;
        }
      }, {
        key: "setCenterPosition",
        value: function setCenterPosition(x, y) {
          if (y === undefined) {
            y = x;
          }
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "radiusX",
        get: function get() {
          return this._radiusX;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._radiusX !== value;
          this._radiusX = value;
        }
      }, {
        key: "radiusY",
        get: function get() {
          return this._radiusY;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._radiusY !== value;
          this._radiusY = value;
        }
      }, {
        key: "setRadius",
        value: function setRadius(radiusX, radiusY) {
          if (radiusY === undefined) {
            radiusY = radiusX;
          }
          this.radiusX = radiusX;
          this.radiusY = radiusY;
          return this;
        }
      }, {
        key: "startAngle",
        get: function get() {
          return this._startAngle;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._startAngle !== value;
          this._startAngle = value;
        }
      }, {
        key: "endAngle",
        get: function get() {
          return this._endAngle;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._endAngle !== value;
          this._endAngle = value;
        }
      }, {
        key: "anticlockwise",
        get: function get() {
          return this._anticlockwise;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._anticlockwise !== value;
          this._anticlockwise = value;
        }
      }, {
        key: "setAngle",
        value: function setAngle(startAngle, endAngle, anticlockwise) {
          // startAngle, endAngle in degrees
          if (anticlockwise === undefined) {
            anticlockwise = false;
          }
          this.startAngle = startAngle;
          this.endAngle = endAngle;
          this.anticlockwise = anticlockwise;
          return this;
        }
      }, {
        key: "pie",
        get: function get() {
          return this._pie;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._pie !== value;
          this._pie = value;
        }
      }, {
        key: "setPie",
        value: function setPie(pie) {
          if (pie === undefined) {
            pie = true;
          }
          this.pie = pie;
          return this;
        }
      }, {
        key: "iterations",
        get: function get() {
          return this._iterations;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._iterations !== value;
          this._iterations = value;
        }
      }, {
        key: "setIterations",
        value: function setIterations(iterations) {
          this.iterations = iterations;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.pathData.length = 0;
          if (this.pie) {
            this.pathData.push(this.x, this.y);
          }
          ArcTo$1(this.x, this.y, this.radiusX, this.radiusY, this.startAngle, this.endAngle, this.anticlockwise, this.iterations, this.pathData);
          if (this.pie) {
            this.pathData.push(this.x, this.y);
          }
          // Close
          this.pathData.push(this.pathData[0], this.pathData[1]);
          _get(_getPrototypeOf(Arc.prototype), "updateData", this).call(this);
          return this;
        }
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy) {
          ctx.beginPath();
          var x = this.x - dx,
            y = this.y - dy,
            startAngle = DegToRad$b(this.startAngle),
            endAngle = DegToRad$b(this.endAngle);
          if (this.pie) {
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(startAngle) * this.radiusX, y + Math.sin(startAngle) * this.radiusY);
          }
          ctx.ellipse(x, y, this.radiusX, this.radiusY, 0, startAngle, endAngle, this.anticlockwise);
          if (this.pie) {
            ctx.lineTo(x, y);
          }
          if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
          }
          if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
          }
        }
      }]);
      return Arc;
    }(PathBase);
  
    var Circle = /*#__PURE__*/function (_Arc) {
      _inherits(Circle, _Arc);
      function Circle(x, y, radius) {
        _classCallCheck(this, Circle);
        return _callSuper(this, Circle, [x, y, radius, radius, 0, 360]);
      }
      return _createClass(Circle);
    }(Arc);
  
    var Curve = /*#__PURE__*/function (_PathBase) {
      _inherits(Curve, _PathBase);
      function Curve(curve) {
        var _this;
        _classCallCheck(this, Curve);
        _this = _callSuper(this, Curve);
        _this.setCurve(curve);
        _this.setIterations(32);
        return _this;
      }
      _createClass(Curve, [{
        key: "curve",
        get: function get() {
          return this._curve;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._curve !== value;
          this._curve = value;
        }
      }, {
        key: "setCurve",
        value: function setCurve(curve) {
          this.curve = curve;
          return this;
        }
      }, {
        key: "iterations",
        get: function get() {
          return this._iterations;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._iterations !== value;
          this._iterations = value;
        }
      }, {
        key: "setIterations",
        value: function setIterations(iterations) {
          this.iterations = iterations;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.pathData.length = 0;
          var points = this.curve.getPoints(this.iterations);
          for (var i = 0, cnt = points.length; i < cnt; i++) {
            this.pathData.push(points[i].x, points[i].y);
          }
          this.pathData.push(points[0].x, points[0].y);
          _get(_getPrototypeOf(Curve.prototype), "updateData", this).call(this);
          return this;
        }
      }]);
      return Curve;
    }(PathBase);
  
    var Ellipse = /*#__PURE__*/function (_Arc) {
      _inherits(Ellipse, _Arc);
      function Ellipse(x, y, radiusX, radiusY) {
        _classCallCheck(this, Ellipse);
        return _callSuper(this, Ellipse, [x, y, radiusX, radiusY, 0, 360]);
      }
      return _createClass(Ellipse);
    }(Arc);
  
    var Line = /*#__PURE__*/function (_PathBase) {
      _inherits(Line, _PathBase);
      function Line(x0, y0, x1, y1) {
        var _this;
        _classCallCheck(this, Line);
        if (x0 === undefined) {
          x0 = 0;
        }
        if (y0 === undefined) {
          y0 = 0;
        }
        if (x1 === undefined) {
          x1 = 0;
        }
        if (y1 === undefined) {
          y1 = 0;
        }
        _this = _callSuper(this, Line);
        _this.setP0(x0, y0);
        _this.setP1(x1, y1);
        return _this;
      }
      _createClass(Line, [{
        key: "x0",
        get: function get() {
          return this._x0;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x0 !== value;
          this._x0 = value;
        }
      }, {
        key: "y0",
        get: function get() {
          return this._y0;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y0 !== value;
          this._y0 = value;
        }
      }, {
        key: "setP0",
        value: function setP0(x, y) {
          this.x0 = x;
          this.y0 = y;
          return this;
        }
      }, {
        key: "x1",
        get: function get() {
          return this._x1;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x1 !== value;
          this._x1 = value;
        }
      }, {
        key: "y1",
        get: function get() {
          return this._y1;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y1 !== value;
          this._y1 = value;
        }
      }, {
        key: "setP1",
        value: function setP1(x, y) {
          this.x1 = x;
          this.y1 = y;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.pathData.length = 0;
          this.pathData.push(this.x0, this.y0);
          this.pathData.push(this.x1, this.y1);
          this.pathData.push(this.x0, this.y0);
          _get(_getPrototypeOf(Line.prototype), "updateData", this).call(this);
          return this;
        }
      }]);
      return Line;
    }(PathBase);
  
    var StartAt = function StartAt(x, y, pathData) {
      pathData.length = 0;
      if (x != null) {
        pathData.push(x, y);
      }
      return pathData;
    };
  
    //import QuadraticBezierInterpolation from '../../utils/math/interpolation/QuadraticBezierInterpolation.js';
  
    var QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;
    var QuadraticBezierTo = function QuadraticBezierTo(cx, cy, x, y, iterations, pathData) {
      var pathDataCnt = pathData.length;
      var p0x = pathData[pathDataCnt - 2];
      var p0y = pathData[pathDataCnt - 1];
      for (var i = 1, last = iterations - 1; i <= last; i++) {
        var t = i / last;
        pathData.push(QuadraticBezierInterpolation(t, p0x, cx, x), QuadraticBezierInterpolation(t, p0y, cy, y));
      }
      return pathData;
    };
  
    // import CubicBezierInterpolation from '../../utils/math/interpolation/CubicBezierInterpolation.js';
  
    var CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;
    var CubicBezierCurveTo = function CubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
      var pathDataCnt = pathData.length;
      var p0x = pathData[pathDataCnt - 2];
      var p0y = pathData[pathDataCnt - 1];
      for (var i = 1, last = iterations - 1; i <= last; i++) {
        var t = i / last;
        pathData.push(CubicBezierInterpolation(t, p0x, cx0, cx1, x), CubicBezierInterpolation(t, p0y, cy0, cy1, y));
      }
      return pathData;
    };
  
    var DuplicateLast = function DuplicateLast(pathData) {
      var len = pathData.length;
      if (len < 2) {
        return pathData;
      }
      var lastX = pathData[len - 2];
      var lastY = pathData[len - 1];
      pathData.push(lastX);
      pathData.push(lastY);
      return pathData;
    };
  
    var AddPathMethods = {
      clear: function clear() {
        this.start();
        return this;
      },
      start: function start() {
        this.startAt();
        return this;
      },
      startAt: function startAt(x, y) {
        this.restorePathData();
        this.accumulationLengths = undefined;
        StartAt(x, y, this.pathData);
        this.firstPointX = x;
        this.firstPointY = y;
        this.lastPointX = x;
        this.lastPointY = y;
        return this;
      },
      lineTo: function lineTo(x, y, relative) {
        if (relative === undefined) {
          relative = false;
        }
        if (relative) {
          x += this.lastPointX;
          y += this.lastPointY;
        }
        LineTo(x, y, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        return this;
      },
      verticalLineTo: function verticalLineTo(x, relative) {
        this.lineTo(x, this.lastPointY, relative);
        return this;
      },
      horizontalLineTo: function horizontalLineTo(y, relative) {
        this.lineTo(this.lastPointX, y, relative);
        return this;
      },
      ellipticalArc: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = false;
        }
        ArcTo$1(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise, this.iterations, this.pathData);
        this.lastPointX = this.pathData[this.pathData.length - 2];
        this.lastPointY = this.pathData[this.pathData.length - 1];
        return this;
      },
      arc: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
        return this;
      },
      quadraticBezierTo: function quadraticBezierTo(cx, cy, x, y) {
        QuadraticBezierTo(cx, cy, x, y, this.iterations, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx;
        this.lastCY = cy;
        return this;
      },
      smoothQuadraticBezierTo: function smoothQuadraticBezierTo(x, y) {
        var cx = this.lastPointX * 2 - this.lastCX;
        var cy = this.lastPointY * 2 - this.lastCY;
        this.quadraticBezierTo(cx, cy, x, y);
        return this;
      },
      cubicBezierCurveTo: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        CubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y, this.iterations, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx1;
        this.lastCY = cy1;
        return this;
      },
      smoothCubicBezierCurveTo: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        var cx0 = this.lastPointX * 2 - this.lastCX;
        var cy0 = this.lastPointY * 2 - this.lastCY;
        this.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
        return this;
      },
      close: function close() {
        // Line to first point        
        var startX = this.pathData[0],
          startY = this.pathData[1];
        if (startX !== this.lastPointX || startY !== this.lastPointY) {
          this.lineTo(startX, startY);
        }
        this.closePath = true;
        return this;
      },
      end: function end() {
        DuplicateLast(this.pathData);
        return this;
      }
    };
  
    //import PointRotateAround from '../../utils/math/RotateAround.js';
  
    var PointRotateAround$1 = Phaser.Math.RotateAround;
    var RotateAround$5 = function RotateAround(centerX, centerY, angle, pathData) {
      var point = {
        x: 0,
        y: 0
      };
      for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        point.x = pathData[i];
        point.y = pathData[i + 1];
        PointRotateAround$1(point, centerX, centerY, angle);
        pathData[i] = point.x;
        pathData[i + 1] = point.y;
      }
      return pathData;
    };
  
    var Scale$2 = function Scale(centerX, centerY, scaleX, scaleY, pathData) {
      for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        var x = pathData[i] - centerX;
        var y = pathData[i + 1] - centerY;
        x *= scaleX;
        y *= scaleY;
        pathData[i] = x + centerX;
        pathData[i + 1] = y + centerY;
      }
      return pathData;
    };
  
    var Offset = function Offset(x, y, pathData) {
      for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        pathData[i] += x;
        pathData[i + 1] += y;
      }
      return pathData;
    };
  
    var DegToRad$a = Phaser.Math.DegToRad;
    var PointRotateAround = Phaser.Math.RotateAround;
    var TransformPointsMethods = {
      rotateAround: function rotateAround(centerX, centerY, angle) {
        if (this.pathData.length === 0) {
          return this;
        }
        angle = DegToRad$a(angle);
        RotateAround$5(centerX, centerY, angle, this.pathData);
        var pathDataCnt = this.pathData.length;
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];
        if (this.lastCX !== undefined) {
          var point = {
            x: this.lastCX,
            y: this.lastCY
          };
          PointRotateAround(point, centerX, centerY, angle);
          this.lastCX = point.x;
          this.lastCY = point.y;
        }
        return this;
      },
      scale: function scale(centerX, centerY, scaleX, scaleY) {
        if (this.pathData.length === 0) {
          return this;
        }
        Scale$2(centerX, centerY, scaleX, scaleY, this.pathData);
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];
        if (this.lastCX !== undefined) {
          var x = this.lastCX - centerX;
          var y = this.lastCY - centerY;
          x *= scaleX;
          y *= scaleY;
          this.lastCX = x + centerX;
          this.lastCY = y + centerY;
        }
        return this;
      },
      offset: function offset(x, y) {
        Offset(x, y, this.pathData);
        return this;
      }
    };
  
    var Copy = function Copy(dest, src, startIdx, endIdx) {
      if (startIdx === undefined) {
        startIdx = 0;
      }
      if (endIdx === undefined) {
        endIdx = src.length;
      }
      dest.length = endIdx - startIdx;
      for (var i = 0, len = dest.length; i < len; i++) {
        dest[i] = src[i + startIdx];
      }
      return dest;
    };
  
    var SavePathDataMethods = {
      savePathData: function savePathData() {
        if (this.pathDataSaved) {
          return this;
        }
        this.pathDataSave = _toConsumableArray(this.pathData);
        this.pathData.length = 0;
        this.pathDataSaved = true;
        return this;
      },
      restorePathData: function restorePathData() {
        if (!this.pathDataSaved) {
          return this;
        }
        Copy(this.pathData, this.pathDataSave);
        this.pathDataSave = undefined;
        this.pathDataSaved = false;
        return this;
      }
    };
  
    var DistanceBetween$7 = Phaser.Math.Distance.Between;
    var Wrap$1 = Phaser.Math.Wrap;
    var Linear$c = Phaser.Math.Linear;
    var AppendFromPathSegment = function AppendFromPathSegment(srcPathData, accumulationLengths, startT, endT, destPathData) {
      if (endT === undefined) {
        endT = startT;
        startT = 0;
      }
      startT = WrapT(startT);
      endT = WrapT(endT);
      if (startT === endT) {
        return;
      }
      var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
      var startL = totalPathLength * startT;
      var endL = totalPathLength * endT;
      if (startT < endT) {
        AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
      } else {
        AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
        AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
      }
      DuplicateLast(destPathData);
    };
    var AddPathSegment = function AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData) {
      var skipState = startL > 0;
      for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
        var pIdx = i * 2;
        var d = accumulationLengths[i];
        if (skipState) {
          if (d < startL) {
            continue;
          } else if (d == startL) {
            skipState = false;
          } else {
            // d > startL
            var deltaD = d - accumulationLengths[i - 1];
            var t = 1 - (d - startL) / deltaD;
            destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
            destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
            skipState = false;
          }
        }
        if (d <= endL) {
          destPathData.push(srcPathData[pIdx]);
          destPathData.push(srcPathData[pIdx + 1]);
          if (d === endL) {
            break;
          }
        } else {
          // d > endL
          var deltaD = d - accumulationLengths[i - 1];
          var t = 1 - (d - endL) / deltaD;
          destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
          destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
          break;
        }
      }
    };
    var GetInterpolation = function GetInterpolation(pathData, i0, i1, t) {
      var p0 = pathData[i0],
        p1 = pathData[i1];
      return Linear$c(p0, p1, t);
    };
    var WrapT = function WrapT(t) {
      if (t === 0) {
        return 0;
      } else if (t % 1 === 0) {
        return 1;
      }
      return Wrap$1(t, 0, 1);
    };
    var PathSegmentMethods = {
      updateAccumulationLengths: function updateAccumulationLengths() {
        if (this.accumulationLengths == null) {
          this.accumulationLengths = [];
        } else if (this.accumulationLengths.length === this.pathData.length / 2) {
          return this;
        }
        var accumulationLengths = this.accumulationLengths;
        var pathData = this.pathData;
        var prevX, prevY, x, y;
        var d,
          accumulationLength = 0;
        for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
          x = pathData[i];
          y = pathData[i + 1];
          d = prevX === undefined ? 0 : DistanceBetween$7(prevX, prevY, x, y);
          accumulationLength += d;
          accumulationLengths.push(accumulationLength);
          prevX = x;
          prevY = y;
        }
        this.totalPathLength = accumulationLength;
        return this;
      },
      setDisplayPathSegment: function setDisplayPathSegment(startT, endT) {
        if (!this.pathDataSaved) {
          this.updateAccumulationLengths();
          this.savePathData();
        }
        this.pathData.length = 0;
        AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);
        return this;
      },
      appendFromPathSegment: function appendFromPathSegment(src, startT, endT) {
        if (startT === undefined) {
          var _this$pathData;
          (_this$pathData = this.pathData).push.apply(_this$pathData, _toConsumableArray(src.pathData));
        } else {
          src.updateAccumulationLengths();
          AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
        }
        this.firstPointX = this.pathData[0];
        this.firstPointY = this.pathData[1];
        this.lastPointX = this.pathData[this.pathData.length - 2];
        this.lastPointY = this.pathData[this.pathData.length - 1];
        return this;
      }
    };
  
    var GraphicsMethods = {
      draw: function draw(graphics, isFill, isStroke) {
        var points = this.toPoints();
        if (isFill) {
          graphics.fillPoints(points, this.closePath, this.closePath);
        }
        if (isStroke) {
          graphics.strokePoints(points, this.closePath, this.closePath);
        }
        return this;
      }
    };
  
    var ToPoints = function ToPoints(pathData, points) {
      if (points === undefined) {
        points = [];
      }
      for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        points.push({
          x: pathData[i],
          y: pathData[i + 1]
        });
      }
      return points;
    };
  
    //import Polygon from '../../utils/geom/polygon/Polygon.js';
  
    var Polygon = Phaser.Geom.Polygon;
    var ToPolygon = function ToPolygon(pathData, polygon) {
      if (polygon === undefined) {
        polygon = new Polygon();
      }
      polygon.setTo(pathData);
      return polygon;
    };
  
    var PathDataBuilder = /*#__PURE__*/function () {
      function PathDataBuilder(pathData) {
        _classCallCheck(this, PathDataBuilder);
        if (pathData === undefined) {
          pathData = [];
        }
        this.pathData = pathData;
        this.closePath = false;
        this.setIterations(32);
        this.firstPointX = undefined;
        this.firstPointY = undefined;
        this.lastPointX = undefined;
        this.lastPointY = undefined;
        this.accumulationLengths = undefined;
      }
      _createClass(PathDataBuilder, [{
        key: "setIterations",
        value: function setIterations(iterations) {
          this.iterations = iterations;
          return this;
        }
      }, {
        key: "toPoints",
        value: function toPoints() {
          return ToPoints(this.pathData);
        }
      }, {
        key: "toPolygon",
        value: function toPolygon(polygon) {
          return ToPolygon(this.pathData, polygon);
        }
      }]);
      return PathDataBuilder;
    }();
    Object.assign(PathDataBuilder.prototype, AddPathMethods, TransformPointsMethods, SavePathDataMethods, PathSegmentMethods, GraphicsMethods);
  
    var Lines = /*#__PURE__*/function (_PathBase) {
      _inherits(Lines, _PathBase);
      function Lines() {
        var _this;
        _classCallCheck(this, Lines);
        _this = _callSuper(this, Lines);
        _this.builder = new PathDataBuilder(_this.pathData);
        return _this;
      }
      _createClass(Lines, [{
        key: "iterations",
        get: function get() {
          return this.builder.iterations;
        },
        set: function set(value) {
          this.dirty = this.dirty || this.builder.iterations !== value;
          this.builder.setIterations(value);
        }
      }, {
        key: "setIterations",
        value: function setIterations(iterations) {
          this.iterations = iterations;
          return this;
        }
      }, {
        key: "lastPointX",
        get: function get() {
          return this.builder.lastPointX;
        }
      }, {
        key: "lastPointY",
        get: function get() {
          return this.builder.lastPointY;
        }
      }, {
        key: "start",
        value: function start() {
          this.builder.start();
          this.dirty = true;
          return this;
        }
      }, {
        key: "startAt",
        value: function startAt(x, y) {
          this.builder.startAt(x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "lineTo",
        value: function lineTo(x, y, relative) {
          this.builder.lineTo(x, y, relative);
          this.dirty = true;
          return this;
        }
      }, {
        key: "verticalLineTo",
        value: function verticalLineTo(x, relative) {
          this.builder.verticalLineTo(x, relative);
          this.dirty = true;
          return this;
        }
      }, {
        key: "horizontalLineTo",
        value: function horizontalLineTo(y, relative) {
          this.builder.horizontalLineTo(y, relative);
          this.dirty = true;
          return this;
        }
      }, {
        key: "ellipticalArc",
        value: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
          this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);
          this.dirty = true;
          return this;
        }
      }, {
        key: "arc",
        value: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
          this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);
          this.dirty = true;
          return this;
        }
      }, {
        key: "quadraticBezierTo",
        value: function quadraticBezierTo(cx, cy, x, y) {
          this.builder.quadraticBezierTo(cx, cy, x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "smoothQuadraticBezierTo",
        value: function smoothQuadraticBezierTo(x, y) {
          this.builder.smoothQuadraticBezierTo(x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "cubicBezierCurveTo",
        value: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
          this.builder.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "smoothCubicBezierCurveTo",
        value: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
          this.builder.smoothCubicBezierCurveTo(cx1, cy1, x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "close",
        value: function close() {
          this.builder.close();
          this.closePath = this.builder.closePath;
          this.dirty = true;
          return this;
        }
      }, {
        key: "end",
        value: function end() {
          this.builder.end();
          this.dirty = true;
          return this;
        }
      }, {
        key: "rotateAround",
        value: function rotateAround(centerX, centerY, angle) {
          this.builder.rotateAround(centerX, centerY, angle);
          this.dirty = true;
          return this;
        }
      }, {
        key: "scale",
        value: function scale(centerX, centerY, scaleX, scaleY) {
          this.builder.scale(centerX, centerY, scaleX, scaleY);
          this.dirty = true;
          return this;
        }
      }, {
        key: "offset",
        value: function offset(x, y) {
          this.builder.offset(x, y);
          this.dirty = true;
          return this;
        }
      }, {
        key: "toPolygon",
        value: function toPolygon(polygon) {
          return this.builder.toPolygon(polygon);
        }
      }, {
        key: "appendPathFrom",
        value: function appendPathFrom(src, startT, endT) {
          this.builder.appendFromPathSegment(src.builder, startT, endT);
          return this;
        }
      }, {
        key: "copyPathFrom",
        value: function copyPathFrom(src, startT, endT) {
          this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
          return this;
        }
      }, {
        key: "setDisplayPathSegment",
        value: function setDisplayPathSegment(startT, endT) {
          this.builder.setDisplayPathSegment(startT, endT);
          return this;
        }
      }]);
      return Lines;
    }(PathBase);
  
    var GetTint$1 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
    var Rectangle$2 = /*#__PURE__*/function (_BaseGeom) {
      _inherits(Rectangle, _BaseGeom);
      function Rectangle(x, y, width, height) {
        var _this;
        _classCallCheck(this, Rectangle);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 0;
        }
        if (height === undefined) {
          height = width;
        }
        _this = _callSuper(this, Rectangle);
        _this.pathData = [];
        _this.closePath = true;
        _this.setTopLeftPosition(x, y);
        _this.setSize(width, height);
        return _this;
      }
      _createClass(Rectangle, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x !== value;
          this._x = value;
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y !== value;
          this._y = value;
        }
      }, {
        key: "setTopLeftPosition",
        value: function setTopLeftPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._width !== value;
          this._width = value;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._height !== value;
          this._height = value;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.width = width;
          this.height = height;
          return this;
        }
      }, {
        key: "centerX",
        get: function get() {
          return this.x + this.width / 2;
        },
        set: function set(value) {
          this.x = value - this.width / 2;
        }
      }, {
        key: "centerY",
        get: function get() {
          return this.y + this.height / 2;
        },
        set: function set(value) {
          this.y = value - this.height / 2;
        }
      }, {
        key: "setCenterPosition",
        value: function setCenterPosition(x, y) {
          this.centerX = x;
          this.centerY = y;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.pathData.length = 0;
          var x0 = this.x,
            x1 = x0 + this.width,
            y0 = this.y,
            y1 = y0 + this.height;
          this.pathData.push(x0, y0);
          this.pathData.push(x1, y0);
          this.pathData.push(x1, y1);
          this.pathData.push(x0, y1);
          this.pathData.push(x0, y0);
          _get(_getPrototypeOf(Rectangle.prototype), "updateData", this).call(this);
          return this;
        }
      }, {
        key: "webglRender",
        value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
          if (this.isFilled) {
            var fillTint = pipeline.fillTint;
            var fillTintColor = GetTint$1(this.fillColor, this.fillAlpha * alpha);
            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;
            pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
          }
          if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
          }
        }
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy) {
          if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fillRect(-dx, -dy, this.width, this.height);
          }
          if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.beginPath();
            ctx.rect(-dx, -dy, this.width, this.height);
            ctx.stroke();
          }
        }
      }]);
      return Rectangle;
    }(BaseGeom);
  
    var GetValue$2W = Phaser.Utils.Objects.GetValue;
    var RoundRectangle = /*#__PURE__*/function (_PathBase) {
      _inherits(RoundRectangle, _PathBase);
      function RoundRectangle(x, y, width, height, radius, iterations) {
        var _this;
        _classCallCheck(this, RoundRectangle);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 0;
        }
        if (height === undefined) {
          height = width;
        }
        if (radius === undefined) {
          radius = 0;
        }
        if (iterations === undefined) {
          iterations = 6;
        }
        _this = _callSuper(this, RoundRectangle);
        _this.setTopLeftPosition(x, y);
        _this.setSize(width, height);
        _this.setRadius(radius);
        _this.setIterations(iterations);
        _this.closePath = true;
        return _this;
      }
      _createClass(RoundRectangle, [{
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x !== value;
          this._x = value;
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y !== value;
          this._y = value;
        }
      }, {
        key: "setTopLeftPosition",
        value: function setTopLeftPosition(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._width !== value;
          this._width = value;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._height !== value;
          this._height = value;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          this.width = width;
          this.height = height;
          return this;
        }
      }, {
        key: "centerX",
        get: function get() {
          return this.x + this.width / 2;
        },
        set: function set(value) {
          this.x = value - this.width / 2;
        }
      }, {
        key: "centerY",
        get: function get() {
          return this.y + this.height / 2;
        },
        set: function set(value) {
          this.y = value - this.height / 2;
        }
      }, {
        key: "setCenterPosition",
        value: function setCenterPosition(x, y) {
          this.centerX = x;
          this.centerY = y;
          return this;
        }
      }, {
        key: "radiusTL",
        get: function get() {
          return this._radiusTL;
        },
        set: function set(value) {
          var isConvex = value > 0;
          this.dirty = this.dirty || this._radiusTL !== value || this._convexTL !== isConvex;
          this._convexTL = isConvex;
          this._radiusTL = Math.abs(value);
        }
      }, {
        key: "radiusTR",
        get: function get() {
          return this._radiusTR;
        },
        set: function set(value) {
          var isConvex = value > 0;
          this.dirty = this.dirty || this._radiusTR !== value || this._convexTR !== isConvex;
          this._convexTR = isConvex;
          this._radiusTR = Math.abs(value);
        }
      }, {
        key: "radiusBL",
        get: function get() {
          return this._radiusBL;
        },
        set: function set(value) {
          var isConvex = value > 0;
          this.dirty = this.dirty || this._radiusBL !== value || this._convexBL !== isConvex;
          this._convexBL = isConvex;
          this._radiusBL = Math.abs(value);
        }
      }, {
        key: "radiusBR",
        get: function get() {
          return this._radiusBR;
        },
        set: function set(value) {
          var isConvex = value > 0;
          this.dirty = this.dirty || this._radiusBR !== value || this._convexBR !== isConvex;
          this._convexBR = isConvex;
          this._radiusBR = Math.abs(value);
        }
      }, {
        key: "radius",
        get: function get() {
          return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR);
        },
        set: function set(value) {
          if (typeof value === 'number') {
            this.radiusTL = value;
            this.radiusTR = value;
            this.radiusBL = value;
            this.radiusBR = value;
          } else {
            this.radiusTL = GetValue$2W(value, 'tl', 0);
            this.radiusTR = GetValue$2W(value, 'tr', 0);
            this.radiusBL = GetValue$2W(value, 'bl', 0);
            this.radiusBR = GetValue$2W(value, 'br', 0);
          }
        }
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          if (radius === undefined) {
            radius = 0;
          }
          this.radius = radius;
          return this;
        }
      }, {
        key: "iterations",
        get: function get() {
          return this._iterations;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._iterations !== value;
          this._iterations = value;
        }
      }, {
        key: "setIterations",
        value: function setIterations(iterations) {
          this.iterations = iterations;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          var pathData = this.pathData;
          pathData.length = 0;
          var width = this.width,
            height = this.height,
            radius,
            iterations = this.iterations + 1;
  
          // top-left
          radius = this.radiusTL;
          if (radius > 0) {
            if (this._convexTL) {
              var centerX = radius;
              var centerY = radius;
              ArcTo$1(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
            } else {
              var centerX = 0;
              var centerY = 0;
              ArcTo$1(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
            }
          } else {
            LineTo(0, 0, pathData);
          }
  
          // top-right
          radius = this.radiusTR;
          if (radius > 0) {
            if (this._convexTR) {
              var centerX = width - radius;
              var centerY = radius;
              ArcTo$1(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
            } else {
              var centerX = width;
              var centerY = 0;
              ArcTo$1(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
            }
          } else {
            LineTo(width, 0, pathData);
          }
  
          // bottom-right
          radius = this.radiusBR;
          if (radius > 0) {
            if (this._convexBR) {
              var centerX = width - radius;
              var centerY = height - radius;
              ArcTo$1(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
            } else {
              var centerX = width;
              var centerY = height;
              ArcTo$1(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
            }
          } else {
            LineTo(width, height, pathData);
          }
  
          // bottom-left
          radius = this.radiusBL;
          if (radius > 0) {
            if (this._convexBL) {
              var centerX = radius;
              var centerY = height - radius;
              ArcTo$1(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
            } else {
              var centerX = 0;
              var centerY = height;
              ArcTo$1(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
            }
          } else {
            LineTo(0, height, pathData);
          }
          pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
          Offset(this.x, this.y, pathData);
          _get(_getPrototypeOf(RoundRectangle.prototype), "updateData", this).call(this);
          return this;
        }
      }]);
      return RoundRectangle;
    }(PathBase);
  
    var GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
    var Triangle$1 = /*#__PURE__*/function (_BaseGeom) {
      _inherits(Triangle, _BaseGeom);
      function Triangle(x0, y0, x1, y1, x2, y2) {
        var _this;
        _classCallCheck(this, Triangle);
        if (x0 === undefined) {
          x0 = 0;
        }
        if (y0 === undefined) {
          y0 = 0;
        }
        if (x1 === undefined) {
          x1 = 0;
        }
        if (y1 === undefined) {
          y1 = 0;
        }
        if (x2 === undefined) {
          x2 = 0;
        }
        if (y2 === undefined) {
          y2 = 0;
        }
        _this = _callSuper(this, Triangle);
        _this.pathData = [];
        _this.closePath = true;
        _this.setP0(x0, y0);
        _this.setP1(x1, y1);
        _this.setP2(x2, y2);
        return _this;
      }
      _createClass(Triangle, [{
        key: "x0",
        get: function get() {
          return this._x0;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x0 !== value;
          this._x0 = value;
        }
      }, {
        key: "y0",
        get: function get() {
          return this._y0;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y0 !== value;
          this._y0 = value;
        }
      }, {
        key: "setP0",
        value: function setP0(x, y) {
          this.x0 = x;
          this.y0 = y;
          return this;
        }
      }, {
        key: "x1",
        get: function get() {
          return this._x1;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x1 !== value;
          this._x1 = value;
        }
      }, {
        key: "y1",
        get: function get() {
          return this._y1;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y1 !== value;
          this._y1 = value;
        }
      }, {
        key: "setP1",
        value: function setP1(x, y) {
          this.x1 = x;
          this.y1 = y;
          return this;
        }
      }, {
        key: "x2",
        get: function get() {
          return this._x2;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._x2 !== value;
          this._x2 = value;
        }
      }, {
        key: "y2",
        get: function get() {
          return this._y2;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._y2 !== value;
          this._y2 = value;
        }
      }, {
        key: "setP2",
        value: function setP2(x, y) {
          this.dirty = this.dirty || this.x2 !== x || this.y2 !== y;
          this.x2 = x;
          this.y2 = y;
          return this;
        }
      }, {
        key: "updateData",
        value: function updateData() {
          this.pathData.length = 0;
          this.pathData.push(this.x0, this.y0);
          this.pathData.push(this.x1, this.y1);
          this.pathData.push(this.x2, this.y2);
          this.pathData.push(this.x0, this.y0);
          _get(_getPrototypeOf(Triangle.prototype), "updateData", this).call(this);
          return this;
        }
      }, {
        key: "webglRender",
        value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
          if (this.isFilled) {
            var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);
            var x0 = this.x0 - dx;
            var y0 = this.y0 - dy;
            var x1 = this.x1 - dx;
            var y1 = this.y1 - dy;
            var x2 = this.x2 - dx;
            var y2 = this.y2 - dy;
            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);
            pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
          }
          if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
          }
        }
      }, {
        key: "canvasRender",
        value: function canvasRender(ctx, dx, dy) {
          var x1 = this.x1 - dx;
          var y1 = this.y1 - dy;
          var x2 = this.x2 - dx;
          var y2 = this.y2 - dy;
          var x3 = this.x3 - dx;
          var y3 = this.y3 - dy;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x3, y3);
          ctx.closePath();
          if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
          }
          if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
          }
        }
      }]);
      return Triangle;
    }(BaseGeom);
  
    var ShapesUpdateMethods$4 = {
      buildShapes: function buildShapes() {
        this.addShape(new RoundRectangle().setName('box')).addShape(new Lines().setName('checker'));
      },
      updateShapes: function updateShapes() {
        var centerX = this.width / 2,
          centerY = this.height / 2,
          radius = Math.min(centerX, centerY);
        var width = radius * 2;
        var x = centerX - radius,
          y = centerY - radius;
        var boxLineWidth = this.boxLineWidth;
        var checkLineWidth = Math.max(width / 10, 2);
        var boxShape = this.getShape('box');
        var checkerShape = this.getShape('checker');
  
        // Setup shapes
        if (this.isSizeChanged) {
          // Box
          var posOffset = width * (1 - this.boxSize) / 2;
          var halfBoxLineWidth = boxLineWidth / 2;
          var boxInnerWidth = width * this.boxSize - boxLineWidth;
          boxShape.setTopLeftPosition(x + halfBoxLineWidth + posOffset, y + halfBoxLineWidth + posOffset).setSize(boxInnerWidth, boxInnerWidth);
          if (this.isCircleShape) {
            boxShape.setRadius(boxInnerWidth / 2);
          } else {
            boxShape.setRadius(0);
          }
  
          // Checker
          var posOffset = width * (1 - this.checkerSize) / 2;
          var unit = width * this.checkerSize / 4;
          var u1 = unit * 1,
            u2 = unit * 2,
            u3 = unit * 3;
          checkerShape.startAt(u1, u2).lineTo(u2, u3).lineTo(u3, u1).offset(x + posOffset, y + posOffset).end();
        }
  
        // Set styles
        if (this.checked) {
          boxShape.fillStyle(this.boxFillColor, this.boxFillAlpha).lineStyle(boxLineWidth, this.boxStrokeColor, this.boxStrokeAlpha);
          checkerShape.lineStyle(checkLineWidth, this.checkerColor);
        } else {
          boxShape.fillStyle(this.uncheckedBoxFillColor, this.uncheckedBoxFillAlpha).lineStyle(boxLineWidth, this.uncheckedBoxStrokeColor, this.uncheckedBoxStrokeAlpha);
          checkerShape.lineStyle();
        }
  
        // Play checker animation
        if (this.checked) {
          checkerShape.setDisplayPathSegment(this.checkerAnimProgress);
        }
      }
    };
  
    var GetValue$2V = Phaser.Utils.Objects.GetValue;
    var Linear$b = Phaser.Math.Linear;
    var EaseValueTask = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(EaseValueTask, _EaseValueTaskBase);
      function EaseValueTask(gameObject, config) {
        var _this;
        _classCallCheck(this, EaseValueTask);
        _this = _callSuper(this, EaseValueTask, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.resetFromJSON();
        _this.boot();
        return _this;
      }
      _createClass(EaseValueTask, [{
        key: "start",
        value: function start(config) {
          if (this.timer.isRunning) {
            return this;
          }
          var target = this.target;
          this.propertyKey = GetValue$2V(config, 'key', 'value');
          var currentValue = target[this.propertyKey];
          this.fromValue = GetValue$2V(config, 'from', currentValue);
          this.toValue = GetValue$2V(config, 'to', currentValue);
          this.setEase(GetValue$2V(config, 'ease', this.ease));
          this.setDuration(GetValue$2V(config, 'duration', this.duration));
          this.setRepeat(GetValue$2V(config, 'repeat', 0));
          this.setDelay(GetValue$2V(config, 'delay', 0));
          this.setRepeatDelay(GetValue$2V(config, 'repeatDelay', 0));
          this.timer.setDuration(this.duration).setRepeat(this.repeat).setDelay(this.delay).setRepeatDelay(this.repeatDelay);
          target[this.propertyKey] = this.fromValue;
          _get(_getPrototypeOf(EaseValueTask.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(target, timer) {
          var t = timer.t;
          t = this.easeFn(t);
          target[this.propertyKey] = Linear$b(this.fromValue, this.toValue, t);
        }
      }]);
      return EaseValueTask;
    }(EaseValueTaskBase);
  
    var CheckerAnimationMethods = {
      setCheckerAnimationDuration: function setCheckerAnimationDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.checkerAnimDuration = duration;
        return this;
      },
      playCheckerAnimation: function playCheckerAnimation() {
        if (this.checkerAnimProgressTask === undefined) {
          this.checkerAnimProgressTask = new EaseValueTask(this, {
            eventEmitter: null
          });
        }
        this.checkerAnimProgressTask.restart({
          key: 'checkerAnimProgress',
          from: 0,
          to: 1,
          duration: this.checkerAnimDuration
        });
        return this;
      },
      stopCheckerAnimation: function stopCheckerAnimation() {
        if (this.checkerAnimProgressTask === undefined) {
          return this;
        }
        this.checkerAnimProgressTask.stop();
        return this;
      }
    };
  
    var methods$B = {};
    Object.assign(methods$B, StyleMethods$2, SizeMethods$1, ShapesUpdateMethods$4, CheckerAnimationMethods);
  
    var GetValue$2U = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$J = Phaser.Utils.Objects.IsPlainObject;
    var DefaultBoxFillColor = 0x005cb2;
    var DefaultCheckerColor = 0xffffff;
    var CheckboxShape = /*#__PURE__*/function (_BaseShapes) {
      _inherits(CheckboxShape, _BaseShapes);
      function CheckboxShape(scene, x, y, width, height, color, config) {
        var _this;
        _classCallCheck(this, CheckboxShape);
        if (IsPlainObject$J(x)) {
          config = x;
          x = GetValue$2U(config, 'x', 0);
          y = GetValue$2U(config, 'y', 0);
          width = GetValue$2U(config, 'width', 2);
          height = GetValue$2U(config, 'height', 2);
          color = GetValue$2U(config, 'color', DefaultBoxFillColor);
        } else if (IsPlainObject$J(color)) {
          config = color;
          color = GetValue$2U(config, 'color', DefaultBoxFillColor);
        }
        _this = _callSuper(this, CheckboxShape, [scene, x, y, width, height]);
        _this.type = 'rexCheckbox';
        if (color === undefined) {
          color = DefaultBoxFillColor;
        }
        _this.setBoxShape(GetValue$2U(config, 'circleBox', false));
        _this.setBoxFillStyle(color, GetValue$2U(config, 'boxFillAlpha', 1));
        _this.setUncheckedBoxFillStyle(GetValue$2U(config, 'uncheckedColor', null), GetValue$2U(config, 'uncheckedBoxFillAlpha', 1));
        _this.setBoxStrokeStyle(GetValue$2U(config, 'boxLineWidth', 4), GetValue$2U(config, 'boxStrokeColor', color), GetValue$2U(config, 'boxStrokeAlpha', 1));
        _this.setUncheckedBoxStrokeStyle(_this.boxLineWidth, GetValue$2U(config, 'uncheckedBoxStrokeColor', _this.boxStrokeColor), GetValue$2U(config, 'uncheckedBoxStrokeAlpha', _this.boxStrokeAlpha));
        _this.setCheckerStyle(GetValue$2U(config, 'checkerColor', DefaultCheckerColor), GetValue$2U(config, 'checkerAlpha', 1));
        _this.setBoxSize(GetValue$2U(config, 'boxSize', 1));
        _this.setCheckerSize(GetValue$2U(config, 'checkerSize', 1));
        _this.setCheckerAnimationDuration(GetValue$2U(config, 'animationDuration', 150));
        _this.buildShapes();
        var value = GetValue$2U(config, 'checked');
        if (value === undefined) {
          value = GetValue$2U(config, 'value', false);
        }
        _this.setValue(value);
        return _this;
      }
      _createClass(CheckboxShape, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          value = !!value;
          if (this._value === value) {
            return;
          }
          this.dirty = true;
          this._value = value;
          if (value) {
            this.playCheckerAnimation();
          } else {
            this.stopCheckerAnimation();
          }
          this.emit('valuechange', value);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "toggleValue",
        value: function toggleValue() {
          this.setValue(!this.value);
          return this;
        }
      }, {
        key: "checked",
        get: function get() {
          return this.value;
        },
        set: function set(value) {
          this.value = value;
        }
      }, {
        key: "setChecked",
        value: function setChecked(checked) {
          if (checked === undefined) {
            checked = true;
          }
          this.setValue(checked);
          return this;
        }
      }, {
        key: "toggleChecked",
        value: function toggleChecked() {
          this.toggleValue();
          return this;
        }
      }, {
        key: "checkerAnimProgress",
        get: function get() {
          return this._checkerAnimProgress;
        },
        set: function set(value) {
          if (this._checkerAnimProgress === value) {
            return;
          }
          this._checkerAnimProgress = value;
          this.dirty = true;
        }
      }]);
      return CheckboxShape;
    }(BaseShapes);
    Object.assign(CheckboxShape.prototype, methods$B);
  
    var GetValue$2T = Phaser.Utils.Objects.GetValue;
    var Button = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Button, _ComponentBase);
      function Button(gameObject, config) {
        var _this;
        _classCallCheck(this, Button);
        _this = _callSuper(this, Button, [gameObject, config]);
        // this.parent = gameObject;
  
        _this._enable = undefined;
        gameObject.setInteractive(GetValue$2T(config, "inputConfig", undefined));
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Button, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.pointer = undefined;
          this.lastClickTime = undefined;
          this.isDown = false;
          this.isOver = false;
          this.setEnable(GetValue$2T(o, "enable", true));
          this.setMode(GetValue$2T(o, "mode", 1));
          this.setClickInterval(GetValue$2T(o, "clickInterval", 100));
          this.setDragThreshold(GetValue$2T(o, 'threshold', undefined));
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          var gameObject = this.parent;
          gameObject.on('pointerdown', this.onPress, this);
          gameObject.on('pointerup', this.onRelease, this);
          gameObject.on('pointerout', this.onPointOut, this);
          gameObject.on('pointermove', this.onMove, this);
          gameObject.on('pointerover', this.onOver, this);
          gameObject.on('pointerout', this.onOut, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // GameObject events will be removed when this gameObject destroyed 
          // this.parent.on('pointerdown', this.onPress, this);
          // this.parent.on('pointerup', this.onRelease, this);
          // this.parent.on('pointerout', this.onPointOut, this);
          // this.parent.on('pointermove', this.onMove, this);
          this.pointer = null;
          _get(_getPrototypeOf(Button.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.cancel();
          }
          this._enable = e;
          var eventName = e ? 'enable' : 'disable';
          this.emit(eventName, this, this.parent);
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = CLICKMODE$1[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setClickInterval",
        value: function setClickInterval(interval) {
          this.clickInterval = interval; // ms
          return this;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
  
        // internal
      }, {
        key: "onPress",
        value: function onPress(pointer, localX, localY, event) {
          if (this.pointer !== undefined) {
            return;
          }
          this.pointer = pointer;
          this.isDown = true;
          this.emit('down', this, this.parent, pointer, event);
          if (this.mode === 0) {
            this.click(pointer.downTime, pointer, event);
          }
        }
      }, {
        key: "onRelease",
        value: function onRelease(pointer, localX, localY, event) {
          if (this.pointer !== pointer) {
            return;
          }
          this.isDown = false;
          this.emit('up', this, this.parent, pointer, event);
          if (this.mode === 1) {
            this.click(pointer.upTime, pointer, event);
          }
          this.pointer = undefined;
        }
      }, {
        key: "onPointOut",
        value: function onPointOut(pointer, event) {
          if (this.pointer !== pointer) {
            return;
          }
          this.cancel();
        }
      }, {
        key: "onMove",
        value: function onMove(pointer, localX, localY, event) {
          if (this.pointer !== pointer) {
            return;
          }
          if (this.dragThreshold === undefined) {
            return;
          }
          if (this.mode === 1) {
            if (pointer.getDistance() >= this.dragThreshold) {
              this.cancel();
            }
          }
        }
      }, {
        key: "onOver",
        value: function onOver(pointer, localX, localY, event) {
          if (!this.enable) {
            return this;
          }
          this.isOver = true;
          this.emit('over', this, this.parent, pointer, event);
          return this;
        }
      }, {
        key: "onOut",
        value: function onOut(pointer, event) {
          if (!this.enable) {
            return this;
          }
          this.isOver = false;
          this.emit('out', this, this.parent, pointer, event);
          return this;
        }
      }, {
        key: "click",
        value: function click(nowTime, pointer, event) {
          if (!this.enable) {
            return this;
          }
          if (nowTime === undefined) {
            // fires 'click' event manually
            this.emit('click', this, this.parent, pointer, event);
            return this;
          }
          this.pointer = undefined;
          var lastClickTime = this.lastClickTime;
          if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
            return this;
          }
          this.lastClickTime = nowTime;
          this.emit('click', this, this.parent, pointer, event);
          return this;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.pointer = undefined;
          return this;
        }
      }]);
      return Button;
    }(ComponentBase);
    var CLICKMODE$1 = {
      press: 0,
      pointerdown: 0,
      release: 1,
      pointerup: 1
    };
  
    var GetValue$2S = Phaser.Utils.Objects.GetValue;
    var Checkbox = /*#__PURE__*/function (_CheckboxShape) {
      _inherits(Checkbox, _CheckboxShape);
      function Checkbox(scene, x, y, width, height, color, config) {
        var _this;
        _classCallCheck(this, Checkbox);
        _this = _callSuper(this, Checkbox, [scene, x, y, width, height, color, config]);
        _this._click = new Button(_assertThisInitialized(_this), GetValue$2S(config, 'click'));
        _this._click.on('click', function () {
          this.toggleValue();
        }, _assertThisInitialized(_this));
        _this.setReadOnly(GetValue$2S(config, 'readOnly', false));
        return _this;
      }
      _createClass(Checkbox, [{
        key: "readOnly",
        get: function get() {
          return !this._click.enable;
        },
        set: function set(value) {
          this._click.enable = !value;
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.readOnly = enable;
          return this;
        }
      }]);
      return Checkbox;
    }(CheckboxShape);
  
    ObjectFactory.register('checkbox', function (x, y, width, height, color, config) {
      var gameObject = new Checkbox(this.scene, x, y, width, height, color, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Checkbox', Checkbox);
  
    var StyleMethods = {
      setTrackFillStyle: function setTrackFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.trackFillColor !== color || this.trackFillAlpha !== alpha;
        this.trackFillColor = color;
        this.trackFillAlpha = alpha;
        return this;
      },
      setFalseValueTrackFillStyle: function setFalseValueTrackFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.falseValueTrackColor !== color || this.uncheckedTrackFillAlpha !== alpha;
        this.falseValueTrackColor = color;
        this.falseValueTrackFillAlpha = alpha;
        return this;
      },
      setThumbStyle: function setThumbStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }
        this.dirty = this.dirty || this.thumbColor !== color || this.checkAlpha !== alpha;
        this.thumbColor = color;
        this.thumbAlpha = alpha;
        return this;
      }
    };
  
    var SizeMethods = {
      setTrackSize: function setTrackSize(width, height) {
        this.dirty = this.dirty || this.trackWidth !== width || this.trackHeight !== height;
        this.trackWidth = width;
        this.trackHeight = height;
        return this;
      },
      setTrackRadius: function setTrackRadius(radius) {
        this.dirty = this.dirty || this.trackRadius !== radius;
        this.trackRadius = radius;
        return this;
      },
      setThumbSize: function setThumbSize(width, height) {
        if (height === undefined) {
          height = width;
        }
        this.dirty = this.dirty || this.thumbWidth !== width || this.thumbHeight !== height;
        this.thumbWidth = width;
        this.thumbHeight = height;
        return this;
      },
      setThumbRadius: function setThumbRadius(radius) {
        this.dirty = this.dirty || this.thumbRadius !== radius;
        this.thumbRadius = radius;
        return this;
      }
    };
  
    var PositionMethods = {
      setThumbPosition: function setThumbPosition(left, right) {
        if (right === undefined) {
          right = 1 - left;
        }
        this.thumbLeftX = left;
        this.thumbRightX = right;
        return this;
      },
      setRTL: function setRTL(rtl) {
        if (rtl === undefined) {
          rtl = true;
        }
        this.rtl = rtl;
        return this;
      }
    };
  
    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2019 Photon Storm Ltd.
     * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
     */
  
    /**
     * Calculates a linear (interpolation) value over t.
     *
     * @function Phaser.Math.Linear
     * @since 3.0.0
     *
     * @param {number} p0 - The first point.
     * @param {number} p1 - The second point.
     * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.
     *
     * @return {number} The step t% of the way between p0 and p1.
     */
    var Linear$a = function Linear(p0, p1, t) {
      return (p1 - p0) * t + p0;
    };
  
    var MixColor = function MixColor(color0, color1, t) {
      var r = Linear$a(GetR(color0), GetR(color1), t);
      var g = Linear$a(GetG(color0), GetG(color1), t);
      var b = Linear$a(GetB(color0), GetB(color1), t);
      return (r & 0xff) << 16 | (g & 0xff) << 8 | b & 0xff;
    };
  
    var Linear$9 = Phaser.Math.Linear;
    var ShapesUpdateMethods$3 = {
      buildShapes: function buildShapes() {
        this.addShape(new RoundRectangle().setName('track')).addShape(new RoundRectangle().setName('thumb'));
      },
      updateShapes: function updateShapes() {
        var width = this.width,
          height = this.height;
        var toggleAnimProgress = this.value ? this.toggleAnimProgress : 1 - this.toggleAnimProgress;
  
        // Track
        var trackShape = this.getShape('track');
        if (this.isSizeChanged) {
          var trackWidth = width * this.trackWidth,
            trackHeight = height * this.trackHeight,
            trackX = (width - trackWidth) / 2,
            trackY = (height - trackHeight) / 2,
            trackRadius = height * this.trackRadius;
          trackShape.setTopLeftPosition(trackX, trackY).setSize(trackWidth, trackHeight).setRadius(trackRadius);
        }
        var trackFillColor = MixColor(this.falseValueTrackColor, this.trackFillColor, toggleAnimProgress);
        var trackFillAlpha = Linear$9(this.falseValueTrackFillAlpha, this.trackFillAlpha, toggleAnimProgress);
        trackShape.fillStyle(trackFillColor, trackFillAlpha);
  
        // Thumb
        var thumbShape = this.getShape('thumb');
        if (this.isSizeChanged) {
          var thumbWidth = width * this.thumbWidth,
            thumbHeight = height * this.thumbHeight,
            thumbRadius = height * this.thumbRadius;
          thumbShape.setSize(thumbWidth, thumbHeight).setRadius(thumbRadius);
        }
        var thumbX = Linear$9(this.thumbLeftX, this.thumbRightX, toggleAnimProgress) * width;
        if (this.rtl) {
          thumbX = width - thumbX;
        }
        var thumbY = height / 2;
        thumbShape.setCenterPosition(thumbX, thumbY);
        thumbShape.fillStyle(this.thumbColor, this.thumbAlpha);
      }
    };
  
    var ToggleAnimationMethods = {
      setToggleAnimationDuration: function setToggleAnimationDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.toggleAnimDuration = duration;
        return this;
      },
      playToggleAnimation: function playToggleAnimation() {
        if (this.toggleAnimProgressTask === undefined) {
          this.toggleAnimProgressTask = new EaseValueTask(this, {
            eventEmitter: null
          });
        }
        this.toggleAnimProgressTask.restart({
          key: 'toggleAnimProgress',
          from: 0,
          to: 1,
          duration: this.toggleAnimDuration
        });
        return this;
      },
      stopToggleAnimation: function stopToggleAnimation() {
        if (this.toggleAnimProgressTask === undefined) {
          return this;
        }
        this.toggleAnimProgressTask.stop();
        return this;
      }
    };
  
    var methods$A = {};
    Object.assign(methods$A, StyleMethods, SizeMethods, PositionMethods, ShapesUpdateMethods$3, ToggleAnimationMethods);
  
    var GrayScale = function GrayScale(color) {
      var shade = 0.3 * GetR(color) + 0.59 * GetG(color) + 0.11 * GetB(color);
      return (shade & 0xff) << 16 | (shade & 0xff) << 8 | shade & 0xff;
    };
  
    var GetValue$2R = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$I = Phaser.Utils.Objects.IsPlainObject;
    var DefaultTrackFillColor = 0x005cb2;
    var DefaultThumbFillColor = 0xffffff;
    var ToggleSwitchShape = /*#__PURE__*/function (_BaseShapes) {
      _inherits(ToggleSwitchShape, _BaseShapes);
      function ToggleSwitchShape(scene, x, y, width, height, color, config) {
        var _this;
        _classCallCheck(this, ToggleSwitchShape);
        if (IsPlainObject$I(x)) {
          config = x;
          x = GetValue$2R(config, 'x', 0);
          y = GetValue$2R(config, 'y', 0);
          width = GetValue$2R(config, 'width', 2);
          height = GetValue$2R(config, 'height', 2);
          color = GetValue$2R(config, 'color', DefaultTrackFillColor);
        } else if (IsPlainObject$I(color)) {
          config = color;
          color = GetValue$2R(config, 'color', DefaultTrackFillColor);
        }
        _this = _callSuper(this, ToggleSwitchShape, [scene, x, y, width, height]);
        _this.type = 'rexToggleSwitch';
        if (color === undefined) {
          color = DefaultTrackFillColor;
        }
        _this.setTrackFillStyle(color, GetValue$2R(config, 'trackFillAlpha', 1));
        _this.setFalseValueTrackFillStyle(GetValue$2R(config, 'falseValueTrackColor', GrayScale(color)), GetValue$2R(config, 'falseValueTrackFillAlpha', 1));
        _this.setThumbStyle(GetValue$2R(config, 'thumbColor', DefaultThumbFillColor), GetValue$2R(config, 'thumbAlpha', 1));
        _this.setTrackSize(GetValue$2R(config, 'trackWidth', 0.9), GetValue$2R(config, 'trackHeight', 0.5));
        _this.setTrackRadius(GetValue$2R(config, 'trackRadius', _this.trackHeight * 0.5));
        var thumbHeight = GetValue$2R(config, 'thumbHeight', undefined);
        var thumbWidth = GetValue$2R(config, 'thumbWidth', thumbHeight);
        if (thumbWidth === undefined) {
          thumbWidth = _this.trackHeight * 0.9;
        }
        _this.setThumbSize(thumbWidth, thumbHeight);
        _this.setThumbRadius(GetValue$2R(config, 'thumbRadius', _this.thumbHeight * 0.5));
        _this.setThumbPosition(GetValue$2R(config, 'thumbLeft', 0.3), GetValue$2R(config, 'thumbRight', undefined));
        _this.setRTL(GetValue$2R(config, 'rtl', false));
        _this.setToggleAnimationDuration(GetValue$2R(config, 'animationDuration', 150));
        _this.buildShapes();
        _this.setValue(GetValue$2R(config, 'value', false), 0);
        return _this;
      }
      _createClass(ToggleSwitchShape, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          value = !!value;
          if (this._value === value) {
            return;
          }
          this.dirty = true;
          this._value = value;
          this.playToggleAnimation();
          this.emit('valuechange', value);
        }
      }, {
        key: "setValue",
        value: function setValue(value, duration) {
          if (duration === undefined) {
            duration = this.toggleAnimDuration;
          }
          var durationSave = this.toggleAnimDuration;
          this.toggleAnimDuration = duration;
          this.value = value;
          this.toggleAnimDuration = durationSave;
          return this;
        }
      }, {
        key: "toggleValue",
        value: function toggleValue(duration) {
          this.setValue(!this.value, duration);
          return this;
        }
      }, {
        key: "toggleAnimProgress",
        get: function get() {
          return this._toggleAnimProgress;
        },
        set: function set(value) {
          if (this._toggleAnimProgress === value) {
            return;
          }
          this._toggleAnimProgress = value;
          this.dirty = true;
        }
      }]);
      return ToggleSwitchShape;
    }(BaseShapes);
    Object.assign(ToggleSwitchShape.prototype, methods$A);
  
    var GetValue$2Q = Phaser.Utils.Objects.GetValue;
    var ToggleSwitch = /*#__PURE__*/function (_ToggleSwitchShape) {
      _inherits(ToggleSwitch, _ToggleSwitchShape);
      function ToggleSwitch(scene, x, y, width, height, color, config) {
        var _this;
        _classCallCheck(this, ToggleSwitch);
        _this = _callSuper(this, ToggleSwitch, [scene, x, y, width, height, color, config]);
        _this._click = new Button(_assertThisInitialized(_this), GetValue$2Q(config, 'click'));
        _this._click.on('click', function () {
          this.toggleValue();
        }, _assertThisInitialized(_this));
        _this.setReadOnly(GetValue$2Q(config, 'readOnly', false));
        return _this;
      }
      _createClass(ToggleSwitch, [{
        key: "readOnly",
        get: function get() {
          return !this._click.enable;
        },
        set: function set(value) {
          this._click.enable = !value;
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.readOnly = enable;
          return this;
        }
      }]);
      return ToggleSwitch;
    }(ToggleSwitchShape);
  
    ObjectFactory.register('toggleSwitch', function (x, y, width, height, color, config) {
      var gameObject = new ToggleSwitch(this.scene, x, y, width, height, color, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ToggleSwitch', ToggleSwitch);
  
    var LoadImageMethods = {
      loadFromURL: function loadFromURL(url, callback) {
        var self = this;
        var img = new Image();
        img.onload = function () {
          if (self.width !== img.width || self.height !== img.height) {
            self.resize(img.width, img.height);
          } else {
            self.clear();
          }
          self.context.drawImage(img, 0, 0);
          self.updateTexture();
          if (callback) {
            callback();
          }
          img.onload = null;
          img.src = '';
          img.remove();
        };
        img.src = url;
        return this;
      },
      loadFromURLPromise: function loadFromURLPromise(url) {
        var self = this;
        return new Promise(function (resolve, reject) {
          self.loadFromURL(url, resolve);
        });
      },
      loadFromFile: function loadFromFile(file, callback) {
        var url = URL.createObjectURL(file);
        this.loadFromURL(url, function () {
          URL.revokeObjectURL(url);
          if (callback) {
            callback();
          }
        });
        return this;
      },
      loadFromFilePromise: function loadFromFilePromise(file) {
        var self = this;
        return new Promise(function (resolve, reject) {
          self.loadFromFile(file, resolve);
        });
      }
    };
  
    var Canvas = /*#__PURE__*/function (_CanvasBase) {
      _inherits(Canvas, _CanvasBase);
      function Canvas() {
        _classCallCheck(this, Canvas);
        return _callSuper(this, Canvas, arguments);
      }
      return _createClass(Canvas);
    }(Canvas$1);
    Object.assign(Canvas.prototype, LoadImageMethods);
  
    ObjectFactory.register('canvas', function (x, y, width, height) {
      var gameObject = new Canvas(this.scene, x, y, width, height);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Canvas', Canvas);
  
    var GetValue$2P = Phaser.Utils.Objects.GetValue;
    var CircleMaskImage = /*#__PURE__*/function (_Canvas) {
      _inherits(CircleMaskImage, _Canvas);
      function CircleMaskImage(scene, x, y, key, frame, config) {
        var _this;
        _classCallCheck(this, CircleMaskImage);
        _this = _callSuper(this, CircleMaskImage, [scene, x, y]);
        _this.type = 'rexCircleMaskImage';
        _this.setTexture(key, frame, config);
        return _this;
      }
      _createClass(CircleMaskImage, [{
        key: "setTexture",
        value: function setTexture(key, frame, config) {
          if (_typeof(frame) === 'object') {
            config = frame;
            frame = undefined;
          }
          if (typeof config === 'string') {
            config = {
              maskType: config
            };
          }
          var maskType = GetValue$2P(config, 'maskType', 0);
          var backgroundColor = GetValue$2P(config, 'backgroundColor', undefined);
          var strokeColor = GetValue$2P(config, 'strokeColor', undefined);
          var defaultStrokeWidth = strokeColor != null ? 10 : 0;
          var strokeWidth = GetValue$2P(config, 'strokeWidth', defaultStrokeWidth);
          if (maskType === undefined) {
            maskType = 0;
          } else if (typeof maskType === 'string') {
            maskType = MASKTYPE[maskType];
          }
          this._textureKey = key;
          this._frameName = frame;
          if (maskType === null) {
            this.loadTexture(key, frame);
            this.dirty = true;
            return this;
          }
          var textureFrame = this.scene.sys.textures.getFrame(key, frame);
          if (!textureFrame) {
            return this;
          }
          // Resize to frame size
          if (textureFrame.cutWidth !== this.width || textureFrame.cutHeight !== this.height) {
            this.setCanvasSize(textureFrame.cutWidth, textureFrame.cutHeight);
          } else {
            this.clear();
          }
          var canvas = this.canvas,
            ctx = this.context;
          var width = canvas.width,
            height = canvas.height;
  
          // Fill background
          if (backgroundColor != null) {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);
          }
          ctx.save();
          ctx.beginPath();
  
          // Build clip path 
          var halfStrokeLineWidth = strokeWidth / 2;
          switch (maskType) {
            case 1:
              // ellipse
              var centerX = Math.floor(width / 2);
              var centerY = Math.floor(height / 2);
              var radiusX = centerX - halfStrokeLineWidth;
              var radiusY = centerY - halfStrokeLineWidth;
              ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
              break;
            case 2:
              var radiusConfig = GetValue$2P(config, 'radius', 0);
              var iteration = GetValue$2P(config, 'iteration', undefined);
              AddRoundRectanglePath(ctx, halfStrokeLineWidth, halfStrokeLineWidth, width - strokeWidth, height - strokeWidth, radiusConfig, iteration);
              break;
            default:
              // circle
              var centerX = Math.floor(width / 2);
              var centerY = Math.floor(height / 2);
              var radius = Math.min(centerX, centerY) - halfStrokeLineWidth;
              ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
              break;
          }
  
          // Draw stroke line
          if (strokeColor != null) {
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
          }
  
          // Clip frame image
          ctx.clip();
          this.loadTexture(key, frame);
          ctx.restore();
          this.dirty = true;
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          // Don't draw content again.
          this.setDisplaySize(width, height);
          return this;
        }
      }]);
      return CircleMaskImage;
    }(Canvas$1);
    var MASKTYPE = {
      circle: 0,
      ellipse: 1,
      roundRectangle: 2
    };
  
    ObjectFactory.register('circleMaskImage', function (x, y, key, frame, config) {
      var gameObject = new CircleMaskImage(this.scene, x, y, key, frame, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CircleMaskImage', CircleMaskImage);
  
    var GetValue$2O = Phaser.Utils.Objects.GetValue;
    var AlphaMaskImage = /*#__PURE__*/function (_Canvas) {
      _inherits(AlphaMaskImage, _Canvas);
      function AlphaMaskImage(scene, x, y, key, frame, config) {
        var _this;
        _classCallCheck(this, AlphaMaskImage);
        _this = _callSuper(this, AlphaMaskImage, [scene, x, y]);
        _this.type = 'rexAlphaMaskImage';
        _this.maskFrame = null;
        _this.setTexture(key, frame, config);
        return _this;
      }
      _createClass(AlphaMaskImage, [{
        key: "setTexture",
        value: function setTexture(key, frame, config) {
          if (_typeof(frame) === 'object') {
            config = frame;
            frame = undefined;
          }
          if (typeof config === 'string') {
            config = {
              mask: {
                key: config
              }
            };
          }
          var maskKey = GetValue$2O(config, 'mask.key');
          var maskFrame = GetValue$2O(config, 'mask.frame');
          var invertMaskAlpha = GetValue$2O(config, 'mask.invertAlpha', false);
          var maskScale = GetValue$2O(config, 'mask.scale');
          var backgroundColor = GetValue$2O(config, 'backgroundColor');
          if (maskKey) {
            this._maskKey = maskKey;
            this._maskFrame = maskFrame;
            this._maskScale = maskScale;
            var texture = maskKey ? this.scene.sys.textures.get(maskKey) : null;
            this.maskFrame = texture ? texture.get(maskFrame) : null;
          }
          this._textureKey = key;
          this._frameName = frame;
          var maskTextureFrame = this.maskFrame;
          if (maskTextureFrame === null) {
            this.loadTexture(key, frame);
            this.dirty = true;
            return this;
          }
          var hasBackgroundColor = backgroundColor != null;
          this.loadTexture(key, frame);
  
          // Draw mask
          var canvas = this.canvas,
            ctx = this.context;
          var width = canvas.width,
            height = canvas.height;
          ctx.save();
          ctx.globalCompositeOperation = invertMaskAlpha ? 'destination-out' : 'destination-in';
          var maskWidth, maskHeight;
          if (this._maskScale != null) {
            maskWidth = maskTextureFrame.cutWidth * this._maskScale;
            maskHeight = maskTextureFrame.cutHeight * this._maskScale;
          } else {
            maskWidth = width;
            maskHeight = height;
          }
          var maskX = (width - maskWidth) / 2;
          var maskY = (height - maskHeight) / 2;
          this.drawFrame(this._maskKey, this._maskFrame, maskX, maskY, maskWidth, maskHeight);
          ctx.restore();
          if (hasBackgroundColor) {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
          }
          this.dirty = true;
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          // Don't draw content again.
          this.setDisplaySize(width, height);
          return this;
        }
      }]);
      return AlphaMaskImage;
    }(Canvas$1);
  
    ObjectFactory.register('alphaMaskImage', function (x, y, key, frame, config) {
      var gameObject = new AlphaMaskImage(this.scene, x, y, key, frame, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.AlphaMaskImage', AlphaMaskImage);
  
    var Linear$8 = Phaser.Math.Linear;
    var Percent$5 = Phaser.Math.Percent;
    var ProgressValueMethods = {
      setValue: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }
        if (min !== undefined) {
          value = Percent$5(value, min, max);
        }
        this.value = value;
        return this;
      },
      addValue: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent$5(inc, min, max);
        }
        this.value += inc;
        return this;
      },
      getValue: function getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
          value = Linear$8(min, max, value);
        }
        return value;
      }
    };
  
    var Percent$4 = Phaser.Math.Percent;
    var SetEaseValuePropName = function SetEaseValuePropName(name) {
      this.easeValuePropName = name;
      return this;
    };
    var SetEaseValueDuration = function SetEaseValueDuration(duration) {
      this.easeValueDuration = duration;
      return this;
    };
    var SetEaseValueFunction = function SetEaseValueFunction(ease) {
      this.easeFunction = ease;
      return this;
    };
    var StopEaseValue = function StopEaseValue() {
      if (this.easeValueTask) {
        this.easeValueTask.stop();
      }
      return this;
    };
    var EaseValueTo = function EaseValueTo(value, min, max) {
      if (value === undefined || value === null) {
        return this;
      }
      if (min !== undefined) {
        value = Percent$4(value, min, max);
      }
      if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.easeValueTask.restart({
        key: this.easeValuePropName,
        to: value,
        duration: this.easeValueDuration,
        ease: this.easeFunction
      });
      return this;
    };
    var EaseValueRepeat = function EaseValueRepeat(from, to, repeat, repeatDelay) {
      if (repeat === undefined) {
        repeat = -1;
      }
      if (repeatDelay === undefined) {
        repeatDelay = 0;
      }
      if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }
      this.easeValueTask.restart({
        key: this.easeValuePropName,
        from: from,
        to: to,
        duration: this.easeValueDuration,
        ease: this.easeFunction,
        repeat: repeat,
        repeatDelay: repeatDelay
      });
      return this;
    };
    var EaseValueMethods = {
      setEaseValuePropName: SetEaseValuePropName,
      setEaseValueDuration: SetEaseValueDuration,
      setEaseValueFunction: SetEaseValueFunction,
      stopEaseValue: StopEaseValue,
      easeValueTo: EaseValueTo,
      easeValueRepeat: EaseValueRepeat
    };
  
    var GetValue$2N = Phaser.Utils.Objects.GetValue;
    var Clamp$d = Phaser.Math.Clamp;
    function ProgressBase (BaseClass) {
      var ProgressBase = /*#__PURE__*/function (_BaseClass) {
        _inherits(ProgressBase, _BaseClass);
        function ProgressBase() {
          _classCallCheck(this, ProgressBase);
          return _callSuper(this, ProgressBase, arguments);
        }
        _createClass(ProgressBase, [{
          key: "bootProgressBase",
          value: function bootProgressBase(config) {
            this.eventEmitter = GetValue$2N(config, 'eventEmitter', this);
            var callback = GetValue$2N(config, 'valuechangeCallback', null);
            if (callback !== null) {
              var scope = GetValue$2N(config, 'valuechangeCallbackScope', undefined);
              this.eventEmitter.on('valuechange', callback, scope);
            }
            this.setEaseValuePropName('value').setEaseValueDuration(GetValue$2N(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$2N(config, 'easeValue.ease', 'Linear'));
            return this;
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(value) {
            value = Clamp$d(value, 0, 1);
            var oldValue = this._value;
            var valueChanged = oldValue != value;
            this.dirty = this.dirty || valueChanged;
            this._value = value;
            if (valueChanged) {
              this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
            }
          }
        }]);
        return ProgressBase;
      }(BaseClass);
      Object.assign(ProgressBase.prototype, ProgressValueMethods, EaseValueMethods);
      return ProgressBase;
    }
  
    var RadToDeg$7 = Phaser.Math.RadToDeg;
    var DegToRad$9 = Phaser.Math.DegToRad;
    var FillArc = function FillArc(shape, x, y, outerRadius, innerRadius, startAngle, endAngle, anticlockwise) {
      var isCircle = Math.abs(endAngle - startAngle) === 360;
      var radStartAngle = DegToRad$9(startAngle),
        radEndAngle = DegToRad$9(endAngle);
      var cosStartAngle = Math.cos(radStartAngle),
        sinStartAngle = Math.sin(radStartAngle),
        cosEndAngle = Math.cos(radEndAngle),
        sinEndAngle = Math.sin(radEndAngle);
      shape.startAt(x + cosStartAngle * outerRadius, y + sinStartAngle * outerRadius);
      shape.arc(x, y, outerRadius, startAngle, endAngle, anticlockwise);
      if (isCircle && innerRadius === 0) ; else {
        shape.lineTo(x + cosEndAngle * innerRadius, y + sinEndAngle * innerRadius);
        if (innerRadius > 0) {
          shape.arc(x, y, innerRadius, endAngle, startAngle, !anticlockwise);
        }
      }
      shape.close();
      return shape;
    };
    var ShapesUpdateMethods$2 = {
      buildShapes: function buildShapes() {
        this.addShape(new Lines().setName('track')).addShape(new Lines().setName('bar')).addShape(new Circle().setName('center'));
      },
      updateShapes: function updateShapes() {
        var x = this.radius;
        var barWidth = this.thickness * this.radius;
        var barOuterRadius = this.radius;
        var barInnerRadius = barOuterRadius - barWidth;
  
        // Track shape
        var trackShape = this.getShape('track');
        if (this.trackColor != null && this.thickness > 0) {
          trackShape.fillStyle(this.trackColor);
          FillArc(trackShape, x, x, barOuterRadius, barInnerRadius, 0, 360, false);
        } else {
          trackShape.reset();
        }
  
        // Bar shape
        var barShape = this.getShape('bar');
        if (this.barColor != null && this.thickness > 0) {
          var anticlockwise, startAngle, endAngle;
          if (this.value === 1) {
            anticlockwise = false;
            startAngle = 0;
            endAngle = 360;
          } else {
            anticlockwise = this.anticlockwise;
            startAngle = RadToDeg$7(this.startAngle);
            var deltaAngle = 360 * (anticlockwise ? 1 - this.value : this.value);
            endAngle = deltaAngle + startAngle;
          }
          barShape.fillStyle(this.barColor);
          FillArc(barShape, x, x, barOuterRadius, barInnerRadius, startAngle, endAngle, false);
        } else {
          barShape.reset();
        }
  
        // Center shape
        var centerShape = this.getShape('center');
        if (this.centerColor && barInnerRadius > 0) {
          centerShape.setCenterPosition(x, x).setRadius(barInnerRadius).fillStyle(this.centerColor);
        } else {
          centerShape.reset();
        }
      }
    };
  
    var GetValue$2M = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$H = Phaser.Utils.Objects.IsPlainObject;
    var Clamp$c = Phaser.Math.Clamp;
    var DefaultStartAngle$1 = Phaser.Math.DegToRad(270);
    var CircularProgress$1 = /*#__PURE__*/function (_ProgressBase) {
      _inherits(CircularProgress, _ProgressBase);
      function CircularProgress(scene, x, y, radius, barColor, value, config) {
        var _this;
        _classCallCheck(this, CircularProgress);
        if (IsPlainObject$H(x)) {
          config = x;
          x = GetValue$2M(config, 'x', 0);
          y = GetValue$2M(config, 'y', 0);
          radius = GetValue$2M(config, 'radius', 1);
          barColor = GetValue$2M(config, 'barColor', undefined);
          value = GetValue$2M(config, 'value', 0);
        }
        if (radius === undefined) {
          radius = 1;
        }
        var width = radius * 2;
        _this = _callSuper(this, CircularProgress, [scene, x, y, width, width]);
        _this.type = 'rexCircularProgress';
        _this.bootProgressBase(config);
        _this.setRadius(radius);
        _this.setTrackColor(GetValue$2M(config, 'trackColor', undefined));
        _this.setBarColor(barColor);
        _this.setCenterColor(GetValue$2M(config, 'centerColor', undefined));
        _this.setThickness(GetValue$2M(config, 'thickness', 0.2));
        _this.setStartAngle(GetValue$2M(config, 'startAngle', DefaultStartAngle$1));
        _this.setAnticlockwise(GetValue$2M(config, 'anticlockwise', false));
        _this.buildShapes();
        _this.setValue(value);
        return _this;
      }
      _createClass(CircularProgress, [{
        key: "resize",
        value: function resize(width, height) {
          width = Math.floor(Math.min(width, height));
          if (width === this.width) {
            return this;
          }
          _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);
          this.setRadius(width / 2);
          return this;
        }
      }, {
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._radius != value;
          this._radius = value;
          var width = value * 2;
          this.resize(width, width);
        }
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          this.radius = radius;
          return this;
        }
      }, {
        key: "trackColor",
        get: function get() {
          return this._trackColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._trackColor != value;
          this._trackColor = value;
        }
      }, {
        key: "setTrackColor",
        value: function setTrackColor(color) {
          this.trackColor = color;
          return this;
        }
      }, {
        key: "barColor",
        get: function get() {
          return this._barColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._barColor != value;
          this._barColor = value;
        }
      }, {
        key: "setBarColor",
        value: function setBarColor(color) {
          this.barColor = color;
          return this;
        }
      }, {
        key: "startAngle",
        get: function get() {
          return this._startAngle;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._startAngle != value;
          this._startAngle = value;
        }
      }, {
        key: "setStartAngle",
        value: function setStartAngle(angle) {
          this.startAngle = angle;
          return this;
        }
      }, {
        key: "anticlockwise",
        get: function get() {
          return this._anticlockwise;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._anticlockwise != value;
          this._anticlockwise = value;
        }
      }, {
        key: "setAnticlockwise",
        value: function setAnticlockwise(anticlockwise) {
          if (anticlockwise === undefined) {
            anticlockwise = true;
          }
          this.anticlockwise = anticlockwise;
          return this;
        }
      }, {
        key: "thickness",
        get: function get() {
          return this._thickness;
        },
        set: function set(value) {
          value = Clamp$c(value, 0, 1);
          this.dirty = this.dirty || this._thickness != value;
          this._thickness = value;
        }
      }, {
        key: "setThickness",
        value: function setThickness(thickness) {
          this.thickness = thickness;
          return this;
        }
      }, {
        key: "centerColor",
        get: function get() {
          return this._centerColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._centerColor != value;
          this._centerColor = value;
        }
      }, {
        key: "setCenterColor",
        value: function setCenterColor(color) {
          this.centerColor = color;
          return this;
        }
      }]);
      return CircularProgress;
    }(ProgressBase(BaseShapes));
    Object.assign(CircularProgress$1.prototype, ShapesUpdateMethods$2);
  
    ObjectFactory.register('circularProgress', function (x, y, radius, barColor, value, config) {
      var gameObject = new CircularProgress$1(this.scene, x, y, radius, barColor, value, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CircularProgress', CircularProgress$1);
  
    var DrawCircle = function DrawCircle(canvas, context, x, y, rx, ry, fillStyle, strokeStyle, lineWidth, startAngle, endAngle, anticlockwise) {
      if (startAngle === undefined) {
        startAngle = 0;
      }
      if (endAngle === undefined) {
        endAngle = 2 * Math.PI;
      }
      if (anticlockwise === undefined) {
        anticlockwise = false;
      }
      context.beginPath();
      context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);
      if (fillStyle != null) {
        context.fillStyle = fillStyle;
        context.fill();
      }
      if (strokeStyle != null) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = lineWidth;
        context.stroke();
      }
    };
  
    var DrawText = function DrawText(canvas, context, x, y, text, font, fillStyle, strokeStyle, lineWidth, textAlign, textBaseline) {
      if (lineWidth === undefined && strokeStyle != null) {
        lineWidth = 2;
      }
      if (textAlign === undefined) {
        textAlign = 'start';
      }
      if (textBaseline === undefined) {
        textBaseline = 'alphabetic';
      }
      context.font = font;
      context.textAlign = textAlign;
      context.textBaseline = textBaseline;
      context.fillStyle = fillStyle;
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.lineCap = 'round';
      context.lineJoin = 'round';
      if (strokeStyle != null && strokeStyle !== 'none' && lineWidth > 0) {
        context.strokeText(text, x, y);
      }
      if (fillStyle != null && fillStyle !== 'none') {
        context.fillText(text, x, y);
      }
    };
  
    var PI2$1 = Phaser.Math.PI2;
    var DrawContent$1 = function DrawContent() {
      var x = this.radius;
      var lineWidth = this.thickness * this.radius;
      var barRadius = this.radius - lineWidth / 2;
      var centerRadius = this.radius - lineWidth;
      var canvas = this.canvas,
        context = this.context;
      var anticlockwise = this.anticlockwise,
        startAngle = this.startAngle,
        endAngle = this.endAngle,
        deltaAngle = this._deltaAngle;
  
      // Draw track
      if (this.trackColor && lineWidth > 0) {
        context.save();
        DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, this.trackColor, lineWidth, startAngle, endAngle, anticlockwise);
        context.restore();
      }
  
      // Draw bar
      if (this.barColor && barRadius > 0) {
        var barEndAngle;
        if (anticlockwise) {
          barEndAngle = (startAngle - deltaAngle * this.value + PI2$1) % PI2$1;
        } else {
          barEndAngle = (startAngle + deltaAngle * this.value) % PI2$1;
        }
        context.save();
        var style;
        if (this.barColor2) {
          var x0 = x + barRadius * Math.cos(startAngle),
            y0 = x + barRadius * Math.sin(startAngle),
            x1 = x + barRadius * Math.cos(barEndAngle),
            y1 = x + barRadius * Math.sin(barEndAngle);
          var grd = context.createLinearGradient(x0, y0, x1, y1);
          grd.addColorStop(0, this.barColor2);
          grd.addColorStop(1, this.barColor);
          style = grd;
        } else {
          style = this.barColor;
        }
        DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, style, lineWidth, startAngle, barEndAngle, anticlockwise);
        context.restore();
      }
  
      // Draw center
      if (this.centerColor && centerRadius > 0) {
        var fillStyle;
        if (this.centerColor2) {
          fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
          fillStyle.addColorStop(0, this.centerColor);
          fillStyle.addColorStop(1, this.centerColor2);
        } else {
          fillStyle = this.centerColor;
        }
        context.save();
        DrawCircle(canvas, context, x, x, centerRadius, centerRadius, fillStyle);
        context.restore();
      }
  
      // Draw text
      if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {
        context.save();
        DrawText(canvas, context, x, x, this.getFormatText(), this.textFont, this.textColor, this.textStrokeColor, this.textStrokeThickness, 'center',
        // textAlign
        'middle' // textBaseline
        );
        context.restore();
      }
    };
  
    var GetValue$2L = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$G = Phaser.Utils.Objects.IsPlainObject;
    var NormalizeAngle$1 = Phaser.Math.Angle.Normalize;
    var Clamp$b = Phaser.Math.Clamp;
    var DefaultStartAngle = Phaser.Math.DegToRad(270);
    var PI2 = Phaser.Math.PI2;
    var CircularProgress = /*#__PURE__*/function (_ProgressBase) {
      _inherits(CircularProgress, _ProgressBase);
      function CircularProgress(scene, x, y, radius, barColor, value, config) {
        var _this;
        _classCallCheck(this, CircularProgress);
        if (IsPlainObject$G(x)) {
          config = x;
          x = GetValue$2L(config, 'x', 0);
          y = GetValue$2L(config, 'y', 0);
          radius = GetValue$2L(config, 'radius', 1);
          barColor = GetValue$2L(config, 'barColor', undefined);
          value = GetValue$2L(config, 'value', 0);
        }
        var width = radius * 2;
        _this = _callSuper(this, CircularProgress, [scene, x, y, width, width]);
        _this.type = 'rexCircularProgressCanvas';
        _this.bootProgressBase(config);
        _this.setRadius(radius);
        _this.setTrackColor(GetValue$2L(config, 'trackColor', undefined));
        _this.setBarColor(barColor);
        _this.setBarColor2(GetValue$2L(config, 'barColor2', undefined));
        _this.setCenterColor(GetValue$2L(config, 'centerColor', undefined));
        _this.setThickness(GetValue$2L(config, 'thickness', 0.2));
        _this.setStartAngle(GetValue$2L(config, 'startAngle', DefaultStartAngle));
        _this.setEndAngle(GetValue$2L(config, 'endAngle', _this.startAngle + PI2));
        _this.setAnticlockwise(GetValue$2L(config, 'anticlockwise', false));
        _this.setTextColor(GetValue$2L(config, 'textColor', undefined));
        _this.setTextStrokeColor(GetValue$2L(config, 'textStrokeColor', undefined), GetValue$2L(config, 'textStrokeThickness', undefined));
        var textFont = GetValue$2L(config, 'textFont', undefined);
        if (textFont) {
          _this.setTextFont(textFont);
        } else {
          _this.setTextFont(GetValue$2L(config, 'textSize', '16px'), GetValue$2L(config, 'textFamily', 'Courier'), GetValue$2L(config, 'textStyle', ''));
        }
        _this.setTextFormatCallback(GetValue$2L(config, 'textFormatCallback', undefined), GetValue$2L(config, 'textFormatCallbackScope', undefined));
        _this.setValue(value);
        return _this;
      }
      _createClass(CircularProgress, [{
        key: "resize",
        value: function resize(width, height) {
          width = Math.floor(Math.min(width, height));
          if (width === this.width) {
            return this;
          }
          _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);
          this.setRadius(width / 2);
          return this;
        }
      }, {
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._radius != value;
          this._radius = value;
          var width = value * 2;
          this.resize(width, width);
        }
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          this.radius = radius;
          return this;
        }
      }, {
        key: "trackColor",
        get: function get() {
          return this._trackColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._trackColor != value;
          this._trackColor = value;
        }
      }, {
        key: "setTrackColor",
        value: function setTrackColor(color) {
          this.trackColor = color;
          return this;
        }
      }, {
        key: "barColor",
        get: function get() {
          return this._barColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._barColor != value;
          this._barColor = value;
        }
      }, {
        key: "setBarColor",
        value: function setBarColor(color) {
          this.barColor = color;
          return this;
        }
      }, {
        key: "barColor2",
        get: function get() {
          return this._barColor2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._barColor2 != value;
          this._barColor2 = value;
        }
      }, {
        key: "setBarColor2",
        value: function setBarColor2(color) {
          this.barColor2 = color;
          return this;
        }
      }, {
        key: "startAngle",
        get: function get() {
          return this._startAngle;
        },
        set: function set(value) {
          value = NormalizeAngle$1(value);
          this.dirty = this.dirty || this._startAngle != value;
          this._startAngle = value;
          this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }
      }, {
        key: "setStartAngle",
        value: function setStartAngle(angle) {
          this.startAngle = angle;
          return this;
        }
      }, {
        key: "endAngle",
        get: function get() {
          return this._endAngle;
        },
        set: function set(value) {
          value = NormalizeAngle$1(value);
          this.dirty = this.dirty || this._endAngle != value;
          this._endAngle = value;
          this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }
      }, {
        key: "setEndAngle",
        value: function setEndAngle(angle) {
          this.endAngle = angle;
          return this;
        }
      }, {
        key: "anticlockwise",
        get: function get() {
          return this._anticlockwise;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._anticlockwise != value;
          this._anticlockwise = value;
          this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
        }
      }, {
        key: "setAnticlockwise",
        value: function setAnticlockwise(anticlockwise) {
          if (anticlockwise === undefined) {
            anticlockwise = true;
          }
          this.anticlockwise = anticlockwise;
          return this;
        }
      }, {
        key: "thickness",
        get: function get() {
          return this._thickness;
        },
        set: function set(value) {
          value = Clamp$b(value, 0, 1);
          this.dirty = this.dirty || this._thickness != value;
          this._thickness = value;
        }
      }, {
        key: "setThickness",
        value: function setThickness(thickness) {
          this.thickness = thickness;
          return this;
        }
      }, {
        key: "centerColor",
        get: function get() {
          return this._centerColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._centerColor != value;
          this._centerColor = value;
        }
      }, {
        key: "centerColor2",
        get: function get() {
          return this._centerColor2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._centerColor2 != value;
          this._centerColor2 = value;
        }
      }, {
        key: "setCenterColor",
        value: function setCenterColor(color, color2) {
          this.centerColor = color;
          this.centerColor2 = color2;
          return this;
        }
      }, {
        key: "textColor",
        get: function get() {
          return this._textColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._textColor != value;
          this._textColor = value;
        }
      }, {
        key: "setTextColor",
        value: function setTextColor(color) {
          this.textColor = color;
          return this;
        }
      }, {
        key: "textStrokeColor",
        get: function get() {
          return this._textStrokeColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._textStrokeColor != value;
          this._textStrokeColor = value;
        }
      }, {
        key: "textStrokeThickness",
        get: function get() {
          return this._textStrokeThickness;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._textStrokeThickness != value;
          this._textStrokeThickness = value;
        }
      }, {
        key: "setTextStrokeColor",
        value: function setTextStrokeColor(color, thickness) {
          if (thickness === undefined) {
            thickness = 2;
          }
          this.textStrokeColor = color;
          this.textStrokeThickness = thickness;
          return this;
        }
      }, {
        key: "textFont",
        get: function get() {
          return this._textFont;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._textFont != value;
          this._textFont = value;
        }
      }, {
        key: "setTextFont",
        value: function setTextFont(fontSize, fontFamily, fontStyle) {
          var font;
          if (fontFamily === undefined) {
            font = fontSize;
          } else {
            font = fontStyle + ' ' + fontSize + ' ' + fontFamily;
          }
          this.textFont = font;
          return this;
        }
      }, {
        key: "setTextFormatCallback",
        value: function setTextFormatCallback(callback, scope) {
          this.textFormatCallback = callback;
          this.textFormatCallbackScope = scope;
          return this;
        }
      }, {
        key: "updateTexture",
        value: function updateTexture() {
          this.clear();
          DrawContent$1.call(this);
          _get(_getPrototypeOf(CircularProgress.prototype), "updateTexture", this).call(this);
          return this;
        }
      }, {
        key: "getFormatText",
        value: function getFormatText(value) {
          if (value === undefined) {
            value = this.value;
          }
          var text;
          if (this.textFormatCallbackScope) {
            text = this.textFormatCallback(value);
          } else {
            text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
          }
          return text;
        }
      }]);
      return CircularProgress;
    }(ProgressBase(Canvas$1));
    var GetDeltaAngle = function GetDeltaAngle(startAngle, endAngle, anticlockwise) {
      if (anticlockwise) {
        if (startAngle <= endAngle) {
          return PI2 + startAngle - endAngle;
        } else {
          return startAngle - endAngle;
        }
      } else {
        if (startAngle >= endAngle) {
          return PI2 + endAngle - startAngle;
        } else {
          return endAngle - startAngle;
        }
      }
    };
  
    ObjectFactory.register('circularProgressCanvas', function (x, y, radius, barColor, value, config) {
      var gameObject = new CircularProgress(this.scene, x, y, radius, barColor, value, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CircularProgressCanvas', CircularProgress);
  
    var UpdateShapes = function UpdateShapes() {
      var skewX = this.skewX;
      var width = this.width - Math.abs(skewX);
      var height = this.height;
      var trackFill = this.getShape('trackFill');
      trackFill.fillStyle(this.trackColor);
      if (trackFill.isFilled) {
        BuildRectangle(trackFill,
        // lines
        0, 0,
        // x0, y0
        width, height,
        // x1, y1
        skewX // skewX
        ).close();
      }
      var bar = this.getShape('bar');
      bar.fillStyle(this.barColor);
      if (bar.isFilled) {
        var barX0, barX1;
        if (!this.rtl) {
          barX0 = 0;
          barX1 = width * this.value;
        } else {
          barX0 = width * (1 - this.value);
          barX1 = width;
        }
        BuildRectangle(bar,
        // lines
        barX0, 0,
        // x0, y0
        barX1, height,
        // x1, y1
        skewX // skew
        ).close();
      }
      var trackStroke = this.getShape('trackStroke');
      trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
      if (trackStroke.isStroked) {
        BuildRectangle(trackStroke,
        // lines            
        0, 0,
        // x0, y0
        width, height,
        // x1, y1
        skewX // skewX
        ).end();
      }
    };
    var BuildRectangle = function BuildRectangle(lines, x0, y0, x1, y1, skewX) {
      var startX = (x0 + x1) / 2; // Start x from middle
      if (skewX >= 0) {
        lines.startAt(startX + skewX, y0).lineTo(x1 + skewX, y0).lineTo(x1, y1).lineTo(x0, y1).lineTo(x0 + skewX, y0).lineTo(startX + skewX, y0);
      } else {
        lines.startAt(startX, y0).lineTo(x1, y0).lineTo(x1 - skewX, y1).lineTo(x0 - skewX, y1).lineTo(x0, y0).lineTo(startX, y0);
      }
      return lines;
    };
  
    var GetValue$2K = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$F = Phaser.Utils.Objects.IsPlainObject;
    var LineProgress$1 = /*#__PURE__*/function (_ProgressBase) {
      _inherits(LineProgress, _ProgressBase);
      function LineProgress(scene, x, y, width, height, barColor, value, config) {
        var _this;
        _classCallCheck(this, LineProgress);
        if (IsPlainObject$F(x)) {
          config = x;
          x = GetValue$2K(config, 'x', 0);
          y = GetValue$2K(config, 'y', 0);
          width = GetValue$2K(config, 'width', 2);
          height = GetValue$2K(config, 'height', 2);
          barColor = GetValue$2K(config, 'barColor', undefined);
          value = GetValue$2K(config, 'value', 0);
        } else if (IsPlainObject$F(width)) {
          config = width;
          width = GetValue$2K(config, 'width', 2);
          height = GetValue$2K(config, 'height', 2);
          barColor = GetValue$2K(config, 'barColor', undefined);
          value = GetValue$2K(config, 'value', 0);
        } else if (IsPlainObject$F(barColor)) {
          config = barColor;
          barColor = GetValue$2K(config, 'barColor', undefined);
          value = GetValue$2K(config, 'value', 0);
        }
        _this = _callSuper(this, LineProgress, [scene, x, y, width, height, config]);
        _this.type = 'rexLineProgress';
        _this.bootProgressBase(config);
        _this.addShape(new Lines().setName('trackFill')).addShape(new Lines().setName('bar')).addShape(new Lines().setName('trackStroke'));
        _this.setTrackColor(GetValue$2K(config, 'trackColor', undefined));
        _this.setBarColor(barColor);
        _this.setTrackStroke(GetValue$2K(config, 'trackStrokeThickness', 2), GetValue$2K(config, 'trackStrokeColor', undefined));
        _this.setSkewX(GetValue$2K(config, 'skewX', 0));
        _this.setRTL(GetValue$2K(config, 'rtl', false));
        _this.setValue(value);
        return _this;
      }
      _createClass(LineProgress, [{
        key: "trackColor",
        get: function get() {
          return this._trackColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._trackColor != value;
          this._trackColor = value;
        }
      }, {
        key: "setTrackColor",
        value: function setTrackColor(color) {
          this.trackColor = color;
          return this;
        }
      }, {
        key: "trackStrokeColor",
        get: function get() {
          return this._trackStrokeColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._trackStrokeColor != value;
          this._trackStrokeColor = value;
        }
      }, {
        key: "trackStrokeThickness",
        get: function get() {
          return this._trackStrokeThickness;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._trackStrokeThickness != value;
          this._trackStrokeThickness = value;
        }
      }, {
        key: "setTrackStroke",
        value: function setTrackStroke(lineWidth, color) {
          this.trackStrokeThickness = lineWidth;
          this.trackStrokeColor = color;
          return this;
        }
      }, {
        key: "barColor",
        get: function get() {
          return this._barColor;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._barColor != value;
          this._barColor = value;
        }
      }, {
        key: "setBarColor",
        value: function setBarColor(color) {
          this.barColor = color;
          return this;
        }
      }, {
        key: "skewX",
        get: function get() {
          return this._skewX;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._skewX != value;
          this._skewX = value;
        }
      }, {
        key: "setSkewX",
        value: function setSkewX(value) {
          this.skewX = value;
          return this;
        }
      }, {
        key: "rtl",
        get: function get() {
          return this._rtl;
        },
        set: function set(value) {
          value = !!value;
          this.dirty = this.dirty || this._rtl != value;
          this._rtl = value;
        }
      }, {
        key: "setRTL",
        value: function setRTL(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.rtl = enable;
          return this;
        }
      }]);
      return LineProgress;
    }(ProgressBase(BaseShapes));
    var Methods$a = {
      updateShapes: UpdateShapes
    };
    Object.assign(LineProgress$1.prototype, Methods$a);
  
    ObjectFactory.register('lineProgress', function (x, y, width, height, barColor, value, config) {
      var gameObject = new LineProgress$1(this.scene, x, y, width, height, barColor, value, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.LineProgress', LineProgress$1);
  
    var AddPolygonPath = function AddPolygonPath(context, points) {
      context.save();
      context.beginPath();
      var point = points[0];
      context.moveTo(point.x, point.y);
      for (var i = 1, cnt = points.length; i < cnt; i++) {
        point = points[i];
        context.lineTo(point.x, point.y);
      }
      context.closePath();
      context.restore();
    };
  
    var DrawPolygon = function DrawPolygon(canvas, context, points, fillStyle, strokeStyle, lineWidth, lineJoin) {
      if (lineJoin === undefined) {
        lineJoin = 'round';
      }
      AddPolygonPath(context, points);
      context.lineJoin = lineJoin;
      if (fillStyle != null) {
        context.fillStyle = fillStyle;
        context.fill();
      }
      if (strokeStyle != null) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = lineWidth;
        context.stroke();
      }
    };
  
    var DrawContent = function DrawContent() {
      var skewX = this.skewX;
      var width = this.width - Math.abs(skewX);
      var height = this.height;
      var canvas = this.canvas,
        context = this.context;
  
      // Has track
      if (this.trackColor || this.trackStrokeColor) {
        BuildPolygon(0, 0,
        // x0, y0
        width, height,
        // x1, y1
        skewX,
        // skewX
        this.trackPoints);
      }
  
      // Has bar
      var barX0, barX1;
      if (this.barColor) {
        if (!this.rtl) {
          barX0 = 0;
          barX1 = width * this.value;
        } else {
          barX0 = width * (1 - this.value);
          barX1 = width;
        }
        BuildPolygon(barX0, 0,
        // x0, y0
        barX1, height,
        // x1, y1
        skewX,
        // skewX
        this.barPoints);
      }
      if (this.trackColor) {
        context.save();
        DrawPolygon(canvas, context, this.trackPoints, this.trackColor);
        context.restore();
      }
      if (this.barColor) {
        context.save();
        var style;
        if (this.barColor2) {
          var grd;
          if (this.isHorizontalGradient) {
            var helfHeight = height / 2;
            grd = context.createLinearGradient(barX0, helfHeight, barX1, helfHeight);
          } else {
            var helfWidth = width / 2;
            grd = context.createLinearGradient(helfWidth, 0, helfWidth, height);
          }
          grd.addColorStop(0, this.rtl ? this.barColor : this.barColor2);
          grd.addColorStop(1, this.rtl ? this.barColor2 : this.barColor);
          style = grd;
        } else {
          style = this.barColor;
        }
        DrawPolygon(canvas, context, this.barPoints, style);
        context.restore();
      }
      if (this.trackStrokeColor && this.trackStrokeThickness > 0) {
        context.save();
        DrawPolygon(canvas, context, this.trackPoints, undefined, this.trackStrokeColor, this.trackStrokeThickness);
        context.restore();
      }
    };
    var BuildPolygon = function BuildPolygon(x0, y0, x1, y1, skewX, out) {
      if (out === undefined) {
        out = [];
      }
      out.length = 4;
      for (var i = 0; i < 4; i++) {
        if (!out[i]) {
          out[i] = {};
        }
      }
      var p;
      if (skewX >= 0) {
        p = out[0];
        p.x = x0 + skewX;
        p.y = y0;
        p = out[1];
        p.x = x1 + skewX;
        p.y = y0;
        p = out[2];
        p.x = x1;
        p.y = y1;
        p = out[3];
        p.x = x0;
        p.y = y1;
      } else {
        p = out[0];
        p.x = x0;
        p.y = y0;
        p = out[1];
        p.x = x1;
        p.y = y0;
        p = out[2];
        p.x = x1 - skewX;
        p.y = y1;
        p = out[3];
        p.x = x0 - skewX;
        p.y = y1;
      }
      return out;
    };
  
    var GetValue$2J = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$E = Phaser.Utils.Objects.IsPlainObject;
    var LineProgress = /*#__PURE__*/function (_ProgressBase) {
      _inherits(LineProgress, _ProgressBase);
      function LineProgress(scene, x, y, width, height, barColor, value, config) {
        var _this;
        _classCallCheck(this, LineProgress);
        if (IsPlainObject$E(x)) {
          config = x;
          x = GetValue$2J(config, 'x', 0);
          y = GetValue$2J(config, 'y', 0);
          width = GetValue$2J(config, 'width', 2);
          height = GetValue$2J(config, 'height', 2);
          barColor = GetValue$2J(config, 'barColor', undefined);
          value = GetValue$2J(config, 'value', 0);
        } else if (IsPlainObject$E(width)) {
          config = width;
          width = GetValue$2J(config, 'width', 2);
          height = GetValue$2J(config, 'height', 2);
          barColor = GetValue$2J(config, 'barColor', undefined);
          value = GetValue$2J(config, 'value', 0);
        } else if (IsPlainObject$E(barColor)) {
          config = barColor;
          barColor = GetValue$2J(config, 'barColor', undefined);
          value = GetValue$2J(config, 'value', 0);
        }
        _this = _callSuper(this, LineProgress, [scene, x, y, width, height]);
        _this.type = 'rexLineProgressCanvas';
        _this.trackPoints = [];
        _this.barPoints = [];
        _this.bootProgressBase(config);
        _this.setTrackColor(GetValue$2J(config, 'trackColor', undefined));
        _this.setBarColor(barColor, GetValue$2J(config, 'barColor2', undefined), GetValue$2J(config, 'isHorizontalGradient', undefined));
        _this.setTrackStroke(GetValue$2J(config, 'trackStrokeThickness', 2), GetValue$2J(config, 'trackStrokeColor', undefined));
        _this.setSkewX(GetValue$2J(config, 'skewX', 0));
        _this.setRTL(GetValue$2J(config, 'rtl', false));
        _this.setValue(value);
        return _this;
      }
      _createClass(LineProgress, [{
        key: "trackColor",
        get: function get() {
          return this._trackColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._trackColor != value;
          this._trackColor = value;
        }
      }, {
        key: "setTrackColor",
        value: function setTrackColor(color) {
          this.trackColor = color;
          return this;
        }
      }, {
        key: "trackStrokeColor",
        get: function get() {
          return this._trackStrokeColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._trackStrokeColor != value;
          this._trackStrokeColor = value;
        }
      }, {
        key: "trackStrokeThickness",
        get: function get() {
          return this._trackStrokeThickness;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._trackStrokeThickness != value;
          this._trackStrokeThickness = value;
        }
      }, {
        key: "setTrackStroke",
        value: function setTrackStroke(lineWidth, color) {
          this.trackStrokeThickness = lineWidth;
          this.trackStrokeColor = color;
          return this;
        }
      }, {
        key: "barColor",
        get: function get() {
          return this._barColor;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._barColor != value;
          this._barColor = value;
        }
      }, {
        key: "barColor2",
        get: function get() {
          return this._barColor2;
        },
        set: function set(value) {
          value = GetStyle(value, this.canvas, this.context);
          this.dirty = this.dirty || this._barColor2 != value;
          this._barColor2 = value;
        }
      }, {
        key: "isHorizontalGradient",
        get: function get() {
          return this._isHorizontalGradient;
        },
        set: function set(value) {
          this.dirty |= this._isHorizontalGradient != value;
          this._isHorizontalGradient = value;
        }
      }, {
        key: "setBarColor",
        value: function setBarColor(color, color2, isHorizontalGradient) {
          if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
          }
          this.barColor = color;
          this.barColor2 = color2;
          this.isHorizontalGradient = isHorizontalGradient;
          return this;
        }
      }, {
        key: "skewX",
        get: function get() {
          return this._skewX;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._skewX != value;
          this._skewX = value;
        }
      }, {
        key: "setSkewX",
        value: function setSkewX(value) {
          this.skewX = value;
          return this;
        }
      }, {
        key: "rtl",
        get: function get() {
          return this._rtl;
        },
        set: function set(value) {
          value = !!value;
          this.dirty = this.dirty || this._rtl != value;
          this._rtl = value;
        }
      }, {
        key: "setRTL",
        value: function setRTL(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.rtl = enable;
          return this;
        }
      }, {
        key: "updateTexture",
        value: function updateTexture() {
          this.clear();
          DrawContent.call(this);
          _get(_getPrototypeOf(LineProgress.prototype), "updateTexture", this).call(this);
          return this;
        }
      }]);
      return LineProgress;
    }(ProgressBase(Canvas$1));
  
    ObjectFactory.register('circularProgressCanvas', function (x, y, width, height, barColor, value, config) {
      var gameObject = new LineProgress(this.scene, x, y, width, height, barColor, value, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.LineProgressCanvas', LineProgress);
  
    Phaser.Math.Wrap;
    var Linear$7 = Phaser.Math.Linear;
    var DrawFitTriangle = function DrawFitTriangle() {
      var triangle = this.getShape('triangle');
      var padding = this.padding;
      var right = this.width - padding.right;
      var left = 0 + padding.left;
      var bottom = this.height - padding.bottom;
      var top = 0 + padding.top;
      var centerX = (left + right) / 2;
      var centerY = (top + bottom) / 2;
      var points = {
        0: {
          // right
          a: {
            x: left,
            y: top
          },
          b: {
            x: right,
            y: centerY
          },
          c: {
            x: left,
            y: bottom
          }
        },
        1: {
          // down
          a: {
            x: left,
            y: top
          },
          b: {
            x: centerX,
            y: bottom
          },
          c: {
            x: right,
            y: top
          }
        },
        2: {
          // left
          a: {
            x: right,
            y: top
          },
          b: {
            x: left,
            y: centerY
          },
          c: {
            x: right,
            y: bottom
          }
        },
        3: {
          // up
          a: {
            x: left,
            y: bottom
          },
          b: {
            x: centerX,
            y: top
          },
          c: {
            x: right,
            y: bottom
          }
        }
      };
      var pax, pay, pbx, pby, pcx, pcy;
      if (this.previousDirection === undefined) {
        var currentTrianglePoints = points[this.direction];
        var pa = currentTrianglePoints.a,
          pb = currentTrianglePoints.b,
          pc = currentTrianglePoints.c;
        pax = pa.x;
        pay = pa.y;
        pbx = pb.x;
        pby = pb.y;
        pcx = pc.x;
        pcy = pc.y;
      } else {
        var p0 = points[this.previousDirection];
        var p1 = points[this.direction];
        var t = this.easeDirectionProgress;
        pax = Linear$7(p0.a.x, p1.a.x, t);
        pay = Linear$7(p0.a.y, p1.a.y, t);
        pbx = Linear$7(p0.b.x, p1.b.x, t);
        pby = Linear$7(p0.b.y, p1.b.y, t);
        pcx = Linear$7(p0.c.x, p1.c.x, t);
        pcy = Linear$7(p0.c.y, p1.c.y, t);
      }
      triangle.startAt(pax, pay).lineTo(pbx, pby).lineTo(pcx, pcy);
      if (!this.arrowOnly) {
        triangle.close();
      } else {
        triangle.end();
      }
    };
  
    var DegToRad$8 = Phaser.Math.DegToRad;
    var Rad120 = DegToRad$8(120);
    var DrawCircleVerticesTriangle = function DrawCircleVerticesTriangle(triangle) {
      var triangle = this.getShape('triangle');
      var centerX = this.width / 2,
        centerY = this.height / 2;
      var radius = Math.min(centerX, centerY) * this.radius,
        verticeRotation = this.verticeRotation;
      triangle.startAt(centerX + radius * Math.cos(verticeRotation + Rad120), centerY + radius * Math.sin(verticeRotation + Rad120)).lineTo(centerX + radius * Math.cos(verticeRotation), centerY + radius * Math.sin(verticeRotation)).lineTo(centerX + radius * Math.cos(verticeRotation - Rad120), centerY + radius * Math.sin(verticeRotation - Rad120));
      if (!this.arrowOnly) {
        triangle.close();
      } else {
        triangle.end();
      }
    };
  
    var ShapesUpdateMethods$1 = {
      buildShapes: function buildShapes() {
        this.addShape(new Lines().setName('triangle'));
      },
      updateShapes: function updateShapes() {
        // Set style
        var triangle = this.getShape('triangle');
        if (!this.arrowOnly) {
          triangle.fillStyle(this.fillColor, this.fillAlpha).lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
        } else {
          triangle.fillStyle().lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
        }
  
        // Set points
        if (this.shapeMode === 0) {
          DrawFitTriangle.call(this);
        } else {
          DrawCircleVerticesTriangle.call(this);
        }
      }
    };
  
    var EaseDirectionMethods = {
      setEaseDuration: function setEaseDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.easeDuration = duration;
        return this;
      },
      playEaseDirectionation: function playEaseDirectionation() {
        if (this.easeDirectionProgressTask === undefined) {
          this.easeDirectionProgressTask = new EaseValueTask(this, {
            eventEmitter: null
          });
        }
        this.easeDirectionProgressTask.restart({
          key: 'easeDirectionProgress',
          from: 0,
          to: 1,
          duration: this.easeDuration
        });
        return this;
      },
      stopEaseDirection: function stopEaseDirection() {
        if (this.easeDirectionProgressTask === undefined) {
          return this;
        }
        this.easeDirectionProgressTask.stop();
        return this;
      }
    };
  
    var GetValue$2I = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$D = Phaser.Utils.Objects.IsPlainObject;
    var DegToRad$7 = Phaser.Math.DegToRad;
    var RadToDeg$6 = Phaser.Math.RadToDeg;
    var Triangle = /*#__PURE__*/function (_BaseShapes) {
      _inherits(Triangle, _BaseShapes);
      function Triangle(scene, x, y, width, height, fillColor, fillAlpha) {
        var _this;
        _classCallCheck(this, Triangle);
        var strokeColor, strokeAlpha, strokeWidth, arrowOnly;
        var direction, easeDuration, padding;
        var radius;
        if (IsPlainObject$D(x)) {
          var config = x;
          x = config.x;
          y = config.y;
          width = config.width;
          height = config.height;
          fillColor = config.color;
          fillAlpha = config.alpha;
          strokeColor = config.strokeColor;
          strokeAlpha = config.strokeAlpha;
          strokeWidth = config.strokeWidth;
          arrowOnly = config.arrowOnly;
          direction = config.direction;
          easeDuration = config.easeDuration;
          padding = config.padding;
          radius = config.radius;
        }
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = width;
        }
        if (arrowOnly === undefined) {
          arrowOnly = false;
        }
        if (direction === undefined) {
          direction = 0;
        }
        if (easeDuration === undefined) {
          easeDuration = 0;
        }
        if (padding === undefined) {
          padding = 0;
        }
        if (radius === undefined) {
          radius = undefined;
        }
        _this = _callSuper(this, Triangle, [scene, x, y, width, height]);
        _this.type = 'rexTriangle';
        _this.setFillStyle(fillColor, fillAlpha);
        if (strokeColor !== undefined && strokeWidth === undefined) {
          strokeWidth = 2;
        }
        _this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
        _this.setArrowOnly(arrowOnly);
        _this.setDirection(direction, easeDuration);
        _this.setPadding(padding);
        _this.setRadius(radius);
        _this.buildShapes();
        return _this;
      }
      _createClass(Triangle, [{
        key: "arrowOnly",
        get: function get() {
          return this._arrowOnly;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._arrowOnly != value;
          this._arrowOnly = value;
        }
      }, {
        key: "setArrowOnly",
        value: function setArrowOnly(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.arrowOnly = enable;
          return this;
        }
      }, {
        key: "direction",
        get: function get() {
          return this._direction;
        },
        set: function set(value) {
          value = ParseDirection(value);
          if (this._direction === value) {
            return;
          }
          if (this.easeDuration > 0 && this._direction !== undefined) {
            this.previousDirection = this._direction;
          } else {
            this.previousDirection = undefined;
          }
          this._direction = value;
          this.verticeAngle = value * 90;
          this.dirty = true;
          if (this.previousDirection !== undefined) {
            this.playEaseDirectionation();
          } else {
            this.stopEaseDirection();
          }
        }
      }, {
        key: "setDirection",
        value: function setDirection(direction, easeDuration) {
          if (easeDuration !== undefined) {
            this.setEaseDuration(easeDuration);
          }
          this.direction = direction;
          return this;
        }
      }, {
        key: "toggleDirection",
        value: function toggleDirection(easeDuration) {
          this.setDirection(this.direction + 2, easeDuration);
          return this;
        }
      }, {
        key: "easeDirectionProgress",
        get: function get() {
          return this._easeDirectionProgress;
        },
        set: function set(value) {
          if (this._easeDirectionProgress === value) {
            return;
          }
          this._easeDirectionProgress = value;
          this.dirty = true;
        }
      }, {
        key: "setPadding",
        value: function setPadding(left, top, right, bottom) {
          if (_typeof(left) === 'object') {
            var config = left;
  
            //  If they specify x and/or y this applies to all
            var x = GetValue$2I(config, 'x', null);
            if (x !== null) {
              left = x;
              right = x;
            } else {
              left = GetValue$2I(config, 'left', 0);
              right = GetValue$2I(config, 'right', left);
            }
            var y = GetValue$2I(config, 'y', null);
            if (y !== null) {
              top = y;
              bottom = y;
            } else {
              top = GetValue$2I(config, 'top', 0);
              bottom = GetValue$2I(config, 'bottom', top);
            }
          } else {
            if (left === undefined) {
              left = 0;
            }
            if (top === undefined) {
              top = left;
            }
            if (right === undefined) {
              right = left;
            }
            if (bottom === undefined) {
              bottom = top;
            }
          }
          if (this.padding === undefined) {
            this.padding = {};
          }
          this.dirty = this.dirty || this.padding.left != left || this.padding.top != top || this.padding.right != right || this.padding.bottom != bottom;
          this.padding.left = left;
          this.padding.top = top;
          this.padding.right = right;
          this.padding.bottom = bottom;
  
          // Switch to fit mode
          this.setRadius();
          return this;
        }
      }, {
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._radius != value;
          this._radius = value;
        }
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          this.radius = radius;
  
          // 0: fit mode
          // 1: circle mode
          this.shapeMode = radius == null ? 0 : 1;
          return this;
        }
      }, {
        key: "verticeRotation",
        get: function get() {
          return this._verticeRotation;
        },
        set: function set(value) {
          this.dirty = this.dirty || this._verticeRotation != value;
          this._verticeRotation = value;
        }
      }, {
        key: "setVerticeRotation",
        value: function setVerticeRotation(rotation) {
          this.verticeRotation = rotation;
          return this;
        }
      }, {
        key: "verticeAngle",
        get: function get() {
          return RadToDeg$6(this.verticeRotation);
        },
        set: function set(value) {
          this.verticeRotation = DegToRad$7(value);
        }
      }, {
        key: "setVerticeAngle",
        value: function setVerticeAngle(angle) {
          this.verticeAngle = angle;
          return this;
        }
      }]);
      return Triangle;
    }(BaseShapes);
    var DirectionNameMap = {
      right: 0,
      down: 1,
      left: 2,
      up: 3
    };
    var ParseDirection = function ParseDirection(direction) {
      if (typeof direction === 'string') {
        direction = DirectionNameMap[direction];
      }
      direction = direction % 4;
      return direction;
    };
    Object.assign(Triangle.prototype, ShapesUpdateMethods$1, EaseDirectionMethods);
  
    ObjectFactory.register('triangle', function (x, y, width, height, fillColor, fillAlpha) {
      var gameObject = new Triangle(this.scene, x, y, width, height, fillColor, fillAlpha);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Triangle', Triangle);
  
    CheckP3Version();
    var Zone$1 = Phaser.GameObjects.Zone;
    var AddItem = Phaser.Utils.Array.Add;
    var RemoveItem$6 = Phaser.Utils.Array.Remove;
    var Base$1 = /*#__PURE__*/function (_Zone) {
      _inherits(Base, _Zone);
      function Base(scene, x, y, width, height) {
        var _this;
        _classCallCheck(this, Base);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 1;
        }
        if (height === undefined) {
          height = 1;
        }
        _this = _callSuper(this, Base, [scene, x, y, width, height]);
        _this.children = [];
        return _this;
      }
      _createClass(Base, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (fromScene) {
            // Stop scene
            var child;
            for (var i = this.children.length - 1; i >= 0; i--) {
              child = this.children[i];
              if (!child.parentContainer &&
              // Not in container
              !child.displayList // Not in scene, neither in layer
              ) {
                // Destroy child which is not in scene, container, or layer manually
                child.destroy(fromScene);
              }
            }
          }
  
          // Destroy/remove children
          this.clear(!fromScene);
          _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "contains",
        value: function contains(gameObject) {
          return this.children.indexOf(gameObject) !== -1;
        }
      }, {
        key: "add",
        value: function add(gameObjects) {
          var parent = this;
          AddItem(this.children, gameObjects, 0,
          // Callback of item added
          function (gameObject) {
            gameObject.once('destroy', parent.onChildDestroy, parent);
          }, this);
          return this;
        }
      }, {
        key: "remove",
        value: function remove(gameObjects, destroyChild) {
          var parent = this;
          RemoveItem$6(this.children, gameObjects,
          // Callback of item removed
          function (gameObject) {
            gameObject.off('destroy', parent.onChildDestroy, parent);
            if (destroyChild) {
              gameObject.destroy();
            }
          });
          return this;
        }
      }, {
        key: "onChildDestroy",
        value: function onChildDestroy(child, fromScene) {
          // Only remove reference
          this.remove(child, false);
        }
      }, {
        key: "clear",
        value: function clear(destroyChild) {
          var parent = this;
          var gameObject;
          for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            gameObject = this.children[i];
            gameObject.off('destroy', parent.onChildDestroy, parent);
            if (destroyChild) {
              gameObject.destroy();
            }
          }
          this.children.length = 0;
          return this;
        }
      }]);
      return Base;
    }(Zone$1);
    var Components$1 = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Base$1, [Components$1.Alpha, Components$1.Flip]);
  
    var GetParent$1 = function GetParent(gameObject, name) {
      var parent;
      if (name === undefined) {
        if (gameObject.hasOwnProperty('rexContainer')) {
          parent = gameObject.rexContainer.parent;
        }
      } else {
        parent = GetParent(gameObject);
        while (parent) {
          if (parent.name === name) {
            break;
          }
          parent = GetParent(parent);
        }
      }
      return parent;
    };
    var GetTopmostParent$1 = function GetTopmostParent(gameObject) {
      var parent = GetParent$1(gameObject);
      while (parent) {
        gameObject = parent;
        parent = GetParent$1(parent);
      }
      return gameObject;
    };
  
    var DegToRad$6 = Phaser.Math.DegToRad;
    var RadToDeg$5 = Phaser.Math.RadToDeg;
    var GetLocalState = function GetLocalState(gameObject) {
      if (!gameObject.hasOwnProperty('rexContainer')) {
        var rexContainer = {
          parent: null,
          self: null,
          layer: null,
          x: 0,
          y: 0,
          syncPosition: true,
          rotation: 0,
          syncRotation: true,
          scaleX: 0,
          scaleY: 0,
          syncScale: true,
          alpha: 0,
          syncAlpha: true,
          syncScrollFactor: true,
          syncCameraFilter: true,
          syncDisplayList: true,
          visible: true,
          active: true
        };
        Object.defineProperty(rexContainer, 'angle', {
          get: function get() {
            return RadToDeg$5(this.rotation);
          },
          set: function set(value) {
            this.rotation = DegToRad$6(value);
          }
        });
        Object.defineProperty(rexContainer, 'displayWidth', {
          get: function get() {
            return gameObject.width * this.scaleX;
          },
          set: function set(width) {
            this.scaleX = width / gameObject.width;
          }
        });
        Object.defineProperty(rexContainer, 'displayHeight', {
          get: function get() {
            return gameObject.height * this.scaleY;
          },
          set: function set(height) {
            this.scaleY = height / gameObject.height;
          }
        });
        gameObject.rexContainer = rexContainer;
      }
      return gameObject.rexContainer;
    };
  
    var Parent = {
      setParent: function setParent(gameObject, parent) {
        if (parent === undefined) {
          parent = this;
        }
        var localState = GetLocalState(gameObject);
        if (parent) {
          // Add to parent
          localState.parent = parent;
          localState.self = gameObject;
        } else {
          // Remove from parent
          localState.parent = null;
          localState.self = null;
        }
        return this;
      },
      getParent: function getParent(gameObject, name) {
        if (typeof gameObject === 'string') {
          name = gameObject;
          gameObject = undefined;
        }
        if (gameObject === undefined) {
          gameObject = this;
        }
        return GetParent$1(gameObject, name);
      },
      getTopmostParent: function getTopmostParent(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        return GetTopmostParent$1(gameObject);
      }
    };
  
    var GetValue$2H = Phaser.Utils.Objects.GetValue;
    var BaseAdd = Base$1.prototype.add;
    var Add$8 = function Add(gameObject, config) {
      this.setParent(gameObject);
      var state = GetLocalState(gameObject);
      SetupSyncFlags(state, config);
      this.resetChildState(gameObject) // Reset local state of child
      .updateChildVisible(gameObject) // Apply parent's visible to child
      .updateChildActive(gameObject) // Apply parent's active to child
      .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
      .updateChildMask(gameObject) // Apply parent's mask to child
      .updateCameraFilter(gameObject); // Apply parent's cameraFilter to child
  
      BaseAdd.call(this, gameObject);
      SyncDisplayList$1.call(this, gameObject, state);
      return this;
    };
    var AddLocal = function AddLocal(gameObject, config) {
      this.setParent(gameObject);
  
      // Set local state from child directly
      var state = GetLocalState(gameObject);
      SetupSyncFlags(state, config);
      // Position
      state.x = gameObject.x;
      state.y = gameObject.y;
      state.rotation = gameObject.rotation;
      state.scaleX = gameObject.scaleX;
      state.scaleY = gameObject.scaleY;
      // Alpha
      state.alpha = gameObject.alpha;
      // Visible
      state.visible = gameObject.visible;
      // Active
      state.active = gameObject.active;
      this.updateChildPosition(gameObject).updateChildAlpha(gameObject).updateChildVisible(gameObject) // Apply parent's visible to child
      .updateChildActive(gameObject) // Apply parent's active to child
      .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
      .updateChildMask(gameObject); // Apply parent's mask to child
  
      BaseAdd.call(this, gameObject);
      SyncDisplayList$1.call(this, gameObject, state);
      return this;
    };
    var SetupSyncFlags = function SetupSyncFlags(state, config) {
      if (config === undefined) {
        config = true;
      }
      if (typeof config === 'boolean') {
        state.syncPosition = config;
        state.syncRotation = config;
        state.syncScale = config;
        state.syncAlpha = config;
        state.syncScrollFactor = config;
        state.syncCameraFilter = config;
        state.syncDisplayList = config;
      } else {
        state.syncPosition = GetValue$2H(config, 'syncPosition', true);
        state.syncRotation = GetValue$2H(config, 'syncRotation', true);
        state.syncScale = GetValue$2H(config, 'syncScale', true);
        state.syncAlpha = GetValue$2H(config, 'syncAlpha', true);
        state.syncScrollFactor = GetValue$2H(config, 'syncScrollFactor', true);
        state.syncCameraFilter = GetValue$2H(config, 'syncCameraFilter', true);
        state.syncDisplayList = GetValue$2H(config, 'syncDisplayList', true);
      }
    };
    var SyncDisplayList$1 = function SyncDisplayList(gameObject, state) {
      this.addToParentContainer(gameObject); // Sync parent's container to child
  
      if (state.syncDisplayList) {
        this.addToPatentLayer(gameObject); // Sync parent's layer to child
      }
      this.addToRenderLayer(gameObject); // Sync parent's render-layer
    };
    var AddChild$2 = {
      // Can override this method
      add: function add(gameObject) {
        if (Array.isArray(gameObject)) {
          this.addMultiple(gameObject);
        } else {
          Add$8.call(this, gameObject);
        }
        return this;
      },
      // Don't override this method
      pin: function pin(gameObject, config) {
        if (Array.isArray(gameObject)) {
          this.addMultiple(gameObject, config);
        } else {
          Add$8.call(this, gameObject, config);
        }
        return this;
      },
      addMultiple: function addMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$8.call(this, gameObjects[i]);
        }
        return this;
      },
      addLocal: function addLocal(gameObject) {
        if (Array.isArray(gameObject)) {
          this.addMultiple(gameObject);
        } else {
          AddLocal.call(this, gameObject);
        }
        return this;
      },
      // Don't override this method
      pinLocal: function pinLocal(gameObject, config) {
        if (Array.isArray(gameObject)) {
          this.addMultiple(gameObject, config);
        } else {
          AddLocal.call(this, gameObject, config);
        }
        return this;
      },
      addLocalMultiple: function addLocalMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          AddLocal.call(this, gameObjects[i]);
        }
        return this;
      }
    };
  
    var BaseRemove = Base$1.prototype.remove;
    var BaseClear = Base$1.prototype.clear;
    var RemoveChild$1 = {
      // Can override this method
      remove: function remove(gameObject, destroyChild) {
        if (GetParent$1(gameObject) !== this) {
          return this;
        }
        this.setParent(gameObject, null);
        if (!destroyChild) {
          this.removeFromRenderLayer(gameObject);
        }
        BaseRemove.call(this, gameObject, destroyChild);
        return this;
      },
      // Don't override this method
      unpin: function unpin(gameObject, destroyChild) {
        if (GetParent$1(gameObject) !== this) {
          return this;
        }
        this.setParent(gameObject, null);
        if (!destroyChild) {
          this.removeFromRenderLayer(gameObject);
        }
        BaseRemove.call(this, gameObject, destroyChild);
        return this;
      },
      clear: function clear(destroyChild) {
        var children = this.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          this.setParent(child, null);
          if (!destroyChild) {
            this.removeFromRenderLayer(child);
          }
        }
        BaseClear.call(this, destroyChild);
        return this;
      }
    };
  
    var ChildState = {
      getLocalState: function getLocalState(gameObject) {
        return GetLocalState(gameObject);
      },
      resetChildState: function resetChildState(gameObject) {
        this.resetChildPositionState(gameObject).resetChildVisibleState(gameObject).resetChildAlphaState(gameObject).resetChildActiveState(gameObject);
        return this;
      },
      resetChildrenState: function resetChildrenState(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          this.resetChildState(gameObjects[i]);
        }
        return this;
      },
      syncProperties: function syncProperties() {
        this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask();
        return this;
      }
    };
  
    var Transform = {
      worldToLocal: function worldToLocal(point) {
        // Transform
        point.x -= this.x;
        point.y -= this.y;
  
        // Rotate
        var c = Math.cos(-this.rotation);
        var s = Math.sin(-this.rotation);
        var tx = point.x;
        var ty = point.y;
        point.x = tx * c - ty * s;
        point.y = tx * s + ty * c;
  
        // Scale
        point.x /= this.scaleX;
        point.y /= this.scaleY;
        return point;
      },
      localToWorld: function localToWorld(point) {
        // Scale
        point.x *= this.scaleX;
        point.y *= this.scaleY;
  
        // Rotate
        var c = Math.cos(this.rotation);
        var s = Math.sin(this.rotation);
        var tx = point.x;
        var ty = point.y;
        point.x = tx * c - ty * s;
        point.y = tx * s + ty * c;
  
        // Transform
        point.x += this.x;
        point.y += this.y;
        return point;
      }
    };
  
    var GetScale = function GetScale(a, b) {
      if (a === b) {
        return 1;
      } else {
        return a / b;
      }
    };
  
    var Position = {
      updateChildPosition: function updateChildPosition(child) {
        if (child.isRexContainerLite) {
          child.syncChildrenEnable = false;
        }
        var localState = GetLocalState(child);
        var parent = localState.parent;
        if (localState.syncPosition) {
          child.x = localState.x;
          child.y = localState.y;
          parent.localToWorld(child);
        }
        if (localState.syncRotation) {
          child.rotation = localState.rotation + parent.rotation;
        }
        if (localState.syncScale) {
          child.scaleX = localState.scaleX * parent.scaleX;
          child.scaleY = localState.scaleY * parent.scaleY;
        }
        if (child.isRexContainerLite) {
          child.syncChildrenEnable = true;
          child.syncPosition();
        }
        return this;
      },
      syncPosition: function syncPosition() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildPosition, this);
        }
        return this;
      },
      resetChildPositionState: function resetChildPositionState(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        localState.x = child.x;
        localState.y = child.y;
        parent.worldToLocal(localState);
        localState.scaleX = GetScale(child.scaleX, parent.scaleX);
        localState.scaleY = GetScale(child.scaleY, parent.scaleY);
        localState.rotation = child.rotation - parent.rotation;
        return this;
      },
      setChildPosition: function setChildPosition(child, x, y) {
        child.x = x;
        child.y = y;
        this.resetChildPositionState(child);
        return this;
      },
      setChildLocalPosition: function setChildLocalPosition(child, x, y) {
        var localState = GetLocalState(child);
        localState.x = x;
        localState.y = y;
        this.updateChildPosition(child);
        return this;
      },
      resetLocalPositionState: function resetLocalPositionState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildPositionState(this);
        }
        return this;
      },
      getChildLocalX: function getChildLocalX(child) {
        var localState = GetLocalState(child);
        return localState.x;
      },
      getChildLocalY: function getChildLocalY(child) {
        var localState = GetLocalState(child);
        return localState.y;
      }
    };
  
    var DegToRad$5 = Phaser.Math.DegToRad;
    var Rotation = {
      updateChildRotation: function updateChildRotation(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        if (localState.syncRotation) {
          child.rotation = parent.rotation + localState.rotation;
        }
        return this;
      },
      syncRotation: function syncRotation() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildRotation, this);
        }
        return this;
      },
      resetChildRotationState: function resetChildRotationState(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        localState.rotation = child.rotation - parent.rotation;
        return this;
      },
      setChildRotation: function setChildRotation(child, rotation) {
        child.rotation = rotation;
        this.resetChildRotationState(child);
        return this;
      },
      setChildAngle: function setChildAngle(child, angle) {
        child.angle = angle;
        this.resetChildRotationState(child);
        return this;
      },
      setChildLocalRotation: function setChildLocalRotation(child, rotation) {
        var localState = GetLocalState(child);
        localState.rotation = rotation;
        this.updateChildRotation(child);
        return this;
      },
      setChildLocalAngle: function setChildLocalAngle(child, angle) {
        var localState = GetLocalState(child);
        localState.rotation = DegToRad$5(angle);
        this.updateChildRotation(child);
        return this;
      },
      resetLocalRotationState: function resetLocalRotationState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildRotationState(this);
        }
        return this;
      },
      getChildLocalRotation: function getChildLocalRotation(child) {
        var localState = GetLocalState(child);
        return localState.rotation;
      }
    };
  
    var Scale$1 = {
      updateChildScale: function updateChildScale(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        if (state.syncScale) {
          child.scaleX = parent.scaleX * state.scaleX;
          child.scaleY = parent.scaleY * state.scaleY;
        }
        return this;
      },
      syncScale: function syncScale() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildScale, this);
        }
        return this;
      },
      resetChildScaleState: function resetChildScaleState(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        state.scaleX = GetScale(child.scaleX, parent.scaleX);
        state.scaleY = GetScale(child.scaleY, parent.scaleY);
        return this;
      },
      setChildScale: function setChildScale(child, scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }
        child.scaleX = scaleX;
        child.scaleY = scaleY;
        this.resetChildScaleState(child);
        return this;
      },
      setChildLocalScale: function setChildLocalScale(child, scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }
        var state = GetLocalState(child);
        state.scaleX = scaleX;
        state.scaleY = scaleY;
        this.updateChildScale(child);
        return this;
      },
      setChildDisplaySize: function setChildDisplaySize(child, width, height) {
        child.setDisplaySize(width, height);
        this.resetChildScaleState(child);
        return this;
      },
      resetLocalScaleState: function resetLocalScaleState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildScaleState(this);
        }
        return this;
      },
      getChildLocalScaleX: function getChildLocalScaleX(child) {
        var localState = GetLocalState(child);
        return localState.scaleX;
      },
      getChildLocalScaleY: function getChildLocalScaleY(child) {
        var localState = GetLocalState(child);
        return localState.scaleY;
      }
    };
  
    /*
  
    Visible in localState:
  
      - visible: original visible of child
      - maskVisible: invisible by parent mask, see MaskChildren.js
          - undefined (not in masking) : Equal to mask visible
          - true (mask visible) : Inside, or across parent's visible area
          - false (maske invisible) : Out of parent's visible area
  
    Visible result of child = (parent visible) && (child visible) && (mask visible)
    */
  
    var Visible$1 = {
      updateChildVisible: function updateChildVisible(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        var maskVisible = localState.hasOwnProperty('maskVisible') ? localState.maskVisible : true;
        var parentVisible = parent ? parent.visible : true;
        child.visible = parentVisible && localState.visible && maskVisible;
        return this;
      },
      syncVisible: function syncVisible() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildVisible, this);
        }
        return this;
      },
      resetChildVisibleState: function resetChildVisibleState(child) {
        var localState = GetLocalState(child);
        // Delete maskVisible property
        if (localState.hasOwnProperty('maskVisible')) {
          delete localState.maskVisible;
        }
        localState.visible = child.visible;
        return this;
      },
      setChildVisible: function setChildVisible(child, visible) {
        // Visible of child will be affect by parent's visible, and mask visible
        this.setChildLocalVisible(child, visible);
        return this;
      },
      // Internal method
      setChildLocalVisible: function setChildLocalVisible(child, visible) {
        if (visible === undefined) {
          visible = true;
        }
        var localState = GetLocalState(child);
        localState.visible = visible;
        this.updateChildVisible(child);
        return this;
      },
      // Internal method
      setChildMaskVisible: function setChildMaskVisible(child, visible) {
        if (visible === undefined) {
          visible = true;
        }
        var localState = GetLocalState(child);
        localState.maskVisible = visible;
        this.updateChildVisible(child);
        return this;
      },
      resetLocalVisibleState: function resetLocalVisibleState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildVisibleState(this);
        }
        return this;
      },
      getChildLocalVisible: function getChildLocalVisible(child) {
        var localState = GetLocalState(child);
        return localState.visible;
      }
    };
  
    var Alpha = {
      updateChildAlpha: function updateChildAlpha(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        if (state.syncAlpha) {
          child.alpha = parent.alpha * state.alpha;
        }
        return this;
      },
      syncAlpha: function syncAlpha() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildAlpha, this);
        }
        return this;
      },
      resetChildAlphaState: function resetChildAlphaState(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        state.alpha = GetScale(child.alpha, parent.alpha);
        return this;
      },
      setChildAlpha: function setChildAlpha(child, alpha) {
        child.alpha = alpha;
        this.resetChildAlphaState(child);
        return this;
      },
      setChildLocalAlpha: function setChildLocalAlpha(child, alpha) {
        var state = GetLocalState(child);
        state.alpha = alpha;
        this.updateChildAlpha(child);
        return this;
      },
      resetLocalAlphaState: function resetLocalAlphaState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildAlphaState(this);
        }
        return this;
      },
      getChildLocalAlpha: function getChildLocalAlpha(child) {
        var localState = GetLocalState(child);
        return localState.alpha;
      }
    };
  
    var Active = {
      updateChildActive: function updateChildActive(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.active = parent.active && localState.active;
        return this;
      },
      syncActive: function syncActive() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildActive, this);
        }
        return this;
      },
      resetChildActiveState: function resetChildActiveState(child) {
        var localState = GetLocalState(child);
        localState.active = child.active;
        return this;
      },
      setChildActive: function setChildActive(child, active) {
        child.active = active;
        this.resetChildActiveState(child);
        return this;
      },
      setChildLocalActive: function setChildLocalActive(child, active) {
        if (active === undefined) {
          active = true;
        }
        var localState = GetLocalState(child);
        localState.active = active;
        this.updateChildActive(child);
        return this;
      },
      resetLocalActiveState: function resetLocalActiveState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
          parent.resetChildActiveState(this);
        }
        return this;
      },
      getChildLocalActive: function getChildLocalActive(child) {
        var localState = GetLocalState(child);
        return localState.active;
      }
    };
  
    var ScrollFactor = {
      updateChildScrollFactor: function updateChildScrollFactor(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        if (localState.syncScrollFactor) {
          child.scrollFactorX = parent.scrollFactorX;
          child.scrollFactorY = parent.scrollFactorY;
        }
        return this;
      },
      syncScrollFactor: function syncScrollFactor() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildScrollFactor, this);
        }
        return this;
      }
    };
  
    var CameraFilter = {
      updateCameraFilter: function updateCameraFilter(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        if (state.syncCameraFilter) {
          child.cameraFilter = parent.cameraFilter;
        }
        return this;
      },
      syncCameraFilter: function syncCameraFilter() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateCameraFilter, this);
        }
        return this;
      }
    };
  
    var Mask = {
      updateChildMask: function updateChildMask(child) {
        // Don't propagate null mask to clear children's mask
        if (this.mask == null) {
          return this;
        }
        var maskGameObject = this.mask.hasOwnProperty('geometryMask') ? this.mask.geometryMask : this.mask.bitmapMask;
        if (maskGameObject !== child) {
          child.mask = this.mask;
        }
        return this;
      },
      syncMask: function syncMask() {
        if (this.syncChildrenEnable) {
          this.children.forEach(this.updateChildMask, this);
        }
        return this;
      },
      setMask: function setMask(mask) {
        this.mask = mask;
        return this;
      },
      clearMask: function clearMask(destroyMask) {
        if (destroyMask === undefined) {
          destroyMask = false;
        }
        var self = this;
  
        // Clear current mask
        this._mask = null;
        this.setChildMaskVisible(this);
        // Also set maskVisible to `true`
  
        this.children.forEach(function (child) {
          // Clear child's mask
          if (child.clearMask) {
            child.clearMask(false);
          }
          if (!child.hasOwnProperty('isRexContainerLite')) {
            self.setChildMaskVisible(child);
            // Set child's maskVisible to `true`
          }
        });
        if (destroyMask && this.mask) {
          this.mask.destroy();
        }
        return this;
      }
    };
  
    var FilterDisplayGameObjects = function FilterDisplayGameObjects(gameObjects) {
      return gameObjects.filter(function (gameObject) {
        if (gameObject.displayList) {
          // Inside a scene or a layer
          return true;
        } else if (gameObject.parentContainer) {
          // Inside a container
          return true;
        }
      });
    };
  
    var Depth = {
      setDepth: function setDepth(value, containerOnly) {
        this.depth = value;
        if (!containerOnly && this.children) {
          var children = this.getAllChildren();
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            children[i].depth = value;
          }
        }
        return this;
      },
      swapDepth: function swapDepth(containerB) {
        var depthA = this.depth;
        var depthB = containerB.depth;
        this.setDepth(depthB);
        containerB.setDepth(depthA);
        return this;
      },
      incDepth: function incDepth(inc) {
        this.depth += inc;
        if (this.children) {
          var children = this.getAllChildren();
          for (var i = 0, cnt = children.length; i < cnt; i++) {
            children[i].depth += inc;
          }
        }
        return this;
      },
      bringToTop: function bringToTop() {
        var displayList = this.displayList;
        if (!displayList) {
          return this;
        }
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children, false);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          if (displayList.exists(child)) {
            displayList.bringToTop(child);
          }
        }
        return this;
      },
      bringMeToTop: function bringMeToTop() {
        return this.bringToTop();
      },
      sendToBack: function sendToBack() {
        var displayList = this.displayList;
        if (!displayList) {
          return this;
        }
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children, true);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          if (displayList.exists(child)) {
            displayList.sendToBack(child);
          }
        }
        return this;
      },
      sendMeToBack: function sendMeToBack() {
        return this.sendToBack();
      },
      moveDepthBelow: function moveDepthBelow(gameObject) {
        var displayList = this.displayList;
        if (!displayList) {
          return this;
        }
        if (gameObject.displayList !== displayList) {
          // Do nothing if not at the same display list
          return this;
        }
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children, false);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          if (displayList.exists(child)) {
            displayList.moveBelow(gameObject, child);
            break;
          }
        }
        return this;
      },
      moveMyDepthBelow: function moveMyDepthBelow(gameObject) {
        return this.moveDepthBelow(gameObject);
      },
      moveDepthAbove: function moveDepthAbove(gameObject) {
        var displayList = this.displayList;
        if (!displayList) {
          return this;
        }
        if (gameObject.displayList !== displayList) {
          // Do nothing if not at the same display list
          return this;
        }
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children, true);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          var child = children[i];
          if (displayList.exists(child)) {
            displayList.moveAbove(gameObject, child);
            break;
          }
        }
        return this;
      },
      moveMyDepthAbove: function moveMyDepthAbove(gameObject) {
        return this.moveDepthAbove(gameObject);
      },
      bringChildToTop: function bringChildToTop(child) {
        var gameObjects;
        if (child.isRexContainerLite) {
          gameObjects = child.getAllChildren([child]);
          gameObjects = FilterDisplayGameObjects(gameObjects);
          gameObjects = SortGameObjectsByDepth(gameObjects, false);
        } else {
          gameObjects = [child];
        }
        var children = this.getAllChildren([this]);
        children = FilterDisplayGameObjects(children);
        children = SortGameObjectsByDepth(children, false);
        var topChild = children[children.length - 1];
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          var gameObject = gameObjects[i];
          if (topChild === gameObject || topChild.displayList !== gameObject.displayList) {
            continue;
          }
          topChild.displayList.moveAbove(gameObject, topChild);
          topChild = gameObject;
        }
        return this;
      },
      sendChildToBack: function sendChildToBack(child) {
        var gameObjects;
        if (child.isRexContainerLite) {
          gameObjects = child.getAllChildren([child]);
          gameObjects = FilterDisplayGameObjects(gameObjects);
          gameObjects = SortGameObjectsByDepth(gameObjects, false);
        } else {
          gameObjects = [child];
        }
        var children = this.getAllChildren([this]);
        children = FilterDisplayGameObjects(children);
        children = SortGameObjectsByDepth(children, false);
        var bottomChild = children[0];
        for (var i = gameObjects.length - 1; i >= 0; i--) {
          var gameObject = gameObjects[i];
          if (bottomChild === gameObject || bottomChild.displayList !== gameObject.displayList) {
            continue;
          }
          bottomChild.displayList.moveBelow(gameObject, bottomChild);
          bottomChild = gameObject;
        }
        return this;
      }
    };
  
    var DepthFirstSearch = function DepthFirstSearch(root, callback) {
      var skip = callback(root);
      if (!skip && root.isRexContainerLite) {
        var children = root.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          DepthFirstSearch(children[i], callback);
        }
      }
    };
    var BreadthFirstSearch = function BreadthFirstSearch(root, callback) {
      var queue = [root];
      while (queue.length > 0) {
        var current = queue.shift();
        var skip = callback(current);
        if (!skip && current.isRexContainerLite) {
          queue.push.apply(queue, _toConsumableArray(current.children));
        }
      }
    };
  
    var ArrayUtils = Phaser.Utils.Array;
    var Children = {
      getChildren: function getChildren(out) {
        if (!out) {
          out = this.children; // Return internal children array
        } else {
          for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            out.push(this.children[i]);
          }
          // Copy children
        }
        return out;
      },
      getAllChildren: function getAllChildren(out) {
        if (out === undefined) {
          out = [];
        }
        var root = this;
        BreadthFirstSearch(root, function (child) {
          // Don't add root
          if (child === root) {
            return;
          }
          out.push(child);
        });
        return out;
      },
      getAllVisibleChildren: function getAllVisibleChildren(out) {
        if (out === undefined) {
          out = [];
        }
        var root = this;
        BreadthFirstSearch(root, function (child) {
          // Don't add root
          if (child === root) {
            return;
          }
          // Don't add invisible child
          if (!child.visible) {
            return true;
          }
          out.push(child);
        });
        return out;
      },
      bfs: function bfs(callback, root) {
        if (root === undefined) {
          root = this;
        }
        BreadthFirstSearch(root, callback);
        return this;
      },
      dfs: function dfs(callback, root) {
        if (root === undefined) {
          root = this;
        }
        DepthFirstSearch(root, callback);
        return this;
      },
      contains: function contains(gameObject) {
        // Override Base.contains method
        var parent = GetParent$1(gameObject);
        if (!parent) {
          return false;
        } else if (parent === this) {
          return true;
        } else {
          return this.contains(parent);
        }
      },
      getByName: function getByName(name, recursive) {
        if (!recursive) {
          return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found
        } else {
          // recursive
          // Breadth-first search
          var queue = [this];
          var parent, child;
          while (queue.length) {
            parent = queue.shift();
            for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
              child = parent.children[i];
              if (child.name === name) {
                return child;
              } else if (child.isRexContainerLite) {
                queue.push(child);
              }
            }
          }
          return null;
        }
      },
      getRandom: function getRandom(startIndex, length) {
        return ArrayUtils.GetRandom(this.children, startIndex, length);
      },
      getFirst: function getFirst(property, value, startIndex, endIndex) {
        return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
      },
      getAll: function getAll(property, value, startIndex, endIndex) {
        return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
      },
      count: function count(property, value, startIndex, endIndex) {
        return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
      },
      swap: function swap(child1, child2) {
        ArrayUtils.Swap(this.children, child1, child2);
        return this;
      },
      setAll: function setAll(property, value, startIndex, endIndex) {
        ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
        return this;
      }
    };
  
    var GetLocalStates = function GetLocalStates(gameObjects) {
      var localStates = [];
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var gameObject = gameObjects[i];
        if (!gameObject.hasOwnProperty('rexContainer')) {
          continue;
        }
        localStates.push(gameObject.rexContainer);
      }
      return localStates;
    };
    var GetScene = function GetScene(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var scene = gameObjects[i].scene;
        if (scene) {
          return scene;
        }
      }
      return null;
    };
    var UpdateChild = function UpdateChild(tween, key, target) {
      if (!target.parent) {
        // target object was removed, so remove this tween too
        tween.remove();
        return;
      }
      var parent = target.parent;
      var child = target.self;
      switch (key) {
        case 'x':
        case 'y':
          parent.updateChildPosition(child);
          break;
        case 'angle':
        case 'rotation':
          parent.updateChildRotation(child);
          break;
        case 'scaleX':
        case 'scaleY':
        case 'displayWidth':
        case 'displayHeight':
          parent.updateChildScale(child);
          break;
        case 'alpha':
          parent.updateChildAlpha(child);
          break;
        default:
          parent.updateChildPosition(child);
          parent.updateChildRotation(child);
          parent.updateChildScale(child);
          parent.updateChildAlpha(child);
          break;
      }
    };
    var Tween = {
      tweenChild: function tweenChild(tweenConfig) {
        var targets = tweenConfig.targets;
        if (!Array.isArray(targets)) {
          targets = [targets];
        }
        var scene = this.scene || GetScene(targets);
        if (!scene) {
          return;
        }
  
        // Map child game objects to local states
        tweenConfig.targets = GetLocalStates(targets);
        var tween = scene.tweens.add(tweenConfig);
  
        // Update child game object in 'update' event
        tween.on('update', UpdateChild);
        return tween;
      },
      tweenSelf: function tweenSelf(tweenConfig) {
        tweenConfig.targets = [this];
        return this.tweenChild(tweenConfig);
      },
      createTweenChildConfig: function createTweenChildConfig(tweenConfig) {
        var targets = tweenConfig.targets;
        if (targets) {
          if (!Array.isArray(targets)) {
            targets = [targets];
          }
          // Map child game objects to local states
          tweenConfig.targets = GetLocalStates(targets);
        }
        var onUpdate = tweenConfig.onUpdate;
        tweenConfig.onUpdate = function (tween, target) {
          if (onUpdate) {
            onUpdate(tween, target);
          }
          UpdateChild(tween, undefined, target);
        };
        return tweenConfig;
      },
      tween: function tween(tweenConfig) {
        var scene = this.scene;
        if (!tweenConfig.targets) {
          tweenConfig.targets = this;
        }
        return scene.tweens.add(tweenConfig);
      }
    };
  
    var ContainerClass = Phaser.GameObjects.Container;
    var IsContainerGameObject = function IsContainerGameObject(gameObject) {
      return gameObject instanceof ContainerClass;
    };
  
    var GetValidChildren = function GetValidChildren(parent) {
      var children = parent.getAllChildren([parent]);
      children = children.filter(function (gameObject) {
        return !!gameObject.displayList ||
        // At scene's displayList or at a layer
        !!gameObject.parentContainer; // At a container
      });
      return children;
    };
    var AddToContainer = function AddToContainer(p3Container) {
      var gameObjects = GetValidChildren(this);
      // This containerLite parent should be considered.
      if (gameObjects.indexOf(this) === -1) {
        gameObjects.push(this);
      }
      SortGameObjectsByDepth(gameObjects);
      p3Container.add(gameObjects);
    };
    var RemoveFromContainer = function RemoveFromContainer(p3Container, descending, addToScene) {
      if (!this.scene) {
        // Destroyed
        return;
      }
      var gameObjects = GetValidChildren(this);
      SortGameObjectsByDepth(gameObjects, descending);
      p3Container.remove(gameObjects);
      if (addToScene) {
        gameObjects.forEach(function (gameObject) {
          gameObject.addToDisplayList();
        });
      }
    };
    var P3Container = {
      addToContainer: function addToContainer(p3Container) {
        if (!IsContainerGameObject(p3Container)) {
          return this;
        }
        this._setParentContainerFlag = true;
        AddToContainer.call(this, p3Container);
        this._setParentContainerFlag = false;
        return this;
      },
      addToLayer: function addToLayer(layer) {
        if (!IsLayerGameObject(layer)) {
          return this;
        }
        AddToContainer.call(this, layer);
        return this;
      },
      removeFromContainer: function removeFromContainer() {
        if (!this.parentContainer) {
          return this;
        }
        this._setParentContainerFlag = true;
        RemoveFromContainer.call(this, this.parentContainer, true, false);
        this._setParentContainerFlag = false;
        return this;
      },
      removeFromLayer: function removeFromLayer(addToScene) {
        if (addToScene === undefined) {
          addToScene = true;
        }
        if (!IsLayerGameObject(this.displayList)) {
          return this;
        }
        RemoveFromContainer.call(this, this.displayList, false, addToScene);
        return this;
      },
      getParentContainer: function getParentContainer() {
        if (this.parentContainer) {
          return this.parentContainer;
        }
  
        // One of parent container has a layer
        var parent = this.getParent();
        while (parent) {
          var p3Container = parent.parentContainer;
          if (p3Container) {
            return p3Container;
          }
          parent = parent.getParent();
        }
        return null;
      },
      addToParentContainer: function addToParentContainer(gameObject) {
        // Do nothing if gameObject is not in any displayList
        if (!gameObject.displayList) {
          return this;
        }
        var p3Container = this.getParentContainer();
        if (!p3Container) {
          return this;
        }
        if (gameObject.isRexContainerLite) {
          // Add containerLite and its children
          gameObject.addToContainer(p3Container);
        } else {
          // Add gameObject directly
          p3Container.add(gameObject);
        }
        return this;
      },
      addToPatentLayer: function addToPatentLayer(gameObject) {
        // Do nothing if gameObject is not in any displayList
        if (!gameObject.displayList) {
          return this;
        }
  
        // At the same display list
        var parentLayer = this.displayList;
        if (parentLayer === gameObject.displayList) {
          return this;
        }
        if (IsLayerGameObject(parentLayer)) {
          if (gameObject.isRexContainerLite) {
            // Add containerLite and its children
            gameObject.addToLayer(parentLayer);
          } else {
            // Add gameObject directly
            parentLayer.add(gameObject);
          }
        }
        return this;
      }
    };
  
    var RenderLayer = {
      hasLayer: function hasLayer() {
        return !!this.privateRenderLayer;
      },
      enableLayer: function enableLayer() {
        if (this.hasLayer()) {
          return this;
        }
        var layer = this.scene.add.layer();
        // layer.name = (this.name) ? `${this.name}.privateLayer` : 'privateLayer';
  
        this.moveDepthBelow(layer);
        this.addToLayer(layer);
        this.privateRenderLayer = layer;
        return this;
      },
      getLayer: function getLayer() {
        if (!this.hasLayer()) {
          this.enableLayer();
        }
        return this.privateRenderLayer;
      },
      getRenderLayer: function getRenderLayer() {
        // This containerLite has a layer
        if (this.hasLayer()) {
          return this.privateRenderLayer;
        }
  
        // One of parent container has a layer
        var parent = this.getParent();
        while (parent) {
          var layer = parent.privateRenderLayer;
          if (layer) {
            return layer;
          }
          parent = parent.getParent();
        }
        return null;
      },
      // Internal method for adding child
      addToRenderLayer: function addToRenderLayer(gameObject) {
        // Don't add to layer if gameObject is not in any displayList
        if (!gameObject.displayList) {
          return this;
        }
  
        // Move gameObject from scene to layer
        var layer = this.getRenderLayer();
        if (!layer) {
          return this;
        }
        if (layer === gameObject.displayList) {
          return this;
        }
        if (gameObject.isRexContainerLite) {
          // Add containerLite and its children
          gameObject.addToLayer(layer);
        } else {
          // Add gameObject directly
          layer.add(gameObject);
        }
        var state = GetLocalState(gameObject);
        state.layer = layer;
        return this;
      },
      // Internal method for removing child
      removeFromRenderLayer: function removeFromRenderLayer(gameObject) {
        // Move gameObject from layer to scene
        var state = GetLocalState(gameObject);
        var layer = state.layer;
        if (!layer) {
          return this;
        }
        if (gameObject.isRexContainerLite) {
          // Remove containerLite and its children
          gameObject.removeFromLayer(true);
        } else {
          // Remove gameObject directly
          layer.remove(gameObject);
        }
        state.layer = null;
        return this;
      }
    };
  
    var Rectangle$1 = Phaser.Geom.Rectangle;
    var Union = Phaser.Geom.Rectangle.Union;
    var GetBoundsOfGameObjects = function GetBoundsOfGameObjects(gameObjects, out) {
      if (out === undefined) {
        out = new Rectangle$1();
      } else if (out === true) {
        if (GlobRect$1 === undefined) {
          GlobRect$1 = new Rectangle$1();
        }
        out = GlobRect$1;
      }
      out.setTo(0, 0, 0, 0);
      var gameObject;
      var firstClone = true;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        gameObject = gameObjects[i];
        if (!gameObject.getBounds) {
          continue;
        }
        var boundsRect = GetBounds(gameObject, true);
        if (firstClone) {
          out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
          firstClone = false;
        } else {
          Union(boundsRect, out, out);
        }
      }
      return out;
    };
    var GlobRect$1;
  
    var GetValue$2G = Phaser.Utils.Objects.GetValue;
    var Snapshot = function Snapshot(config) {
      if (!config) {
        return;
      }
      var gameObjects = config.gameObjects;
      var renderTexture = config.renderTexture; // renderTexture, or dynamicTexture
      var saveTexture = config.saveTexture;
      var x = GetValue$2G(config, 'x', undefined);
      var y = GetValue$2G(config, 'y', undefined);
      var width = GetValue$2G(config, 'width', undefined);
      var height = GetValue$2G(config, 'height', undefined);
      var originX = GetValue$2G(config, 'originX', 0);
      var originY = GetValue$2G(config, 'originY', 0);
      var padding = GetValue$2G(config, 'padding', 0);
      var scrollX, scrollY;
      if (width === undefined || height === undefined || x === undefined || y === undefined) {
        // Union bounds of gameObjects
        var bounds = GetBoundsOfGameObjects(gameObjects, true);
        var isCenterOrigin = x !== undefined && y !== undefined;
        if (isCenterOrigin) {
          width = Math.max(x - bounds.left, bounds.right - x) * 2;
          height = Math.max(y - bounds.top, bounds.bottom - y) * 2;
          originX = 0.5;
          originY = 0.5;
        } else {
          x = bounds.x;
          y = bounds.y;
          width = bounds.width;
          height = bounds.height;
          originX = 0;
          originY = 0;
        }
        scrollX = bounds.x;
        scrollY = bounds.y;
      } else {
        scrollX = x + (0 - originX) * width;
        scrollY = y + (0 - originY) * height;
      }
      scrollX -= padding;
      scrollY -= padding;
      width += padding * 2;
      height += padding * 2;
      var scene = gameObjects[0].scene;
      var textureManager = scene.sys.textures;
  
      // Snapshot on dynamicTexture directly
      if (saveTexture && !renderTexture) {
        renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
      }
  
      // Return a renderTexture
      if (!renderTexture) {
        renderTexture = scene.add.renderTexture(0, 0, width, height);
      }
      if (renderTexture.setPosition) {
        renderTexture.setPosition(x, y);
      }
      if (renderTexture.width !== width || renderTexture.height !== height) {
        renderTexture.setSize(width, height);
      }
      if (renderTexture.setOrigin) {
        renderTexture.setOrigin(originX, originY);
      }
      renderTexture.camera.setScroll(scrollX, scrollY);
  
      // Draw gameObjects
      gameObjects = SortGameObjectsByDepth(Clone$2(gameObjects));
      renderTexture.draw(gameObjects);
  
      // Save render result to texture
      if (saveTexture) {
        if (IsGameObject(renderTexture)) {
          renderTexture.saveTexture(saveTexture);
        } else if (renderTexture.key !== saveTexture) {
          textureManager.renameTexture(renderTexture.key, key);
        }
      }
      return renderTexture;
    };
  
    var RenderTexture$1 = {
      snapshot: function snapshot(config) {
        // Save scale
        var scaleXSave = this.scaleX;
        var scaleYSave = this.scaleY;
        var scale1 = scaleXSave === 1 && scaleYSave === 1;
        if (!scale1) {
          this.setScale(1);
        }
  
        // Snapshot with scale = 1
        if (config === undefined) {
          config = {};
        }
        config.gameObjects = this.getAllVisibleChildren();
        config.x = this.x;
        config.y = this.y;
        config.originX = this.originX;
        config.originY = this.originY;
        var rt = Snapshot(config);
        var isValidRT = !!rt.scene;
  
        // Restore scale
        if (!scale1) {
          this.setScale(scaleXSave, scaleYSave);
          if (isValidRT) {
            rt.setScale(scaleXSave, scaleYSave);
          }
        }
        return isValidRT ? rt : this;
      }
    };
  
    var GetValue$2F = Phaser.Utils.Objects.GetValue;
    var DrawBounds$1 = function DrawBounds(graphics, config) {
      var drawContainer = GetValue$2F(config, 'drawContainer', true);
      var gameObjects = GetValue$2F(config, 'children');
      if (gameObjects === undefined) {
        gameObjects = this.getAllVisibleChildren([this]);
      }
      if (!drawContainer) {
        gameObjects = gameObjects.filter(function (gameObject) {
          return !gameObject.isRexContainerLite;
        });
      }
      DrawBounds$2(gameObjects, graphics, config);
      return this;
    };
  
    var RotateAround$4 = Phaser.Math.RotateAround;
    var ChangeOrigin$1 = function ChangeOrigin(gameObject, originX, originY) {
      if (originY === undefined) {
        originY = originX;
      }
      var deltaXY = {
        x: (originX - gameObject.originX) * gameObject.displayWidth,
        y: (originY - gameObject.originY) * gameObject.displayHeight
      };
      RotateAround$4(deltaXY, 0, 0, gameObject.rotation);
      gameObject.originX = originX;
      gameObject.originY = originY;
      gameObject.x = gameObject.x + deltaXY.x;
      gameObject.y = gameObject.y + deltaXY.y;
      return gameObject;
    };
  
    var ChangeOrigin = function ChangeOrigin(originX, originY) {
      this.syncChildrenEnable = false;
      ChangeOrigin$1(this, originX, originY);
      this.syncChildrenEnable = true;
      var children = this.getAllChildren();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        this.resetChildPositionState(children[i]);
      }
      return this;
    };
  
    var methods$z = {
      changeOrigin: ChangeOrigin,
      drawBounds: DrawBounds$1
    };
    Object.assign(methods$z, Parent, AddChild$2, RemoveChild$1, ChildState, Transform, Position, Rotation, Scale$1, Visible$1, Alpha, Active, ScrollFactor, CameraFilter, Mask, Depth, Children, Tween, P3Container, RenderLayer, RenderTexture$1);
  
    var ContainerLite = /*#__PURE__*/function (_Base) {
      _inherits(ContainerLite, _Base);
      function ContainerLite(scene, x, y, width, height, children) {
        var _this;
        _classCallCheck(this, ContainerLite);
        if (Array.isArray(width)) {
          children = width;
          width = undefined;
          height = undefined;
        }
        _this = _callSuper(this, ContainerLite, [scene, x, y, width, height]);
        _this.type = 'rexContainerLite';
        _this.isRexContainerLite = true;
        _this.syncChildrenEnable = true;
        _this._active = true;
        _this._mask = null;
        _this._scrollFactorX = 1;
        _this._scrollFactorY = 1;
        _this._cameraFilter = 0;
        _this.privateRenderLayer = undefined;
        if (children) {
          _this.add(children);
        }
        return _this;
      }
      _createClass(ContainerLite, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.syncChildrenEnable = false; // Don't sync properties changing anymore
          _get(_getPrototypeOf(ContainerLite.prototype), "destroy", this).call(this, fromScene);
          if (this.privateRenderLayer) {
            this.privateRenderLayer.list.length = 0; // Remove all children without trigger callback
            this.privateRenderLayer.destroy();
          }
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          this.setSize(width, height);
          return this;
        }
      }, {
        key: "x",
        get: function get() {
          return this._x;
        },
        set: function set(value) {
          if (this._x === value) {
            return;
          }
          this._x = value;
          this.syncPosition();
        }
      }, {
        key: "y",
        get: function get() {
          return this._y;
        },
        set: function set(value) {
          if (this._y === value) {
            return;
          }
          this._y = value;
          this.syncPosition();
        }
  
        // Override
      }, {
        key: "rotation",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "rotation", this);
        },
        set: function set(value) {
          if (this.rotation === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "rotation", value, this, true);
          this.syncPosition();
        }
  
        // Override
      }, {
        key: "scaleX",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "scaleX", this);
        },
        set: function set(value) {
          if (this.scaleX === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "scaleX", value, this, true);
          this.syncPosition();
        }
  
        // Override
      }, {
        key: "scaleY",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "scaleY", this);
        },
        set: function set(value) {
          if (this.scaleY === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "scaleY", value, this, true);
          this.syncPosition();
        }
  
        // Override
      }, {
        key: "scale",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "scale", this);
        },
        set: function set(value) {
          if (this.scale === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "scale", value, this, true);
          this.syncPosition();
        }
  
        // Override
      }, {
        key: "visible",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "visible", this);
        },
        set: function set(value) {
          if (_get(_getPrototypeOf(ContainerLite.prototype), "visible", this) === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "visible", value, this, true);
          this.syncVisible();
        }
  
        // Override
      }, {
        key: "alpha",
        get: function get() {
          return _get(_getPrototypeOf(ContainerLite.prototype), "alpha", this);
        },
        set: function set(value) {
          if (_get(_getPrototypeOf(ContainerLite.prototype), "alpha", this) === value) {
            return;
          }
          _set(_getPrototypeOf(ContainerLite.prototype), "alpha", value, this, true);
          this.syncAlpha();
        }
  
        // Override
      }, {
        key: "active",
        get: function get() {
          return this._active;
        },
        set: function set(value) {
          if (this._active === value) {
            return;
          }
          this._active = value;
          this.syncActive();
        }
  
        // Override
      }, {
        key: "mask",
        get: function get() {
          return this._mask;
        },
        set: function set(mask) {
          if (this._mask === mask) {
            return;
          }
          this._mask = mask;
          this.syncMask();
        }
  
        // Override
      }, {
        key: "scrollFactorX",
        get: function get() {
          return this._scrollFactorX;
        },
        set: function set(value) {
          if (this._scrollFactorX === value) {
            return;
          }
          this._scrollFactorX = value;
          this.syncScrollFactor();
        }
      }, {
        key: "scrollFactorY",
        get: function get() {
          return this._scrollFactorY;
        },
        set: function set(value) {
          if (this._scrollFactorY === value) {
            return;
          }
          this._scrollFactorY = value;
          this.syncScrollFactor();
        }
      }, {
        key: "cameraFilter",
        get: function get() {
          return this._cameraFilter;
        },
        set: function set(value) {
          if (this._cameraFilter === value) {
            return;
          }
          this._cameraFilter = value;
          this.syncCameraFilter();
        }
  
        // Compatiable with container plugin
      }, {
        key: "list",
        get: function get() {
          return this.children;
        }
      }, {
        key: "parentContainer",
        get:
        // For p3-container
        function get() {
          return this._parentContainer;
        },
        set: function set(value) {
          // Initialize
          if (!this._parentContainer && !value) {
            this._parentContainer = value;
            return;
          }
  
          // Set this._parentContainer only,
          // if under AddToContainer, or RemoveFromContainer methods
          if (this.setParentContainerFlag) {
            this._parentContainer = value;
            return;
          }
          // else if (!this.setParentContainerFlag)
  
          // Add itself and all children to container,
          // Or remove itseld and all children from container
          if (this._parentContainer && !value) {
            // Remove from container
            this.removeFromContainer();
            this._parentContainer = value;
          } else if (value) {
            // Add to container
            this._parentContainer = value;
            this.addToContainer(value);
          } else {
            this._parentContainer = value;
          }
        }
      }, {
        key: "setParentContainerFlag",
        get: function get() {
          if (this._setParentContainerFlag) {
            return true;
          }
          var parent = GetParent$1(this);
          return parent ? parent.setParentContainerFlag : false;
        }
      }], [{
        key: "GetParent",
        value: function GetParent(child) {
          return GetParent$1(child);
        }
      }]);
      return ContainerLite;
    }(Base$1);
    Object.assign(ContainerLite.prototype, methods$z);
  
    var GetSizerConfig$1 = function GetSizerConfig(gameObject) {
      if (!gameObject.hasOwnProperty('rexSizer')) {
        gameObject.rexSizer = {};
      }
      return gameObject.rexSizer;
    };
  
    function GetSizerConfig (gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }
      return GetSizerConfig$1(gameObject);
    }
  
    var GetChildPrevState = function GetChildPrevState(child) {
      var childConfig = GetSizerConfig$1(child);
      if (!childConfig.hasOwnProperty('prevState')) {
        childConfig.prevState = {};
      }
      return childConfig.prevState;
    };
  
    var PushIntoBounds = function PushIntoBounds(bounds) {
      if (bounds === undefined) {
        bounds = GetViewport(this.scene);
      }
      this.left = Math.max(this.left, bounds.left);
      this.right = Math.min(this.right, bounds.right);
      this.top = Math.max(this.top, bounds.top);
      this.bottom = Math.min(this.bottom, bounds.bottom);
      return this;
    };
  
    var ALIGN$1 = Phaser.Display.Align;
    var AlignConst = {
      center: ALIGN$1.CENTER,
      left: ALIGN$1.LEFT_CENTER,
      right: ALIGN$1.RIGHT_CENTER,
      top: ALIGN$1.TOP_CENTER,
      bottom: ALIGN$1.BOTTOM_CENTER,
      'left-top': ALIGN$1.TOP_LEFT,
      'top-left': ALIGN$1.TOP_LEFT,
      'left-center': ALIGN$1.LEFT_CENTER,
      'center-left': ALIGN$1.LEFT_CENTER,
      'left-bottom': ALIGN$1.BOTTOM_LEFT,
      'bottom-left': ALIGN$1.BOTTOM_LEFT,
      'center-top': ALIGN$1.TOP_CENTER,
      'top-center': ALIGN$1.TOP_CENTER,
      'center-center': ALIGN$1.CENTER,
      'center-bottom': ALIGN$1.BOTTOM_CENTER,
      'bottom-center': ALIGN$1.BOTTOM_CENTER,
      'right-top': ALIGN$1.TOP_RIGHT,
      'top-right': ALIGN$1.TOP_RIGHT,
      'right-center': ALIGN$1.RIGHT_CENTER,
      'center-right': ALIGN$1.RIGHT_CENTER,
      'right-bottom': ALIGN$1.BOTTOM_RIGHT,
      'bottom-right': ALIGN$1.BOTTOM_RIGHT
    };
  
    var globZone = new Phaser.GameObjects.Zone({
      sys: {
        queueDepthSort: NOOP,
        events: {
          once: NOOP
        }
      }
    }, 0, 0, 1, 1);
    globZone.setOrigin(0);
  
    var ALIGN_CONST = {
      /**
      * A constant representing a top-left alignment or position.
      * @constant
      * @name Phaser.Display.Align.TOP_LEFT
      * @since 3.0.0
      * @type {integer}
      */
      TOP_LEFT: 0,
      /**
      * A constant representing a top-center alignment or position.
      * @constant
      * @name Phaser.Display.Align.TOP_CENTER
      * @since 3.0.0
      * @type {integer}
      */
      TOP_CENTER: 1,
      /**
      * A constant representing a top-right alignment or position.
      * @constant
      * @name Phaser.Display.Align.TOP_RIGHT
      * @since 3.0.0
      * @type {integer}
      */
      TOP_RIGHT: 2,
      /**
      * A constant representing a left-top alignment or position.
      * @constant
      * @name Phaser.Display.Align.LEFT_TOP
      * @since 3.0.0
      * @type {integer}
      */
      LEFT_TOP: 3,
      /**
      * A constant representing a left-center alignment or position.
      * @constant
      * @name Phaser.Display.Align.LEFT_CENTER
      * @since 3.0.0
      * @type {integer}
      */
      LEFT_CENTER: 4,
      /**
      * A constant representing a left-bottom alignment or position.
      * @constant
      * @name Phaser.Display.Align.LEFT_BOTTOM
      * @since 3.0.0
      * @type {integer}
      */
      LEFT_BOTTOM: 5,
      /**
      * A constant representing a center alignment or position.
      * @constant
      * @name Phaser.Display.Align.CENTER
      * @since 3.0.0
      * @type {integer}
      */
      CENTER: 6,
      /**
      * A constant representing a right-top alignment or position.
      * @constant
      * @name Phaser.Display.Align.RIGHT_TOP
      * @since 3.0.0
      * @type {integer}
      */
      RIGHT_TOP: 7,
      /**
      * A constant representing a right-center alignment or position.
      * @constant
      * @name Phaser.Display.Align.RIGHT_CENTER
      * @since 3.0.0
      * @type {integer}
      */
      RIGHT_CENTER: 8,
      /**
      * A constant representing a right-bottom alignment or position.
      * @constant
      * @name Phaser.Display.Align.RIGHT_BOTTOM
      * @since 3.0.0
      * @type {integer}
      */
      RIGHT_BOTTOM: 9,
      /**
      * A constant representing a bottom-left alignment or position.
      * @constant
      * @name Phaser.Display.Align.BOTTOM_LEFT
      * @since 3.0.0
      * @type {integer}
      */
      BOTTOM_LEFT: 10,
      /**
      * A constant representing a bottom-center alignment or position.
      * @constant
      * @name Phaser.Display.Align.BOTTOM_CENTER
      * @since 3.0.0
      * @type {integer}
      */
      BOTTOM_CENTER: 11,
      /**
      * A constant representing a bottom-right alignment or position.
      * @constant
      * @name Phaser.Display.Align.BOTTOM_RIGHT
      * @since 3.0.0
      * @type {integer}
      */
      BOTTOM_RIGHT: 12
    };
  
    var GetBottom = function GetBottom(gameObject) {
      var height = GetDisplayHeight(gameObject);
      return gameObject.y + height - height * gameObject.originY;
    };
  
    var GetCenterX = function GetCenterX(gameObject) {
      var width = GetDisplayWidth(gameObject);
      return gameObject.x - width * gameObject.originX + width * 0.5;
    };
  
    var SetBottom = function SetBottom(gameObject, value) {
      var height = GetDisplayHeight(gameObject);
      gameObject.y = value - height + height * gameObject.originY;
      return gameObject;
    };
  
    var SetCenterX = function SetCenterX(gameObject, x) {
      var width = GetDisplayWidth(gameObject);
      var offsetX = width * gameObject.originX;
      gameObject.x = x + offsetX - width * 0.5;
      return gameObject;
    };
  
    var BottomCenter = function BottomCenter(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
      SetBottom(gameObject, GetBottom(alignIn) + offsetY);
      return gameObject;
    };
  
    var GetLeft = function GetLeft(gameObject) {
      var width = GetDisplayWidth(gameObject);
      return gameObject.x - width * gameObject.originX;
    };
  
    var SetLeft = function SetLeft(gameObject, value) {
      var width = GetDisplayWidth(gameObject);
      gameObject.x = value + width * gameObject.originX;
      return gameObject;
    };
  
    var BottomLeft = function BottomLeft(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetLeft(gameObject, GetLeft(alignIn) - offsetX);
      SetBottom(gameObject, GetBottom(alignIn) + offsetY);
      return gameObject;
    };
  
    var GetRight = function GetRight(gameObject) {
      var width = GetDisplayWidth(gameObject);
      return gameObject.x + width - width * gameObject.originX;
    };
  
    var SetRight = function SetRight(gameObject, value) {
      var width = GetDisplayWidth(gameObject);
      gameObject.x = value - width + width * gameObject.originX;
      return gameObject;
    };
  
    var BottomRight = function BottomRight(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetRight(gameObject, GetRight(alignIn) + offsetX);
      SetBottom(gameObject, GetBottom(alignIn) + offsetY);
      return gameObject;
    };
  
    var SetCenterY = function SetCenterY(gameObject, y) {
      var height = GetDisplayHeight(gameObject);
      var offsetY = height * gameObject.originY;
      gameObject.y = y + offsetY - height * 0.5;
      return gameObject;
    };
  
    var CenterOn = function CenterOn(gameObject, x, y) {
      SetCenterX(gameObject, x);
      return SetCenterY(gameObject, y);
    };
  
    var GetCenterY = function GetCenterY(gameObject) {
      var height = GetDisplayHeight(gameObject);
      return gameObject.y - height * gameObject.originY + height * 0.5;
    };
  
    var Center = function Center(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
      return gameObject;
    };
  
    var LeftCenter = function LeftCenter(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetLeft(gameObject, GetLeft(alignIn) - offsetX);
      SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
      return gameObject;
    };
  
    var RightCenter = function RightCenter(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetRight(gameObject, GetRight(alignIn) + offsetX);
      SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
      return gameObject;
    };
  
    var GetTop = function GetTop(gameObject) {
      var height = GetDisplayHeight(gameObject);
      return gameObject.y - height * gameObject.originY;
    };
  
    var SetTop = function SetTop(gameObject, value) {
      var height = GetDisplayHeight(gameObject);
      gameObject.y = value + height * gameObject.originY;
      return gameObject;
    };
  
    var TopCenter = function TopCenter(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
      SetTop(gameObject, GetTop(alignIn) - offsetY);
      return gameObject;
    };
  
    var TopLeft = function TopLeft(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetLeft(gameObject, GetLeft(alignIn) - offsetX);
      SetTop(gameObject, GetTop(alignIn) - offsetY);
      return gameObject;
    };
  
    var TopRight = function TopRight(gameObject, alignIn, offsetX, offsetY) {
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      SetRight(gameObject, GetRight(alignIn) + offsetX);
      SetTop(gameObject, GetTop(alignIn) - offsetY);
      return gameObject;
    };
  
    var AlignInMap = [];
    AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
    AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
    AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
    AlignInMap[ALIGN_CONST.CENTER] = Center;
    AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
    AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
    AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
    AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
    AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;
    var QuickSet = function QuickSet(child, alignIn, position, offsetX, offsetY) {
      return AlignInMap[position](child, alignIn, offsetX, offsetY);
    };
  
    var AlignIn = function AlignIn(child, x, y, width, height, align) {
      globZone.setPosition(x, y).setSize(width, height);
      QuickSet(child, globZone, align);
    };
  
    var GetValue$2E = Phaser.Utils.Objects.GetValue;
    var Group$1 = Phaser.GameObjects.Group;
    var DrawBounds = function DrawBounds(graphics, config) {
      var scene = graphics.scene;
      var color, lineWidth;
      var createTextCallback, createTextCallbackScope, textAlign;
      if (typeof config === 'number') {
        color = config;
      } else {
        color = GetValue$2E(config, 'color');
        lineWidth = GetValue$2E(config, 'lineWidth');
        var nameTextConfig = GetValue$2E(config, 'name', false);
        if (nameTextConfig) {
          createTextCallback = GetValue$2E(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
          createTextCallbackScope = GetValue$2E(nameTextConfig, 'createTextCallbackScope', undefined);
          textAlign = GetValue$2E(nameTextConfig, 'align', 'left-top');
          if (typeof textAlign === 'string') {
            textAlign = AlignConst[textAlign];
          }
        }
      }
      if (color === undefined) {
        color = 0xffffff;
      }
      if (lineWidth === undefined) {
        lineWidth = 1;
      }
      if (createTextCallback && !graphics.children) {
        graphics.children = new Group$1(scene);
        graphics.once('destroy', function (graphics, fromScene) {
          graphics.children.destroy(!fromScene);
          graphics.children = undefined;
        });
        var graphicsClear = graphics.clear.bind(graphics);
        graphics.clear = function () {
          graphicsClear();
          graphics.children.clear(false, true);
        };
      }
      var children = this.getAllShownChildren([this]),
        child;
      var nameText;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.getBounds || child.width !== undefined && child.height !== undefined) {
          GlobRect = GetBounds(child, GlobRect);
        } else {
          continue;
        }
        if (color != null) {
          graphics.lineStyle(lineWidth, color).strokeRectShape(GlobRect);
        }
        if (child.name && createTextCallback) {
          if (createTextCallbackScope) {
            nameText = createTextCallback.call(createTextCallbackScope, scene);
          } else {
            nameText = createTextCallback(scene);
          }
          if (nameText) {
            nameText.setText(child.name);
            graphics.children.add(nameText);
            AlignIn(nameText, GlobRect.x, GlobRect.y, GlobRect.width, GlobRect.height, textAlign);
          }
        }
      }
      return this;
    };
    var DefaultCreateTextCallback = function DefaultCreateTextCallback(scene, child, childBoundsRect) {
      return scene.add.text(0, 0, '');
    };
    var GlobRect = undefined;
  
    var GetValue$2D = Phaser.Utils.Objects.GetValue;
    var GetBoundsConfig = function GetBoundsConfig(config, out) {
      if (config === undefined) {
        config = 0;
      }
      if (out === undefined) {
        out = {};
      }
      if (typeof config === 'number') {
        out.left = config;
        out.right = config;
        out.top = config;
        out.bottom = config;
      } else {
        out.left = GetValue$2D(config, 'left', 0);
        out.right = GetValue$2D(config, 'right', 0);
        out.top = GetValue$2D(config, 'top', 0);
        out.bottom = GetValue$2D(config, 'bottom', 0);
      }
      return out;
    };
  
    var ContainerAdd = ContainerLite.prototype.add;
    var AddChild$1 = function AddChild(gameObject) {
      ContainerAdd.call(this, gameObject);
      if (this.sizerEventsEnable) {
        gameObject.emit('sizer.add', gameObject, this);
        this.emit('add', gameObject, this);
      }
      return this;
    };
  
    var AddChildMethods$8 = {
      addBackground: function addBackground(gameObject, paddingConfig, childKey) {
        if (this.backgroundChildren === undefined) {
          this.backgroundChildren = [];
        }
        if (typeof paddingConfig === 'string') {
          childKey = paddingConfig;
          paddingConfig = undefined;
        }
        if (paddingConfig === undefined) {
          paddingConfig = 0;
        }
        AddChild$1.call(this, gameObject);
        this.backgroundChildren.push(gameObject);
        var config = this.getSizerConfig(gameObject);
        config.padding = GetBoundsConfig(paddingConfig);
        if (childKey !== undefined) {
          this.addChildrenMap(childKey, gameObject);
        }
        return this;
      },
      isBackground: function isBackground(gameObject) {
        if (this.backgroundChildren === undefined) {
          return false;
        }
        return this.backgroundChildren.indexOf(gameObject) !== -1;
      }
    };
  
    var GetParent = function GetParent(gameObject, name) {
      var parent = null;
      if (name === undefined) {
        if (gameObject.hasOwnProperty('rexContainer')) {
          parent = gameObject.rexContainer.parent;
          if (parent) {
            if (!parent.isRexSizer) {
              // Try to get sizer parent
              parent = GetParent(parent);
            }
          } else {
            parent = null;
          }
        }
      } else {
        parent = GetParent(gameObject);
        while (parent) {
          if (parent.name === name) {
            break;
          }
          parent = GetParent(parent);
        }
      }
      return parent;
    };
    var GetTopmostParent = function GetTopmostParent(gameObject) {
      var parent = GetParent(gameObject);
      while (parent) {
        gameObject = parent;
        parent = GetParent(parent);
      }
      return gameObject;
    };
    var GetParentSizerMethods = {
      getParentSizer: function getParentSizer(gameObject, name) {
        if (typeof gameObject === 'string') {
          name = gameObject;
          gameObject = undefined;
        }
        if (gameObject === undefined) {
          gameObject = this;
        }
        return GetParent(gameObject, name);
      },
      getTopmostSizer: function getTopmostSizer(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        return GetTopmostParent(gameObject);
      },
      hasParentSizer: function hasParentSizer(parentGameObject, gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        var parent = GetParent(gameObject);
        while (parent) {
          if (parent === parentGameObject) {
            return true;
          }
          parent = GetParent(parent);
        }
        return false;
      },
      hasChild: function hasChild(child, gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        return this.hasParentSizer(gameObject, child);
      }
    };
  
    var RemoveItem$5 = Phaser.Utils.Array.Remove;
    var ContainerRemove = ContainerLite.prototype.remove;
    var GetParentSizer$1 = GetParentSizerMethods.getParentSizer;
    var RemoveChild = function RemoveChild(gameObject, destroyChild) {
      // Invoke parent's removeChildCallback method
      var parent = GetParentSizer$1(gameObject);
      while (parent) {
        if (parent.removeChildCallback) {
          parent.removeChildCallback(gameObject, destroyChild);
        }
        parent = GetParentSizer$1(parent);
      }
      if (this.isBackground(gameObject)) {
        RemoveItem$5(this.backgroundChildren, gameObject);
      }
      ContainerRemove.call(this, gameObject, destroyChild);
      if (!destroyChild && this.sizerEventsEnable) {
        gameObject.emit('sizer.remove', gameObject, this);
        this.emit('remove', gameObject, this);
      }
      return this;
    };
  
    var RemoveItem$4 = Phaser.Utils.Array.Remove;
    var GetParentSizer = GetParentSizerMethods.getParentSizer;
    var RemoveChildMethods$7 = {
      removeFromParentSizer: function removeFromParentSizer() {
        var parent = GetParentSizer(gameObject);
        if (parent) {
          parent.remove(this);
        }
        return this;
      },
      removeBackground: function removeBackground(gameObject, destroyChild) {
        if (this.backgroundChildren === undefined) {
          return this;
        }
        if (this.getParentSizer(gameObject) !== this) {
          return this;
        }
        RemoveItem$4(this.backgroundChildren, gameObject);
        RemoveChild.call(this, gameObject, destroyChild);
        return this;
      },
      removeAllBackgrounds: function removeAllBackgrounds(destroyChild) {
        if (this.backgroundChildren === undefined) {
          return this;
        }
        for (var i = this.backgroundChildren.length - 1; i >= 0; i--) {
          this.remove(this.backgroundChildren[i], destroyChild);
        }
        return this;
      }
    };
  
    var AddChildrenMap = function AddChildrenMap(key, gameObject) {
      if (typeof key === 'string') {
        this.childrenMap[key] = gameObject;
      } else {
        var config = key;
        for (key in config) {
          this.childrenMap[key] = config[key];
        }
      }
      return this;
    };
  
    var RemoveChildrenMap = function RemoveChildrenMap(key) {
      if (_typeof(key) === 'object') {
        var gameObject = key;
        for (var key in this.childrenMap) {
          if (this.childrenMap[key] === gameObject) {
            delete this.childrenMap[key];
            return this;
          }
        }
      }
      delete this.childrenMap[key];
      return this;
    };
  
    var GetElement = function GetElement(mapNameList, recursive) {
      if (typeof mapNameList === 'string') {
        mapNameList = mapNameList.split('.');
      }
      if (mapNameList.length === 0) {
        return undefined;
      }
      if (recursive === undefined) {
        recursive = false;
      }
      var name = mapNameList.shift(),
        element = null;
      if (name.charAt(0) === '#') {
        // Get element by name
        name = name.substring(1);
        element = this.getByName(name, recursive);
      } else if (mapNameList.length === 0 && recursive) {
        // Get element by single key and recursive        
        var childrenMap = this.childrenMap;
        if (childrenMap) {
          var queue = [childrenMap];
          var child;
          while (queue.length) {
            childrenMap = queue.shift();
            for (var key in childrenMap) {
              child = childrenMap[key];
              if (key === name) {
                element = child;
                break; // Leave for-loop
              } else if (child && _typeof(child) === 'object' && child.childrenMap) {
                queue.push(child.childrenMap);
              }
            }
            if (element) {
              // leave while-loop
              break;
            }
          }
        }
      } else if (name.indexOf('[') === -1) {
        // Get element by key
        if (this.childrenMap) {
          element = this.childrenMap[name];
        }
      } else {
        // Get element by key[]
        var innerMatch = name.match(RE_OBJ);
        if (innerMatch != null) {
          if (this.childrenMap) {
            var elements = this.childrenMap[innerMatch[1]];
            if (elements) {
              element = elements[innerMatch[2]];
            }
          }
        }
      }
      if (mapNameList.length === 0) {
        return element;
      } else if (element && element.childrenMap) {
        return element.getElement(mapNameList);
      } else {
        return null;
      }
    };
    var RE_OBJ = /(\S+)\[(\d+)\]/i;
  
    var GetChildIndex = function GetChildIndex(child) {
      if (Array.isArray(this.sizerChildren)) {
        var index = this.sizerChildren.indexOf(child);
        if (index === -1) {
          index = null;
        }
        return index;
      } else {
        if (this.getParentSizer(child) !== this) {
          return null;
        }
        for (var key in this.sizerChildren) {
          if (this.sizerChildre[key] === child) {
            return key;
          }
        }
        return null;
      }
    };
  
    var PaddingMethods = {
      getInnerPadding: function getInnerPadding(key) {
        return GetPadding$1(this.space, key);
      },
      setInnerPadding: function setInnerPadding(key, value) {
        SetPadding$1(this.space, key, value);
        return this;
      },
      getOuterPadding: function getOuterPadding(key) {
        return GetPadding$1(this.getSizerConfig(this).padding, key);
      },
      setOuterPadding: function setOuterPadding(key, value) {
        SetPadding$1(this.getSizerConfig(this).padding, key, value);
        return this;
      },
      getChildOuterPadding: function getChildOuterPadding(child, key) {
        if (typeof child === 'string') {
          child = this.getElement(child);
        }
        return GetPadding$1(this.getSizerConfig(child).padding, key);
      },
      setChildOuterPadding: function setChildOuterPadding(child, key, value) {
        if (typeof child === 'string') {
          child = this.getElement(child);
        }
        SetPadding$1(this.getSizerConfig(child).padding, key, value);
        return this;
      }
    };
  
    var ResolveWidth$3 = function ResolveWidth(width) {
      var childrenWidth = this.childrenWidth;
      if (childrenWidth === undefined) {
        // Can't resolve child width
        return undefined;
      }
      var minWidth = this.minWidth !== undefined ? this.minWidth : 0;
      if (width === undefined) {
        width = Math.max(minWidth, childrenWidth);
        if (this.layoutWarnEnable) {
          if (minWidth > 0 && childrenWidth > minWidth) {
            console.warn("Layout width warn: ".concat(this.constructor.name, "'s minWidth (").concat(minWidth, ") < childrenWidth (").concat(childrenWidth, ")"));
          }
        }
      } else {
        if (this.layoutWarnEnable) {
          if (minWidth > width || childrenWidth > width) {
            console.warn("Layout width warn: ".concat(this.constructor.name, "'s minWidth (").concat(minWidth, ") or childrenWidth (").concat(childrenWidth, " > targetWidth ").concat(width, ")"));
          }
        }
      }
      return width;
    };
  
    var HasWidthWrap$2 = function HasWidthWrap() {
      var child;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
          continue;
        }
        if (!child.hasWidthWrap || child.hasWidthWrap()) {
          return true;
        }
      }
      return false;
    };
  
    var ResolveChildrenWidth$1 = function ResolveChildrenWidth(parentWidth) {
      // Resolve width of sizer children
      var child, expandedChildWidth, childWidth;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (child && child.isRexSizer && !child.ignoreLayout) {
          expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
          childWidth = child.resolveWidth(expandedChildWidth);
          if (childWidth === undefined) {
            childWidth = expandedChildWidth;
          }
          child.resolveChildrenWidth(childWidth);
        }
      }
    };
  
    // Default method
    var RunWidthWrap$3 = function RunWidthWrap(parentWidth) {
      var child, expandedChildWidth, childWidth;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
          continue;
        }
        expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
        if (child.isRexSizer) {
          childWidth = child.resolveWidth(expandedChildWidth);
          if (childWidth === undefined) {
            childWidth = expandedChildWidth;
          }
        } else {
          childWidth = expandedChildWidth;
        }
        child.runWidthWrap(childWidth);
      }
      return this;
    };
  
    var ResolveHeight$3 = function ResolveHeight(height) {
      var childrenHeight = this.childrenHeight;
      if (childrenHeight === undefined) {
        // Can't resolve child height
        return undefined;
      }
      var minHeight = this.minHeight !== undefined ? this.minHeight : 0;
      if (height === undefined) {
        height = Math.max(minHeight, childrenHeight);
        if (this.layoutWarnEnable) {
          if (minHeight > 0 && childrenHeight > minHeight) {
            console.warn("Layout height warn: ".concat(this.constructor.name, "'s minHeight (").concat(minHeight, ") < childrenHeight (").concat(childrenHeight, ")"));
          }
        }
      } else {
        if (this.layoutWarnEnable) {
          if (minHeight > height || childrenHeight > height) {
            console.warn("Layout height warn: ".concat(this.constructor.name, "'s minHeight (").concat(minHeight, ") or childrenHeight (").concat(childrenHeight, ") > targetHeight (").concat(height, ")"));
          }
        }
      }
      return height;
    };
  
    var HasHeightWrap$2 = function HasHeightWrap() {
      var child;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
          continue;
        }
        if (!child.hasHeightWrap || child.hasHeightWrap() // all kind of sizers has hasHeightWrap method
        ) {
          return true;
        }
      }
      return false;
    };
  
    var ResolveChildrenHeight$1 = function ResolveChildrenHeight(parentHeight) {
      // Resolve width of sizer children
      var child, expandedChildHeight, childHeight;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (child && child.isRexSizer && !child.ignoreLayout) {
          expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
          childHeight = child.resolveHeight(expandedChildHeight);
          if (childHeight === undefined) {
            childHeight = expandedChildHeight;
          }
          child.resolveChildrenHeight(childHeight);
        }
      }
    };
  
    // Default method
    var RunHeightWrap$3 = function RunHeightWrap(parentHeight) {
      var child, expandedChildHeight, childHeight;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
          continue;
        }
        expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
        if (child.isRexSizer) {
          childHeight = child.resolveHeight(expandedChildHeight);
          if (childHeight === undefined) {
            childHeight = expandedChildHeight;
          }
        } else {
          childHeight = expandedChildHeight;
        }
        child.runHeightWrap(childHeight);
      }
      return this;
    };
  
    var GetChildWidth = function GetChildWidth(child) {
      var childWidth;
      if (child.isRexSizer) {
        // Sizer game object
        var childrenWidth = child.childrenWidth;
        if (childrenWidth == undefined) {
          return undefined;
        }
        childWidth = Math.max(child.minWidth, childrenWidth);
      } else {
        // Normal game object
        if (child.minWidth !== undefined) {
          // Force minWidth
          childWidth = child.minWidth;
        } else if (child._minWidth !== undefined) {
          // Force minWidth
          childWidth = child._minWidth;
        } else {
          childWidth = GetDisplayWidth(child);
        }
      }
      return childWidth;
    };
  
    var GetChildHeight = function GetChildHeight(child) {
      var childHeight;
      if (child.isRexSizer) {
        // Sizer game object
        var childrenHeight = child.childrenHeight;
        if (childrenHeight === undefined) {
          return undefined;
        }
        childHeight = Math.max(child.minHeight, childrenHeight);
      } else {
        // Normal game object
        if (child.minHeight !== undefined) {
          // Force minHeight
          childHeight = child.minHeight;
        } else if (child._minHeight !== undefined) {
          childHeight = child._minHeight;
        } else {
          childHeight = GetDisplayHeight(child);
        }
      }
      return childHeight;
    };
  
    // Override
    var GetExpandedChildWidth$3 = function GetExpandedChildWidth(child, parentWidth) {
      return parentWidth;
    };
  
    // Override
    var GetExpandedChildHeight$3 = function GetExpandedChildHeight(child, parentHeight) {
      return parentHeight;
    };
  
    // Override
    var GetChildrenWidth$5 = function GetChildrenWidth() {
      return 0;
    };
  
    // Override
    var GetChildrenHeight$5 = function GetChildrenHeight() {
      return 0;
    };
  
    var GetAllChildrenSizers = function GetAllChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      var startIdx = out.length;
      var children = this.getChildrenSizers(out);
      var endIdx = out.length;
      for (var i = startIdx; i < endIdx; i++) {
        children[i].getAllChildrenSizers(out);
      }
      return out;
    };
  
    // Default method
    var GetChildrenSizers$5 = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      return out;
    };
  
    var GetShownChildrenMethods = {
      getShownChildren: function getShownChildren(out) {
        if (out === undefined) {
          out = [];
        }
        var children = this.children,
          child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (child.rexSizer && child.rexSizer.hidden) {
            // Don't add hidden child
            continue;
          }
          out.push(child);
        }
        return out;
      },
      getAllShownChildren: function getAllShownChildren(out) {
        if (out === undefined) {
          out = [];
        }
        var queue = [this];
        while (queue.length > 0) {
          var current = queue.shift();
          if (current.rexSizer && current.rexSizer.hidden) {
            continue;
          }
          if (current !== this) {
            out.push(current);
          }
          if (current.isRexContainerLite) {
            queue.push.apply(queue, _toConsumableArray(current.children));
          }
        }
        return out;
      }
    };
  
    var PreLayout$4 = function PreLayout() {
      this._childrenWidth = undefined;
      this._childrenHeight = undefined;
      var children = this.getChildrenSizers(),
        child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.ignoreLayout) {
          continue;
        }
        child.preLayout();
      }
    };
  
    var Layout = function Layout() {
      // Skip hidden or !dirty sizer
      if (this.ignoreLayout) {
        return this;
      }
  
      // Save scale
      var scaleXSave = this.scaleX;
      var scaleYSave = this.scaleY;
      var scale1 = scaleXSave === 1 && scaleYSave === 1;
      if (!scale1) {
        this.setScale(1);
      }
  
      // Run layout with scale = 1
      this.runLayout();
  
      // Restore scale
      if (!scale1) {
        this.setScale(scaleXSave, scaleYSave);
      }
      return this;
    };
  
    // Override
    var RunLayout$1 = function RunLayout(parent, newWidth, newHeight) {
      // Skip hidden or !dirty sizer
      if (this.ignoreLayout) {
        return this;
      }
      var isTopmostParent = !parent;
      // Pre-processor, top parent only
      if (isTopmostParent) {
        this.preLayout();
      }
      var size, width, height;
      var runWidthWrap = isTopmostParent && this.hasWidthWrap();
      var runHeightWrap = isTopmostParent && this.hasHeightWrap();
      size = ResolveSize(this, newWidth, newHeight, runWidthWrap, runHeightWrap);
      if (!size) {
        console.error('Can\'t resolve size of ', this);
      }
      width = size.width;
      height = size.height;
  
      // Resize parent
      this.resize(width, height);
      if (this.sizerEventsEnable) {
        if (this.layoutedChildren === undefined) {
          this.layoutedChildren = [];
        }
      }
  
      // Layout children    
      this.layoutChildren();
  
      // Layout background children
      this.layoutBackgrounds();
      if (this.sizerEventsEnable) {
        this.emit('postlayout', this.layoutedChildren, this);
        this.layoutedChildren.length = 0;
      }
  
      // Custom postLayout callback
      this.postLayout();
  
      // Post-processor, top parent only
      if (isTopmostParent) {
        this._postLayout();
      }
      return this;
    };
    var ResolveSize = function ResolveSize(self, width, height, runWidthWrap, runHeightWrap) {
      var newWidth = ResolveWidth$2(self, width, runWidthWrap);
      var newHeight = ResolveHeight$2(self, height, runHeightWrap);
      if (newWidth === undefined) {
        newWidth = ResolveWidth$2(self, width, runWidthWrap);
      }
      if (newWidth !== undefined && newHeight !== undefined) {
        return {
          width: newWidth,
          height: newHeight
        };
      }
      return false;
    };
    var ResolveWidth$2 = function ResolveWidth(self, width, runWidthWrap) {
      // Calculate parent width
      var width = self.resolveWidth(width);
  
      // Calculate all children width, run width wrap
      if (width !== undefined) {
        if (runWidthWrap) {
          self.resolveChildrenWidth(width);
          self.runWidthWrap(width);
        }
      }
      return width;
    };
    var ResolveHeight$2 = function ResolveHeight(self, height, runHeightWrap) {
      // Calculate parent height
      var height = self.resolveHeight(height);
  
      // Calculate all children width, run width wrap
      if (height !== undefined) {
        if (runHeightWrap) {
          self.resolveChildrenHeight(height);
          self.runHeightWrap(height);
        }
      }
      return height;
    };
  
    // Override
    var LayoutChildren$6 = function LayoutChildren() {};
  
    var _PostLayout = function _PostLayout(parent, newWidth, newHeight) {
      if (this._anchor) {
        this._anchor.updatePosition();
      }
      return this;
    };
  
    // Override
    var PostLayout = function PostLayout(parent, newWidth, newHeight) {
      return this;
    };
  
    var HasResizeMethod = function HasResizeMethod(gameObject) {
      // 1st pass : Has `resize` method?
      if (gameObject.resize) {
        return true;
      }
  
      // 2nd pass : Has `setSize` method?
      if (!gameObject.setSize) {
        return false;
      }
      for (var i = 0, cnt = ExcludeClassList$1.length; i < cnt; i++) {
        var excludeClass = ExcludeClassList$1[i];
        if (excludeClass && gameObject instanceof excludeClass) {
          return false;
        }
      }
      return true;
    };
    var ExcludeClassList$1 = [Phaser.GameObjects.Image, Phaser.GameObjects.Sprite, Phaser.GameObjects.Mesh, Phaser.GameObjects.Shader, Phaser.GameObjects.Video];
  
    var CanSetDisplaySize = function CanSetDisplaySize(gameObject) {
      if (gameObject.displayWidth === undefined) {
        return false;
      }
      for (var i = 0, cnt = ExcludeClassList.length; i < cnt; i++) {
        var excludeClass = ExcludeClassList[i];
        if (excludeClass && gameObject instanceof excludeClass) {
          return false;
        }
      }
      return true;
    };
    var ExcludeClassList = [Phaser.GameObjects.BitmapText];
  
    var ResizeGameObject = function ResizeGameObject(gameObject, newWidth, newHeight) {
      if (!gameObject || newWidth === undefined && newHeight === undefined) {
        return;
      }
      if (HasResizeMethod(gameObject)) {
        // Has `resize`, or `setSize` method
        if (newWidth === undefined) {
          newWidth = gameObject.width;
        }
        if (newHeight === undefined) {
          newHeight = gameObject.height;
        }
        if (gameObject.resize) {
          gameObject.resize(newWidth, newHeight);
        } else {
          gameObject.setSize(newWidth, newHeight);
        }
      } else {
        // Set display width/height
        var canSetDisplaySize = CanSetDisplaySize(gameObject);
        if (newWidth !== undefined) {
          if (canSetDisplaySize) {
            gameObject.displayWidth = newWidth;
          } else {
            gameObject.scaleX = newWidth / gameObject.width;
          }
        }
        if (newHeight !== undefined) {
          if (canSetDisplaySize) {
            gameObject.displayHeight = newHeight;
          } else {
            gameObject.scaleY = newHeight / gameObject.height;
          }
        }
      }
    };
  
    var DefaultResizeCallback = function DefaultResizeCallback(width, height, gameObject, anchor) {
      ResizeGameObject(gameObject, width, height);
    };
  
    var GetValue$2C = Phaser.Utils.Objects.GetValue;
    var Anchor = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Anchor, _ComponentBase);
      function Anchor(gameObject, config) {
        var _this;
        _classCallCheck(this, Anchor);
        _this = _callSuper(this, Anchor, [gameObject, {
          eventEmitter: false
        }]);
        // No event emitter
        // this.parent = gameObject;
  
        _this.viewport = undefined;
        _this.resetFromJSON(config);
        return _this;
      }
      _createClass(Anchor, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.autoAnchor(false);
          this.viewport = undefined;
          this.onUpdateViewportCallback = undefined;
          this.onUpdateViewportCallbackScope = undefined;
          this.onResizeCallback = undefined;
          this.onResizeCallbackScope = undefined;
          _get(_getPrototypeOf(Anchor.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          if (o === undefined) {
            o = {};
          }
  
          // Position
          var alignX, configX;
          if (o.x !== undefined) {
            alignX = null;
            configX = o.x;
          } else if (o.left !== undefined) {
            alignX = 0;
            configX = o.left;
          } else if (o.right !== undefined) {
            alignX = 1;
            configX = o.right;
          } else if (o.centerX !== undefined) {
            alignX = 0.5;
            configX = o.centerX;
          }
          var alignY, configY;
          if (o.y !== undefined) {
            alignY = null;
            configY = o.y;
          } else if (o.top !== undefined) {
            alignY = 0;
            configY = o.top;
          } else if (o.bottom !== undefined) {
            alignY = 1;
            configY = o.bottom;
          } else if (o.centerY !== undefined) {
            alignY = 0.5;
            configY = o.centerY;
          }
          var percentageX, offsetX;
          if (configX !== undefined) {
            configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
            percentageX = parseFloat(configX[0]) / 100;
            offsetX = configX[1] === '' ? 0 : parseFloat(configX[1]);
          }
          var percentageY, offsetY;
          if (configY !== undefined) {
            configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
            percentageY = parseFloat(configY[0]) / 100;
            offsetY = configY[1] === '' ? 0 : parseFloat(configY[1]);
          }
  
          // Size
          var configWidth = o.width;
          var percentageWidth, paddingWidth;
          if (configWidth !== undefined) {
            configWidth = configWidth.split('%');
            percentageWidth = parseFloat(configWidth[0]) / 100;
            paddingWidth = configWidth[1] === '' ? 0 : parseFloat(configWidth[1]);
          }
          var configHeight = o.height;
          var percentageHeight, paddingHeight;
          if (configHeight !== undefined) {
            configHeight = configHeight.split('%');
            percentageHeight = parseFloat(configHeight[0]) / 100;
            paddingHeight = configHeight[1] === '' ? 0 : parseFloat(configHeight[1]);
          }
  
          // Position
          this.setAlign(alignX, alignY);
          this.setPercentage(percentageX, percentageY);
          this.setOffset(offsetX, offsetY);
          // Size
          this.setSizePercentage(percentageWidth, percentageHeight);
          this.setSizePadding(paddingWidth, paddingHeight);
          var onResizeCallback = GetValue$2C(o, 'onResizeCallback', DefaultResizeCallback);
          var onResizeCallbackScope = GetValue$2C(o, 'onResizeCallbackScope');
          this.setResizeCallback(onResizeCallback, onResizeCallbackScope);
          var onUpdateViewportCallback = GetValue$2C(o, 'onUpdateViewportCallback');
          var onUpdateViewportCallbackScope = GetValue$2C(o, 'onUpdateViewportCallbackScope');
          this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);
          this.autoAnchor(o.enable);
          return this;
        }
      }, {
        key: "autoAnchor",
        value: function autoAnchor(enable) {
          if (enable === undefined) {
            enable = true;
          }
          enable = !!enable;
          if (this.autoAnchorEnable === enable) {
            return this;
          }
          if (enable) {
            this.scene.sys.scale.on('resize', this.anchor, this);
            this.anchor();
          } else {
            this.scene.sys.scale.off('resize', this.anchor, this);
          }
          this.autoAnchorEnable = enable;
          return this;
        }
  
        // Position
      }, {
        key: "setAlign",
        value: function setAlign(x, y) {
          this.alignX = x;
          this.alignY = y;
          return this;
        }
      }, {
        key: "setPercentage",
        value: function setPercentage(x, y) {
          this.percentageX = x;
          this.percentageY = y;
          return this;
        }
      }, {
        key: "setOffset",
        value: function setOffset(x, y) {
          this.offsetX = x;
          this.offsetY = y;
          return this;
        }
  
        // Size
      }, {
        key: "setSizePercentage",
        value: function setSizePercentage(width, height) {
          this.percentageWidth = width;
          this.percentageHeight = height;
          return this;
        }
      }, {
        key: "setSizePadding",
        value: function setSizePadding(width, height) {
          this.paddingWidth = width;
          this.paddingHeight = height;
          return this;
        }
      }, {
        key: "setResizeCallback",
        value: function setResizeCallback(callback, scope) {
          this.onResizeCallback = callback;
          this.onResizeCallbackScope = scope;
          return this;
        }
      }, {
        key: "setUpdateViewportCallback",
        value: function setUpdateViewportCallback(callback, scope) {
          this.onUpdateViewportCallback = callback;
          this.onUpdateViewportCallbackScope = scope;
          return this;
        }
      }, {
        key: "anchor",
        value: function anchor() {
          this.updateViewport();
          this.updateSize();
          this.updatePosition();
          return this;
        }
      }, {
        key: "updateSize",
        value: function updateSize() {
          var callback = this.onResizeCallback,
            scope = this.onResizeCallbackScope;
          var newWidth = this.anchorWidth,
            newHeight = this.anchorHeight;
          if (newWidth === undefined && newHeight === undefined || !callback) {
            return;
          }
          var gameObject = this.parent;
          if (newWidth === undefined) {
            newWidth = gameObject.width;
          }
          if (newHeight === undefined) {
            newHeight = gameObject.height;
          }
          if (scope) {
            callback.call(scope, newWidth, newHeight, gameObject, this);
          } else {
            callback(newWidth, newHeight, gameObject, this);
          }
        }
      }, {
        key: "updatePosition",
        value: function updatePosition() {
          var gameObject = this.parent;
          if (this.alignX === null) {
            gameObject.x = this.anchorX;
          } else if (this.alignX !== undefined) {
            gameObject.x = this.anchorX + gameObject.displayWidth * (gameObject.originX - this.alignX);
          }
          if (this.alignY === null) {
            gameObject.y = this.anchorY;
          } else if (this.alignY !== undefined) {
            gameObject.y = this.anchorY + gameObject.displayHeight * (gameObject.originY - this.alignY);
          }
          return this;
        }
      }, {
        key: "anchorX",
        get: function get() {
          return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX;
        }
      }, {
        key: "anchorY",
        get: function get() {
          return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY;
        }
      }, {
        key: "anchorWidth",
        get: function get() {
          if (this.percentageWidth === undefined) {
            return undefined;
          }
          return this.viewport.width * this.percentageWidth + this.paddingWidth;
        }
      }, {
        key: "anchorHeight",
        get: function get() {
          if (this.percentageHeight === undefined) {
            return undefined;
          }
          return this.viewport.height * this.percentageHeight + this.paddingHeight;
        }
      }, {
        key: "updateViewport",
        value: function updateViewport() {
          var camera = this.parent.scene.cameras.main;
          this.viewport = GetViewport(this.scene, camera, this.viewport);
          var viewport = this.viewport;
          var callback = this.onUpdateViewportCallback,
            scope = this.onUpdateViewportCallbackScope;
          if (callback) {
            if (scope) {
              callback.call(scope, viewport, this.parent, this);
            } else {
              callback(viewport, this.parent, this);
            }
          }
        }
      }]);
      return Anchor;
    }(ComponentBase);
  
    var SetAnchor = function SetAnchor(config) {
      if (config === undefined) {
        config = {};
      }
  
      // Assign default onResizeCallback if not given    
      var hasMinWidth = config.hasOwnProperty('width');
      var hasMinHeight = config.hasOwnProperty('height');
      var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');
      if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
        config.onResizeCallback = function (width, height, sizer) {
          if (hasMinWidth) {
            sizer.setMinWidth(width);
          }
          if (hasMinHeight) {
            sizer.setMinHeight(height);
          }
          sizer.layout();
        };
      }
      if (this._anchor === undefined) {
        this._anchor = new Anchor(this, config);
      } else {
        this._anchor.resetFromJSON(config);
      }
      return this;
    };
  
    var GetValue$2B = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
    var Linear$6 = Phaser.Math.Linear;
    var Scale = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(Scale, _EaseValueTaskBase);
      function Scale(gameObject, config) {
        var _this;
        _classCallCheck(this, Scale);
        _this = _callSuper(this, Scale, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.scaleStart = {};
        _this.scaleEnd = {};
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Scale, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Scale.prototype), "resetFromJSON", this).call(this, o);
          this.setMode(GetValue$2B(o, 'mode', 0));
          this.setScaleRange(GetAdvancedValue$3(o, 'start', undefined), GetAdvancedValue$3(o, 'end', 0));
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = MODE$3[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setScaleRange",
        value: function setScaleRange(start, end) {
          if (typeof start === 'number') {
            this.startX = start;
            this.startY = start;
          } else {
            this.startX = GetAdvancedValue$3(start, 'x', this.parent.scaleX);
            this.startY = GetAdvancedValue$3(start, 'y', this.parent.scaleY);
          }
          if (typeof end === 'number') {
            this.endX = end;
            this.endY = end;
          } else {
            this.endX = GetAdvancedValue$3(end, 'x', undefined);
            this.endY = GetAdvancedValue$3(end, 'y', undefined);
          }
          this.hasScaleX = this.startX !== undefined && this.endX !== undefined;
          this.hasScaleY = this.startY !== undefined && this.endY !== undefined;
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.timer.isRunning) {
            return this;
          }
          var gameObject = this.parent;
          if (this.hasScaleX) {
            gameObject.scaleX = this.startX;
          }
          if (this.hasScaleY) {
            gameObject.scaleY = this.startY;
          }
          var repeat = this.repeat;
          if (this.mode === 2) {
            // Yoyo
            if (repeat !== -1) {
              repeat = (repeat + 1) * 2 - 1;
            }
          }
          this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(repeat);
          _get(_getPrototypeOf(Scale.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(gameObject, timer) {
          var t = timer.t;
          if (timer.isOddIteration) {
            // Yoyo
            t = 1 - t;
          }
          t = this.easeFn(t);
          if (this.hasScaleX) {
            gameObject.scaleX = Linear$6(this.startX, this.endX, t);
          }
          if (this.hasScaleY) {
            gameObject.scaleY = Linear$6(this.startY, this.endY, t);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          _get(_getPrototypeOf(Scale.prototype), "complete", this).call(this);
          if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
          }
          return this;
        }
      }]);
      return Scale;
    }(EaseValueTaskBase);
    var MODE$3 = {
      stop: 0,
      destroy: 1,
      yoyo: 2
    };
  
    var PopUp$1 = function PopUp(gameObject, duration, orientation, ease, scale) {
      if (ease === undefined) {
        ease = 'Cubic';
      }
  
      // Ease scale from 0 to current scale
      var start, end;
      switch (orientation) {
        case 0:
        case 'x':
          start = {
            x: 0
          };
          end = {
            x: gameObject.scaleX
          };
          break;
        case 1:
        case 'y':
          start = {
            y: 0
          };
          end = {
            y: gameObject.scaleY
          };
          break;
        default:
          start = 0;
          end = gameObject.scale;
          break;
      }
      var config = {
        mode: 0,
        start: start,
        end: end,
        duration: duration,
        ease: ease
      };
      if (scale === undefined) {
        scale = new Scale(gameObject, config);
      } else {
        scale.resetFromJSON(config);
      }
      scale.restart();
      return scale;
    };
  
    var ScaleDownDestroy = function ScaleDownDestroy(gameObject, duration, orientation, ease, destroyMode, scale) {
      if (ease === undefined) {
        ease = 'Linear';
      }
  
      // Ease from current scale to 0
      if (destroyMode instanceof Scale) {
        scale = destroyMode;
        destroyMode = undefined;
      }
      if (destroyMode === undefined) {
        destroyMode = true;
      }
      var config = {};
      config.mode = destroyMode ? 1 : 0;
      switch (orientation) {
        case 0:
        case 'x':
          config.end = {
            x: 0
          };
          break;
        case 1:
        case 'y':
          config.end = {
            y: 0
          };
          break;
        default:
          config.end = 0;
          break;
      }
      config.duration = duration;
      config.ease = ease;
      if (scale === undefined) {
        scale = new Scale(gameObject, config);
      } else {
        scale.resetFromJSON(config);
      }
      scale.restart();
      return scale;
    };
  
    var Yoyo = function Yoyo(gameObject, duration, peakValue, repeat, orientation, ease, scale) {
      if (peakValue === undefined) {
        peakValue = 1.2;
      }
      if (repeat === undefined) {
        repeat = 0;
      }
      if (ease === undefined) {
        ease = 'Cubic';
      }
  
      // Ease scale from 0 to current scale
      var start, end;
      switch (orientation) {
        case 0:
        case 'x':
          start = {
            x: gameObject.scaleX
          };
          end = {
            x: peakValue
          };
          break;
        case 1:
        case 'y':
          start = {
            y: gameObject.scaleX
          };
          end = {
            y: peakValue
          };
          break;
        default:
          start = gameObject.scaleX;
          end = peakValue;
          break;
      }
      var config = {
        mode: 2,
        start: start,
        end: end,
        duration: duration / 2,
        ease: ease,
        repeat: repeat
      };
      if (scale === undefined) {
        scale = new Scale(gameObject, config);
      } else {
        scale.resetFromJSON(config);
      }
      scale.restart();
      return scale;
    };
  
    var IsPlainObject$C = Phaser.Utils.Objects.IsPlainObject;
    var ScaleMethods = {
      onInitScale: function onInitScale() {
        var gameObject = this;
        var scale = this._scaleBehavior;
  
        // Route 'complete' of scale to gameObject
        scale.completeEventName = undefined;
        scale.on('complete', function () {
          if (scale.completeEventName) {
            gameObject.emit(scale.completeEventName, gameObject);
            scale.completeEventName = undefined;
          }
        });
      },
      popUp: function popUp(duration, orientation, ease) {
        if (IsPlainObject$C(duration)) {
          var config = duration;
          duration = config.duration;
          orientation = config.orientation;
          ease = config.ease;
        }
        var isInit = this._scaleBehavior === undefined;
        this._scaleBehavior = PopUp$1(this, duration, orientation, ease, this._scaleBehavior);
        if (isInit) {
          this.onInitScale();
        }
        this._scaleBehavior.completeEventName = 'popup.complete';
        return this;
      },
      popUpPromise: function popUpPromise(duration, orientation, ease) {
        this.popUp(duration, orientation, ease);
        return WaitComplete(this._scaleBehavior);
      },
      isRunningPopUp: function isRunningPopUp() {
        return this._scaleBehavior && this._scaleBehavior.completeEventName === 'popup.complete';
      },
      scaleDownDestroy: function scaleDownDestroy(duration, orientation, ease, destroyMode) {
        if (IsPlainObject$C(duration)) {
          var config = duration;
          duration = config.duration;
          orientation = config.orientation;
          ease = config.ease;
          destroyMode = config.destroy;
        }
        var isInit = this._scaleBehavior === undefined;
        this._scaleBehavior = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scaleBehavior);
        if (isInit) {
          this.onInitScale();
        }
        this._scaleBehavior.completeEventName = 'scaledown.complete';
        return this;
      },
      scaleDownDestroyPromise: function scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
        this.scaleDownDestroy(duration, orientation, ease, destroyMode);
        return WaitComplete(this._scaleBehavior);
      },
      scaleDown: function scaleDown(duration, orientation, ease) {
        this.scaleDownDestroy(duration, orientation, ease, false);
        return this;
      },
      scaleDownPromise: function scaleDownPromise(duration, orientation, ease) {
        this.scaleDown(duration, orientation, ease);
        return WaitComplete(this._scaleBehavior);
      },
      isRunningScaleDown: function isRunningScaleDown() {
        return this._scaleBehavior && this._scaleBehavior.completeEventName === 'scaledown.complete';
      },
      scaleYoyo: function scaleYoyo(duration, peakValue, repeat, orientation, ease) {
        if (IsPlainObject$C(duration)) {
          var config = duration;
          duration = config.duration;
          peakValue = config.peakValue;
          repeat = config.repeat;
          orientation = config.orientation;
          ease = config.ease;
        }
        var isInit = this._scaleBehavior === undefined;
        this._scaleBehavior = Yoyo(this, duration, peakValue, repeat, orientation, ease, this._scaleBehavior);
        if (isInit) {
          this.onInitScale();
        }
        this._scaleBehavior.completeEventName = 'scaleyoyo.complete';
        return this;
      },
      scaleYoyoPromise: function scaleYoyoPromise(duration, peakValue, repeat, orientation, ease) {
        this.scaleYoyo(duration, peakValue, repeat, orientation, ease);
        return WaitComplete(this._scaleBehavior);
      },
      isRunningScaleYoyo: function isRunningScaleYoyo() {
        return this._scaleBehavior && (this._scaleBehavior.completeEventName = 'scaleyoyo.complete');
      },
      isRunningEaseScale: function isRunningEaseScale() {
        return this.isRunningPopUp() || this.isRunningScaleDown() || this.isRunningScaleYoyo();
      }
    };
  
    var methods$y = {};
    Object.assign(methods$y, ScaleMethods);
    methods$y.onInitScale = function () {
      ScaleMethods.onInitScale.call(this);
      var gameObject = this;
      var scale = this._scaleBehavior;
      // Update local state
      scale.on('update', function () {
        var parent = GetParentSizerMethods.getParentSizer(gameObject);
        if (parent) {
          parent.resetChildPositionState(gameObject);
        }
      });
    };
  
    var GetValue$2A = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
    var Linear$5 = Phaser.Math.Linear;
    var Fade$2 = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(Fade, _EaseValueTaskBase);
      function Fade(gameObject, config) {
        var _this;
        _classCallCheck(this, Fade);
        _this = _callSuper(this, Fade, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Fade, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);
          this.setMode(GetValue$2A(o, 'mode', 0));
          this.setAlphaRange(GetAdvancedValue$2(o, 'start', this.parent.alpha), GetAdvancedValue$2(o, 'end', 0));
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = MODE$2[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setAlphaRange",
        value: function setAlphaRange(start, end) {
          this.alphaStart = start;
          this.alphaEnd = end;
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.timer.isRunning) {
            return this;
          }
          var gameObject = this.parent;
          gameObject.setAlpha(this.alphaStart);
          this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
          _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(gameObject, timer) {
          var t = timer.t;
          if (timer.isOddIteration) {
            // Yoyo
            t = 1 - t;
          }
          gameObject.alpha = Linear$5(this.alphaStart, this.alphaEnd, t);
        }
      }, {
        key: "complete",
        value: function complete() {
          _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);
          if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
          }
          return this;
        }
      }]);
      return Fade;
    }(EaseValueTaskBase);
    var MODE$2 = {
      stop: 0,
      destroy: 1,
      yoyo: 2
    };
  
    var IsPlainObject$B = Phaser.Utils.Objects.IsPlainObject;
    var FadeIn = function FadeIn(gameObject, duration, alpha, fade) {
      var startAlpha, endAlpha;
      if (IsPlainObject$B(alpha)) {
        startAlpha = alpha.start;
        endAlpha = alpha.end;
      } else {
        endAlpha = alpha;
      }
      if (startAlpha === undefined) {
        startAlpha = 0;
      }
      if (endAlpha === undefined) {
        endAlpha = 1;
      }
      var config = {
        mode: 0,
        start: startAlpha,
        end: endAlpha,
        duration: duration
      };
      if (fade === undefined) {
        fade = new Fade$2(gameObject, config);
      } else {
        fade.resetFromJSON(config);
      }
      fade.restart();
      return fade;
    };
  
    var FadeOutDestroy = function FadeOutDestroy(gameObject, duration, destroyMode, fade) {
      if (destroyMode instanceof Fade$2) {
        fade = destroyMode;
        destroyMode = undefined;
      }
      if (destroyMode === undefined) {
        destroyMode = true;
      }
      var config = {
        mode: destroyMode ? 1 : 0,
        end: 0,
        duration: duration
      };
      if (fade === undefined) {
        fade = new Fade$2(gameObject, config);
      } else {
        fade.resetFromJSON(config);
      }
      fade.restart();
      return fade;
    };
  
    var IsPlainObject$A = Phaser.Utils.Objects.IsPlainObject;
    var FadeMethods = {
      onInitFade: function onInitFade() {
        var gameObject = this;
        var fade = this._fade;
  
        // Route 'complete' of fade to gameObject
        fade.completeEventName = undefined;
        fade.on('complete', function () {
          if (fade.completeEventName) {
            gameObject.emit(fade.completeEventName, gameObject);
            fade.completeEventName = undefined;
          }
        });
      },
      fadeIn: function fadeIn(duration, alpha) {
        if (IsPlainObject$A(duration)) {
          var config = duration;
          duration = config.duration;
          alpha = config.alpha;
        }
        var isInit = this._fade === undefined;
        this._fade = FadeIn(this, duration, alpha, this._fade);
        if (isInit) {
          this.onInitFade();
        }
        this._fade.completeEventName = 'fadein.complete';
        return this;
      },
      fadeInPromise: function fadeInPromise(duration, alpha) {
        this.fadeIn(duration, alpha);
        return WaitComplete(this._fade);
      },
      isRunningFadeIn: function isRunningFadeIn() {
        return this._fade && this._fade.completeEventName === 'fadein.complete';
      },
      fadeOutDestroy: function fadeOutDestroy(duration, destroyMode) {
        if (IsPlainObject$A(duration)) {
          var config = duration;
          duration = config.duration;
          destroyMode = config.destroy;
        }
        var isInit = this._fade === undefined;
        this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);
        if (isInit) {
          this.onInitFade();
        }
        this._fade.completeEventName = 'fadeout.complete';
        return this;
      },
      fadeOutDestroyPromise: function fadeOutDestroyPromise(duration, destroyMode) {
        this.fadeOutDestroy(duration, destroyMode);
        return WaitComplete(this._fade);
      },
      fadeOut: function fadeOut(duration) {
        this.fadeOutDestroy(duration, false);
        return this;
      },
      fadeOutPromise: function fadeOutPromise(duration) {
        this.fadeOut(duration);
        return WaitComplete(this._fade);
      },
      isRunningFadeOut: function isRunningFadeOut() {
        return this._fade && this._fade.completeEventName === 'fadeout.complete';
      },
      isRunningEaseFade: function isRunningEaseFade() {
        return this.isRunningFadeIn() || this.isRunningFadeOut();
      }
    };
  
    var methods$x = {};
    Object.assign(methods$x, FadeMethods);
    methods$x.onInitFade = function () {
      FadeMethods.onInitFade.call(this);
      var gameObject = this;
      var fade = this._fade;
      // Update local state
      fade.on('update', function () {
        var parent = GetParentSizerMethods.getParentSizer(gameObject);
        if (parent) {
          parent.resetChildAlphaState(gameObject);
        }
      });
    };
  
    var GetValue$2z = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
    var Linear$4 = Phaser.Math.Linear;
    var EaseMove = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(EaseMove, _EaseValueTaskBase);
      function EaseMove(gameObject, config) {
        var _this;
        _classCallCheck(this, EaseMove);
        _this = _callSuper(this, EaseMove, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(EaseMove, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(EaseMove.prototype), "resetFromJSON", this).call(this, o);
          this.setMode(GetValue$2z(o, 'mode', 0));
          if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
            var endX = GetAdvancedValue$1(o, 'x', undefined);
            var endY = GetAdvancedValue$1(o, 'y', undefined);
            this.setTargetPosition(endX, endY);
          } else {
            this.setTargetPosition(o);
          }
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = MODE$1[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setTargetPosition",
        value: function setTargetPosition(x, y) {
          if (typeof x === 'number' || typeof y === 'number') {
            // endX, endY
            // x,y : a number, or undefined
            this.startX = this.parent.x;
            this.startY = this.parent.y;
            this.endX = x;
            this.endY = y;
          } else {
            var config = x;
            this.startX = GetAdvancedValue$1(config, 'startX', undefined);
            this.startY = GetAdvancedValue$1(config, 'startY', undefined);
            this.endX = GetAdvancedValue$1(config, 'endX', undefined);
            this.endY = GetAdvancedValue$1(config, 'endY', undefined);
          }
          this.hasMoveX = this.startX !== undefined && this.endX !== undefined;
          this.hasMoveY = this.startY !== undefined && this.endY !== undefined;
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.timer.isRunning) {
            return this;
          }
          var gameObject = this.parent;
          if (this.hasMoveX) {
            gameObject.x = this.startX;
          }
          if (this.hasMoveY) {
            gameObject.y = this.startY;
          }
          this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
          _get(_getPrototypeOf(EaseMove.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(gameObject, timer) {
          var t = timer.t;
          if (timer.isOddIteration) {
            // Yoyo
            t = 1 - t;
          }
          t = this.easeFn(t);
          if (this.hasMoveX) {
            gameObject.x = Linear$4(this.startX, this.endX, t);
          }
          if (this.hasMoveY) {
            gameObject.y = Linear$4(this.startY, this.endY, t);
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          _get(_getPrototypeOf(EaseMove.prototype), "complete", this).call(this);
          if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
          }
          return this;
        }
      }]);
      return EaseMove;
    }(EaseValueTaskBase);
    var MODE$1 = {
      stop: 0,
      destroy: 1,
      yoyo: 2
    };
  
    var ParseValue = function ParseValue(propertyValue, startValue) {
      // propertyValue : number or string
      if (typeof propertyValue === 'number') {
        return propertyValue;
      } else {
        var op = propertyValue[0];
        var num = parseFloat(propertyValue.substr(2));
        switch (op) {
          case '+':
            return startValue + num;
          case '-':
            return startValue - num;
          case '*':
            return startValue * num;
          case '/':
            return startValue / num;
        }
      }
    };
  
    var EaseMoveTo = function EaseMoveTo(gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
      if (destroyMode instanceof EaseMove) {
        easeMove = destroyMode;
        destroyMode = undefined;
      }
      if (destroyMode === undefined) {
        destroyMode = false;
      }
      var config = {};
      config.mode = destroyMode ? 1 : 0;
      if (endX !== undefined) {
        config.startX = gameObject.x;
        config.endX = ParseValue(endX, gameObject.x);
      }
      if (endY !== undefined) {
        config.startY = gameObject.y;
        config.endY = ParseValue(endY, gameObject.y);
      }
      config.duration = duration;
      config.ease = ease === undefined ? 'Linear' : ease;
      if (easeMove === undefined) {
        easeMove = new EaseMove(gameObject, config);
      } else {
        easeMove.resetFromJSON(config);
      }
      easeMove.restart();
      return easeMove;
    };
  
    var EaseMoveFrom = function EaseMoveFrom(gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
      if (destroyMode instanceof EaseMove) {
        easeMove = destroyMode;
        destroyMode = undefined;
      }
      if (destroyMode === undefined) {
        destroyMode = false;
      }
      var config = {};
      config.mode = destroyMode ? 1 : 0;
      if (startX !== undefined) {
        config.startX = ParseValue(startX, gameObject.x);
        config.endX = gameObject.x;
      }
      if (startY !== undefined) {
        config.startY = ParseValue(startY, gameObject.y);
        config.endY = gameObject.y;
      }
      config.duration = duration;
      config.ease = ease === undefined ? 'Linear' : ease;
      if (easeMove === undefined) {
        easeMove = new EaseMove(gameObject, config);
      } else {
        easeMove.resetFromJSON(config);
      }
      easeMove.restart();
      return easeMove;
    };
  
    var IsPlainObject$z = Phaser.Utils.Objects.IsPlainObject;
    var DistanceBetween$6 = Phaser.Math.Distance.Between;
    var EaseMoveMethods = {
      onInitEaseMove: function onInitEaseMove() {
        var gameObject = this;
        var easeMove = this._easeMove;
        // Route 'complete' of easeMove to gameObject
        easeMove.completeEventName = undefined;
        easeMove.on('complete', function () {
          if (easeMove.completeEventName) {
            gameObject.emit(easeMove.completeEventName, gameObject);
            easeMove.completeEventName = undefined;
          }
        });
      },
      moveFrom: function moveFrom(duration, x, y, ease, destroyMode) {
        if (IsPlainObject$z(duration)) {
          var config = duration;
          x = config.x;
          y = config.y;
          if (config.hasOwnProperty('speed')) {
            duration = DistanceBetween$6(x, y, this.x, this.y) * 1000 / config.speed;
          } else {
            duration = config.duration;
          }
          ease = config.ease;
        }
        var isInit = this._easeMove === undefined;
        this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);
        if (isInit) {
          this.onInitEaseMove();
        }
        this._easeMove.completeEventName = 'movefrom.complete';
        return this;
      },
      moveFromPromise: function moveFromPromise(duration, x, y, ease, destroyMode) {
        this.moveFrom(duration, x, y, ease, destroyMode);
        return WaitComplete(this._easeMove);
      },
      moveFromDestroy: function moveFromDestroy(duration, x, y, ease) {
        this.moveFrom(duration, x, y, ease, true);
        return this;
      },
      moveFromDestroyPromise: function moveFromDestroyPromise(duration, x, y, ease) {
        this.moveFromDestroy(duration, x, y, ease);
        return WaitComplete(this._easeMove);
      },
      isRunningMoveFrom: function isRunningMoveFrom() {
        return this._easeMove && (this._easeMove.completeEventName = 'movefrom.complete');
      },
      moveTo: function moveTo(duration, x, y, ease, destroyMode) {
        if (IsPlainObject$z(duration)) {
          var config = duration;
          x = config.x;
          y = config.y;
          if (config.hasOwnProperty('speed')) {
            duration = DistanceBetween$6(x, y, this.x, this.y) * 1000 / config.speed;
          } else {
            duration = config.duration;
          }
          ease = config.ease;
        }
        var isInit = this._easeMove === undefined;
        this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);
        if (isInit) {
          this.onInitEaseMove();
        }
        this._easeMove.completeEventName === 'moveto.complete';
        return this;
      },
      moveToPromise: function moveToPromise(duration, x, y, ease, destroyMode) {
        this.moveTo(duration, x, y, ease, destroyMode);
        return WaitComplete(this._easeMove);
      },
      moveToDestroy: function moveToDestroy(duration, x, y, ease) {
        this.moveTo(duration, x, y, ease, true);
        return this;
      },
      moveToDestroyPromise: function moveToDestroyPromise(duration, x, y, ease) {
        this.moveToDestroy(duration, x, y, ease, true);
        return WaitComplete(this._easeMove);
      },
      isRunningMoveTo: function isRunningMoveTo() {
        return this._easeMove && this._easeMove.completeEventName === 'moveto.complete';
      },
      isRunningEaseMove: function isRunningEaseMove() {
        return this.isRunningMoveFrom() || this.isRunningMoveTo();
      },
      moveStop: function moveStop(toEnd) {
        if (!this._easeMove) {
          return this;
        }
        this._easeMove.stop(toEnd);
        return this;
      }
    };
  
    var methods$w = {};
    Object.assign(methods$w, EaseMoveMethods);
    methods$w.onInitEaseMove = function () {
      EaseMoveMethods.onInitEaseMove.call(this);
      var gameObject = this;
      var easeMove = this._easeMove;
      easeMove.on('update', function () {
        var parent = GetParentSizerMethods.getParentSizer(gameObject);
        if (parent) {
          parent.resetChildPositionState(gameObject);
        }
      });
    };
  
    var GetValue$2y = Phaser.Utils.Objects.GetValue;
    var ShakePosition = /*#__PURE__*/function (_TickTask) {
      _inherits(ShakePosition, _TickTask);
      function ShakePosition(gameObject, config) {
        var _this;
        _classCallCheck(this, ShakePosition);
        _this = _callSuper(this, ShakePosition, [gameObject, config]);
        // this.parent = gameObject;
  
        _this.timer = new Timer$1();
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(ShakePosition, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.timer.resetFromJSON(GetValue$2y(o, 'timer'));
          this.setEnable(GetValue$2y(o, 'enable', true));
          this.setMode(GetValue$2y(o, 'mode', 1));
          this.isRunning = GetValue$2y(o, 'isRunning', false);
          this.setMagnitudeMode(GetValue$2y(o, 'magnitudeMode', 1));
          this.setAxisMode(GetValue$2y(o, "axis", 0));
          this.setDuration(GetValue$2y(o, 'duration', 500));
          this.setMagnitude(GetValue$2y(o, 'magnitude', 10));
          this.ox = GetValue$2y(o, 'ox', undefined);
          this.oy = GetValue$2y(o, 'oy', undefined);
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            timer: this.timer.toJSON(),
            enable: this.enable,
            mode: this.mode,
            isRunning: this.isRunning,
            magnitudeMode: magnitudeMode,
            duration: this.duration,
            magnitude: this.magnitude,
            ox: this.ox,
            oy: this.oy
          };
        }
  
        // override
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          _get(_getPrototypeOf(ShakePosition.prototype), "shutdown", this).call(this, fromScene);
          this.timer.destroy();
          this.timer = undefined;
        }
      }, {
        key: "startTicking",
        value: function startTicking() {
          _get(_getPrototypeOf(ShakePosition.prototype), "startTicking", this).call(this);
          if (this.mode === 0) {
            // Effect mode
            this.scene.game.events.on('poststep', this.update, this);
            this.scene.game.events.on('prestep', this.backToOrigin, this);
          } else {
            // Behavior Mode
            this.scene.sys.events.on('preupdate', this.update, this);
          }
        }
      }, {
        key: "stopTicking",
        value: function stopTicking() {
          _get(_getPrototypeOf(ShakePosition.prototype), "stopTicking", this).call(this);
          if (this.scene) {
            // Scene might be destoryed
            if (this.mode === 0) {
              // Effect mode
              this.scene.game.events.off('poststep', this.update, this);
              this.scene.game.events.off('prestep', this.backToOrigin, this);
            } else {
              // Behavior Mode
              this.scene.sys.events.off('preupdate', this.update, this);
            }
          }
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e == undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(mode) {
          if (typeof mode === 'string') {
            mode = MODE[mode];
          }
          this.mode = mode;
          return this;
        }
      }, {
        key: "setMagnitudeMode",
        value: function setMagnitudeMode(magnitudeMode) {
          if (typeof magnitudeMode === 'string') {
            magnitudeMode = MANITUDEMODE[magnitudeMode];
          }
          this.magnitudeMode = magnitudeMode;
          return this;
        }
      }, {
        key: "setAxisMode",
        value: function setAxisMode(m) {
          if (typeof m === 'string') {
            m = DIRECTIONNODE$1[m];
          }
          this.axisMode = m;
          return this;
        }
      }, {
        key: "setDuration",
        value: function setDuration(duration) {
          this.duration = duration;
          return this;
        }
      }, {
        key: "setMagnitude",
        value: function setMagnitude(magnitude) {
          this.magnitude = magnitude;
          return this;
        }
      }, {
        key: "start",
        value: function start(duration, magnitude) {
          if (typeof duration !== 'number') {
            var config = duration;
            magnitude = GetValue$2y(config, 'magnitude', undefined);
            duration = GetValue$2y(config, 'duration', undefined);
          }
          if (magnitude !== undefined) {
            this.setMagnitude(magnitude);
          }
          if (duration !== undefined) {
            this.setDuration(duration);
          }
          this.timer.setDuration(this.duration).start();
          _get(_getPrototypeOf(ShakePosition.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "shake",
        value: function shake(duration, magnitude) {
          this.start(duration, magnitude);
          return this;
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          if (!this.isRunning || !this.enable) {
            return this;
          }
          var gameObject = this.parent;
          if (!gameObject.active) {
            return this;
          }
          this.timer.update(time, delta);
          if (this.timer.isDone) {
            this.backToOrigin();
            this.complete();
          } else {
            if (this.ox === undefined) {
              this.ox = gameObject.x;
              this.oy = gameObject.y;
            }
            var magnitude = this.magnitude;
            if (this.magnitudeMode === 1)
              // decay
              {
                magnitude *= 1 - this.timer.t;
              }
            var a = Math.random() * Math.PI * 2;
            var x = this.ox + Math.cos(a) * magnitude;
            var y = this.oy + Math.sin(a) * magnitude;
            switch (this.axisMode) {
              case 1:
                gameObject.x = x;
                break;
              case 2:
                gameObject.y = y;
                break;
              default:
                gameObject.x = x;
                gameObject.y = y;
                break;
            }
          }
          return this;
        }
      }, {
        key: "backToOrigin",
        value: function backToOrigin() {
          if (!this.isRunning || !this.enable) {
            return this;
          }
          if (this.ox === undefined) {
            return this;
          }
          var gameObject = this.parent;
          switch (this.axisMode) {
            case 1:
              gameObject.x = this.ox;
              break;
            case 2:
              gameObject.y = this.oy;
              break;
            default:
              gameObject.x = this.ox;
              gameObject.y = this.oy;
              break;
          }
          this.ox = undefined;
          this.oy = undefined;
          return this;
        }
      }]);
      return ShakePosition;
    }(TickTask);
    var MODE = {
      effect: 0,
      behavior: 1
    };
    var DIRECTIONNODE$1 = {
      'both': 0,
      'h&v': 0,
      'x&y': 0,
      'horizontal': 1,
      'h': 1,
      'x': 1,
      'vertical': 2,
      'v': 2,
      'y': 2
    };
    var MANITUDEMODE = {
      constant: 0,
      decay: 1
    };
  
    var IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;
    var OnInitShake = function OnInitShake(gameObject, shake) {
      // Route 'complete' of shake to gameObject
      shake.on('complete', function () {
        gameObject.emit('shake.complete', gameObject);
      });
  
      // Shake effect won't change position
    };
    var ShakeMethods = {
      shake: function shake(duration, magnitude, magnitudeMode) {
        if (IsPlainObject$y(duration)) {
          var config = duration;
          duration = config.duration;
          magnitude = config.magnitude;
          magnitudeMode = config.magnitudeMode;
        }
        if (this._shake === undefined) {
          this._shake = new ShakePosition(this, {
            mode: 0,
            magnitudeMode: 1
          });
          OnInitShake(this, this._shake);
        }
        if (duration !== undefined) {
          this._shake.setDuration(duration);
        }
        if (magnitude !== undefined) {
          this._shake.setMagnitude(magnitude);
        }
        if (magnitudeMode !== undefined) {
          this._shake.setMagnitudeMode(magnitudeMode);
        }
        this._shake.shake();
        return this;
      },
      shakePromise: function shakePromise(duration, alpha) {
        this.shake(duration, alpha);
        return WaitComplete(this._shake);
      }
    };
  
    var IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;
    var EaseData = /*#__PURE__*/function (_ComponentBase) {
      _inherits(EaseData, _ComponentBase);
      function EaseData(parent, config) {
        var _this;
        _classCallCheck(this, EaseData);
        _this = _callSuper(this, EaseData, [parent, config]);
        _this.parent.setDataEnabled();
        _this.easeTasks = {};
        return _this;
      }
      _createClass(EaseData, [{
        key: "complete",
        value: function complete(key) {
          this.emit("complete-".concat(key), this.parent, this);
          this.emit('complete', key, this.parent, this);
        }
      }, {
        key: "getEaseTask",
        value: function getEaseTask(key) {
          var easeTask = this.easeTasks[key];
          if (easeTask === undefined) {
            easeTask = new EaseValueTask(this.parent);
            this.easeTasks[key] = easeTask;
            easeTask.setTarget(this.parent.data.values).on('complete', function () {
              this.complete(key);
            }, this);
          }
          return easeTask;
        }
      }, {
        key: "easeTo",
        value: function easeTo(key, value, duration, ease) {
          if (IsPlainObject$x(key)) {
            var config = key;
            key = config.key;
            value = config.value;
            duration = config.duration;
            ease = config.ease;
            var speed = config.speed;
            if (duration === undefined && speed !== undefined) {
              duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
            }
          }
          if (duration === undefined) {
            duration = 1000;
          }
          if (ease === undefined) {
            ease = 'Linear';
          }
          var easeTask = this.getEaseTask(key);
          easeTask.restart({
            key: key,
            to: value,
            duration: duration,
            ease: ease
          });
          return this;
        }
      }, {
        key: "easeFrom",
        value: function easeFrom(key, value, duration, ease) {
          if (IsPlainObject$x(key)) {
            var config = key;
            key = config.key;
            value = config.value;
            duration = config.duration;
            ease = config.ease;
            var speed = config.speed;
            if (duration === undefined && speed !== undefined) {
              duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
            }
          }
          if (duration === undefined) {
            duration = 1000;
          }
          if (ease === undefined) {
            ease = 'Linear';
          }
          var easeTask = this.getEaseTask(key);
          easeTask.restart({
            key: key,
            from: value,
            duration: duration,
            ease: ease
          });
          return this;
        }
      }, {
        key: "stopEase",
        value: function stopEase(key, toEnd) {
          if (toEnd === undefined) {
            toEnd = true;
          }
          var easeTask = this.easeTasks[key];
          if (easeTask) {
            easeTask.stop(toEnd);
          }
          return this;
        }
      }, {
        key: "stopAll",
        value: function stopAll(toEnd) {
          if (toEnd === undefined) {
            toEnd = true;
          }
          for (var key in this.easeTasks) {
            this.stopEase(key, toEnd);
          }
          return this;
        }
      }]);
      return EaseData;
    }(ComponentBase);
  
    var OnInitEaseData = function OnInitEaseData(gameObject, easeData) {
      // Route 'complete' of easeData to gameObject
      easeData.on('complete', function (key) {
        gameObject.emit("easedata.".concat(key, ".complete"), gameObject);
        gameObject.emit('easedata.complete', key, gameObject);
      });
    };
    var EaseDataMethods = {
      easeDataTo: function easeDataTo(key, value, duration, ease) {
        if (!this._easeData) {
          this._easeData = new EaseData(this);
          OnInitEaseData(this, this._easeData);
        }
        this._easeData.easeTo(key, value, duration, ease);
        return this;
      },
      easeDataToPromise: function easeDataToPromise(key, value, duration, ease) {
        this.easeDataTo(key, value, duration, ease);
        return WaitEvent(this._easeData, "complete-".concat(key));
      },
      stopEaseData: function stopEaseData(key, toEnd) {
        if (!this._easeData) {
          return this;
        }
        this._easeData.stopEase(key, toEnd);
        return this;
      },
      stopAllEaseData: function stopAllEaseData(toEnd) {
        if (!this._easeData) {
          return this;
        }
        this._easeData.stopAll(toEnd);
        return this;
      }
    };
  
    var RemoveItem$3 = Phaser.Utils.Array.Remove;
    var OnInitDelayCallTimers = function OnInitDelayCallTimers(gameObject) {
      gameObject._delayCallTimers = [];
      gameObject.once('destroy', function () {
        var timers = gameObject._delayCallTimers;
        for (var i = 0, cnt = timers.length; i < cnt; i++) {
          timers[i].remove();
        }
        gameObject._delayCallTimers = undefined;
      });
    };
    var DelayCallMethods$2 = {
      delayCall: function delayCall(delay, callback, scope) {
        var timers = this._delayCallTimers;
        if (timers === undefined) {
          OnInitDelayCallTimers(this);
        }
        var timer;
        var self = this;
        var OnTimeOut = function OnTimeOut() {
          RemoveItem$3(self._delayCallTimers, timer);
          if (scope) {
            callback.call(scope);
          } else {
            callback();
          }
        };
        timer = this.scene.time.delayedCall(delay, OnTimeOut);
        this._delayCallTimers.push(timer);
        return this;
      }
    };
  
    var Show = function Show(gameObject) {
      _hide(gameObject, false);
    };
    var Hide = function Hide(gameObject) {
      _hide(gameObject, true);
    };
    var IsShown = function IsShown(gameObject) {
      if (!gameObject) {
        return false;
      }
      var config = GetSizerConfig$1(gameObject);
      return !config.hidden;
    };
    var _hide = function _hide(gameObject, hidden) {
      if (!gameObject) {
        return;
      }
      var config = GetSizerConfig$1(gameObject);
      config.hidden = hidden;
      var parent = GetParent$1(gameObject);
      if (parent) {
        parent.setChildVisible(gameObject, !hidden);
      } else {
        gameObject.setVisible(!hidden);
      }
    };
  
    var HideMethods = {
      show: function show(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        Show(gameObject);
        return this;
      },
      hide: function hide(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        Hide(gameObject);
        return this;
      },
      isShow: function isShow(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        return IsShown(gameObject);
      }
    };
  
    var StateProperties$1 = ['next', 'exit', 'enter'];
    var FSM$1 = /*#__PURE__*/function () {
      /*
      var config = {
          start: 'A',   // default: undefined
          states: {
              A: {
                  next: 'B',  // function() { return 'B'; }
                  enter: function() {},
                  exit: function() {},
              },
              // ...
          },        
          extend: {
              i: 0,
              name: 'abc'
              // ...
          },
          init: function() {},
          enable: true,
          eventEmitter: true,
      };
      */
      function FSM(config) {
        _classCallCheck(this, FSM);
        // Attach get-next-state function
        var states = GetValue$3G(config, 'states', undefined);
        if (states) {
          this.addStates(states);
        }
  
        // Attach extend members
        var extend = GetValue$3G(config, 'extend', undefined);
        if (extend) {
          for (var name in extend) {
            if (!this.hasOwnProperty(name) || this[name] === undefined) {
              this[name] = extend[name];
            }
          }
        }
  
        // Event emitter
        var eventEmitter = GetValue$3G(config, 'eventEmitter', undefined);
        var EventEmitterClass = GetValue$3G(config, 'EventEmitterClass', undefined);
        this.setEventEmitter(eventEmitter, EventEmitterClass);
        this._stateLock = false;
        this.resetFromJSON(config);
      }
      _createClass(FSM, [{
        key: "shutdown",
        value: function shutdown() {
          this.destroyEventEmitter();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.shutdown();
        }
      }, {
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setEnable(GetValue$3G(o, 'enable', true));
          this.start(GetValue$3G(o, 'start', undefined));
          var init = GetValue$3G(o, 'init', undefined);
          if (init) {
            init.call(this);
          }
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            curState: this.state,
            prevState: this.prevState,
            enable: this.enable,
            start: this._start
          };
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "state",
        get: function get() {
          return this._state;
        },
        set: function set(newState) {
          if (!this.enable || this._stateLock) {
            return;
          }
          if (this._state === newState) {
            return;
          }
          this._prevState = this._state;
          this._state = newState;
          this._stateLock = true; // lock state
  
          this.emit('statechange', this);
          if (this._prevState != null) {
            var exitEventName = 'exit_' + this._prevState;
            var exitCallback = this[exitEventName];
            if (exitCallback) {
              exitCallback.call(this);
            }
            this.emit(exitEventName, this);
          }
          this._stateLock = false;
          if (this._state != null) {
            var enterEventName = 'enter_' + this._state;
            var enterCallback = this[enterEventName];
            if (enterCallback) {
              enterCallback.call(this);
            }
            this.emit(enterEventName, this);
          }
        }
      }, {
        key: "prevState",
        get: function get() {
          return this._prevState;
        }
      }, {
        key: "start",
        value: function start(state) {
          this._start = state;
          this._prevState = undefined;
          this._state = state; // Won't fire statechange events
          return this;
        }
      }, {
        key: "goto",
        value: function goto(nextState) {
          if (nextState != null) {
            this.state = nextState;
          }
          return this;
        }
      }, {
        key: "next",
        value: function next() {
          var nextState;
          var getNextState = this['next_' + this.state];
          if (getNextState) {
            if (typeof getNextState === 'string') {
              nextState = getNextState;
            } else {
              nextState = getNextState.call(this);
            }
          }
          this["goto"](nextState);
          return this;
        }
      }, {
        key: "stateProperties",
        get: function get() {
          return StateProperties$1;
        }
      }, {
        key: "addState",
        value: function addState(name, state) {
          if (typeof name !== 'string') {
            state = name;
            name = state.name;
          }
          var stateProperties = this.stateProperties;
          for (var i = 0, cnt = stateProperties.length; i < cnt; i++) {
            var propertyName = stateProperties[i];
            var propertyValue = state[propertyName];
            if (propertyValue) {
              this["".concat(propertyName, "_").concat(name)] = propertyValue;
            }
          }
          return this;
        }
      }, {
        key: "addStates",
        value: function addStates(states) {
          if (Array.isArray(states)) {
            for (var i = 0, cnt = states.length; i < cnt; i++) {
              this.addState(states[i]);
            }
          } else {
            for (var name in states) {
              this.addState(name, states[name]);
            }
          }
          return this;
        }
      }, {
        key: "runMethod",
        value: function runMethod(methodName, a1, a2, a3, a4, a5) {
          var fn = this[methodName + '_' + this.state];
          if (!fn) {
            return undefined;
          }
  
          // Copy from eventemitter3
          var len = arguments.length;
          switch (len) {
            case 1:
              return fn.call(this);
            case 2:
              return fn.call(this, a1);
            case 3:
              return fn.call(this, a1, a2);
            case 4:
              return fn.call(this, a1, a2, a3);
            case 5:
              return fn.call(this, a1, a2, a3, a4);
            case 6:
              return fn.call(this, a1, a2, a3, a4, a5);
          }
          var args = new Array(len - 1);
          for (var i = 1; i < len; i++) {
            args[i - 1] = arguments[i];
          }
          return fn.apply(this, args);
        }
      }]);
      return FSM;
    }();
    Object.assign(FSM$1.prototype, EventEmitterMethods);
  
    var HasListener = function HasListener(eventEmitter, eventName, fn, context, once) {
      if (once === undefined) {
        once = false;
      }
      var listeners = eventEmitter._events[eventName];
      if (!listeners) {
        return false;
      }
      for (var i = 0, cnt = listeners.length; i < cnt; i++) {
        var listener = listeners[i];
        if (listener.fn === fn && listener.context === context && listener.once === once) {
          return true;
        }
      }
      return false;
    };
  
    var StateProperties = ['next', 'exit', 'enter', 'update', 'preupdate', 'postupdate'];
    var FSM = /*#__PURE__*/function (_FSMBase) {
      _inherits(FSM, _FSMBase);
      function FSM() {
        _classCallCheck(this, FSM);
        return _callSuper(this, FSM, arguments);
      }
      _createClass(FSM, [{
        key: "shutdown",
        value:
        /*
        var config = {
            start: 'A',   // default: undefined
            states: {
                A: {
                    next: 'B',  // function() { return 'B'; }
                    enter: function() {},
                    exit: function() {},
                    update: function(time, delta) {},
                    preupdate: function(time, delta) {},
                    postupdate: function(time, delta) {},
                },
                // ...
            },        
            extend: {
                i: 0,
                name: 'abc'
                // ...
            },
            init: function() {},
            enable: true,
            scene: undefined,
            eventEmitter: true,
        };
        */
        function shutdown() {
          this.stopUpdate();
          this.stopPreUpdate();
          this.stopPostUpdate();
          this._scene = undefined;
          _get(_getPrototypeOf(FSM.prototype), "shutdown", this).call(this);
        }
      }, {
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(FSM.prototype), "resetFromJSON", this).call(this, o);
          this._scene = GetValue$3G(o, 'scene', undefined);
          return this;
        }
      }, {
        key: "stateProperties",
        get: function get() {
          return StateProperties;
        }
      }, {
        key: "update",
        value: function update(time, delta) {
          this.runMethod('update', time, delta);
        }
      }, {
        key: "preupdate",
        value: function preupdate(time, delta) {
          this.runMethod('preupdate', time, delta);
        }
      }, {
        key: "postupdate",
        value: function postupdate(time, delta) {
          this.runMethod('postupdate', time, delta);
        }
      }, {
        key: "startUpdate",
        value: function startUpdate(scene) {
          if (!scene) {
            scene = this._scene;
          }
          var eventEmitter = scene.sys.events;
          if (HasListener(eventEmitter, 'update', this.update, this)) {
            return this;
          }
          this._scene = scene;
          eventEmitter.on('update', this.update, this);
          return this;
        }
      }, {
        key: "stopUpdate",
        value: function stopUpdate() {
          if (!this._scene) {
            return this;
          }
          this._scene.sys.events.off('update', this.update, this);
          return this;
        }
      }, {
        key: "startPreUpdate",
        value: function startPreUpdate(scene) {
          if (!scene) {
            scene = this._scene;
          }
          var eventEmitter = scene.sys.events;
          if (HasListener(eventEmitter, 'preupdate', this.preupdate, this)) {
            return this;
          }
          this._scene = scene;
          eventEmitter.on('preupdate', this.preupdate, this);
          return this;
        }
      }, {
        key: "stopPreUpdate",
        value: function stopPreUpdate() {
          if (!this._scene) {
            return this;
          }
          this._scene.sys.events.off('preupdate', this.preupdate, this);
          return this;
        }
      }, {
        key: "startPostUpdate",
        value: function startPostUpdate(scene) {
          if (!scene) {
            scene = this._scene;
          }
          var eventEmitter = scene.sys.events;
          if (HasListener(eventEmitter, 'postupdate', this.postupdate, this)) {
            return this;
          }
          this._scene = scene;
          eventEmitter.on('postupdate', this.postupdate, this);
          return this;
        }
      }, {
        key: "stopPostUpdate",
        value: function stopPostUpdate() {
          if (!this._scene) {
            return this;
          }
          this._scene.sys.events.off('postupdate', this.postupdate, this);
          return this;
        }
      }]);
      return FSM;
    }(FSM$1);
  
    /*
    graph TD
  
    IDLE --> |"requestOpen()"| TRANS_OPNE["TRAN_OPEN<br>runTransitionInCallback()"]
    TRANS_OPNE --> |transitInTime| OPEN
    OPEN --> |"requestClose()"| TRANS_CLOSE["TRANS_CLOSE<br>runTransitionOutCallback()"]
    TRANS_CLOSE --> |transitOutTime| CLOSE
    CLOSE --> |"requestOpen()"| TRANS_OPNE
    */
    var State$1 = /*#__PURE__*/function (_FSM) {
      _inherits(State, _FSM);
      function State(parent, config) {
        var _this;
        _classCallCheck(this, State);
        _this = _callSuper(this, State, [config]);
        _this.parent = parent;
        var initState = config.initState || 'IDLE';
        _this.start(initState);
        return _this;
      }
      _createClass(State, [{
        key: "init",
        value: function init() {
          this.start('IDLE');
        }
  
        // IDLE -> TRANS_OPNE
      }, {
        key: "next_IDLE",
        value: function next_IDLE() {
          return 'TRANS_OPNE';
        }
        // IDLE
  
        // TRANS_OPNE -> OPEN
      }, {
        key: "next_TRANS_OPNE",
        value: function next_TRANS_OPNE() {
          return 'OPEN';
        }
      }, {
        key: "enter_TRANS_OPNE",
        value: function enter_TRANS_OPNE() {
          var transitionBehavior = this.parent;
          if (transitionBehavior.transitInTime > 0) {
            var delay = transitionBehavior.runTransitionInCallback();
            transitionBehavior.delayCall(delay, this.next, this);
          } else {
            this.next();
          }
        }
      }, {
        key: "exit_TRANS_OPNE",
        value: function exit_TRANS_OPNE() {
          var transitionBehavior = this.parent;
          transitionBehavior.removeDelayCall();
        }
        // TRANS_OPNE
  
        // OPEN -> TRANS_CLOSE
      }, {
        key: "next_OPEN",
        value: function next_OPEN() {
          return 'TRANS_CLOSE';
        }
      }, {
        key: "enter_OPEN",
        value: function enter_OPEN() {
          var transitionBehavior = this.parent;
          transitionBehavior.onOpen();
        }
      }, {
        key: "exit_OPEN",
        value: function exit_OPEN() {
          var transitionBehavior = this.parent;
          transitionBehavior.removeDelayCall();
        }
        // OPEN
  
        // TRANS_CLOSE -> CLOSE
      }, {
        key: "next_TRANS_CLOSE",
        value: function next_TRANS_CLOSE() {
          return 'CLOSE';
        }
      }, {
        key: "enter_TRANS_CLOSE",
        value: function enter_TRANS_CLOSE() {
          var transitionBehavior = this.parent;
          if (transitionBehavior.transitOutTime > 0) {
            var delay = transitionBehavior.runTransitionOutCallback();
            transitionBehavior.delayCall(delay, this.next, this);
          } else {
            this.next();
          }
        }
      }, {
        key: "exit_TRANS_CLOSE",
        value: function exit_TRANS_CLOSE() {
          var transitionBehavior = this.parent;
          transitionBehavior.removeDelayCall();
        }
        // TRANS_CLOSE
  
        // CLOSE -> TRANS_OPNE
      }, {
        key: "next_CLOSE",
        value: function next_CLOSE() {
          return 'TRANS_OPNE';
        }
      }, {
        key: "enter_CLOSE",
        value: function enter_CLOSE() {
          var transitionBehavior = this.parent;
          transitionBehavior.onClose();
        }
      }, {
        key: "exit_CLOSE",
        value: function exit_CLOSE() {}
        // CLOSE
      }, {
        key: "canOpen",
        value: function canOpen() {
          return this.state === 'IDLE' || this.state === 'CLOSE';
        }
      }, {
        key: "canClose",
        value: function canClose() {
          return this.state === 'IDLE' || this.state === 'OPEN';
        }
      }]);
      return State;
    }(FSM);
  
    var PostStepDelayCall = function PostStepDelayCall(gameObject, delay, callback, scope, args) {
      // Invoke callback under game's 'poststep' event
      var scene = GetSceneObject(gameObject);
      var timer = scene.time.delayedCall(delay, function () {
        scene.game.events.once('poststep', function () {
          callback.call(scope, args);
        });
      });
      return timer;
    };
  
    var DelayCallMethods$1 = {
      delayCall: function delayCall(delay, callback, scope) {
        // Invoke callback under scene's 'postupdate' event
        this.delayCallTimer = PostStepDelayCall(this, delay, callback, scope);
        return this;
      },
      removeDelayCall: function removeDelayCall() {
        if (this.delayCallTimer) {
          this.delayCallTimer.remove(false);
          this.delayCallTimer = undefined;
        }
        return this;
      }
    };
  
    var ConfigurationMethods$3 = {
      setTransitInTime: function setTransitInTime(time) {
        this.transitInTime = time;
        return this;
      },
      setTransitOutTime: function setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
      },
      setTransitInCallback: function setTransitInCallback(callback) {
        if (!callback) {
          callback = NOOP;
        }
        this.transitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setTransitOutCallback: function setTransitOutCallback(callback) {
        if (!callback) {
          callback = NOOP;
        }
        this.transitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      }
    };
  
    var OpenMethods$1 = {
      // Override
      runTransitionInCallback: function runTransitionInCallback() {
        this.transitInCallback(this.parent, this.transitInTime);
        return this.transitInTime;
      },
      // Override
      onOpen: function onOpen() {},
      requestOpen: function requestOpen(openEventData, duration) {
        if (!this._state.canOpen()) {
          return this;
        }
        this.openEventData = arguments.length > 0 ? openEventData : this.parent;
        var transitionTimeSave = this.transitInTime;
        if (duration !== undefined) {
          this.transitInTime = duration;
        }
        this._state["goto"]('TRANS_OPNE');
        this.transitInTime = transitionTimeSave;
        return this;
      }
    };
  
    var CloseMethods = {
      // Override
      runTransitionOutCallback: function runTransitionOutCallback() {
        this.transitOutCallback(this.parent, this.transitOutTime);
        return this.transitOutTime;
      },
      // Override
      onClose: function onClose() {
        // Destroy parent and this behavior
        if (this.oneShotMode) {
          this.parent.destroy();
          // Will invoke `this.destroy()`
        }
      },
      requestClose: function requestClose(closeEventData, duration) {
        if (!this._state.canClose) {
          return this;
        }
        this.closeEventData = arguments.length > 0 ? closeEventData : this.parent;
        var transitionTimeSave = this.transitOutTime;
        if (duration !== undefined) {
          this.transitOutTime = duration;
        }
        this._state["goto"]('TRANS_CLOSE');
        this.transitOutTime = transitionTimeSave;
        return this;
      }
    };
  
    var methods$v = {};
    Object.assign(methods$v, DelayCallMethods$1, ConfigurationMethods$3, OpenMethods$1, CloseMethods);
  
    var GetValue$2x = Phaser.Utils.Objects.GetValue;
    var OpenCloseTransition = /*#__PURE__*/function (_ComponentBase) {
      _inherits(OpenCloseTransition, _ComponentBase);
      function OpenCloseTransition(gameObject, config) {
        var _this;
        _classCallCheck(this, OpenCloseTransition);
        _this = _callSuper(this, OpenCloseTransition, [gameObject, config]);
        // this.parent = gameObject;
        // this.scene
  
        _this.setTransitInTime(GetValue$2x(config, 'duration.in', 200));
        _this.setTransitOutTime(GetValue$2x(config, 'duration.out', 200));
        _this.setTransitInCallback(GetValue$2x(config, 'transitIn'));
        _this.setTransitOutCallback(GetValue$2x(config, 'transitOut'));
        _this.oneShotMode = GetValue$2x(config, 'destroy', false);
        _this.delayCallTimer = undefined;
        _this._state = new State$1(_assertThisInitialized(_this), {
          eventEmitter: false,
          initState: GetValue$2x(config, 'initState', 'IDLE')
        });
        _this.openEventData = undefined;
        _this.closeEventData = undefined;
        return _this;
      }
      _createClass(OpenCloseTransition, [{
        key: "state",
        get: function get() {
          return this._state.state;
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.transitInCallback = undefined;
          this.transitOutCallback = undefined;
          this.openEventData = undefined;
          this.closeEventData = undefined;
          this.removeDelayCall();
          _get(_getPrototypeOf(OpenCloseTransition.prototype), "shutdown", this).call(this, fromScene);
        }
      }]);
      return OpenCloseTransition;
    }(ComponentBase);
    Object.assign(OpenCloseTransition.prototype, methods$v);
  
    var Rectangle = Phaser.GameObjects.Rectangle;
    var FullWindowRectangle = /*#__PURE__*/function (_Rectangle) {
      _inherits(FullWindowRectangle, _Rectangle);
      function FullWindowRectangle(scene, color, alpha) {
        var _this;
        _classCallCheck(this, FullWindowRectangle);
        _this = _callSuper(this, FullWindowRectangle, [scene, 0, 0, 2, 2, color, 1]);
        _this.fullWindow = new FullWindow(_assertThisInitialized(_this));
        _this.setAlpha(alpha);
        return _this;
      }
      _createClass(FullWindowRectangle, [{
        key: "tint",
        get: function get() {
          return this.fillColor;
        },
        set: function set(value) {
          this.setFillStyle(value, this.fillAlpha);
        }
      }]);
      return FullWindowRectangle;
    }(Rectangle);
  
    var GetValue$2w = Phaser.Utils.Objects.GetValue;
    var TouchEventStop = /*#__PURE__*/function (_ComponentBase) {
      _inherits(TouchEventStop, _ComponentBase);
      function TouchEventStop(gameObject, config) {
        var _this;
        _classCallCheck(this, TouchEventStop);
        _this = _callSuper(this, TouchEventStop, [gameObject, {
          eventEmitter: false
        }]);
        // No event emitter
        // this.parent = gameObject;
  
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(TouchEventStop, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setHitAreaMode(GetValue$2w(o, 'hitAreaMode', 0));
          this.setEnable(GetValue$2w(o, 'enable', true));
          this.setStopMode(GetValue$2w(o, 'stopAllLevels', true));
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          this.parent.on('pointerdown', function (pointer, localX, localY, event) {
            if (this.stopAllLevels) {
              event.stopPropagation();
            }
          }, this).on('pointerup', function (pointer, localX, localY, event) {
            if (this.stopAllLevels) {
              event.stopPropagation();
            }
          }, this).on('pointermove', function (pointer, localX, localY, event) {
            if (this.stopAllLevels) {
              event.stopPropagation();
            }
          }, this).on('pointerover', function (pointer, localX, localY, event) {
            if (this.stopAllLevels) {
              event.stopPropagation();
            }
          }, this).on('pointerout', function (pointer, event) {
            if (this.stopAllLevels) {
              event.stopPropagation();
            }
          }, this);
        }
      }, {
        key: "setHitAreaMode",
        value: function setHitAreaMode(mode) {
          if (typeof mode === 'string') {
            mode = HitAreaMode[mode];
          }
          var gameObject = this.parent;
          if (gameObject.input) {
            gameObject.removeInteractive();
          }
          if (mode === 0) {
            gameObject.setInteractive();
          } else {
            gameObject.setInteractive({
              hitArea: {},
              hitAreaCallback: function hitAreaCallback() {
                return true;
              }
            });
          }
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          if (e) {
            this.parent.setInteractive();
          } else {
            this.parent.disableInteractive();
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "setStopMode",
        value: function setStopMode(allLevels) {
          if (allLevels === undefined) {
            allLevels = true;
          }
          this.stopAllLevels = allLevels;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }]);
      return TouchEventStop;
    }(ComponentBase);
    var HitAreaMode = {
      "default": 0,
      fullWindow: 1
    };
  
    var GetValue$2v = Phaser.Utils.Objects.GetValue;
    var Cover = /*#__PURE__*/function (_FullWindowRectangle) {
      _inherits(Cover, _FullWindowRectangle);
      function Cover(scene, config) {
        var _this;
        _classCallCheck(this, Cover);
        var fillColor = GetValue$2v(config, 'color', 0x0);
        var fillAlpha = GetValue$2v(config, 'alpha', 0.8);
        _this = _callSuper(this, Cover, [scene, fillColor, fillAlpha]);
        _this.touchEventStop = new TouchEventStop(_assertThisInitialized(_this), {
          hitAreaMode: 1
        });
        return _this;
      }
      return _createClass(Cover);
    }(FullWindowRectangle);
  
    var CreateCover = function CreateCover(gameObject, config) {
      var scene = gameObject.scene;
      var cover = new Cover(scene, config);
      scene.add.existing(cover);
  
      // Put cover behind game object
      if (gameObject.isRexContainerLite) {
        gameObject.pin(cover, {
          syncPosition: false,
          syncRotation: false,
          syncScale: false,
          syncAlpha: false,
          syncScrollFactor: false
        });
        gameObject.moveDepthBelow(cover);
      } else {
        scene.children.moveBelow(cover, gameObject);
      }
      return cover;
    };
  
    var DefaultTransitCallbacks = {
      popUp: function popUp(gameObject, duration) {
        if (gameObject._modalScaleSave !== undefined) {
          gameObject.scaleX = gameObject._modalScaleSave;
          gameObject.scaleY = gameObject._modalScaleSave;
        } else {
          gameObject._modalScaleSave = gameObject.scaleX;
        }
        PopUp$1(gameObject, duration);
      },
      scaleDown: function scaleDown(gameObject, duration) {
        // Don't destroy here
        ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
      },
      fadeIn: function fadeIn(gameObject, duration) {
        if (gameObject._modalAlphaSave !== undefined) {
          gameObject.alpha = gameObject._modalAlphaSave;
        } else {
          gameObject._modalAlphaSave = gameObject.alpha;
        }
        FadeIn(gameObject, duration);
      },
      fadeOut: function fadeOut(gameObject, duration) {
        // Don't destroy here
        FadeOutDestroy(gameObject, duration, false);
      }
    };
  
    var DefaultCoverTransitInCallback = function DefaultCoverTransitInCallback(cover, duration) {
      if (cover._modalAlphaSave !== undefined) {
        cover.alpha = cover._modalAlphaSave;
      } else {
        cover._modalAlphaSave = cover.alpha;
      }
      FadeIn(cover, duration, cover.alpha);
    };
    var DefaultCoverTransitOutCallback = function DefaultCoverTransitOutCallback(cover, duration) {
      FadeOutDestroy(cover, duration, false);
    };
  
    var IsPointInBounds = function IsPointInBounds(gameObject, x, y, preTest, postTest) {
      // Can't get bounds
      if (!gameObject) {
        return false;
      }
      if (preTest && !preTest(gameObject, x, y)) {
        return false;
      }
      var boundsRect = GetBounds(gameObject, true);
      if (!boundsRect.contains(x, y)) {
        return false;
      }
      if (postTest && !postTest(gameObject, x, y)) {
        return false;
      }
      return true;
    };
  
    var GetValue$2u = Phaser.Utils.Objects.GetValue;
    var Modal$2 = /*#__PURE__*/function (_OpenCloseTransition) {
      _inherits(Modal, _OpenCloseTransition);
      function Modal(gameObject, config) {
        var _this;
        _classCallCheck(this, Modal);
        if (config === undefined) {
          config = {};
        }
        if (config.transitIn == null) {
          config.transitIn = TransitionMode$1.popUp;
        }
        if (config.transitOut == null) {
          config.transitOut = TransitionMode$1.scaleDown;
        }
        config.destroy = GetValue$2u(config, 'destroy', true);
        _this = _callSuper(this, Modal, [gameObject, config]);
        // this.parent = gameObject;
        // this.scene
  
        // Cover : key of modal, to block touch input        
        var coverConfig = GetValue$2u(config, 'cover');
        _this.cover = coverConfig !== false ? CreateCover(gameObject, coverConfig) : undefined;
        if (_this.cover) {
          _this.setCoverTransitInCallback(GetValue$2u(coverConfig, 'transitIn', DefaultCoverTransitInCallback));
          _this.setCoverTransitOutCallback(GetValue$2u(coverConfig, 'transitOut', DefaultCoverTransitOutCallback));
        }
  
        // Close conditions:
        var touchOutsideClose = GetValue$2u(config, 'touchOutsideClose', false);
        var timeOutDuration = GetValue$2u(config, 'duration.hold', -1);
        var timeOutClose = GetValue$2u(config, 'timeOutClose', timeOutDuration >= 0);
        var anyTouchClose = GetValue$2u(config, 'anyTouchClose', false);
        var manualClose = GetValue$2u(config, 'manualClose', false);
        if (manualClose) {
          touchOutsideClose = false;
          anyTouchClose = false;
          timeOutClose = false;
        }
        if (anyTouchClose) {
          touchOutsideClose = false;
        }
        if (timeOutClose) {
          _this.setDisplayTime(timeOutDuration);
        } else {
          _this.setDisplayTime(-1);
        }
  
        // Registet touch-close event after opened
        if (anyTouchClose) {
          _this.once('open', _this.anyTouchClose, _assertThisInitialized(_this));
        } else if (touchOutsideClose) {
          _this.once('open', _this.touchOutsideClose, _assertThisInitialized(_this));
        }
        if (GetValue$2u(config, 'openOnStart', true)) {
          // Run this.requestOpen() next tick
          // User can register events before this.requestOpen()
          _this.delayCall(0, _this.requestOpen, _assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Modal, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // Registered in touchOutsideClose(), or anyTouchClose()
          if (!this.cover) {
            this.scene.input.off('pointerup', this.touchCloseCallback, this);
          }
          if (this.cover && !fromScene) {
            this.cover.destroy();
            this.cover = undefined;
          }
          _get(_getPrototypeOf(Modal.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "touchOutsideClose",
        value: function touchOutsideClose() {
          if (this.cover) {
            this.cover.on('pointerup', this.touchCloseCallback, this);
          } else {
            this.scene.input.on('pointerup', this.touchCloseCallback, this);
          }
          this.clickOutsideTest = true;
          return this;
        }
      }, {
        key: "anyTouchClose",
        value: function anyTouchClose() {
          if (this.cover) {
            this.cover.once('pointerup', this.touchCloseCallback, this);
          } else {
            this.scene.input.once('pointerup', this.touchCloseCallback, this);
          }
          return this;
        }
      }, {
        key: "touchCloseCallback",
        value: function touchCloseCallback(pointer) {
          if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
            return;
          }
          this.requestClose();
        }
      }, {
        key: "runTransitionInCallback",
        value: function runTransitionInCallback() {
          var duration = _get(_getPrototypeOf(Modal.prototype), "runTransitionInCallback", this).call(this);
          var cover = this.cover;
          if (cover && this.coverTransitInCallback) {
            this.coverTransitInCallback(cover, duration);
          }
          return duration;
        }
      }, {
        key: "runTransitionOutCallback",
        value: function runTransitionOutCallback() {
          var duration = _get(_getPrototypeOf(Modal.prototype), "runTransitionOutCallback", this).call(this);
          var cover = this.cover;
          if (cover && this.coverTransitOutCallback) {
            this.coverTransitOutCallback(cover, duration);
          }
          return duration;
        }
      }, {
        key: "onOpen",
        value: function onOpen() {
          var duration = this.displayTime;
          if (duration >= 0) {
            this.delayCall(duration, this.requestClose,
            // callback
            this // scope
            );
          }
          this.emit('open', this.parent, this);
          _get(_getPrototypeOf(Modal.prototype), "onOpen", this).call(this);
        }
      }, {
        key: "onClose",
        value: function onClose() {
          this.emit('close', this.closeEventData);
          _get(_getPrototypeOf(Modal.prototype), "onClose", this).call(this);
        }
      }, {
        key: "setDisplayTime",
        value: function setDisplayTime(time) {
          this.displayTime = time;
          return this;
        }
      }, {
        key: "setTransitInCallback",
        value: function setTransitInCallback(callback) {
          if (typeof callback === 'string') {
            callback = TransitionMode$1[callback];
          }
          switch (callback) {
            case TransitionMode$1.popUp:
              callback = DefaultTransitCallbacks.popUp;
              break;
            case TransitionMode$1.fadeIn:
              callback = DefaultTransitCallbacks.fadeIn;
              break;
          }
          _get(_getPrototypeOf(Modal.prototype), "setTransitInCallback", this).call(this, callback);
          // callback = function(gameObject, duration) {}
          return this;
        }
      }, {
        key: "setTransitOutCallback",
        value: function setTransitOutCallback(callback) {
          if (typeof callback === 'string') {
            callback = TransitionMode$1[callback];
          }
          switch (callback) {
            case TransitionMode$1.scaleDown:
              callback = DefaultTransitCallbacks.scaleDown;
              break;
            case TransitionMode$1.fadeOut:
              callback = DefaultTransitCallbacks.fadeOut;
              break;
          }
          _get(_getPrototypeOf(Modal.prototype), "setTransitOutCallback", this).call(this, callback);
          // callback = function(gameObject, duration) {}
          return this;
        }
      }, {
        key: "setCoverTransitInCallback",
        value: function setCoverTransitInCallback(callback) {
          this.coverTransitInCallback = callback;
          return this;
        }
      }, {
        key: "setCoverTransitOutCallback",
        value: function setCoverTransitOutCallback(callback) {
          this.coverTransitOutCallback = callback;
          return this;
        }
      }]);
      return Modal;
    }(OpenCloseTransition);
    var TransitionMode$1 = {
      popUp: 0,
      fadeIn: 1,
      scaleDown: 0,
      fadeOut: 1
    };
  
    var Modal$1 = function Modal(gameObject, config) {
      var modalBehavior = new Modal$2(gameObject, config);
  
      // Route modal's 'open', 'close' event
      modalBehavior.on('open', function () {
        gameObject.emit('modal.open', modalBehavior);
      });
      modalBehavior.on('close', function (closeEventData) {
        gameObject.emit('modal.close', closeEventData, modalBehavior);
      });
  
      // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method
      gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
      /*
      It is not necessary to turn off gameObject's 'modal.requestClose' event because that :
        - If `config.destroy` is `undefined` (or `true), gameObject and modalBehavior will be destroyed
      - If `config.destroy` is `false` (for reusing dialog), keeping gameObject and modalBehavior 
      */
  
      return modalBehavior;
    };
    var ModalPromise = function ModalPromise(gameObject, config) {
      var modalBehavior = Modal$1(gameObject, config);
      return new Promise(function (resolve, reject) {
        modalBehavior.once('close', function (closeEventData) {
          resolve(closeEventData);
        });
      });
    };
    var ModalClose = function ModalClose(gameObject, closeEventData) {
      gameObject.emit('modal.requestClose', closeEventData);
    };
  
    var IsFunction = function IsFunction(obj) {
      return obj && typeof obj === 'function';
    };
  
    var ModalMethods$1 = {
      // Override
      // onCreateModalBehavior(self, config) { },
      modal: function modal(config, onClose) {
        if (IsFunction(config)) {
          onClose = config;
          config = undefined;
        }
        if (this._modalBehavior === undefined) {
          if (this.onCreateModalBehavior) {
            this.onCreateModalBehavior(this, config);
          }
          this._modalBehavior = Modal$1(this, config);
        }
        if (onClose) {
          this._modalBehavior.once('close', onClose);
        }
        this._modalBehavior.requestOpen();
        return this;
      },
      modalPromise: function modalPromise(config) {
        var self = this;
        return new Promise(function (resolve, reject) {
          self.modal(config, resolve);
        });
      },
      modalClose: function modalClose(closeEventData) {
        ModalClose(this, closeEventData);
        return this;
      }
    };
  
    var GetPointerWorldXY = function GetPointerWorldXY(pointer, mainCamera, out) {
      var camera = pointer.camera;
      if (!camera) {
        return null;
      }
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globalOut$1;
      }
      if (camera === mainCamera) {
        out.x = pointer.worldX;
        out.y = pointer.worldY;
      } else {
        camera.getWorldPoint(pointer.x, pointer.y, out);
      }
      return out;
    };
    var globalOut$1 = {};
  
    var IsPointerInBounds = function IsPointerInBounds(gameObject, pointer, preTest, postTest) {
      var mainCamera = gameObject.scene.sys.cameras.main,
        worldXY;
      var useScreenXY = gameObject.scrollFactorX === 0 && gameObject.scrollFactorY === 0;
      if (pointer) {
        if (useScreenXY) {
          return IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest);
        } else {
          worldXY = GetPointerWorldXY(pointer, mainCamera, true);
          if (!worldXY) {
            return false;
          }
          return IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest);
        }
      } else {
        var inputManager = gameObject.scene.input.manager;
        var pointersTotal = inputManager.pointersTotal;
        var pointers = inputManager.pointers;
        for (var i = 0; i < pointersTotal; i++) {
          pointer = pointers[i];
          if (useScreenXY) {
            if (IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest)) {
              return true;
            }
          } else {
            worldXY = GetPointerWorldXY(pointer, mainCamera, true);
            if (!worldXY) {
              continue;
            }
            if (IsPointInBounds(gameObject, worldXY.x, worldXY.y, preTest, postTest)) {
              return true;
            }
          }
        }
        return false;
      }
    };
  
    var IsInTouching = function IsInTouching(pointer, gameObject) {
      if (IsGameObject(pointer) || typeof pointer === 'string') {
        gameObject = pointer;
        pointer = undefined;
      }
      if (gameObject === undefined) {
        gameObject = this;
      } else if (typeof gameObject === 'string') {
        gameObject = this.getElement(gameObject);
      }
      return IsPointerInBounds(gameObject, pointer);
    };
  
    var IsArray = function IsArray(obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  
    var ContainsPoint = function ContainsPoint(gameObject, x, y, preTest, postTest) {
      return IsPointInBounds(gameObject, x, y, GetPreTestCallback(preTest), GetPostTestCallback(postTest));
    };
    var IsNotHiddenSizer = function IsNotHiddenSizer(gameObject) {
      var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
      return !isHiddenSizer;
    };
    var GetPreTestCallback = function GetPreTestCallback(preTest) {
      if (!preTest) {
        return IsNotHiddenSizer;
      }
      return function (gameObject, x, y) {
        if (!IsNotHiddenSizer(gameObject)) {
          return false;
        }
        preTest(gameObject, x, y);
        return true;
      };
    };
    var GetPostTestCallback = function GetPostTestCallback(postTest) {
      return postTest;
    };
  
    var PointToChild$1 = function PointToChild(x, y, preTest, postTest, children) {
      if (!IsFunction(preTest)) {
        children = preTest;
        preTest = undefined;
        postTest = undefined;
      }
      if (children === undefined) {
        if (this.sizerChildren) {
          children = this.sizerChildren;
        } else {
          children = this.children;
        }
      }
      if (IsArray(children)) {
        var child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (ContainsPoint(child, x, y, preTest, postTest)) {
            return child;
          }
        }
      } else {
        var child;
        for (var key in children) {
          child = children[key];
          if (ContainsPoint(child, x, y, preTest, postTest)) {
            return child;
          }
        }
      }
      return null;
    };
  
    var CopyState = function CopyState(gamObject, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = GlobState;
      }
      out.x = gamObject.x;
      out.y = gamObject.y;
      out.scaleX = gamObject.scaleX;
      out.scaleY = gamObject.scaleY;
      out.width = gamObject.width;
      out.height = gamObject.height;
      out.displayWidth = gamObject.displayWidth;
      out.displayHeight = gamObject.displayHeight;
      return out;
    };
    var GlobState = {};
  
    var PreLayoutChild = function PreLayoutChild(child) {
      if (this.sizerEventsEnable) {
        CopyState(child, this.getChildPrevState(child));
        this.layoutedChildren.push(child);
      }
    };
  
    var LayoutChild = function LayoutChild(child, x, y, width, height, align, offsetX, offsetY) {
      AlignIn(child, x, y, width, height, align);
      if (offsetX !== undefined) {
        child.x += offsetX;
      }
      if (offsetY !== undefined) {
        child.y += offsetY;
      }
      this.resetChildPositionState(child);
      if (this.sizerEventsEnable) {
        child.emit('sizer.postlayout', child, this);
      }
    };
  
    var ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;
    var LayoutBackgrounds = function LayoutBackgrounds() {
      if (this.backgroundChildren === undefined) {
        return;
      }
      var backgrounds = this.backgroundChildren;
      var startX = this.left,
        startY = this.top;
      var parentWidth = this.width,
        parentHeight = this.height;
      var child, childConfig, padding, x, y, width, height;
      for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
        child = backgrounds[i];
        childConfig = child.rexSizer;
        if (childConfig.hidden) {
          continue;
        }
        padding = childConfig.padding;
        PreLayoutChild.call(this, child);
        x = startX + padding.left;
        y = startY + padding.top;
        width = parentWidth - padding.left - padding.right;
        height = parentHeight - padding.top - padding.bottom;
        ResizeGameObject(child, width, height);
        LayoutChild.call(this, child, x, y, width, height, ALIGN_CENTER$4);
      }
    };
  
    var IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;
    var SetDraggable = function SetDraggable(sensor, draggable, dragTarget) {
      if (IsPlainObject$w(sensor)) {
        var config = sensor;
        sensor = config.sensor;
        dragTarget = config.target;
        draggable = config.draggable;
      } else {
        if (typeof draggable !== 'boolean') {
          dragTarget = draggable;
          draggable = undefined;
        }
      }
      var sensorType = _typeof(sensor);
      if (sensorType === 'string') {
        var sensorName = sensor;
        sensor = this.getElement(sensorName);
        if (!sensor) {
          console.error("Can get element '".concat(sensorName, "'"));
          return this;
        }
      } else if (sensor === undefined || sensorType != 'object') {
        draggable = sensor;
        sensor = this;
      }
      if (draggable === undefined) {
        draggable = true;
      }
      if (sensor.input && sensor.input._rexUIDragSizer) {
        // Draggable is already registered
        sensor.input.draggable = draggable;
      } else if (draggable) {
        // Register draggable
        sensor.setInteractive();
        sensor.scene.input.setDraggable(sensor);
        sensor.on('drag', function (pointer, dragX, dragY) {
          var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
          currentDragTarget.x += dragX - sensor.x;
          currentDragTarget.y += dragY - sensor.y;
          currentDragTarget.emit('sizer.drag', pointer, dragX, dragY);
        }, this).on('dragstart', function (pointer, dragX, dragY) {
          var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
          currentDragTarget.emit('sizer.dragstart', pointer, dragX, dragY);
        }, this).on('dragend', function (pointer, dragX, dragY, dropped) {
          var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
          currentDragTarget.emit('sizer.dragend', pointer, dragX, dragY, dropped);
        }, this).on('drop', function (pointer, dropZone) {
          var currentDragTarget = dragTarget === undefined ? this.getTopmostSizer() : dragTarget;
          currentDragTarget.emit('sizer.drop', pointer, dropZone);
        });
        sensor.input._rexUIDragSizer = true;
      } else ;
      return this;
    };
  
    var ClickMethods = {
      onClick: function onClick(gameObject, callback, scope, config) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          config = scope;
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._click === undefined) {
          gameObject._click = new Button(gameObject, config);
        }
        gameObject._click.on('click', callback, scope);
        return this;
      },
      offClick: function offClick(gameObject, callback, scope) {
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._click === undefined) {
          return this;
        }
        gameObject._click.off('click', callback, scope);
        return this;
      },
      enableClick: function enableClick(gameObject, enabled) {
        if (typeof gameObject === 'boolean') {
          enabled = gameObject;
          gameObject = undefined;
        }
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._click === undefined) {
          return this;
        }
        gameObject._click.setEnable(enabled);
        return this;
      },
      disableClick: function disableClick(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._click === undefined) {
          return this;
        }
        gameObject._click.setEnable(false);
        return this;
      }
    };
  
    var GetValue$2t = Phaser.Utils.Objects.GetValue;
    var ClickOutside = /*#__PURE__*/function (_ComponentBase) {
      _inherits(ClickOutside, _ComponentBase);
      function ClickOutside(gameObject, config) {
        var _this;
        _classCallCheck(this, ClickOutside);
        _this = _callSuper(this, ClickOutside, [gameObject, config]);
        // this.parent = gameObject;
  
        _this._enable = undefined;
        var inputConfig = GetValue$2t(config, "inputConfig", undefined);
        if (inputConfig) {
          gameObject.setInteractive(inputConfig);
        }
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(ClickOutside, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.pointer = undefined;
          this.lastClickTime = undefined;
          this.setEnable(GetValue$2t(o, "enable", true));
          this.setMode(GetValue$2t(o, "mode", 1));
          this.setClickInterval(GetValue$2t(o, "clickInterval", 100));
          this.setDragThreshold(GetValue$2t(o, 'threshold', undefined));
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          var scene = this.parent.scene;
          scene.input.on('pointerdown', this.onPress, this);
          scene.input.on('pointerup', this.onRelease, this);
          scene.input.on('pointermove', this.onMove, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          var scene = this.parent.scene;
          scene.input.off('pointerdown', this.onPress, this);
          scene.input.off('pointerup', this.onRelease, this);
          scene.input.off('pointermove', this.onMove, this);
          this.pointer = null;
          _get(_getPrototypeOf(ClickOutside.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.cancel();
          }
          this._enable = e;
          var eventName = e ? 'enable' : 'disable';
          this.emit(eventName, this, this.parent);
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "setMode",
        value: function setMode(m) {
          if (typeof m === 'string') {
            m = CLICKMODE[m];
          }
          this.mode = m;
          return this;
        }
      }, {
        key: "setClickInterval",
        value: function setClickInterval(interval) {
          this.clickInterval = interval; // ms
          return this;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }, {
        key: "isPointerInside",
        value: function isPointerInside(pointer) {
          var gameObject = this.parent;
          var isInsideCallback = gameObject.input ? IsPointerInHitArea : IsPointerInBounds;
          return isInsideCallback(gameObject, pointer);
        }
  
        // internal
      }, {
        key: "onPress",
        value: function onPress(pointer) {
          // Do nothing if game object is not visible
          if (!this.parent.willRender(pointer.camera)) {
            return;
          }
          if (this.pointer !== undefined) {
            return;
          }
          this.pointer = pointer;
          if (this.mode === 0) {
            if (!this.isPointerInside(pointer)) {
              this.click(pointer.downTime, pointer);
            }
          }
        }
      }, {
        key: "onRelease",
        value: function onRelease(pointer) {
          // Do nothing if game object is not visible
          if (!this.parent.willRender(pointer.camera)) {
            return;
          }
          if (this.pointer !== pointer) {
            return;
          }
          if (this.mode === 1) {
            if (!this.isPointerInside(pointer)) {
              this.click(pointer.upTime, pointer);
            }
          }
          this.pointer = undefined;
        }
      }, {
        key: "onMove",
        value: function onMove(pointer, localX, localY, event) {
          if (this.pointer !== pointer) {
            return;
          }
          if (this.dragThreshold === undefined) {
            return;
          }
          if (this.mode === 1) {
            if (pointer.getDistance() >= this.dragThreshold || this.isPointerInside(pointer)) {
              this.cancel();
            }
          }
        }
      }, {
        key: "click",
        value: function click(nowTime, pointer) {
          if (!this.enable) {
            return this;
          }
          if (nowTime === undefined) {
            // fires 'clickoutside' event manually
            this.emit('clickoutside', this, this.parent, pointer);
            return this;
          }
          this.pointer = undefined;
          var lastClickTime = this.lastClickTime;
          if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
            return this;
          }
          this.lastClickTime = nowTime;
          this.emit('clickoutside', this, this.parent, pointer);
          return this;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.pointer = undefined;
          return this;
        }
      }]);
      return ClickOutside;
    }(ComponentBase);
    var CLICKMODE = {
      press: 0,
      pointerdown: 0,
      release: 1,
      pointerup: 1
    };
  
    var ClickOutsideMethods = {
      onClickOutside: function onClickOutside(gameObject, callback, scope, config) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          config = scope;
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._clickOutside === undefined) {
          gameObject._clickOutside = new ClickOutside(gameObject, config);
        }
        gameObject._clickOutside.on('clickoutside', callback, scope);
        return this;
      },
      offClickOutside: function offClickOutside(gameObject, callback, scope) {
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._clickOutside === undefined) {
          return this;
        }
        gameObject._clickOutside.off('clickoutside', callback, scope);
        return this;
      },
      enableClickOutside: function enableClickOutside(gameObject, enabled) {
        if (typeof gameObject === 'boolean') {
          enabled = gameObject;
          gameObject = undefined;
        }
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._clickOutside === undefined) {
          return this;
        }
        gameObject._clickOutside.setEnable(enabled);
        return this;
      },
      disableClickOutside: function disableClickOutside(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._clickOutside === undefined) {
          return this;
        }
        gameObject._clickOutside.setEnable(false);
        return this;
      }
    };
  
    var Cooldown = /*#__PURE__*/function (_FSM) {
      _inherits(Cooldown, _FSM);
      function Cooldown() {
        var _this;
        _classCallCheck(this, Cooldown);
        _this = _callSuper(this, Cooldown, [{
          eventEmitter: false
        }]);
        _this["goto"]('IDLE');
        return _this;
      }
      _createClass(Cooldown, [{
        key: "setCooldownTime",
        value: function setCooldownTime(time) {
          this.cooldownTime = time;
          this.cooldownMode = time !== undefined;
          return this;
        }
      }, {
        key: "request",
        value: function request() {
          return this.runMethod('request');
        }
  
        // IDLE state
      }, {
        key: "update_IDLE",
        value: function update_IDLE() {
          this.compensationTime = 0;
        }
      }, {
        key: "request_IDLE",
        value: function request_IDLE() {
          this.next();
          return true;
        }
      }, {
        key: "next_IDLE",
        value: function next_IDLE() {
          if (this.cooldownMode) {
            return 'COOLDOWN';
          }
        }
  
        // COOLDOWN state
      }, {
        key: "enter_COOLDOWN",
        value: function enter_COOLDOWN() {
          this.remainderTime = this.cooldownTime + this.compensationTime;
        }
      }, {
        key: "update_COOLDOWN",
        value: function update_COOLDOWN(time, delta) {
          this.remainderTime -= delta;
          if (this.remainderTime < 0) {
            this.compensationTime = this.cooldownTime > delta ? -this.remainderTime : 0;
            this["goto"]('IDLE');
          }
        }
      }, {
        key: "request_COOLDOWN",
        value: function request_COOLDOWN() {
          return false;
        }
      }]);
      return Cooldown;
    }(FSM);
  
    var GetValue$2s = Phaser.Utils.Objects.GetValue;
    var InTouching = /*#__PURE__*/function (_ComponentBase) {
      _inherits(InTouching, _ComponentBase);
      function InTouching(gameObject, config) {
        var _this;
        _classCallCheck(this, InTouching);
        _this = _callSuper(this, InTouching, [gameObject, config]);
        // this.parent = gameObject;
  
        _this._enable = undefined;
        _this.cooldown = new Cooldown();
        _this.parent.setInteractive(GetValue$2s(config, 'inputConfig', undefined));
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(InTouching, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.pointer = undefined;
          this.prevIsInTouch = false;
          this.isInTouching = false;
          this.setEnable(GetValue$2s(o, 'enable', true));
          this.setCooldown(GetValue$2s(o, 'cooldown', undefined));
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          var gameObject = this.parent;
          gameObject.on('pointerdown', this.onPointIn, this);
          gameObject.on('pointerover', this.onPointIn, this);
          gameObject.on('pointerup', this.onPointOut, this);
          gameObject.on('pointerout', this.onPointOut, this);
          this.scene.sys.events.on('preupdate', this.preupdate, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // GameObject events will be removed when this gameObject destroyed 
          // this.parent.off('pointerdown', this.onPointIn, this);
          // this.parent.off('pointerover', this.onPointIn, this);
          // this.parent.off('pointerup', this.onPointOut, this);
          // this.parent.off('pointerout', this.onPointOut, this);
          this.scene.sys.events.off('preupdate', this.preupdate, this);
          this.pointer = undefined;
          _get(_getPrototypeOf(InTouching.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.prevIsInTouch = false;
            this.isInTouching = false;
            this.pointer = undefined;
          }
          this._enable = e;
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "cooldownTime",
        get: function get() {
          return this.cooldown.cooldownTime;
        },
        set: function set(time) {
          this.cooldown.setCooldownTime(time);
        }
      }, {
        key: "setCooldown",
        value: function setCooldown(time) {
          this.cooldownTime = time;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
  
        // internal
      }, {
        key: "onPointIn",
        value: function onPointIn(pointer, localX, localY) {
          if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
            return;
          }
          this.pointer = pointer;
          this.isInTouching = true;
        }
      }, {
        key: "onPointOut",
        value: function onPointOut(pointer) {
          if (!this.enable || this.pointer !== pointer) {
            return;
          }
          this.pointer = undefined;
          this.isInTouching = false;
        }
      }, {
        key: "preupdate",
        value: function preupdate(time, delta) {
          this.cooldown.update(time, delta);
          if (!this.prevIsInTouch && this.isInTouching) {
            this.emit('touchstart', this, this.parent);
          }
          if (this.isInTouching && this.cooldown.request()) {
            this.emit('intouch', this, this.parent, this.pointer);
          }
          if (this.prevIsInTouch && !this.isInTouching) {
            this.emit('touchend', this, this.parent);
          }
          this.prevIsInTouch = this.isInTouching;
        }
      }]);
      return InTouching;
    }(ComponentBase);
  
    var TouchingMethods = {
      isPointerInBounds: function isPointerInBounds(target) {
        if (target === undefined) {
          target = this;
        } else if (typeof target === 'string') {
          target = this.getElement(target);
        }
        if (!target) {
          return false;
        }
        return IsPointerInBounds(target);
      },
      onTouching: function onTouching(gameObject, callback, scope, config) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          config = scope;
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          gameObject._inTouching = new InTouching(gameObject, config);
        }
        gameObject._inTouching.on('intouch', callback, scope);
        return this;
      },
      offTouching: function offTouching(gameObject, callback, scope) {
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          return this;
        }
        gameObject._inTouching.off('intouch', callback, scope);
        return this;
      },
      onTouchingEnd: function onTouchingEnd(gameObject, callback, scope, config) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          config = scope;
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          gameObject._inTouching = new InTouching(gameObject, config);
        }
        gameObject._inTouching.on('touchend', callback, scope);
        return this;
      },
      offTouchingEnd: function offTouchingEnd(gameObject, callback, scope) {
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          return this;
        }
        gameObject._inTouching.off('touchend', callback, scope);
        return this;
      },
      enableTouching: function enableTouching(gameObject, enabled) {
        if (typeof gameObject === 'boolean') {
          enabled = gameObject;
          gameObject = undefined;
        }
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          return this;
        }
        gameObject._inTouching.setEnable(enabled);
        return this;
      },
      disableTouching: function disableTouching(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (gameObject._inTouching === undefined) {
          return this;
        }
        gameObject._inTouching.setEnable(false);
        return this;
      }
    };
  
    var HoverMethods = {
      onOver: function onOver(gameObject, callback, scope) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        gameObject.setInteractive().on('pointerover', callback, scope);
        return this;
      },
      onOut: function onOut(gameObject, callback, scope) {
        if (!gameObject) {
          return this;
        }
        if (typeof gameObject === 'function') {
          scope = callback;
          callback = gameObject;
          gameObject = this;
        }
        gameObject.setInteractive().on('pointerout', callback, scope);
        return this;
      }
    };
  
    var PointToChild = function PointToChild(parents, x, y) {
      var parent;
      for (var i = 0, cnt = parents.length; i < cnt; i++) {
        parent = parents[i];
        if (!ContainsPoint(parent, x, y)) {
          continue;
        }
        return parent.pointToChild(x, y);
      }
      return null;
    };
  
    var EmitChildEvent = function EmitChildEvent(eventEmitter, eventName, targets, targetMode, x, y, pointer, event) {
      var child;
      if (y === undefined) {
        child = x;
      } else {
        if (targetMode === 'parent') {
          child = PointToChild(targets, x, y);
        } else {
          for (var i = 0, cnt = targets.length; i < cnt; i++) {
            var target = targets[i];
            if (ContainsPoint(target, x, y)) {
              child = target;
              break;
            }
          }
        }
      }
      if (!child) {
        return;
      }
      eventEmitter.emit(eventName, child, pointer, event);
    };
  
    var GetValue$2r = Phaser.Utils.Objects.GetValue;
    var DownChild = function DownChild(config) {
      var downConfig = GetValue$2r(config, 'down', undefined);
      if (downConfig === false) {
        return;
      } else if (downConfig === true) {
        downConfig = undefined;
      }
      this.on('pointerdown', OnDown, this);
    };
    var OnDown = function OnDown(pointer, localX, localY, event) {
      var childrenInteractive = this._childrenInteractive;
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "down"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
    };
  
    var GetValue$2q = Phaser.Utils.Objects.GetValue;
    var UpChild = function UpChild(config) {
      var upConfig = GetValue$2q(config, 'up', undefined);
      if (upConfig === false) {
        return;
      } else if (upConfig === true) {
        upConfig = undefined;
      }
      this.on('pointerup', OnUp, this);
    };
    var OnUp = function OnUp(pointer, localX, localY, event) {
      var childrenInteractive = this._childrenInteractive;
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "up"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
    };
  
    var GetValue$2p = Phaser.Utils.Objects.GetValue;
    var OverChild = function OverChild(config) {
      var overConfig = GetValue$2p(config, 'over', undefined);
      if (overConfig === false) {
        return;
      } else if (overConfig === true) {
        overConfig = undefined;
      }
      this.on('pointermove', OnMove$1, this).on('pointerover', OnMove$1, this).on('pointerout', OnOut$1, this); // pointer-up is included too
    };
    var OnMove$1 = function OnMove(pointer, localX, localY, event) {
      var childrenInteractive = this._childrenInteractive;
      var child = PointToChild(childrenInteractive.targetSizers, pointer.worldX, pointer.worldY);
      var preChild = childrenInteractive.lastOverChild;
      if (child && preChild && child === preChild) {
        return;
      }
      childrenInteractive.lastOverChild = child;
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, childrenInteractive.targetMode, preChild, undefined, pointer, event);
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "over"), childrenInteractive.targetSizers, childrenInteractive.targetMode, child, undefined, pointer, event);
    };
    var OnOut$1 = function OnOut(pointer, event) {
      var childrenInteractive = this._childrenInteractive;
      var child = childrenInteractive.lastOverChild;
      childrenInteractive.lastOverChild = null;
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, childrenInteractive.targetMode, child, undefined, pointer, event);
    };
  
    var GetValue$2o = Phaser.Utils.Objects.GetValue;
    var ClickChild = function ClickChild(config) {
      var clickConfig = GetValue$2o(config, 'click', undefined);
      if (clickConfig === false) {
        return;
      } else if (clickConfig === true) {
        clickConfig = undefined;
      }
      if (clickConfig === undefined) {
        clickConfig = {};
      }
      if (!clickConfig.hasOwnProperty('threshold')) {
        clickConfig.threshold = 10;
      }
      var childrenInteractive = this._childrenInteractive;
      this._click = new Button(this, clickConfig);
      this._click.on('click', function (button, gameObject, pointer, event) {
        EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "click"), childrenInteractive.targetSizers, childrenInteractive.targetMode, pointer.worldX, pointer.worldY, pointer, event);
      }, this);
    };
  
    var GetValue$2n = Phaser.Utils.Objects.GetValue;
    var OnePointerTracer = /*#__PURE__*/function (_TickTask) {
      _inherits(OnePointerTracer, _TickTask);
      function OnePointerTracer(gameObject, config) {
        var _this;
        _classCallCheck(this, OnePointerTracer);
        var scene = GetSceneObject(gameObject);
        if (scene === gameObject) {
          gameObject = undefined;
        }
        _this = _callSuper(this, OnePointerTracer, [scene, config]);
        _this.gameObject = gameObject;
        if (gameObject) {
          gameObject.setInteractive(GetValue$2n(config, 'inputConfig', undefined));
        }
        _this._enable = undefined;
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(OnePointerTracer, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setEnable(GetValue$2n(o, 'enable', true));
          this.setDetectBounds();
          if (this.gameObject === undefined) {
            this.setDetectBounds(GetValue$2n(o, 'bounds', undefined));
          } else {
            this.setDetectBounds();
          }
          this.tracerState = TOUCH0$2;
          // this.recongizedState = new stateClass(this);
          this.pointer = undefined;
          this.lastPointer = undefined; // Last catched pointer
          this.movedState = false;
          this.isTouchingAnyObject = false;
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          _get(_getPrototypeOf(OnePointerTracer.prototype), "boot", this).call(this);
          if (this.gameObject) {
            this.gameObject.on('pointerdown', this.onPointerDown, this);
          } else {
            this.scene.input.on('pointerdown', this.onPointerDown, this);
          }
          this.scene.input.on('pointerup', this.onPointerUp, this);
          this.scene.input.on('gameout', this.dragCancel, this);
          this.scene.input.on('pointermove', this.onPointerMove, this);
          this.scene.sys.events.once('shutdown', this.destroy, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          if (!this.scene) {
            return;
          }
          if (this.gameObject) ; else {
            this.scene.input.off('pointerdown', this.onPointerDown, this);
          }
          this.scene.input.off('pointerup', this.onPointerUp, this);
          this.scene.input.off('gameout', this.dragCancel, this);
          this.scene.input.off('pointermove', this.onPointerMove, this);
          this.scene.sys.events.off('shutdown', this.destroy, this);
          this.gameObject = undefined;
          this.bounds = undefined;
          this.pointer = undefined;
          this.lastPointer = undefined; // Last catched pointer
          this.movedState = false;
          _get(_getPrototypeOf(OnePointerTracer.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.dragCancel();
          }
          this._enable = e;
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "setDetectBounds",
        value: function setDetectBounds(bounds) {
          this.bounds = bounds;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "onPointerDown",
        value: function onPointerDown(pointer, gameObjects) {
          if (!this.enable) {
            return;
          }
          if (this.pointer !== undefined) {
            return;
          }
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          if (!isInsideBounds) {
            return;
          }
          if (this.pointer === pointer) {
            return;
          }
          this.pointer = pointer;
          this.lastPointer = pointer;
          this.movedState = false;
          this.tracerState = TOUCH1$2;
          if (this.gameObject === undefined) {
            this.isTouchingAnyObject = gameObjects.length > 0;
          }
          this.onDragStart();
        }
      }, {
        key: "onPointerUp",
        value: function onPointerUp(pointer) {
          if (!this.enable) {
            return;
          }
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          if (!isInsideBounds) {
            return;
          }
          if (this.pointer !== pointer) {
            return;
          }
          this.pointer = undefined;
          this.movedState = false;
          this.tracerState = TOUCH0$2;
          this.onDragEnd();
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(pointer) {
          if (!this.enable) {
            return;
          }
          if (pointer.isDown) {
            var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
            var isCatchedPointer = this.pointer === pointer;
            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
              // Pointer moves out of bounds
              this.onPointerUp(pointer);
            } else {
              // Pointer drags in bounds
              if (!this.movedState) {
                this.movedState = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
              }
              if (this.movedState) {
                this.onDrag();
              }
            }
          }
        }
      }, {
        key: "dragCancel",
        value: function dragCancel() {
          if (this.tracerState === TOUCH1$2) {
            this.onDragEnd();
          }
          this.pointer = undefined;
          this.tracerState = TOUCH0$2;
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          this.emit('dragstart', this);
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          this.emit('dragend', this);
        }
      }, {
        key: "onDrag",
        value: function onDrag() {
          this.emit('drag', this);
        }
  
        // onLastPointerMove() { }
      }, {
        key: "preUpdate",
        value: function preUpdate(time, delta) {}
      }, {
        key: "postUpdate",
        value: function postUpdate(time, delta) {}
      }, {
        key: "startTicking",
        value: function startTicking() {
          _get(_getPrototypeOf(OnePointerTracer.prototype), "startTicking", this).call(this);
          this.scene.sys.events.on('preupdate', this.preUpdate, this);
          this.scene.sys.events.on('postupdate', this.postUpdate, this);
        }
      }, {
        key: "stopTicking",
        value: function stopTicking() {
          _get(_getPrototypeOf(OnePointerTracer.prototype), "stopTicking", this).call(this);
          if (this.scene) {
            // Scene might be destoryed
            this.scene.sys.events.off('preupdate', this.preUpdate, this);
            this.scene.sys.events.off('postupdate', this.postUpdate, this);
          }
        }
      }, {
        key: "setRecongizedStateObject",
        value: function setRecongizedStateObject(stateObject) {
          this.recongizedState = stateObject;
          return this;
        }
      }, {
        key: "state",
        get: function get() {
          return this.recongizedState.state;
        },
        set: function set(newState) {
          this.recongizedState.state = newState;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.state = IDLE$7;
          return this;
        }
      }, {
        key: "isPointerInGameObject",
        value: function isPointerInGameObject(gameObject, preTest, postTest) {
          var pointer = this.lastPointer;
          if (!pointer) {
            return false;
          }
          return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
      }]);
      return OnePointerTracer;
    }(TickTask);
    var TOUCH0$2 = 0;
    var TOUCH1$2 = 1;
    var IDLE$7 = 'IDLE';
  
    var GetValue$2m = Phaser.Utils.Objects.GetValue;
    var DistanceBetween$5 = Phaser.Math.Distance.Between;
    var Tap = /*#__PURE__*/function (_OnePointerTracer) {
      _inherits(Tap, _OnePointerTracer);
      function Tap(gameObject, config) {
        var _this;
        _classCallCheck(this, Tap);
        _this = _callSuper(this, Tap, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {
              enter: function enter() {
                self.stop();
                self.tapsCount = 0;
                self.x = 0;
                self.y = 0;
                self.worldX = 0;
                self.worldY = 0;
                self.lastPointer = undefined;
              },
              exit: function exit() {
                var pointer = self.lastPointer;
                self.x = pointer.x;
                self.y = pointer.y;
                self.worldX = pointer.worldX;
                self.worldY = pointer.worldY;
              }
            },
            BEGIN: {
              enter: function enter() {
                self.start();
                self.tapsCount = 0;
                self.emit('tappingstart', self, self.gameObject, self.lastPointer);
              }
            },
            RECOGNIZED: {
              enter: function enter() {
                self.start();
                self.emit('tap', self, self.gameObject, self.lastPointer);
                self.emit("".concat(self.tapsCount, "tap"), self, self.gameObject, self.lastPointer);
              }
            }
          },
          init: function init() {
            this.state = IDLE$6;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        return _this;
      }
      _createClass(Tap, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Tap.prototype), "resetFromJSON", this).call(this, o);
          this.setHoldTime(GetValue$2m(o, 'time', 250)); // min-hold-time of Press is 251
          this.setTapInterval(GetValue$2m(o, 'tapInterval', 200));
          this.setDragThreshold(GetValue$2m(o, 'threshold', 9));
          this.setTapOffset(GetValue$2m(o, 'tapOffset', 10));
          var taps = GetValue$2m(o, 'taps', undefined);
          if (taps !== undefined) {
            this.setTaps(taps);
          } else {
            this.setMaxTaps(GetValue$2m(o, 'maxTaps', undefined));
            this.setMinTaps(GetValue$2m(o, 'minTaps', undefined));
          }
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          switch (this.state) {
            case IDLE$6:
              this.state = BEGIN$5;
              break;
            case BEGIN$5:
              var pointer = this.lastPointer;
              var tapsOffset = DistanceBetween$5(pointer.upX, pointer.upY, pointer.x, pointer.y);
              if (tapsOffset > this.tapOffset) {
                // Can't recognize next level, restart here
                this.state = RECOGNIZED$5;
                this.state = BEGIN$5;
              }
              break;
            case RECOGNIZED$5:
              this.state = BEGIN$5;
              break;
          }
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          if (this.state === BEGIN$5) {
            this.tapsCount++; // Try recognize next level
            this.emit('tapping', this, this.gameObject, this.lastPointer);
            if (this.maxTaps !== undefined && this.tapsCount === this.maxTaps) {
              // Reach to maxTaps, stop here                
              this.state = RECOGNIZED$5;
            }
          }
        }
      }, {
        key: "onDrag",
        value: function onDrag() {
          if (this.state === IDLE$6) {
            return;
          }
          if (this.pointer.getDistance() > this.dragThreshold) {
            // Cancel
            this.state = IDLE$6;
          }
        }
      }, {
        key: "preUpdate",
        value: function preUpdate(time, delta) {
          if (!this.isRunning || !this.enable) {
            return;
          }
          if (this.state === BEGIN$5) {
            var pointer = this.lastPointer;
            if (pointer.isDown) {
              var holdTime = time - pointer.downTime;
              if (holdTime > this.holdTime) {
                this.state = IDLE$6;
              }
            } else {
              // isUp
              var releasedTime = time - pointer.upTime;
              if (releasedTime > this.tapInterval) {
                if (this.minTaps === undefined || this.tapsCount >= this.minTaps) {
                  this.state = RECOGNIZED$5;
                } else {
                  this.state = IDLE$6;
                }
              }
            }
          }
        }
      }, {
        key: "postUpdate",
        value: function postUpdate(time, delta) {
          if (!this.isRunning || !this.enable) {
            return;
          }
          // Clear RECOGNIZED after update()
          if (this.state === RECOGNIZED$5) {
            this.state = IDLE$6;
          }
        }
      }, {
        key: "isTapped",
        get: function get() {
          return this.state === RECOGNIZED$5;
        }
      }, {
        key: "setHoldTime",
        value: function setHoldTime(time) {
          this.holdTime = time; // ms
          return this;
        }
      }, {
        key: "setTapInterval",
        value: function setTapInterval(time) {
          this.tapInterval = time; // ms
          return this;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }, {
        key: "setTapOffset",
        value: function setTapOffset(distance) {
          this.tapOffset = distance;
          return this;
        }
      }, {
        key: "setMaxTaps",
        value: function setMaxTaps(taps) {
          this.maxTaps = taps;
          return this;
        }
      }, {
        key: "setMinTaps",
        value: function setMinTaps(taps) {
          this.minTaps = taps;
          return this;
        }
      }, {
        key: "setTaps",
        value: function setTaps(minTaps, maxTaps) {
          if (maxTaps === undefined) {
            maxTaps = minTaps;
          }
          this.setMinTaps(minTaps).setMaxTaps(maxTaps);
          return this;
        }
      }]);
      return Tap;
    }(OnePointerTracer);
    var IDLE$6 = 'IDLE';
    var BEGIN$5 = 'BEGIN';
    var RECOGNIZED$5 = 'RECOGNIZED';
  
    var GetValue$2l = Phaser.Utils.Objects.GetValue;
    var Press = /*#__PURE__*/function (_OnePointerTracer) {
      _inherits(Press, _OnePointerTracer);
      function Press(gameObject, config) {
        var _this;
        _classCallCheck(this, Press);
        _this = _callSuper(this, Press, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {
              enter: function enter() {
                self.x = 0;
                self.y = 0;
                self.worldX = 0;
                self.worldY = 0;
                self.lastPointer = undefined;
              },
              exit: function exit() {
                var pointer = self.lastPointer;
                self.x = pointer.x;
                self.y = pointer.y;
                self.worldX = pointer.worldX;
                self.worldY = pointer.worldY;
              }
            },
            BEGIN: {
              enter: function enter() {
                self.start();
              },
              exit: function exit() {
                self.stop();
              }
            },
            RECOGNIZED: {
              enter: function enter() {
                self.emit('pressstart', self, self.gameObject, self.lastPointer);
              },
              exit: function exit() {
                self.emit('pressend', self, self.gameObject, self.lastPointer);
              }
            }
          },
          init: function init() {
            this.state = IDLE$5;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        return _this;
      }
      _createClass(Press, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Press.prototype), "resetFromJSON", this).call(this, o);
          this.setDragThreshold(GetValue$2l(o, 'threshold', 9));
          this.setHoldTime(GetValue$2l(o, 'time', 251));
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          this.state = BEGIN$4;
          if (this.holdTime === 0) {
            this.state = RECOGNIZED$4;
          }
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          this.state = IDLE$5;
        }
      }, {
        key: "onDrag",
        value: function onDrag() {
          if (this.state === IDLE$5) {
            return;
          }
          if (this.pointer.getDistance() > this.dragThreshold) {
            this.state = IDLE$5;
          }
        }
      }, {
        key: "preUpdate",
        value: function preUpdate(time, delta) {
          if (!this.isRunning || !this.enable) {
            return;
          }
          if (this.state === BEGIN$4) {
            var holdTime = time - this.pointer.downTime;
            if (holdTime >= this.holdTime) {
              this.state = RECOGNIZED$4;
            }
          }
        }
      }, {
        key: "isPressed",
        get: function get() {
          return this.state === RECOGNIZED$4;
        }
      }, {
        key: "setHoldTime",
        value: function setHoldTime(time) {
          this.holdTime = time; // ms
          return this;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }]);
      return Press;
    }(OnePointerTracer);
    var IDLE$5 = 'IDLE';
    var BEGIN$4 = 'BEGIN';
    var RECOGNIZED$4 = 'RECOGNIZED';
  
    var GetValue$2k = Phaser.Utils.Objects.GetValue;
    var Pan = /*#__PURE__*/function (_OnePointerTracer) {
      _inherits(Pan, _OnePointerTracer);
      function Pan(gameObject, config) {
        var _this;
        _classCallCheck(this, Pan);
        _this = _callSuper(this, Pan, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {},
            BEGIN: {
              enter: function enter() {
                var pointer = self.pointer;
                self.startX = pointer.x;
                self.startY = pointer.y;
                self.startWorldX = pointer.worldX;
                self.startWorldY = pointer.worldY;
              }
            },
            RECOGNIZED: {
              enter: function enter() {
                self.emit('panstart', self, self.gameObject, self.lastPointer);
              },
              exit: function exit() {
                var pointer = self.lastPointer;
                self.endX = pointer.x;
                self.endY = pointer.y;
                self.endWorldX = pointer.worldX;
                self.endWorldY = pointer.worldY;
                self.emit('panend', self, self.gameObject, self.lastPointer);
              }
            }
          },
          init: function init() {
            this.state = IDLE$4;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        return _this;
      }
      _createClass(Pan, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Pan.prototype), "resetFromJSON", this).call(this, o);
          this.setDragThreshold(GetValue$2k(o, 'threshold', 10));
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          this.state = BEGIN$3;
          if (this.dragThreshold === 0) {
            this.state = RECOGNIZED$3;
          }
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          this.state = IDLE$4;
        }
      }, {
        key: "onDrag",
        value: function onDrag() {
          switch (this.state) {
            case BEGIN$3:
              if (this.pointer.getDistance() >= this.dragThreshold) {
                this.state = RECOGNIZED$3;
              }
              break;
            case RECOGNIZED$3:
              var p1 = this.pointer.position;
              var p0 = this.pointer.prevPosition;
              this.dx = p1.x - p0.x;
              this.dy = p1.y - p0.y;
              var pointer = this.pointer;
              this.x = pointer.x;
              this.y = pointer.y;
              this.worldX = pointer.worldX;
              this.worldY = pointer.worldY;
              this.emit('pan', this, this.gameObject, this.lastPointer);
              break;
          }
        }
      }, {
        key: "isPanned",
        get: function get() {
          return this.state === RECOGNIZED$3;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }]);
      return Pan;
    }(OnePointerTracer);
    var IDLE$4 = 'IDLE';
    var BEGIN$3 = 'BEGIN';
    var RECOGNIZED$3 = 'RECOGNIZED';
  
    var DistanceBetween$4 = Phaser.Math.Distance.Between;
    var AngleBetween$1 = Phaser.Math.Angle.Between;
    var VelocityMethods = {
      getDt: function getDt() {
        var dt = GetTickDelta(this.scene);
        return dt;
      },
      getVelocity: function getVelocity() {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = DistanceBetween$4(p0.x, p0.y, p1.x, p1.y);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
      },
      getVelocityX: function getVelocityX() {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = Math.abs(p1.x - p0.x);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
      },
      getVelocityY: function getVelocityY() {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = Math.abs(p1.y - p0.y);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
      },
      getVelocityAngle: function getVelocityAngle() {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var angle = AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
        return angle;
      }
    };
  
    var DIRMODE$1 = {
      'up&down': 0,
      'left&right': 1,
      '4dir': 2,
      '8dir': 3
    };
  
    var AngleToDirections = function AngleToDirections(angle, dirMode, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globOut$1;
      }
      out.left = false;
      out.right = false;
      out.up = false;
      out.down = false;
      angle = (angle + 360) % 360;
      switch (dirMode) {
        case 0:
          // up & down
          if (angle < 180) {
            out.down = true;
          } else {
            out.up = true;
          }
          break;
        case 1:
          // left & right
          if (angle > 90 && angle <= 270) {
            out.left = true;
          } else {
            out.right = true;
          }
          break;
        case 2:
          // 4 dir
          if (angle > 45 && angle <= 135) {
            out.down = true;
          } else if (angle > 135 && angle <= 225) {
            out.left = true;
          } else if (angle > 225 && angle <= 315) {
            out.up = true;
          } else {
            out.right = true;
          }
          break;
        case 3:
          // 8 dir
          if (angle > 22.5 && angle <= 67.5) {
            out.down = true;
            out.right = true;
          } else if (angle > 67.5 && angle <= 112.5) {
            out.down = true;
          } else if (angle > 112.5 && angle <= 157.5) {
            out.down = true;
            out.left = true;
          } else if (angle > 157.5 && angle <= 202.5) {
            out.left = true;
          } else if (angle > 202.5 && angle <= 247.5) {
            out.left = true;
            out.up = true;
          } else if (angle > 247.5 && angle <= 292.5) {
            out.up = true;
          } else if (angle > 292.5 && angle <= 337.5) {
            out.up = true;
            out.right = true;
          } else {
            out.right = true;
          }
          break;
      }
      return out;
    };
    var globOut$1 = {};
  
    var GetValue$2j = Phaser.Utils.Objects.GetValue;
    var RadToDeg$4 = Phaser.Math.RadToDeg;
    var Swipe = /*#__PURE__*/function (_OnePointerTracer) {
      _inherits(Swipe, _OnePointerTracer);
      function Swipe(gameObject, config) {
        var _this;
        _classCallCheck(this, Swipe);
        _this = _callSuper(this, Swipe, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {
              enter: function enter() {
                self.x = 0;
                self.y = 0;
                self.worldX = 0;
                self.worldY = 0;
              },
              exit: function exit() {
                var pointer = self.lastPointer;
                self.x = pointer.x;
                self.y = pointer.y;
                self.worldX = pointer.worldX;
                self.worldY = pointer.worldY;
              }
            },
            BEGIN: {
              enter: function enter() {
                self.validDrag = false;
              }
            },
            RECOGNIZED: {
              enter: function enter() {
                self.start();
                self.updateDirectionStates();
                self.emit('swipe', self, self.gameObject, self.lastPointer);
              },
              exit: function exit() {
                self.stop();
                self.clearDirectionStates();
              }
            }
          },
          init: function init() {
            this.state = IDLE$3;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        _this.clearDirectionStates();
        return _this;
      }
      _createClass(Swipe, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Swipe.prototype), "resetFromJSON", this).call(this, o);
          this.setDragThreshold(GetValue$2j(o, 'threshold', 10));
          this.setVelocityThreshold(GetValue$2j(o, 'velocityThreshold', 1000));
          this.setDirectionMode(GetValue$2j(o, 'dir', '8dir'));
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          this.state = BEGIN$2;
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          this.state = IDLE$3;
        }
      }, {
        key: "onDrag",
        value: function onDrag() {
          if (this.state === BEGIN$2) {
            if (!this.validDrag) {
              this.validDrag = this.dragThreshold === 0 || this.pointer.getDistance() >= this.dragThreshold;
            }
            if (this.validDrag && this.dragVelocity > this.velocityThreshold) {
              this.state = RECOGNIZED$2;
            }
          }
        }
      }, {
        key: "postUpdate",
        value: function postUpdate(time, delta) {
          if (!this.isRunning || !this.enable) {
            return;
          }
          // Clear RECOGNIZED after update()
          if (this.state === RECOGNIZED$2) {
            this.state = IDLE$3;
          }
        }
      }, {
        key: "isSwiped",
        get: function get() {
          return this.state === RECOGNIZED$2;
        }
      }, {
        key: "dragVelocity",
        get: function get() {
          var velocity;
          switch (this.dirMode) {
            case 0:
              velocity = this.getVelocityY();
              break;
            // up & down
            case 1:
              velocity = this.getVelocityX();
              break;
            // left & right
            default:
              velocity = this.getVelocity();
              break;
            // 4 dir, 8 dir
          }
          return velocity;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }, {
        key: "setVelocityThreshold",
        value: function setVelocityThreshold(velocity) {
          this.velocityThreshold = velocity;
          return this;
        }
      }, {
        key: "setDirectionMode",
        value: function setDirectionMode(m) {
          if (typeof m === 'string') {
            m = DIRMODE$1[m];
          }
          this.dirMode = m;
          return this;
        }
      }, {
        key: "updateDirectionStates",
        value: function updateDirectionStates() {
          var angle = RadToDeg$4(this.getVelocityAngle());
          AngleToDirections(angle, this.dirMode, this);
          return this;
        }
      }, {
        key: "clearDirectionStates",
        value: function clearDirectionStates() {
          this.left = false;
          this.right = false;
          this.up = false;
          this.down = false;
          return this;
        }
      }]);
      return Swipe;
    }(OnePointerTracer);
    Object.assign(Swipe.prototype, VelocityMethods);
    var IDLE$3 = 'IDLE';
    var BEGIN$2 = 'BEGIN';
    var RECOGNIZED$2 = 'RECOGNIZED';
  
    var GetValue$2i = Phaser.Utils.Objects.GetValue;
    var SpliceOne$2 = Phaser.Utils.Array.SpliceOne;
    var DistanceBetween$3 = Phaser.Math.Distance.Between;
    var AngleBetween = Phaser.Math.Angle.Between;
    var TwoPointersTracer = /*#__PURE__*/function () {
      function TwoPointersTracer(gameObject, config) {
        _classCallCheck(this, TwoPointersTracer);
        var scene = GetSceneObject(gameObject);
        if (scene === gameObject) {
          gameObject = undefined;
        }
        var amount = scene.input.manager.pointersTotal - 1;
        if (amount < 2) {
          scene.input.addPointer(2 - amount);
        }
        this.scene = scene;
        this.gameObject = gameObject;
        if (gameObject) {
          gameObject.setInteractive(GetValue$2i(config, 'inputConfig', undefined));
        }
  
        // Event emitter
        this.setEventEmitter(GetValue$2i(config, 'eventEmitter', undefined));
        this._enable = undefined;
        this.pointers = [];
        this.movedState = {};
        this.resetFromJSON(config);
        this.boot();
      }
      _createClass(TwoPointersTracer, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setEnable(GetValue$2i(o, "enable", true));
          this.bounds = GetValue$2i(o, 'bounds', undefined);
          this.tracerState = TOUCH0$1;
          this.pointers.length = 0;
          Clear$1(this.movedState);
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          if (this.gameObject) {
            this.gameObject.on('pointerdown', this.onPointerDown, this);
          } else {
            this.scene.input.on('pointerdown', this.onPointerDown, this);
          }
          this.scene.input.on('pointerup', this.onPointerUp, this);
          this.scene.input.on('gameout', this.dragCancel, this);
          this.scene.input.on('pointermove', this.onPointerMove, this);
          this.scene.sys.events.once('shutdown', this.destroy, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown() {
          if (!this.scene) {
            return;
          }
          this.destroyEventEmitter();
          this.pointers.length = 0;
          Clear$1(this.movedState);
          if (this.gameObject) ; else {
            this.scene.input.off('pointerdown', this.onPointerDown, this);
          }
          this.scene.input.off('pointerup', this.onPointerUp, this);
          this.scene.input.off('gameout', this.dragCancel, this);
          this.scene.input.off('pointermove', this.onPointerMove, this);
          this.scene.sys.events.off('shutdown', this.destroy, this);
          this.scene = undefined;
          this.gameObject = undefined;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.shutdown();
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.dragCancel();
          }
          this._enable = e;
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "onPointerDown",
        value: function onPointerDown(pointer) {
          if (!this.enable) {
            return;
          }
          if (this.pointers.length === 2) {
            return;
          }
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          if (!isInsideBounds) {
            return;
          }
          var index = this.pointers.indexOf(pointer);
          if (index !== -1) {
            // Already in catched pointers
            return;
          }
          this.movedState[pointer.id] = false;
          this.pointers.push(pointer);
          switch (this.tracerState) {
            case TOUCH0$1:
              this.tracerState = TOUCH1$1;
              this.onDrag1Start();
              break;
            case TOUCH1$1:
              this.tracerState = TOUCH2;
              this.onDrag2Start();
              break;
          }
        }
      }, {
        key: "onPointerUp",
        value: function onPointerUp(pointer) {
          if (!this.enable) {
            return;
          }
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          if (!isInsideBounds) {
            return;
          }
          var index = this.pointers.indexOf(pointer);
          if (index === -1) {
            // Not in catched pointers
            return;
          } else {
            delete this.movedState[pointer.id];
            SpliceOne$2(this.pointers, index);
          }
          switch (this.tracerState) {
            case TOUCH1$1:
              this.tracerState = TOUCH0$1;
              this.onDrag1End();
              break;
            case TOUCH2:
              this.tracerState = TOUCH1$1;
              this.onDrag2End();
              this.onDrag1Start();
              break;
          }
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(pointer) {
          if (!this.enable) {
            return;
          }
          if (pointer.isDown) {
            var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
            var isCatchedPointer = this.pointers.indexOf(pointer) !== -1;
            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
              // Pointer moves out of bounds, lose pointer
              this.onPointerUp(pointer);
            } else {
              // Pointer drags in bounds
              if (!this.movedState[pointer.id]) {
                this.movedState[pointer.id] = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
              }
              if (this.movedState[pointer.id]) {
                switch (this.tracerState) {
                  case TOUCH1$1:
                    this.onDrag1();
                    break;
                  case TOUCH2:
                    this.onDrag2();
                    break;
                }
              }
            }
          }
        }
      }, {
        key: "dragCancel",
        value: function dragCancel() {
          if (this.tracerState === TOUCH2) {
            this.onDrag2End();
          }
          this.pointers.length = 0;
          Clear$1(this.movedState);
          this.tracerState = TOUCH0$1;
          return this;
        }
      }, {
        key: "onDrag1Start",
        value: function onDrag1Start() {
          this.emit('drag1start', this);
        }
      }, {
        key: "onDrag1End",
        value: function onDrag1End() {
          this.emit('drag1end', this);
        }
      }, {
        key: "onDrag1",
        value: function onDrag1() {
          this.emit('drag1', this);
        }
      }, {
        key: "onDrag2Start",
        value: function onDrag2Start() {
          this.emit('drag2start', this);
        }
      }, {
        key: "onDrag2End",
        value: function onDrag2End() {
          this.emit('drag2end', this);
        }
      }, {
        key: "onDrag2",
        value: function onDrag2() {
          this.emit('drag2', this);
        }
      }, {
        key: "distanceBetween",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var p0 = this.pointers[0],
            p1 = this.pointers[1];
          return DistanceBetween$3(p0.x, p0.y, p1.x, p1.y);
        }
      }, {
        key: "angleBetween",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var p0 = this.pointers[0],
            p1 = this.pointers[1];
          return AngleBetween(p0.x, p0.y, p1.x, p1.y);
        }
      }, {
        key: "drag1Vector",
        get: function get() {
          var pointer = this.pointers[0];
          if (pointer && this.movedState[pointer.id]) {
            var p1 = pointer.position;
            var p0 = pointer.prevPosition;
            tmpDragVector.x = p1.x - p0.x;
            tmpDragVector.y = p1.y - p0.y;
          } else {
            tmpDragVector.x = 0;
            tmpDragVector.y = 0;
          }
          return tmpDragVector;
        }
      }, {
        key: "centerX",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var p0 = this.pointers[0].position;
          var p1 = this.pointers[1].position;
          return (p0.x + p1.x) / 2;
        }
      }, {
        key: "centerY",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var p0 = this.pointers[0].position;
          var p1 = this.pointers[1].position;
          return (p0.y + p1.y) / 2;
        }
      }, {
        key: "prevCenterX",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
          var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
          return (preP0.x + preP1.x) / 2;
        }
      }, {
        key: "prevCenterY",
        get: function get() {
          if (this.tracerState !== TOUCH2) {
            return 0;
          }
          var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
          var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
          return (preP0.y + preP1.y) / 2;
        }
      }, {
        key: "movementCenterX",
        get: function get() {
          return this.centerX - this.prevCenterX;
        }
      }, {
        key: "movementCenterY",
        get: function get() {
          return this.centerY - this.prevCenterY;
        }
      }, {
        key: "setRecongizedStateObject",
        value: function setRecongizedStateObject(stateObject) {
          this.recongizedState = stateObject;
          return this;
        }
      }, {
        key: "state",
        get: function get() {
          return this.recongizedState.state;
        },
        set: function set(newState) {
          this.recongizedState.state = newState;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.state = IDLE$2;
          return this;
        }
      }, {
        key: "isPointer0InGameObject",
        value: function isPointer0InGameObject(gameObject, preTest, postTest) {
          var pointer = this.pointers[0];
          if (!pointer) {
            return false;
          }
          return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
      }, {
        key: "isPointer1InGameObject",
        value: function isPointer1InGameObject(gameObject, preTest, postTest) {
          var pointer = this.pointers[1];
          if (!pointer) {
            return false;
          }
          return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
      }]);
      return TwoPointersTracer;
    }();
    Object.assign(TwoPointersTracer.prototype, EventEmitterMethods$1);
    var tmpDragVector = {};
    var TOUCH0$1 = 0;
    var TOUCH1$1 = 1;
    var TOUCH2 = 2;
    var IDLE$2 = 'IDLE';
  
    var GetValue$2h = Phaser.Utils.Objects.GetValue;
    var Pinch = /*#__PURE__*/function (_TwoPointersTracer) {
      _inherits(Pinch, _TwoPointersTracer);
      function Pinch(gameObject, config) {
        var _this;
        _classCallCheck(this, Pinch);
        _this = _callSuper(this, Pinch, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {
              enter: function enter() {
                self.prevDistance = undefined;
                self.scaleFactor = 1;
              }
            },
            BEGIN: {},
            RECOGNIZED: {
              enter: function enter() {
                self.emit('pinchstart', self);
              },
              exit: function exit() {
                self.emit('pinchend', self);
              }
            }
          },
          init: function init() {
            this.state = IDLE$1;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        return _this;
      }
      _createClass(Pinch, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Pinch.prototype), "resetFromJSON", this).call(this, o);
          this.setDragThreshold(GetValue$2h(o, 'threshold', 0));
          return this;
        }
      }, {
        key: "onDrag2Start",
        value: function onDrag2Start() {
          this.scaleFactor = 1;
          this.prevDistance = this.distanceBetween;
          this.state = BEGIN$1;
          if (this.dragThreshold === 0) {
            this.state = RECOGNIZED$1;
          }
        }
      }, {
        key: "onDrag2End",
        value: function onDrag2End() {
          this.state = IDLE$1;
        }
      }, {
        key: "onDrag2",
        value: function onDrag2() {
          switch (this.state) {
            case BEGIN$1:
              if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
                var curDistance = this.distanceBetween;
                this.scaleFactor = curDistance / this.prevDistance;
                this.prevDistance = curDistance;
                this.state = RECOGNIZED$1;
              }
              break;
            case RECOGNIZED$1:
              var curDistance = this.distanceBetween;
              this.scaleFactor = curDistance / this.prevDistance;
              this.emit('pinch', this);
              this.prevDistance = curDistance;
              break;
          }
        }
      }, {
        key: "isPinched",
        get: function get() {
          return this.state === RECOGNIZED$1;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }]);
      return Pinch;
    }(TwoPointersTracer);
    var IDLE$1 = 'IDLE';
    var BEGIN$1 = 'BEGIN';
    var RECOGNIZED$1 = 'RECOGNIZED';
  
    var RotateAround$3 = Phaser.Math.RotateAround;
    var RotateObjectAround = function RotateObjectAround(gameObject, x, y, angle) {
      RotateAround$3(gameObject, x, y, angle);
      gameObject.rotation += angle;
      return gameObject;
    };
  
    var ScreenXYToWorldXY = function ScreenXYToWorldXY(screenX, screenY, camera, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globalOut;
      }
      camera.getWorldPoint(screenX, screenY, out);
      return out;
    };
    var globalOut = {};
  
    var SpinObject = function SpinObject(gameObject, camera) {
      if (!this.isRotation) {
        return this;
      }
      if (camera === undefined) {
        camera = this.pointers[0].camera;
      }
      var movementX = this.movementCenterX,
        movementY = this.movementCenterY;
      var worldXY = ScreenXYToWorldXY(this.centerX, this.centerY, camera, true);
      var centerWorldX = worldXY.x;
      var centerWorldY = worldXY.y;
      var angle = this.rotation;
      if (Array.isArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          gameObject = gameObjects[i];
          gameObject.x += movementX;
          gameObject.y += movementY;
          RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
        }
      } else {
        gameObject.x += movementX;
        gameObject.y += movementY;
        RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
      }
      return this;
    };
  
    var GetValue$2g = Phaser.Utils.Objects.GetValue;
    var WrapDegrees = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 
    var ShortestBetween = Phaser.Math.Angle.ShortestBetween;
    var RadToDeg$3 = Phaser.Math.RadToDeg;
    var DegToRad$4 = Phaser.Math.DegToRad;
    var Rotate = /*#__PURE__*/function (_TwoPointersTracer) {
      _inherits(Rotate, _TwoPointersTracer);
      function Rotate(gameObject, config) {
        var _this;
        _classCallCheck(this, Rotate);
        _this = _callSuper(this, Rotate, [gameObject, config]);
        var self = _assertThisInitialized(_this);
        var stateConfig = {
          states: {
            IDLE: {
              enter: function enter() {
                self.prevAngle = undefined;
                self.angle = 0;
              }
            },
            BEGIN: {},
            RECOGNIZED: {
              enter: function enter() {
                self.emit('rotatestart', self);
              },
              exit: function exit() {
                self.emit('rotateend', self);
              }
            }
          },
          init: function init() {
            this.state = IDLE;
          },
          eventEmitter: false
        };
        _this.setRecongizedStateObject(new FSM(stateConfig));
        return _this;
      }
      _createClass(Rotate, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Rotate.prototype), "resetFromJSON", this).call(this, o);
          this.setDragThreshold(GetValue$2g(o, 'threshold', 0));
          return this;
        }
      }, {
        key: "onDrag2Start",
        value: function onDrag2Start() {
          this.prevAngle = WrapDegrees(RadToDeg$3(this.angleBetween)); // Degrees
          this.state = BEGIN;
          if (this.dragThreshold === 0) {
            this.state = RECOGNIZED;
          }
        }
      }, {
        key: "onDrag2End",
        value: function onDrag2End() {
          this.state = IDLE;
        }
      }, {
        key: "onDrag2",
        value: function onDrag2() {
          switch (this.state) {
            case BEGIN:
              if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
                var curAngle = WrapDegrees(RadToDeg$3(this.angleBetween));
                this.angle = ShortestBetween(this.prevAngle, curAngle);
                this.prevAngle = curAngle;
                this.state = RECOGNIZED;
              }
              break;
            case RECOGNIZED:
              var curAngle = WrapDegrees(RadToDeg$3(this.angleBetween));
              this.angle = ShortestBetween(this.prevAngle, curAngle);
              this.prevAngle = curAngle;
              this.emit('rotate', this);
              break;
          }
        }
      }, {
        key: "isRotated",
        get: function get() {
          return this.state === RECOGNIZED;
        }
      }, {
        key: "rotation",
        get: function get() {
          return DegToRad$4(this.angle);
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }]);
      return Rotate;
    }(TwoPointersTracer);
    var methods$u = {
      spinObject: SpinObject
    };
    Object.assign(Rotate.prototype, methods$u);
    var IDLE = 'IDLE';
    var BEGIN = 'BEGIN';
    var RECOGNIZED = 'RECOGNIZED';
  
    var GetValue$2f = Phaser.Utils.Objects.GetValue;
    var TapChild = function TapChild(config) {
      var tapConfig = GetValue$2f(config, 'tap', undefined);
      if (tapConfig === false) {
        return;
      } else if (tapConfig === true) {
        tapConfig = undefined;
      }
      var childrenInteractive = this._childrenInteractive;
      this._tap = new Tap(this, tapConfig);
      this._tap.on('tap', function (tap, gameObject, lastPointer) {
        EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix).concat(tap.tapsCount, "tap"), childrenInteractive.targetSizers, childrenInteractive.targetMode, tap.worldX, tap.worldY, lastPointer);
      }, this);
    };
  
    var GetValue$2e = Phaser.Utils.Objects.GetValue;
    var PressChild = function PressChild(config) {
      var pressConfig = GetValue$2e(config, 'press', undefined);
      if (pressConfig === false) {
        return;
      } else if (pressConfig === true) {
        pressConfig = undefined;
      }
      var childrenInteractive = this._childrenInteractive;
      this._press = new Press(this, pressConfig);
      this._press.on('pressstart', function (press, gameObject, lastPointer) {
        EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressstart"), childrenInteractive.targetSizers, childrenInteractive.targetMode, press.worldX, press.worldY, lastPointer);
      }, this).on('pressend', function (press, gameObject, lastPointer) {
        EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressend"), childrenInteractive.targetSizers, childrenInteractive.targetMode, press.worldX, press.worldY, lastPointer);
      }, this);
    };
  
    var GetValue$2d = Phaser.Utils.Objects.GetValue;
    var SwipeChild = function SwipeChild(config) {
      var swipeConfig = GetValue$2d(config, 'swipe', undefined);
      if (swipeConfig === false) {
        return;
      } else if (swipeConfig === true) {
        swipeConfig = undefined;
      }
      if (swipeConfig === undefined) {
        swipeConfig = {};
      }
      if (!swipeConfig.hasOwnProperty('dir')) {
        swipeConfig.dir = '4dir';
      }
      var childrenInteractive = this._childrenInteractive;
      this._swipe = new Swipe(this, swipeConfig);
      this._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
        var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
        EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "swipe").concat(dirName), childrenInteractive.targetSizers, childrenInteractive.targetMode, swipe.worldX, swipe.worldY, lastPointer);
      }, this);
    };
  
    var GetValue$2c = Phaser.Utils.Objects.GetValue;
    var SetChildrenInteractive = function SetChildrenInteractive(gameObject, config) {
      gameObject.setInteractive();
      if (GetValue$2c(config, 'dropZone', false)) {
        gameObject.input.dropZone = true;
      }
      gameObject._childrenInteractive = {
        targetSizers: GetValue$2c(config, 'targets', [gameObject]),
        targetMode: GetValue$2c(config, 'targetMode', 'parent'),
        eventEmitter: GetValue$2c(config, 'eventEmitter', gameObject),
        eventNamePrefix: GetValue$2c(config, 'inputEventPrefix', 'child.')
      };
      DownChild.call(gameObject, config);
      UpChild.call(gameObject, config);
      OverChild.call(gameObject, config);
      ClickChild.call(gameObject, config);
      TapChild.call(gameObject, config);
      PressChild.call(gameObject, config);
      SwipeChild.call(gameObject, config);
      return gameObject;
    };
  
    var SetChildrenInteractiveWrap = function SetChildrenInteractiveWrap(config) {
      SetChildrenInteractive(this, config);
      return this;
    };
  
    var BroadcastEvent = function BroadcastEvent() {
      var gameObjects = this.getAllChildren([this]);
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var gameObject = gameObjects[i];
        gameObject.emit.apply(gameObject, arguments);
      }
      return this;
    };
  
    var methods$t = {
      getSizerConfig: GetSizerConfig,
      getChildPrevState: GetChildPrevState,
      pushIntoBounds: PushIntoBounds,
      drawBounds: DrawBounds,
      resolveWidth: ResolveWidth$3,
      hasWidthWrap: HasWidthWrap$2,
      resolveChildrenWidth: ResolveChildrenWidth$1,
      runWidthWrap: RunWidthWrap$3,
      resolveHeight: ResolveHeight$3,
      hasHeightWrap: HasHeightWrap$2,
      resolveChildrenHeight: ResolveChildrenHeight$1,
      runHeightWrap: RunHeightWrap$3,
      getChildWidth: GetChildWidth,
      getChildHeight: GetChildHeight,
      getExpandedChildWidth: GetExpandedChildWidth$3,
      getExpandedChildHeight: GetExpandedChildHeight$3,
      getChildrenWidth: GetChildrenWidth$5,
      getChildrenHeight: GetChildrenHeight$5,
      addChildrenMap: AddChildrenMap,
      addElement: AddChildrenMap,
      removeChildrenMap: RemoveChildrenMap,
      getElement: GetElement,
      getChildIndex: GetChildIndex,
      getAllChildrenSizers: GetAllChildrenSizers,
      getChildrenSizers: GetChildrenSizers$5,
      preLayout: PreLayout$4,
      layout: Layout,
      runLayout: RunLayout$1,
      layoutChildren: LayoutChildren$6,
      layoutBackgrounds: LayoutBackgrounds,
      postLayout: PostLayout,
      _postLayout: _PostLayout,
      setAnchor: SetAnchor,
      isInTouching: IsInTouching,
      pointToChild: PointToChild$1,
      setDraggable: SetDraggable,
      setChildrenInteractive: SetChildrenInteractiveWrap,
      broadcastEvent: BroadcastEvent
    };
    Object.assign(methods$t, PaddingMethods, AddChildMethods$8, RemoveChildMethods$7, GetParentSizerMethods, methods$y, methods$x, methods$w, ShakeMethods, EaseDataMethods, DelayCallMethods$2, ClickMethods, ClickOutsideMethods, TouchingMethods, HoverMethods, HideMethods, ModalMethods$1, GetShownChildrenMethods);
  
    var GetValue$2b = Phaser.Utils.Objects.GetValue;
    var Base = /*#__PURE__*/function (_Container) {
      _inherits(Base, _Container);
      function Base(scene, x, y, minWidth, minHeight, config) {
        var _this;
        _classCallCheck(this, Base);
        _this = _callSuper(this, Base, [scene, x, y, 1, 1]);
        _this.isRexSizer = true;
        var origin = GetValue$2b(config, 'origin', 0.5);
        var originX = GetValue$2b(config, 'originX', origin);
        var originY = GetValue$2b(config, 'originY', origin);
        _this.setOrigin(originX, originY);
        _this.setMinSize(minWidth, minHeight);
        _this.setName(GetValue$2b(config, 'name', ''));
        _this.rexSizer = {};
        _this.space = {};
        _this.backgroundChildren = undefined;
        _this.sizerChildren = undefined; // [] or {}
        _this.childrenMap = {};
        _this.layoutedChildren = undefined;
        _this.enableLayoutWarn(false);
        var anchorConfig = GetValue$2b(config, 'anchor', undefined);
        if (anchorConfig) {
          _this.setAnchor(anchorConfig);
        }
        _this.setInnerPadding(GetValue$2b(config, 'space', 0));
        var draggable = GetValue$2b(config, 'draggable', false);
        if (draggable) {
          _this.setDraggable(draggable);
        }
        _this.setSizerEventsEnable(GetValue$2b(config, 'sizerEvents', false));
        _this.setDirty(true);
        if (GetValue$2b(config, 'enableLayer', false)) {
          _this.enableLayer();
        }
        return _this;
      }
      _createClass(Base, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (fromScene) {
            // In this case, children will be cleared and destroy in scene level
            var sizers = this.getAllChildrenSizers([this]);
            for (var i = 0, cnt = sizers.length; i < cnt; i++) {
              sizers[i].sizerEventsEnable = false;
            }
          }
          _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
          Clear$1(this.backgroundChildren);
          Clear$1(this.sizerChildren);
          this.childrenMap = undefined;
          this.space = undefined;
          this.rexSizer = undefined;
          this.layoutedChildren = undefined;
        }
      }, {
        key: "setMinSize",
        value: function setMinSize(minWidth, minHeight) {
          this.setMinWidth(minWidth).setMinHeight(minHeight);
          return this;
        }
      }, {
        key: "setMinWidth",
        value: function setMinWidth(minWidth) {
          if (minWidth == null) {
            minWidth = 0;
          }
          this.minWidth = minWidth;
          return this;
        }
      }, {
        key: "setMinHeight",
        value: function setMinHeight(minHeight) {
          if (minHeight == null) {
            minHeight = 0;
          }
          this.minHeight = minHeight;
          return this;
        }
      }, {
        key: "setDirty",
        value: function setDirty(dirty) {
          if (dirty === undefined) {
            dirty = true;
          }
          this.dirty = dirty;
          return this;
        }
      }, {
        key: "setSizerEventsEnable",
        value: function setSizerEventsEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.sizerEventsEnable = enable;
          return this;
        }
      }, {
        key: "enableLayoutWarn",
        value: function enableLayoutWarn(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.layoutWarnEnable = enable;
          return this;
        }
      }, {
        key: "ignoreLayout",
        get: function get() {
          // Skip hidden or !dirty sizer
          return this.rexSizer.hidden || !this.dirty;
        }
      }, {
        key: "childrenWidth",
        get: function get() {
          if (this._childrenWidth === undefined) {
            this._childrenWidth = this.getChildrenWidth();
          }
          return this._childrenWidth;
        }
      }, {
        key: "childrenHeight",
        get: function get() {
          if (this._childrenHeight === undefined) {
            this._childrenHeight = this.getChildrenHeight();
          }
          return this._childrenHeight;
        }
      }, {
        key: "left",
        get: function get() {
          return this.x - GetDisplayWidth(this) * this.originX;
        },
        set: function set(value) {
          this.x += value - this.left;
        }
      }, {
        key: "alignLeft",
        value: function alignLeft(value) {
          this.left = value;
          return this;
        }
      }, {
        key: "right",
        get: function get() {
          return this.left + GetDisplayWidth(this);
        },
        set: function set(value) {
          this.x += value - this.right;
        }
      }, {
        key: "alignRight",
        value: function alignRight(value) {
          this.right = value;
          return this;
        }
      }, {
        key: "centerX",
        get: function get() {
          return this.left + GetDisplayWidth(this) / 2;
        },
        set: function set(value) {
          this.x += value - this.centerX;
        }
      }, {
        key: "alignCenterX",
        value: function alignCenterX(value) {
          this.centerX = value;
          return this;
        }
      }, {
        key: "top",
        get: function get() {
          return this.y - GetDisplayHeight(this) * this.originY;
        },
        set: function set(value) {
          this.y += value - this.top;
        }
      }, {
        key: "alignTop",
        value: function alignTop(value) {
          this.top = value;
          return this;
        }
      }, {
        key: "bottom",
        get: function get() {
          return this.top + GetDisplayHeight(this);
        },
        set: function set(value) {
          this.y += value - this.bottom;
        }
      }, {
        key: "alignBottom",
        value: function alignBottom(value) {
          this.bottom = value;
          return this;
        }
      }, {
        key: "centerY",
        get: function get() {
          return this.top + GetDisplayHeight(this) / 2;
        },
        set: function set(value) {
          this.y += value - this.centerY;
        }
      }, {
        key: "alignCenterY",
        value: function alignCenterY(value) {
          this.centerY = value;
          return this;
        }
      }, {
        key: "innerLeft",
        get: function get() {
          return this.left + this.space.left * this.scaleX;
        }
      }, {
        key: "innerRight",
        get: function get() {
          return this.right - this.space.right * this.scaleX;
        }
      }, {
        key: "innerTop",
        get: function get() {
          return this.top + this.space.top * this.scaleY;
        }
      }, {
        key: "innerBottom",
        get: function get() {
          return this.bottom - this.space.bottom * this.scaleY;
        }
      }, {
        key: "innerWidth",
        get: function get() {
          return (this.width - this.space.left - this.space.right) * this.scaleX;
        }
      }, {
        key: "innerHeight",
        get: function get() {
          return (this.height - this.space.top - this.space.bottom) * this.scaleY;
        }
      }, {
        key: "minInnerWidth",
        get: function get() {
          var result = (this.minWidth - this.space.left - this.space.right) * this.scaleX;
          return Math.max(result, 0);
        }
      }, {
        key: "minInnerHeight",
        get: function get() {
          var result = (this.minHeight - this.space.top - this.space.bottom) * this.scaleY;
          return Math.max(result, 0);
        }
      }]);
      return Base;
    }(ContainerLite);
    Object.assign(Base.prototype, methods$t);
  
    var GetChildrenWidth$4 = function GetChildrenWidth() {
      if (this.rexSizer.hidden) {
        return 0;
      }
      var result = 0;
      var children = this.sizerChildren;
      var child, padding, childWidth;
      var hasUnknownChildWidth = false;
      for (var key in children) {
        child = children[key];
        childWidth = this.getChildWidth(child);
        if (childWidth === undefined) {
          hasUnknownChildWidth = true;
        }
        if (hasUnknownChildWidth) {
          continue;
        }
        padding = child.rexSizer.padding;
        childWidth += padding.left + padding.right;
        result = Math.max(childWidth, result);
      }
      if (hasUnknownChildWidth) {
        return undefined;
      }
      return result + this.space.left + this.space.right;
    };
  
    var GetChildrenHeight$4 = function GetChildrenHeight() {
      if (this.rexSizer.hidden) {
        return 0;
      }
      var result = 0;
      var children = this.sizerChildren;
      var child, padding, childHeight;
      var hasUnknownChildHeight = false;
      for (var key in children) {
        child = children[key];
        childHeight = this.getChildHeight(child);
        if (childHeight === undefined) {
          hasUnknownChildHeight = true;
        }
        if (hasUnknownChildHeight) {
          continue;
        }
        padding = child.rexSizer.padding;
        childHeight += padding.top + padding.bottom;
        result = Math.max(childHeight, result);
      }
      if (hasUnknownChildHeight) {
        return undefined;
      }
      return result + this.space.top + this.space.bottom;
    };
  
    var GetExpandedChildWidth$2 = function GetExpandedChildWidth(child, parentWidth) {
      if (parentWidth === undefined) {
        parentWidth = this.width;
      }
      var childWidth;
      var childConfig = child.rexSizer;
      if (childConfig.expandWidth) {
        var space = this.space;
        var innerWidth = parentWidth - space.left - space.right;
        var padding = childConfig.padding;
        childWidth = innerWidth - padding.left - padding.right;
      }
      return childWidth;
    };
  
    var GetExpandedChildHeight$2 = function GetExpandedChildHeight(child, parentHeight) {
      if (parentHeight === undefined) {
        parentHeight = this.height;
      }
      var childHeight;
      var childConfig = child.rexSizer;
      if (childConfig.expandHeight) {
        var space = this.space;
        var innerHeight = parentHeight - space.top - space.bottom;
        var padding = childConfig.padding;
        childHeight = innerHeight - padding.top - padding.bottom;
      }
      return childHeight;
    };
  
    var GetChildrenSizers$4 = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      var children = this.sizerChildren,
        child;
      for (var key in children) {
        child = children[key];
        if (child.isRexSizer) {
          out.push(child);
        }
      }
      return out;
    };
  
    var FitTo = function FitTo(source, target, fitMode, out) {
      if (fitMode === undefined) {
        fitMode = 0;
      } else {
        var fitModeType = _typeof(fitMode);
        if (fitModeType === 'boolean') {
          out = fitMode;
          fitMode = 0;
        } else if (fitModeType === 'string') {
          fitMode = FitModeMap[fitMode];
        }
      }
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globalSize;
      }
      var scaleX = target.width / source.width;
      var scaleY = target.height / source.height;
      var scale = !fitMode ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);
      out.width = source.width * scale;
      out.height = source.height * scale;
      return out;
    };
    var FitModeMap = {
      'fit': 0,
      'FIT': 0,
      'envelop': 1,
      'ENVELOP': 1
    };
    var globalSize = {};
  
    var CheckSize = function CheckSize(child, parent) {
      if (child.layoutWarnEnable) {
        if (child.width < child.childrenWidth) {
          // Warning
          console.warn("Layout width error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
        }
        if (child.height < child.childrenHeight) {
          // Warning
          console.warn("Layout height error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
        }
      }
    };
  
    var LayoutChildren$5 = function LayoutChildren() {
      var child, childConfig, padding;
      var startX = this.innerLeft,
        startY = this.innerTop;
      var innerWidth = this.innerWidth,
        innerHeight = this.innerHeight;
      var x, y, width, height; // Align zone
      var childWidth, childHeight, childSize;
      // Layout current page
      var children = this.sizerChildren;
      for (var key in children) {
        child = children[key];
        if (child.rexSizer.hidden) {
          continue;
        }
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        PreLayoutChild.call(this, child);
        childWidth = this.getExpandedChildWidth(child);
        childHeight = this.getExpandedChildHeight(child);
        if (childConfig.aspectRatio > 0) {
          sourceSize.width = childConfig.aspectRatio;
          sourceSize.height = 1;
          targetSize.width = childWidth;
          targetSize.height = childHeight;
          childSize = FitTo(sourceSize, targetSize, 'FIT', true);
          childWidth = childSize.width;
          childHeight = childSize.height;
        }
  
        // Set size
        if (child.isRexSizer) {
          child.runLayout(this, childWidth, childHeight);
          CheckSize(child, this);
        } else {
          ResizeGameObject(child, childWidth, childHeight);
        }
  
        // Set position
        x = startX + padding.left;
        width = innerWidth - padding.left - padding.right;
        y = startY + padding.top;
        height = innerHeight - padding.top - padding.bottom;
        LayoutChild.call(this, child, x, y, width, height, childConfig.align, childConfig.alignOffsetX, childConfig.alignOffsetY);
      }
    };
    var sourceSize = {};
    var targetSize = {};
  
    var IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$2a = Phaser.Utils.Objects.GetValue;
    var ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;
    var UUID$3 = Phaser.Utils.String.UUID;
    var Add$7 = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY, aspectRatio) {
      AddChild$1.call(this, gameObject);
      if (IsPlainObject$v(childKey)) {
        var config = childKey;
        childKey = GetValue$2a(config, 'key', undefined);
        align = GetValue$2a(config, 'align', ALIGN_CENTER$3);
        padding = GetValue$2a(config, 'padding', 0);
        expand = GetValue$2a(config, 'expand', true);
        if (!gameObject.isRexSizer) {
          // Get minWidth,minHeight from config
          minWidth = GetValue$2a(config, 'minWidth', gameObject._minWidth);
          minHeight = GetValue$2a(config, 'minHeight', gameObject._minHeighted);
        }
        offsetX = GetValue$2a(config, 'offsetX', 0);
        offsetY = GetValue$2a(config, 'offsetY', 0);
        aspectRatio = GetValue$2a(config, 'aspectRatio', 0);
      }
      var hasValidKey = childKey !== undefined;
      if (!hasValidKey) {
        childKey = UUID$3();
      }
      if (typeof align === 'string') {
        align = AlignConst[align];
      }
      if (align === undefined) {
        align = ALIGN_CENTER$3;
      }
      if (padding === undefined) {
        padding = 0;
      }
      if (expand === undefined) {
        expand = true;
      }
      if (!gameObject.isRexSizer) {
        // Get minWidth,minHeight from game object
        if (minWidth === undefined) {
          minWidth = gameObject._minWidth;
        }
        if (minHeight === undefined) {
          minHeight = gameObject._minHeight;
        }
      }
      if (offsetX === undefined) {
        offsetX = 0;
      }
      if (offsetY === undefined) {
        offsetY = 0;
      }
      if (aspectRatio === undefined) {
        aspectRatio = 0;
      } else if (aspectRatio === true) {
        aspectRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
      }
      if (aspectRatio > 0) {
        expand = true;
        if (minWidth === undefined) {
          minWidth = 0;
        }
        if (minHeight === undefined) {
          minHeight = 0;
        }
      }
      var config = this.getSizerConfig(gameObject);
      config.align = align;
      config.padding = GetBoundsConfig(padding);
      if (IsPlainObject$v(expand)) {
        config.expandWidth = GetValue$2a(expand, 'width', false);
        config.expandHeight = GetValue$2a(expand, 'height', false);
      } else {
        config.expandWidth = expand;
        config.expandHeight = expand;
      }
      if (!gameObject.isRexSizer) {
        // Expand normal game object
        if (config.expandWidth) {
          // minWidth is still undefined, uses current display width
          gameObject.minWidth = minWidth === undefined ? GetDisplayWidth(gameObject) : minWidth;
        }
        if (config.expandHeight) {
          // minHeight is still undefined, uses current display height
          gameObject.minHeight = minHeight === undefined ? GetDisplayHeight(gameObject) : minHeight;
        }
      }
      config.alignOffsetX = offsetX;
      config.alignOffsetY = offsetY;
      config.aspectRatio = aspectRatio;
      if (this.sizerChildren.hasOwnProperty(childKey)) {
        this.sizerChildren[childKey].destroy();
      }
      this.sizerChildren[childKey] = gameObject;
      if (hasValidKey) {
        this.addChildrenMap(childKey, gameObject);
      }
      return this;
    };
    var AddChildMethods$7 = {
      add: Add$7
    };
  
    var ContainerClear = ContainerLite.prototype.clear;
    var ClearChildren = function ClearChildren(destroyChild) {
      if (this.backgroundChildren) {
        this.backgroundChildren.length = 0;
      }
      var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
      var children;
      if (fireRemoveEvent) {
        children = this.getChildren([]);
      }
      ContainerClear.call(this, destroyChild);
      if (fireRemoveEvent) {
        var gameObject;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          gameObject = children[i];
          gameObject.emit('sizer.remove', gameObject, this);
          this.emit('remove', gameObject, this);
        }
      }
      return this;
    };
  
    var RemoveChildMethods$6 = {
      remove: function remove(gameObject, destroyChild) {
        var key;
        if (typeof gameObject === 'string') {
          key = gameObject;
          gameObject = this.sizerChildren[key];
          if (!gameObject) {
            return this;
          }
        } else if (this.getParentSizer(gameObject) !== this) {
          return this;
        } else {
          key = this.childToKey(gameObject);
        }
        if (key) {
          delete this.sizerChildren[key];
          if (this.childrenMap.hasOwnProperty(key)) {
            delete this.childrenMap[key];
          }
        }
        RemoveChild.call(this, gameObject, destroyChild);
        return this;
      },
      removeAll: function removeAll(destroyChild) {
        for (var key in this.sizerChildren) {
          this.remove(key, destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        for (var key in this.sizerChildren) {
          delete this.sizerChildren[key];
          if (this.childrenMap.hasOwnProperty(key)) {
            delete this.childrenMap[key];
          }
        }
        ClearChildren.call(this, destroyChild);
        return this;
      }
    };
  
    var methods$s = {
      getChildrenWidth: GetChildrenWidth$4,
      getChildrenHeight: GetChildrenHeight$4,
      getExpandedChildWidth: GetExpandedChildWidth$2,
      getExpandedChildHeight: GetExpandedChildHeight$2,
      getChildrenSizers: GetChildrenSizers$4,
      layoutChildren: LayoutChildren$5
    };
    Object.assign(methods$s, AddChildMethods$7, RemoveChildMethods$6);
  
    var IndexOf = function IndexOf(obj, child) {
      if (Array.isArray(obj)) {
        return obj.indexOf(child);
      } else {
        for (var key in obj) {
          if (obj[key] === child) {
            return key;
          }
        }
        return null;
      }
    };
  
    var IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$29 = Phaser.Utils.Objects.GetValue;
    var OverlapSizer = /*#__PURE__*/function (_BaseSizer) {
      _inherits(OverlapSizer, _BaseSizer);
      function OverlapSizer(scene, x, y, minWidth, minHeight, config) {
        var _this;
        _classCallCheck(this, OverlapSizer);
        if (IsPlainObject$u(x)) {
          config = x;
          x = GetValue$29(config, 'x', 0);
          y = GetValue$29(config, 'y', 0);
          minWidth = GetValue$29(config, 'width', undefined);
          minHeight = GetValue$29(config, 'height', undefined);
        } else if (IsPlainObject$u(minWidth)) {
          config = minWidth;
          minWidth = GetValue$29(config, 'width', undefined);
          minHeight = GetValue$29(config, 'height', undefined);
        }
        _this = _callSuper(this, OverlapSizer, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexOverlapSizer';
        _this.sizerChildren = {};
        _this.addChildrenMap('items', _this.sizerChildren);
        return _this;
      }
      _createClass(OverlapSizer, [{
        key: "childToKey",
        value: function childToKey(gameObject) {
          if (typeof gameObject === 'string') {
            var key = gameObject;
            if (this.sizerChildren.hasOwnPropery(key)) {
              return key;
            }
          } else {
            return IndexOf(this.sizerChildren, gameObject);
          }
          return null;
        }
      }]);
      return OverlapSizer;
    }(Base);
    Object.assign(OverlapSizer.prototype, methods$s);
  
    var GetDistance = Phaser.Math.Distance.Between;
    var IsLocalPointInKnob = function IsLocalPointInKnob(knob, localX, localY) {
      var centerX = knob.width / 2;
      return GetDistance(centerX, centerX, localX, localY) <= centerX;
    };
  
    var GetAngle$1 = Phaser.Math.Angle.Between;
    var NormalizeAngle = Phaser.Math.Angle.Normalize;
    var OnTouchPad = function OnTouchPad(pointer, localX, localY) {
      if (!this.enable) {
        return;
      }
      if (!pointer.isDown) {
        return;
      }
      var knob = this.sizerChildren.knob;
      if (!IsLocalPointInKnob(knob, localX, localY)) {
        return;
      }
      var centerX = knob.width / 2;
      var startAngle = knob.startAngle;
      var endAngle = GetAngle$1(centerX, centerX, localX, localY);
      var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
      var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);
      this.stopEaseValue();
      if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
        this.value = value;
      } else {
        this.easeValueTo(value);
      }
    };
    var InstallEvents$1 = function InstallEvents() {
      var knob = this.sizerChildren.knob;
      knob.on('pointerdown', OnTouchPad, this).on('pointermove', OnTouchPad, this).setInteractive();
    };
  
    var GetAngle = Phaser.Math.Angle.Between;
    var WrapAngle = Phaser.Math.Angle.Wrap;
    var OnPointerDown = function OnPointerDown(pointer, localX, localY) {
      if (!this.enable || this.panPointer) {
        return;
      }
      var knob = this.sizerChildren.knob;
      if (!IsLocalPointInKnob(knob, localX, localY)) {
        return;
      }
      OnPanStart.call(this, pointer);
    };
    var OnPointerMove = function OnPointerMove(pointer, localX, localY) {
      if (!this.enable) {
        return;
      }
      if (!pointer.isDown) {
        return;
      }
      var knob = this.sizerChildren.knob;
      switch (this.panState) {
        case TOUCH0:
          if (IsLocalPointInKnob(knob, localX, localY)) {
            OnPanStart.call(this, pointer);
          }
          break;
        case TOUCH1:
          if (IsLocalPointInKnob(knob, localX, localY)) {
            OnPan.call(this);
          } else {
            OnPanEnd.call(this);
          }
          break;
      }
    };
    var OnPointerUp = function OnPointerUp(pointer, localX, localY) {
      if (!this.enable || this.panPointer !== pointer) {
        return;
      }
      OnPanEnd.call(this);
    };
    var OnPanStart = function OnPanStart(pointer) {
      this.panPointer = pointer;
      this.panState = TOUCH1;
    };
    var OnPanEnd = function OnPanEnd() {
      this.panPointer = undefined;
      this.panState = TOUCH0;
    };
    var OnPan = function OnPan() {
      var p0 = this.panPointer.prevPosition,
        p1 = this.panPointer.position;
      var knob = this.sizerChildren.knob;
      var startAngle = GetAngle(knob.x, knob.y, p0.x, p0.y),
        endAngle = GetAngle(knob.x, knob.y, p1.x, p1.y);
      var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
      var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);
      this.stopEaseValue();
      this.value += deltaValue;
    };
    var TOUCH0 = 0;
    var TOUCH1 = 1;
    var InstallEvents = function InstallEvents() {
      var knob = this.sizerChildren.knob;
      knob.on('pointerdown', OnPointerDown, this).on('pointermove', OnPointerMove, this).on('pointerup', OnPointerUp, this).setInteractive();
      this.panPointer = undefined;
      this.panState = TOUCH0;
    };
  
    var SetTextFormatCallback = function SetTextFormatCallback(callback, scope) {
      this.textFormatCallback = callback;
      this.textFormatCallbackScope = scope;
      return this;
    };
    var GetFormatText = function GetFormatText(value) {
      if (value === undefined) {
        value = this.value;
      }
      var text;
      if (this.textFormatCallbackScope) {
        text = this.textFormatCallback(value);
      } else {
        text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
      }
      return text;
    };
    var UpdateText = function UpdateText(value) {
      var textObject = this.sizerChildren.text;
      if (textObject && this.textFormatCallback) {
        textObject.setText(GetFormatText.call(this, value));
        if (textObject.layout) {
          textObject.layout();
        }
      }
      return this;
    };
    var TextObjectMethods = {
      setTextFormatCallback: SetTextFormatCallback,
      getFormatText: GetFormatText,
      updateText: UpdateText
    };
  
    var GetValue$28 = Phaser.Utils.Objects.GetValue;
    var SnapTo$1 = Phaser.Math.Snap.To;
    var Knob = /*#__PURE__*/function (_ProgressBase) {
      _inherits(Knob, _ProgressBase);
      function Knob(scene, config) {
        var _this;
        _classCallCheck(this, Knob);
        if (config === undefined) {
          config = {};
        }
  
        // Create sizer
        _this = _callSuper(this, Knob, [scene, config]);
        _this.type = 'rexKnob';
        _this.bootProgressBase(config);
  
        // Add elements
        var background = GetValue$28(config, 'background', undefined);
        var textObject = GetValue$28(config, 'text', undefined);
        if (background) {
          _this.addBackground(background);
        }
        // Get text object
        if (textObject) {
          // Don't draw text on knob directly
          config.textColor = undefined;
          config.textStrokeColor = undefined;
          _this.setTextFormatCallback(GetValue$28(config, 'textFormatCallback', undefined), GetValue$28(config, 'textFormatCallbackScope', undefined));
        }
        // Create circular progress object
        var knob = new CircularProgress$1(scene, config);
        knob.setDepth(GetValue$28(config, 'knobDepth', 0));
        knob._value = -1; // To trigger text updating
        scene.add.existing(knob);
        _this.add(knob, 'knob');
        if (textObject) {
          _this.add(textObject, 'text', 'center', 0, false);
          scene.children.moveBelow(knob, textObject); // Move knob below textObject
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('knob', knob);
        _this.addChildrenMap('text', textObject);
        _this.setEnable(GetValue$28(config, 'enable', undefined));
        _this.setGap(GetValue$28(config, 'gap', undefined));
        _this.setValue(GetValue$28(config, 'value', 0), GetValue$28(config, 'min', undefined), GetValue$28(config, 'max', undefined));
  
        // Input
        var inputMode = GetValue$28(config, 'input', 0);
        if (typeof inputMode === 'string') {
          inputMode = INPUTMODE$1[inputMode];
        }
        switch (inputMode) {
          case 0:
            // 'pan'
            InstallEvents.call(_assertThisInitialized(_this));
            break;
          case 1:
            // 'click'
            InstallEvents$1.call(_assertThisInitialized(_this));
            break;
        }
        return _this;
      }
      _createClass(Knob, [{
        key: "setEnable",
        value: function setEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.enable = enable;
          return this;
        }
      }, {
        key: "setGap",
        value: function setGap(gap) {
          this.gap = gap;
          return this;
        }
  
        // Override
      }, {
        key: "value",
        get: function get() {
          return this.sizerChildren.knob.value;
        }
  
        // Override
        ,
        set: function set(value) {
          if (this.gap !== undefined) {
            value = SnapTo$1(value, this.gap);
          }
          var oldValue = this.value;
          this.sizerChildren.knob.value = value;
          var newValue = this.value;
          if (oldValue !== newValue) {
            this.updateText();
            this.eventEmitter.emit('valuechange', newValue, oldValue, this.eventEmitter);
          }
        }
      }]);
      return Knob;
    }(ProgressBase(OverlapSizer));
    var INPUTMODE$1 = {
      pan: 0,
      drag: 0,
      click: 1,
      none: -1
    };
    Object.assign(Knob.prototype, TextObjectMethods);
  
    ObjectFactory.register('knob', function (config) {
      var gameObject = new Knob(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Knob', Knob);
  
    var ShapeClasses = {
      arc: Arc,
      circle: Circle,
      curve: Curve,
      ellipse: Ellipse,
      line: Line,
      lines: Lines,
      rectangle: Rectangle$2,
      roundRectangle: RoundRectangle,
      triangle: Triangle$1
    };
    var GetValue$27 = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;
    var ClearAll = function ClearAll() {
      var shapes = this.getShapes();
      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shapes[i].lineStyle().fillStyle();
      }
    };
    var ShapesUpdateMethods = {
      createShape: function createShape(shapeType, name) {
        var ShapeClass = ShapeClasses[shapeType];
        var shape = new ShapeClass();
        if (name) {
          shape.setName(name);
        }
        return shape;
      },
      buildShapes: function buildShapes(config) {
        var createCallback = GetValue$27(config, 'create', undefined);
        if (IsPlainObject$t(createCallback)) {
          var shapes = createCallback;
          for (var shapeType in shapes) {
            var name = shapes[shapeType];
            switch (_typeof(name)) {
              case 'number':
                for (var i = 0; i < name; i++) {
                  this.addShape(this.createShape(shapeType));
                }
                break;
              case 'string':
                this.addShape(this.createShape(shapeType, name));
                break;
              default:
                //Array
                var names = name;
                for (var i = 0, cnt = names.length; i < cnt; i++) {
                  this.addShape(this.createShape(shapeType, names[i]));
                }
                break;
            }
          }
        } else if (Array.isArray(createCallback)) {
          var shapes = createCallback;
          for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            var shape = shapes[i];
            this.addShape(this.createShape(shape.type, shape.name));
          }
        } else if (typeof createCallback === 'function') {
          createCallback.call(this);
        }
        this.setUpdateShapesCallback(GetValue$27(config, 'update'));
      },
      setUpdateShapesCallback: function setUpdateShapesCallback(callback) {
        if (callback === undefined) {
          callback = ClearAll;
        }
        this.dirty = this.dirty || this.updateCallback !== callback;
        this.updateCallback = callback;
        return this;
      },
      updateShapes: function updateShapes() {
        this.updateCallback.call(this);
      }
    };
  
    var TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
    var TransformXY = Phaser.Math.TransformXY;
    var WorldXYToGameObjectLocalXY = function WorldXYToGameObjectLocalXY(gameObject, worldX, worldY, camera, out) {
      if (camera === undefined) {
        camera = gameObject.scene.cameras.main;
      }
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        out = globOut;
      }
      var csx = camera.scrollX;
      var csy = camera.scrollY;
      var px = worldX + csx * gameObject.scrollFactorX - csx;
      var py = worldY + csy * gameObject.scrollFactorY - csy;
      if (gameObject.parentContainer) {
        if (tempMatrix$1 === undefined) {
          tempMatrix$1 = new TransformMatrix();
          parentMatrix = new TransformMatrix();
        }
        gameObject.getWorldTransformMatrix(tempMatrix$1, parentMatrix);
        tempMatrix$1.applyInverse(px, py, out);
      } else {
        TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, out);
      }
      out.x += gameObject.displayOriginX;
      out.y += gameObject.displayOriginY;
      return out;
    };
    var tempMatrix$1, parentMatrix;
    var globOut = {};
  
    var GetValue$26 = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;
    var CustomShapes = /*#__PURE__*/function (_BaseShapes) {
      _inherits(CustomShapes, _BaseShapes);
      function CustomShapes(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, CustomShapes);
        if (IsPlainObject$s(x)) {
          config = x;
          x = GetValue$26(config, 'x', 0);
          y = GetValue$26(config, 'y', 0);
          width = GetValue$26(config, 'width', 2);
          height = GetValue$26(config, 'height', 2);
        }
        _this = _callSuper(this, CustomShapes, [scene, x, y, width, height]);
        _this.type = GetValue$26(config, 'type', 'rexCustomShapes');
        _this.buildShapes(config);
        return _this;
      }
      _createClass(CustomShapes, [{
        key: "centerX",
        get: function get() {
          return this.width / 2;
        }
      }, {
        key: "centerY",
        get: function get() {
          return this.height / 2;
        }
      }, {
        key: "worldToLocalXY",
        value: function worldToLocalXY(worldX, worldY, camera, out) {
          if (typeof camera === 'boolean') {
            out = camera;
            camera = undefined;
          }
          return WorldXYToGameObjectLocalXY(this, worldX, worldY, camera, out);
        }
      }]);
      return CustomShapes;
    }(BaseShapes);
    Object.assign(CustomShapes.prototype, ShapesUpdateMethods);
  
    ObjectFactory.register('customShapes', function (x, y, width, height, config) {
      var gameObject = new CustomShapes(this.scene, x, y, width, height, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CustomShapes', CustomShapes);
  
    var GetValue$25 = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;
    var CustomProgress = /*#__PURE__*/function (_ProgressBase) {
      _inherits(CustomProgress, _ProgressBase);
      function CustomProgress(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, CustomProgress);
        if (IsPlainObject$r(x)) {
          config = x;
          x = GetValue$25(config, 'x', 0);
          y = GetValue$25(config, 'y', 0);
          width = GetValue$25(config, 'width', 2);
          height = GetValue$25(config, 'height', 2);
        }
        if (config === undefined) {
          config = {};
        }
        if (!config.type) {
          config.type = 'rexCustomProgress';
        }
        _this = _callSuper(this, CustomProgress, [scene, x, y, width, height, config]);
        _this.bootProgressBase(config);
        _this.setValue(GetValue$25(config, 'value', 0));
        return _this;
      }
      _createClass(CustomProgress, [{
        key: "centerX",
        get: function get() {
          return this.width / 2;
        }
      }, {
        key: "centerY",
        get: function get() {
          return this.height / 2;
        }
      }, {
        key: "radius",
        get: function get() {
          return Math.min(this.centerX, this.centerY);
        }
      }]);
      return CustomProgress;
    }(ProgressBase(CustomShapes));
  
    ObjectFactory.register('customProgress', function (x, y, width, height, config) {
      var gameObject = new CustomProgress(this.scene, x, y, width, height, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.CustomProgress', CustomProgress);
  
    var SetTransitionCallbackMethods = {
      setTransitionStartCallback: function setTransitionStartCallback(callback, scope) {
        this.onStartCallback = callback;
        this.onStartCallbackScope = scope;
        return this;
      },
      setTransitionProgressCallback: function setTransitionProgressCallback(callback, scope) {
        this.onProgressCallback = callback;
        this.onProgressCallbackScope = scope;
        return this;
      },
      setTransitionCompleteCallback: function setTransitionCompleteCallback(callback, scope) {
        this.onCompleteCallback = callback;
        this.onCompleteCallbackScope = scope;
        return this;
      }
    };
  
    var FitImages = function FitImages() {
      var scaleMode = this.scaleMode - 1; // 1->0(FIT), 2->1(ENVELOP)
      for (var i = 0, cnt = this.images.length; i < cnt; i++) {
        var image = this.images[i];
        var result = FitTo(image, this, scaleMode, true);
        var biasScale = result.width / image.width;
        this.setChildLocalScale(image, biasScale);
        image.biasScale = biasScale;
      }
    };
  
    var OnTextureChange = function OnTextureChange(newImage) {
      if (this.scaleMode === 0) {
        this.resize(newImage.width, newImage.height);
      } else {
        // Fit all images to parent's size
        FitImages.call(this);
      }
    };
  
    var IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$24 = Phaser.Utils.Objects.GetValue;
    var GetRandomItem = Phaser.Utils.Array.GetRandom;
    var DirMode = {
      out: 0,
      "in": 1
    };
    var GetValueFromConfigs = function GetValueFromConfigs(key, defaultValue) {
      for (var i = 0, cnt = arguments.length <= 2 ? 0 : arguments.length - 2; i < cnt; i++) {
        var config = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];
        if (config && config.hasOwnProperty(key)) {
          return config[key];
        }
      }
      return defaultValue;
    };
    var TransitionMethods = {
      setTransitionDirection: function setTransitionDirection(dir) {
        if (typeof dir === 'string') {
          dir = DirMode[dir];
        }
        this.dir = dir;
        return this;
      },
      setDuration: function setDuration(duration) {
        this.duration = duration;
        return this;
      },
      setEaseFunction: function setEaseFunction(ease) {
        this.easeFunction = ease;
        return this;
      },
      setNextTexture: function setNextTexture(texture, frame) {
        this.nextImage.setTexture(texture, frame);
        OnTextureChange.call(this, this.nextImage);
        return this;
      },
      transit: function transit(texture, frame, mode) {
        if (this.isRunning) {
          this.ignoreCompleteEvent = true;
          this.stop();
          this.ignoreCompleteEvent = false;
        }
        if (mode !== undefined) {
          texture = {
            key: texture,
            frame: frame,
            mode: mode
          };
        }
        this.currentTransitionMode = undefined;
        if (IsPlainObject$q(texture)) {
          var config = texture;
          texture = GetValue$24(config, 'key', undefined);
          frame = GetValue$24(config, 'frame', undefined);
          mode = GetValue$24(config, 'mode');
          if (Array.isArray(mode)) {
            mode = GetRandomItem(mode);
          }
          var modeConfig;
          if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
            modeConfig = this.transitionModes[mode];
            this.currentTransitionMode = mode;
          }
          this.setDuration(GetValueFromConfigs('duration', this.duration, config, modeConfig)).setEaseFunction(GetValueFromConfigs('ease', this.easeFunction, config, modeConfig)).setTransitionDirection(GetValueFromConfigs('dir', this.dir, config, modeConfig));
          var maskGameObject = GetValueFromConfigs('mask', undefined, config, modeConfig);
          if (maskGameObject) {
            this.setMaskGameObject(maskGameObject);
          }
          this.setMaskEnable(maskGameObject === true);
          var onStart = GetValueFromConfigs('onStart', undefined, config, modeConfig);
          var onProgress = GetValueFromConfigs('onProgress', undefined, config, modeConfig);
          var onComplete = GetValueFromConfigs('onComplete', undefined, config, modeConfig);
          if (onStart !== undefined || onProgress !== undefined || onComplete !== undefined) {
            this.setTransitionStartCallback(onStart, GetValueFromConfigs('onStartScope', undefined, config, modeConfig)).setTransitionProgressCallback(onProgress, GetValueFromConfigs('onProgressScope', undefined, config, modeConfig)).setTransitionCompleteCallback(onComplete, GetValueFromConfigs('onCompleteScope', undefined, config, modeConfig));
          }
        }
        this.setNextTexture(texture, frame);
        this.start();
        return this;
      },
      addTransitionMode: function addTransitionMode(name, config) {
        if (this.transitionModes === undefined) {
          this.transitionModes = {};
        }
        if (IsPlainObject$q(name)) {
          config = name;
          name = config.name;
          delete config.name;
        }
        this.transitionModes[name] = config;
        return this;
      },
      start: function start() {
        if (this.easeValueTask === undefined) {
          this.easeValueTask = new EaseValueTask(this, {
            eventEmitter: null
          });
        }
        this.easeValueTask.restart({
          key: 't',
          from: 0,
          to: 1,
          duration: this.duration,
          ease: this.easeFunction
        });
        return this;
      },
      pause: function pause() {
        if (this.easeValueTask) {
          this.easeValueTask.pause();
        }
        return this;
      },
      resume: function resume() {
        if (this.easeValueTask) {
          this.easeValueTask.resume();
        }
        return this;
      },
      stop: function stop() {
        if (this.easeValueTask) {
          this.easeValueTask.stop();
        }
        this.setT(1);
        return this;
      }
    };
  
    var DrawShape = function DrawShape(width, height, padding, originX, originY) {
      this.clear().fillStyle(0xffffff);
      switch (this.shapeType) {
        case 1:
          // circle
          // Assume that all padding are the same value in this circle shape
          padding = padding.left;
          var radius = Math.min(width, height) / 2;
          this.fillCircle(-width * (originX - 0.5),
          // centerX
          -height * (originY - 0.5),
          // centerY
          radius + padding // radius
          );
          break;
        default:
          // 0|'rectangle'
          this.fillRect(-(width * originX) - padding.left,
          // x
          -(height * originY) - padding.top,
          // y
          width + padding.left + padding.right,
          // width
          height + padding.top + padding.bottom // height
          );
          break;
      }
    };
  
    var Graphics = Phaser.GameObjects.Graphics;
    var DefaultMaskGraphics = /*#__PURE__*/function (_Graphics) {
      _inherits(DefaultMaskGraphics, _Graphics);
      function DefaultMaskGraphics(parent, shapeType, padding) {
        var _this;
        _classCallCheck(this, DefaultMaskGraphics);
        if (shapeType === undefined) {
          shapeType = 0;
        }
        if (typeof shapeType === 'string') {
          shapeType = SHAPEMODE[shapeType];
        }
        _this = _callSuper(this, DefaultMaskGraphics, [parent.scene]);
        _this.parent = parent;
        _this.shapeType = shapeType;
        _this.padding = GetBoundsConfig(padding);
        _this.setPosition().resize().setVisible(false);
        // Don't add it to display list
        return _this;
      }
      _createClass(DefaultMaskGraphics, [{
        key: "destroy",
        value: function destroy() {
          this.parent = undefined;
          _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "destroy", this).call(this);
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          var parent = this.parent;
          if (x === undefined) {
            x = parent.x;
          }
          if (y === undefined) {
            y = parent.y;
          }
          _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "setPosition", this).call(this, x, y);
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height, padding) {
          var parent = this.parent;
          if (width === undefined) {
            width = parent.width;
          }
          if (height === undefined) {
            height = parent.height;
          }
          if (padding === undefined) {
            padding = this.padding;
          } else if (typeof padding === 'number') {
            padding = GetBoundsConfig(padding);
          }
          var isSizeChanged = this.width !== width || this.height !== height;
          var isPaddingChanged = this.padding !== padding && !IsKeyValueEqual(this.padding, padding);
          if (!isSizeChanged && !isPaddingChanged) {
            return this;
          }
          this.width = width;
          this.height = height;
          if (isPaddingChanged) {
            Clone$2(padding, this.padding);
          }
  
          // Graphics does not have originX, originY properties
          this.originX = parent.originX;
          this.originY = parent.originY;
          DrawShape.call(this, width, height, padding, parent.originX, parent.originY);
          return this;
        }
      }, {
        key: "setOrigin",
        value: function setOrigin(originX, originY) {
          if (originY === undefined) {
            originY = originX;
          }
          var parent = this.parent;
          if (originX === undefined) {
            originX = parent.originX;
          }
          if (originY === undefined) {
            originY = parent.originY;
          }
          if (this.originX === originX && this.originY === originY) {
            return this;
          }
          this.originX = originX;
          this.originY = originY;
          DrawShape.call(this, this.width, this.height, this.padding, originX, originY);
          return this;
        }
      }]);
      return DefaultMaskGraphics;
    }(Graphics);
    var SHAPEMODE = {
      rectangle: 0,
      circle: 1
    };
  
    var MaskMethods = {
      setMaskGameObject: function setMaskGameObject(gameObject) {
        if (!gameObject) {
          this.removeMaskGameObject();
          return this;
        }
        if (this.maskGameObject) {
          if (gameObject === true && this.maskGameObject instanceof DefaultMaskGraphics) {
            return this;
          }
          if (this.maskGameObject === gameObject) {
            return this;
          }
  
          // Remove previous Mask Game Object
          this.removeMaskGameObject();
        }
  
        // Add new Mask Game Object
        if (gameObject === true) {
          gameObject = new DefaultMaskGraphics(this);
        }
        gameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(false);
        this.addLocal(gameObject);
        this.maskGameObject = gameObject;
        if (!gameObject._maskObject) {
          gameObject._maskObject = gameObject.createGeometryMask();
          gameObject.once('destroy', function () {
            gameObject._maskObject.destroy();
            gameObject._maskObject = undefined;
          });
        }
        this.childrenMask = gameObject._maskObject;
        return this;
      },
      removeMaskGameObject: function removeMaskGameObject(destroyMaskGameObject) {
        if (destroyMaskGameObject === undefined) {
          destroyMaskGameObject = true;
        }
        this.backImage.clearMask();
        this.frontImage.clearMask();
        this.childrenMask = undefined;
        this.remove(this.maskGameObject, destroyMaskGameObject);
        this.maskGameObject = undefined;
        return this;
      },
      setImageMaskEnable: function setImageMaskEnable(gameObject, enable, invertAlpha) {
        if (enable === undefined) {
          enable = true;
        }
        if (invertAlpha === undefined) {
          invertAlpha = false;
        }
        if (enable) {
          // Use DefaultMaskGraphics if not given    
          if (!this.childrenMask) {
            this.setMaskGameObject(true);
          }
          gameObject.setMask(this.childrenMask);
          this.childrenMask.setInvertAlpha(invertAlpha);
        } else {
          gameObject.clearMask();
        }
        return this;
      },
      setCurrentImageMaskEnable: function setCurrentImageMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
        return this;
      },
      setNextImageMaskEnable: function setNextImageMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
        return this;
      },
      setCellImagesMaskEnable: function setCellImagesMaskEnable(enable, invertAlpha) {
        var cellImages = this.getCellImages();
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
          this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
        }
        return this;
      },
      setMaskEnable: function setMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.backImage, enable, invertAlpha);
        this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
        this.setCellImagesMaskEnable(enable, invertAlpha);
        return this;
      }
    };
  
    var GetFrameNameCallback = function GetFrameNameCallback(baseFrameName, delimiter) {
      if (_typeof(baseFrameName) === 'object') {
        baseFrameName = baseFrameName.name;
      }
      if (delimiter === undefined) {
        delimiter = ',';
      }
      var callback;
      if (baseFrameName === '__BASE') {
        callback = function callback(colIndex, rowIndex) {
          return "".concat(colIndex).concat(delimiter).concat(rowIndex);
        };
      } else {
        callback = function callback(colIndex, rowIndex) {
          return "".concat(baseFrameName, "_").concat(colIndex).concat(delimiter).concat(rowIndex);
        };
      }
      return callback;
    };
  
    var GenerateFrames = function GenerateFrames(scene, key, frame, columns, rows, getFrameNameCallback) {
      if (frame == null) {
        frame = '__BASE';
      }
      if (!getFrameNameCallback) {
        getFrameNameCallback = GetFrameNameCallback(frame, getFrameNameCallback);
      }
      var texture = scene.sys.textures.get(key);
      var baseFrame = _typeof(frame) === 'object' ? frame : texture.get(frame);
      var baseWidth = baseFrame.width,
        baseHeight = baseFrame.height;
      var cellX, cellY, cellName;
      var cellWidth = baseWidth / columns,
        cellHeight = baseHeight / rows;
      var frameCutX = baseFrame.cutX,
        frameCutY = baseFrame.cutY;
      var offsetX = 0,
        offsetY = 0;
      for (var y = 0; y < rows; y++) {
        offsetX = 0;
        for (var x = 0; x < columns; x++) {
          cellName = getFrameNameCallback(x, y);
          cellX = offsetX + frameCutX;
          cellY = offsetY + frameCutY;
          texture.add(cellName, 0, cellX, cellY, cellWidth, cellHeight);
          offsetX += cellWidth;
        }
        offsetY += cellHeight;
      }
      return {
        getFrameNameCallback: getFrameNameCallback,
        cellWidth: cellWidth,
        cellHeight: cellHeight,
        columns: columns,
        rows: rows
      };
    };
  
    var GetValue$23 = Phaser.Utils.Objects.GetValue;
    var DefaultImageClass = Phaser.GameObjects.Image;
    var IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
    var RotateAround$2 = Phaser.Math.RotateAround;
    var GridCutImage = function GridCutImage(gameObject, columns, rows, config) {
      if (IsPlainObject$p(columns)) {
        config = columns;
        columns = GetValue$23(config, 'columns', 1);
        rows = GetValue$23(config, 'rows', 1);
      }
      var createImageCallback = GetValue$23(config, 'createImageCallback');
      if (!createImageCallback) {
        var ImageClass = GetValue$23(config, 'ImageClass', DefaultImageClass);
        createImageCallback = function createImageCallback(scene, key, frame) {
          return new ImageClass(scene, 0, 0, key, frame);
        };
      }
      var originX = GetValue$23(config, 'originX', 0.5);
      var originY = GetValue$23(config, 'originY', 0.5);
      var addToScene = GetValue$23(config, 'add', true);
      var align = GetValue$23(config, 'align', addToScene);
      var imageObjectPool = GetValue$23(config, 'objectPool', undefined);
      var scene = gameObject.scene;
      var texture = gameObject.texture;
      var frame = gameObject.frame;
      var result = GenerateFrames(scene, texture, frame, columns, rows);
      var getFrameNameCallback = result.getFrameNameCallback;
      var scaleX = gameObject.scaleX,
        scaleY = gameObject.scaleY;
      var rotation = gameObject.rotation;
      var topLeft = gameObject.getTopLeft(),
        startX = topLeft.x,
        startY = topLeft.y;
      var cellGameObjects = [];
      var scaleCellWidth = result.cellWidth * scaleX,
        scaleCellHeight = result.cellHeight * scaleY;
      for (var y = 0; y < rows; y++) {
        for (var x = 0; x < columns; x++) {
          var cellGameObject;
          var frameName = getFrameNameCallback(x, y);
          if (imageObjectPool && imageObjectPool.length > 0) {
            cellGameObject = imageObjectPool.pop().setTexture(texture, frameName);
          } else {
            cellGameObject = createImageCallback(scene, texture, frameName);
          }
          if (addToScene) {
            scene.add.existing(cellGameObject);
          }
          if (align) {
            var cellTLX = startX + scaleCellWidth * x;
            var cellTLY = startY + scaleCellHeight * y;
            var cellX = cellTLX + originX * scaleCellWidth;
            var cellY = cellTLY + originY * scaleCellHeight;
            cellGameObject.setOrigin(originX, originY).setPosition(cellX, cellY).setScale(scaleX, scaleY).setRotation(rotation);
            RotateAround$2(cellGameObject, startX, startY, rotation);
          }
          cellGameObjects.push(cellGameObject);
        }
      }
      return cellGameObjects;
    };
  
    var GridCutMethods = {
      gridCutImage: function gridCutImage(gameObject, columns, rows, config) {
        if (config === undefined) {
          config = {};
        }
        config.objectPool = this.imagesPool;
        var cellImages = GridCutImage(gameObject, columns, rows, config),
          cellImage;
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
          cellImage = cellImages[i];
          cellImage.setVisible(true);
          this.add(cellImage);
        }
        this.cellImages = cellImages;
        this.setChildLocalVisible(gameObject, false); // Set cut target to invisible
        return cellImages;
      },
      gridCutCurrentImage: function gridCutCurrentImage(columns, rows, config) {
        return this.gridCutImage(this.currentImage, columns, rows, config);
      },
      gridCutNextImage: function gridCutNextImage(columns, rows, config) {
        return this.gridCutImage(this.nextImage, columns, rows, config);
      },
      getCellImages: function getCellImages() {
        return this.cellImages;
      },
      freeCellImages: function freeCellImages() {
        var _this$imagesPool;
        if (this.cellImages.length === 0) {
          return this;
        }
        var texture = this.cellImages[0].texture;
        var cellImages = this.cellImages,
          cellImage,
          frameName;
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
          cellImage = cellImages[i];
  
          // Reset property of cell image
          this.setChildLocalAlpha(cellImage, 1).setChildLocalScale(cellImage, 1).setChildLocalVisible(cellImage, false);
          cellImage.clearMask();
  
          // Remove frame object
          frameName = cellImage.frame.name;
          cellImage.setTexture();
          texture.remove(frameName);
        }
        (_this$imagesPool = this.imagesPool).push.apply(_this$imagesPool, _toConsumableArray(cellImages));
        cellImages.length = 0;
        return this;
      }
    };
  
    var FlipMethods = {
      setFlipX: function setFlipX(value) {
        this.flipX = value;
        return this;
      },
      setFlipY: function setFlipY(value) {
        this.flipY = value;
        return this;
      },
      toggleFlipX: function toggleFlipX() {
        this.flipX = !this.flipX;
        return this;
      },
      toggleFlipY: function toggleFlipY() {
        this.flipY = !this.flipY;
        return this;
      },
      setFlip: function setFlip(x, y) {
        this.flipX = x;
        this.flipY = y;
        return this;
      },
      resetFlip: function resetFlip() {
        this.flipX = false;
        this.flipY = false;
        return this;
      }
    };
  
    var methods$r = {};
    Object.assign(methods$r, SetTransitionCallbackMethods, TransitionMethods, MaskMethods, GridCutMethods, FlipMethods);
  
    var OnStart = function OnStart(parent, currentImage, nextImage, t) {};
    var OnProgress = function OnProgress(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1 - t).setChildLocalAlpha(nextImage, t);
    };
    var OnComplete = function OnComplete(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1);
    };
  
    var IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$22 = Phaser.Utils.Objects.GetValue;
    var Clamp$a = Phaser.Math.Clamp;
    var TransitionImage = /*#__PURE__*/function (_Container) {
      _inherits(TransitionImage, _Container);
      function TransitionImage(scene, x, y, texture, frame, config) {
        var _this;
        _classCallCheck(this, TransitionImage);
        if (IsPlainObject$o(x)) {
          config = x;
          x = GetValue$22(config, 'x', 0);
          y = GetValue$22(config, 'y', 0);
          texture = GetValue$22(config, 'key', undefined);
          frame = GetValue$22(config, 'frame', undefined);
        } else if (IsPlainObject$o(frame)) {
          config = frame;
          frame = undefined;
        }
        var backImage = GetValue$22(config, 'back', undefined);
        var frontImage = GetValue$22(config, 'front', undefined);
        if (!backImage) {
          backImage = scene.add.image(x, y, texture, frame);
        }
        if (!frontImage) {
          frontImage = scene.add.image(x, y, texture, frame);
        }
        var width = GetValue$22(config, 'width', undefined);
        var height = GetValue$22(config, 'height', undefined);
        var scaleMode = width !== undefined && height !== undefined ? 1 : 0;
        if (width === undefined) {
          width = frontImage.width;
        }
        if (height === undefined) {
          height = frontImage.height;
        }
        _this = _callSuper(this, TransitionImage, [scene, x, y, width, height]);
        _this.type = 'rexTransitionImage';
        _this._flipX = false;
        _this._flipY = false;
        scaleMode = GetValue$22(config, 'scaleMode', scaleMode);
        if (typeof scaleMode === 'string') {
          scaleMode = ScaleModeMap[scaleMode];
        }
        _this.scaleMode = scaleMode;
        backImage.setVisible(false);
        _this.addMultiple([backImage, frontImage]);
        _this.backImage = backImage;
        _this.frontImage = frontImage;
        _this.images = [_this.backImage, _this.frontImage];
        _this.maskGameObject = undefined;
        _this.cellImages = [];
        _this.imagesPool = [];
        _this.transitionModes = undefined;
        _this.currentTransitionMode = undefined;
  
        // Transition parameters
        var onStart = GetValue$22(config, 'onStart', undefined);
        var onProgress = GetValue$22(config, 'onProgress', undefined);
        var onComplete = GetValue$22(config, 'onComplete', undefined);
        var dir = GetValue$22(config, 'dir', 0);
        if (onStart === undefined && onProgress === undefined && onComplete === undefined) {
          onStart = OnStart;
          onProgress = OnProgress;
          onComplete = OnComplete;
          dir = 0;
        }
        _this.setTransitionStartCallback(onStart, GetValue$22(config, 'onStartScope', undefined)).setTransitionProgressCallback(onProgress, GetValue$22(config, 'onProgressScope', undefined)).setTransitionCompleteCallback(onComplete, GetValue$22(config, 'onCompleteScope', undefined)).setTransitionDirection(dir).setDuration(GetValue$22(config, 'duration', 1000)).setEaseFunction(GetValue$22(config, 'ease', 'Linear'));
        var maskGameObject = GetValue$22(config, 'mask', undefined);
        if (maskGameObject) {
          _this.setMaskGameObject(maskGameObject);
        }
        _this.setMaskEnable(false);
        _this.ignoreCompleteEvent = false;
        OnTextureChange.call(_assertThisInitialized(_this), _this.frontImage);
        return _this;
      }
      _createClass(TransitionImage, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (this.childrenMask) {
            this.childrenMask.destroy();
            this.childrenMask = undefined;
          }
          this.backImage = undefined;
          this.frontImage = undefined;
          this.images.length = 0;
          this.maskGameObject = undefined;
          this.cellImages.length = 0;
          this.imagesPool.length = 0;
          this.transitionModes = undefined;
          _get(_getPrototypeOf(TransitionImage.prototype), "destroy", this).call(this, fromScene);
          this.onStartCallback = undefined;
          this.onStartCallbackScope = undefined;
          this.onProgressCallback = undefined;
          this.onProgressCallbackScope = undefined;
          this.onCompleteCallback = undefined;
          this.onCompleteCallbackScope = undefined;
          this.easeValueTask = undefined;
        }
      }, {
        key: "currentImage",
        get: function get() {
          return this.dir === 0 ? this.frontImage : this.backImage;
        }
      }, {
        key: "nextImage",
        get: function get() {
          return this.dir === 0 ? this.backImage : this.frontImage;
        }
      }, {
        key: "texture",
        get: function get() {
          return this.nextImage.texture;
        }
      }, {
        key: "frame",
        get: function get() {
          return this.nextImage.frame;
        }
      }, {
        key: "tint",
        get: function get() {
          return this._tint;
        },
        set: function set(value) {
          if (this._tint === value) {
            return;
          }
          this._tint = value;
          this.backImage.setTint(value);
          this.frontImage.setTint(value);
        }
      }, {
        key: "setTint",
        value: function setTint(value) {
          this.tint = value;
          return this;
        }
      }, {
        key: "flipX",
        get: function get() {
          return this._flipX;
        },
        set: function set(value) {
          if (this._flipX === value) {
            return;
          }
          this._flipX = value;
          this.backImage.setFlipX(value);
          this.frontImage.setFlipX(value);
        }
      }, {
        key: "setFlipX",
        value: function setFlipX(value) {
          this.flipX = value;
          return this;
        }
      }, {
        key: "toggleFlipX",
        value: function toggleFlipX() {
          this.flipX = !this.flipX;
          return this;
        }
      }, {
        key: "flipY",
        get: function get() {
          return this._flipY;
        },
        set: function set(value) {
          if (this._flipY === value) {
            return;
          }
          this._flipY = value;
          this.backImage.setFlipY(value);
          this.frontImage.setFlipY(value);
        }
      }, {
        key: "setFlipY",
        value: function setFlipY(value) {
          this.flipY = value;
          return this;
        }
      }, {
        key: "toggleFlipY",
        value: function toggleFlipY() {
          this.flipY = !this.flipY;
          return this;
        }
      }, {
        key: "setFlip",
        value: function setFlip(flipX, flipY) {
          this.flipX = flipX;
          this.flipY = flipY;
          return this;
        }
      }, {
        key: "t",
        get: function get() {
          return this._t;
        },
        set: function set(value) {
          value = Clamp$a(value, 0, 1);
          if (this._t === value) {
            return;
          }
          this._t = value;
          var currentImage = this.currentImage;
          var nextImage = this.nextImage;
  
          // Start
          if (value === 0) {
            this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, true);
            RunCallback.call(this, this.onStartCallback, this.onStartCallbackScope, this, currentImage, nextImage, value);
          }
  
          // Progress
          RunCallback.call(this, this.onProgressCallback, this.onProgressCallbackScope, this, currentImage, nextImage, value);
  
          // Complete
          if (value === 1) {
            RunCallback.call(this, this.onCompleteCallback, this.onCompleteCallbackScope, this, currentImage, nextImage, value);
            var key = nextImage.texture.key,
              frame = nextImage.frame.name;
            this.frontImage.setTexture(key, frame);
            this.backImage.setTexture(key, frame);
            OnTextureChange.call(this, nextImage);
            this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, false).setMaskEnable(false).freeCellImages();
          }
          if (value === 1 && !this.ignoreCompleteEvent) {
            this.emit('complete');
          }
        }
      }, {
        key: "setT",
        value: function setT(value) {
          this.t = value;
          return this;
        }
      }, {
        key: "isRunning",
        get: function get() {
          return this.easeValueTask ? this.easeValueTask.isRunning : false;
        }
      }, {
        key: "setOrigin",
        value: function setOrigin(originX, originY) {
          _get(_getPrototypeOf(TransitionImage.prototype), "setOrigin", this).call(this, originX, originY);
          this.backImage.setOrigin(originX, originY);
          this.frontImage.setOrigin(originX, originY);
          if (this.maskGameObject) {
            this.maskGameObject.setOrigin(originX, originY);
          }
          return this;
        }
      }, {
        key: "setTexture",
        value: function setTexture(texture, frame) {
          // Without transition
          this.frontImage.setTexture(texture, frame);
          this.backImage.setTexture(texture, frame).setVisible(false);
          OnTextureChange.call(this, this.frontImage);
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(width, height) {
          _get(_getPrototypeOf(TransitionImage.prototype), "setSize", this).call(this, width, height);
          if (this.scaleMode) {
            FitImages.call(this);
          }
          return this;
        }
      }]);
      return TransitionImage;
    }(ContainerLite);
    var RunCallback = function RunCallback(callback, scope, parent, currentImage, nextImage, t) {
      if (!callback) {
        return;
      }
      if (this.scaleMode) {
        var localScale;
        if (currentImage.biasScale > 0) {
          localScale = this.getChildLocalScaleX(currentImage);
          localScale = localScale / currentImage.biasScale;
          this.setChildLocalScale(currentImage, localScale);
        }
        if (nextImage.biasScale) {
          localScale = this.getChildLocalScaleX(nextImage);
          localScale = localScale / nextImage.biasScale;
          this.setChildLocalScale(nextImage, localScale);
        }
      }
      if (scope) {
        callback.call(scope, parent, currentImage, nextImage, t);
      } else {
        callback(parent, currentImage, nextImage, t);
      }
      if (this.scaleMode) {
        var localScale;
        if (currentImage.biasScale > 0) {
          localScale = this.getChildLocalScaleX(currentImage);
          localScale = localScale * currentImage.biasScale;
          this.setChildLocalScale(currentImage, localScale);
        }
        if (nextImage.biasScale) {
          localScale = this.getChildLocalScaleX(nextImage);
          localScale = localScale * nextImage.biasScale;
          this.setChildLocalScale(nextImage, localScale);
        }
      }
    };
  
    // mixin
    Object.assign(TransitionImage.prototype, methods$r);
    var ScaleModeMap = {
      fit: 1,
      FIT: 1,
      envelop: 2,
      ENVELOP: 2
    };
  
    ObjectFactory.register('transitionImage', function (x, y, texture, frame, config) {
      var gameObject = new TransitionImage(this.scene, x, y, texture, frame, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TransitionImage', TransitionImage);
  
    // Slide modes
    var SlideLeft = 'slideLeft';
    var SlideRight = 'slideRight';
    var SlideUp = 'slideUp';
    var SlideDown = 'slideDown';
    var SlideAwayLeft = 'slideAwayLeft';
    var SlideAwayRight = 'slideAwayRight';
    var SlideAwayUp = 'slideAwayUp';
    var SlideAwayDown = 'slideAwayDown';
    var PushLeft = 'pushLeft';
    var PushRight = 'pushRight';
    var PushUp = 'pushUp';
    var PushDown = 'pushDown';
  
    // Zoom modes
    var ZoomOut = 'zoomOut';
    var ZoomIn = 'zoomIn';
    var ZoomInOut = 'zoomInOut';
  
    // Fade effect mode
    var Fade$1 = 'fade';
    var CrossFade = 'crossFade';
  
    // Wipe modes
    var WipeLeft = 'wipeLeft';
    var WipeRight = 'wipeRight';
    var WipeUp = 'wipeUp';
    var WipeDown = 'wipeDown';
  
    // Iris modes
    var IrisOut = 'irisOut';
    var IrisIn = 'irisIn';
    var IrisInOut = 'irisInOut';
  
    // Pie modes
    var PieOut = 'pieOut';
    var PieIn = 'pieIn';
    var PieInOut = 'pieInOut';
  
    // blinds, squares, diamonds, circles, curtain
    var Blinds = 'blinds';
    var Squares = 'squares';
    var Diamonds = 'diamonds';
    var Circles = 'circles';
    var Curtain = 'curtain';
  
    // Shader effect modes
    var Pixellate = 'pixellate';
    var Dissolve = 'dissolve';
    var RevealLeft = 'revealLeft';
    var RevealRight = 'revealRight';
    var RevealUp = 'revealUp';
    var RevealDown = 'revealDown';
  
    var AddSlideAwayModes = function AddSlideAwayModes(image) {
      image.addTransitionMode(SlideAwayRight, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var x = currentImage.width * t;
          parent.setChildLocalPosition(currentImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
        }
      }).addTransitionMode(SlideAwayLeft, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var x = currentImage.width * -t;
          parent.setChildLocalPosition(currentImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
        }
      }).addTransitionMode(SlideAwayDown, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var y = currentImage.height * t;
          parent.setChildLocalPosition(currentImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
        }
      }).addTransitionMode(SlideAwayUp, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var y = currentImage.height * -t;
          parent.setChildLocalPosition(currentImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
        }
      });
    };
  
    var AddSlideModes = function AddSlideModes(image) {
      image.addTransitionMode(SlideRight, {
        ease: 'Linear',
        dir: 'in',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var x = nextImage.width * (t - 1);
          parent.setChildLocalPosition(nextImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(SlideLeft, {
        ease: 'Linear',
        dir: 'in',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var x = nextImage.width * (1 - t);
          parent.setChildLocalPosition(nextImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(SlideDown, {
        ease: 'Linear',
        dir: 'in',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var y = nextImage.height * (t - 1);
          parent.setChildLocalPosition(nextImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(SlideUp, {
        ease: 'Linear',
        dir: 'in',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var y = nextImage.height * (1 - t);
          parent.setChildLocalPosition(nextImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      });
    };
  
    var AddSliderModes = function AddSliderModes(image) {
      image.addTransitionMode(PushRight, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          // SlideAwayRight
          var x = currentImage.width * t;
          parent.setChildLocalPosition(currentImage, x, 0);
  
          // SlideLeft
          var x = nextImage.width * (t - 1);
          parent.setChildLocalPosition(nextImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(PushLeft, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          // SlideAwayLeft
          var x = currentImage.width * -t;
          parent.setChildLocalPosition(currentImage, x, 0);
  
          // SlideRight
          var x = nextImage.width * (1 - t);
          parent.setChildLocalPosition(nextImage, x, 0);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(PushDown, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          // SlideAwayDown
          var y = currentImage.height * t;
          parent.setChildLocalPosition(currentImage, 0, y);
  
          // SlideUp
          var y = nextImage.height * (t - 1);
          parent.setChildLocalPosition(nextImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      }).addTransitionMode(PushUp, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          // SlideAwayUp
          var y = currentImage.height * -t;
          parent.setChildLocalPosition(currentImage, 0, y);
  
          // SlideDown
          var y = nextImage.height * (1 - t);
          parent.setChildLocalPosition(nextImage, 0, y);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalPosition(currentImage, 0, 0);
          parent.setChildLocalPosition(nextImage, 0, 0);
        }
      });
    };
  
    var AddZoomModes = function AddZoomModes(image) {
      image.addTransitionMode(ZoomOut, {
        ease: 'Linear',
        dir: 'out',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var scale = 1 - t;
          parent.setChildLocalScale(currentImage, scale, scale);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalScale(currentImage, 1, 1);
        }
      }).addTransitionMode(ZoomIn, {
        ease: 'Linear',
        dir: 'in',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var scale = t;
          parent.setChildLocalScale(nextImage, scale, scale);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalScale(nextImage, 1, 1);
        }
      }).addTransitionMode(ZoomInOut, {
        ease: 'Linear',
        dir: 'out',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.tint = 0; // Turn nextImage to black
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var scale;
          if (t < 0.5) {
            scale = 1 - Yoyo$1(t);
            parent.setChildLocalScale(currentImage, scale, scale);
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            scale = 1 - Yoyo$1(t);
            parent.setChildLocalScale(nextImage, scale, scale);
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalScale(currentImage, 1, 1);
          parent.setChildVisible(currentImage, true);
          currentImage.tint = 0xffffff;
          parent.setChildLocalScale(nextImage, 1, 1);
          parent.setChildVisible(nextImage, true);
          nextImage.tint = 0xffffff;
        }
      });
    };
  
    var AddFadeModes = function AddFadeModes(image) {
      image.addTransitionMode(Fade$1, {
        ease: 'Linear',
        dir: 'out',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.tint = 0; // Turn nextImage to black
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var tintGray;
          if (t < 0.5) {
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildVisible(currentImage, true);
          currentImage.tint = 0xffffff;
          parent.setChildVisible(nextImage, true);
          nextImage.tint = 0xffffff;
        }
      }).addTransitionMode(CrossFade, {
        ease: 'Linear',
        dir: 'out',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {},
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.setChildLocalAlpha(currentImage, 1 - t);
          parent.setChildLocalAlpha(nextImage, t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.setChildLocalAlpha(currentImage, 1);
        }
      });
    };
  
    var CreateMask$7 = function CreateMask(scene) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: [{
          name: 'rect',
          type: 'rectangle'
        }],
        update: function update() {
          var rect = this.getShape('rect').fillStyle(0xffffff);
          var t = 1 - this.value;
          switch (this.wipeMode) {
            case 'right':
              rect.setSize(this.width * t, this.height).setTopLeftPosition(this.width - rect.width, 0);
              break;
            case 'left':
              rect.setSize(this.width * t, this.height).setTopLeftPosition(0, 0);
              break;
            case 'down':
              rect.setSize(this.width, this.height * t).setTopLeftPosition(0, this.height - rect.height);
              break;
            case 'up':
              rect.setSize(this.width, this.height * t).setTopLeftPosition(0, 0);
              break;
          }
        }
      });
      return maskGameObject;
    };
    var AddWipeModes = function AddWipeModes(image) {
      var maskGameObject = CreateMask$7(image.scene);
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(WipeRight, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true);
          parent.maskGameObject.wipeMode = 'right';
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(WipeLeft, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true);
          parent.maskGameObject.wipeMode = 'left';
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(WipeDown, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true);
          parent.maskGameObject.wipeMode = 'down';
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(WipeUp, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true);
          parent.maskGameObject.wipeMode = 'up';
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      });
    };
  
    var CreateMask$6 = function CreateMask(scene) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: [{
          name: 'rect',
          type: 'rectangle'
        }],
        update: function update() {
          this.getShape('rect').fillStyle(0xffffff).setSize(this.width * this.value, this.height * this.value).setCenterPosition(this.centerX, this.centerY);
        }
      });
      return maskGameObject;
    };
    var AddIrisModes = function AddIrisModes(image) {
      var maskGameObject = CreateMask$6(image.scene);
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(IrisOut, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(IrisIn, {
        ease: 'Linear',
        dir: 'in',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setNextImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(1 - t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(IrisInOut, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.tint = 0; // Turn nextImage to black
          parent.setCurrentImageMaskEnable(true);
          parent.setNextImageMaskEnable(true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var tintGray;
          if (t < 0.5) {
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(1 - t);
            currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(1 - t);
            nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
          parent.setChildVisible(currentImage, true);
          currentImage.tint = 0xffffff;
          parent.setChildVisible(nextImage, true);
          nextImage.tint = 0xffffff;
        }
      });
    };
  
    var CreateMask$5 = function CreateMask(scene) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: [{
          name: 'pie',
          type: 'arc'
        }],
        update: function update() {
          var radius = Math.max(this.width, this.height) * 2;
          var deltaAngle = 90 * this.value;
          this.getShape('pie').fillStyle(0xffffff).setCenterPosition(this.centerX, 0).setRadius(radius).setAngle(90 - deltaAngle, 90 + deltaAngle).setPie();
        }
      });
      return maskGameObject;
    };
    var AddPieModes = function AddPieModes(image) {
      var maskGameObject = CreateMask$5(image.scene);
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(PieOut, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(PieIn, {
        ease: 'Linear',
        dir: 'in',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setNextImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(1 - t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      }).addTransitionMode(PieInOut, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.tint = 0; // Turn nextImage to black
          parent.setCurrentImageMaskEnable(true);
          parent.setNextImageMaskEnable(true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var tintGray;
          if (t < 0.5) {
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(1 - t);
            currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(1 - t);
            nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
          parent.setChildVisible(currentImage, true);
          currentImage.tint = 0xffffff;
          parent.setChildVisible(nextImage, true);
          nextImage.tint = 0xffffff;
        }
      });
    };
  
    var CreateMask$4 = function CreateMask(scene, columns) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: {
          rectangle: columns
        },
        update: function update() {
          var shapes = this.getShapes();
          var shapeWidth = this.width / columns;
          for (var i = 0; i < columns; i++) {
            shapes[i].fillStyle(0xffffff).setSize(shapeWidth * this.value, this.height).setTopLeftPosition(shapeWidth * i, 0);
          }
        }
      });
      return maskGameObject;
    };
    var AddBlindsModes = function AddBlindsModes(image) {
      var maskGameObject = CreateMask$4(image.scene, 10);
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(Blinds, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      });
    };
  
    var CreateMask$3 = function CreateMask(scene, columns, rows) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: {
          rectangle: columns * rows
        },
        update: function update() {
          var shapes = this.getShapes();
          var shapeWidth = this.width / columns,
            shapeHeight = this.height / rows;
          for (var r = 0; r < rows; r++) {
            for (var c = 0; c < columns; c++) {
              shapes[c * rows + r].fillStyle(0xffffff).setSize(shapeWidth * this.value, shapeHeight * this.value).setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
            }
          }
        }
      });
      return maskGameObject;
    };
    var AddSquaresModes = function AddSquaresModes(image) {
      var maskGameObject = CreateMask$3(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(Squares, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      });
    };
  
    var CreateMask$2 = function CreateMask(scene, columns, rows) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: {
          lines: columns * rows
        },
        update: function update() {
          var shapes = this.getShapes();
          var shapeHalfWidth = this.width / (columns - 1),
            shapeHelfHeight = this.height / rows;
          var shapeHeight = shapeHelfHeight * 2;
          var halfWidth = shapeHalfWidth * this.value,
            halfHeight = shapeHelfHeight * this.value;
          for (var r = 0; r < rows; r++) {
            for (var c = 0; c < columns; c++) {
              var centerX = c * shapeHalfWidth;
              var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
              shapes[c * rows + r].fillStyle(0xffffff).start(centerX + halfWidth, centerY).lineTo(centerX, centerY + halfHeight).lineTo(centerX - halfWidth, centerY).lineTo(centerX, centerY - halfHeight).lineTo(centerX + halfWidth, centerY).close();
            }
          }
        }
      });
      return maskGameObject;
    };
    var AddDiamondsMode = function AddDiamondsMode(image) {
      var maskGameObject = CreateMask$2(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(Diamonds, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      });
    };
  
    var CreateMask$1 = function CreateMask(scene, columns, rows) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: {
          circle: columns * rows
        },
        update: function update() {
          var shapes = this.getShapes();
          var shapeHalfWidth = this.width / (columns - 1),
            shapeHelfHeight = this.height / rows;
          var shapeHeight = shapeHelfHeight * 2;
          var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
          for (var r = 0; r < rows; r++) {
            for (var c = 0; c < columns; c++) {
              var centerX = c * shapeHalfWidth;
              var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
              shapes[c * rows + r].fillStyle(0xffffff).setCenterPosition(centerX, centerY).setRadius(radius);
            }
          }
        }
      });
      return maskGameObject;
    };
    var AddCirclesMode = function AddCirclesMode(image) {
      var maskGameObject = CreateMask$1(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(Circles, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setCurrentImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          parent.maskGameObject.setValue(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
        }
      });
    };
  
    var CreateMask = function CreateMask(scene, columns) {
      var maskGameObject = new CustomProgress(scene, {
        type: 'Graphics',
        create: {
          lines: columns
        },
        update: function update() {
          var shapes = this.getShapes();
          var shapeWidth = this.width / columns;
          var radius = shapeWidth / 2;
          for (var i = 0; i < columns; i++) {
            var leftX = shapeWidth * i;
            var bottomY = this.height * this.value;
            var centerX = leftX + radius;
            shapes[i].fillStyle(0xffffff).start(leftX, 0).horizontalLineTo(bottomY).arc(centerX, bottomY, radius, 180, 0, true).horizontalLineTo(-bottomY).lineTo(leftX, 0).close();
          }
        }
      });
      return maskGameObject;
    };
    var AddCurtainMode = function AddCurtainMode(image) {
      var maskGameObject = CreateMask(image.scene, 10);
      image.once('destroy', function () {
        maskGameObject.destroy();
      }).addTransitionMode(Curtain, {
        ease: 'Linear',
        dir: 'out',
        mask: maskGameObject,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.tint = 0; // Turn nextImage to black
          parent.setCurrentImageMaskEnable(true, true);
          parent.setNextImageMaskEnable(true, true);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          var tintGray;
          if (t < 0.5) {
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(t);
            currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            t = Yoyo$1(t);
            tintGray = Math.floor(255 * (1 - t));
            parent.maskGameObject.setValue(t);
            nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          parent.removeMaskGameObject(false);
          parent.setChildVisible(currentImage, true);
          currentImage.tint = 0xffffff;
          parent.setChildVisible(nextImage, true);
          nextImage.tint = 0xffffff;
        }
      });
    };
  
    var AddPixellateMode = function AddPixellateMode(image) {
      image.addTransitionMode(Pixellate, {
        ease: 'Linear',
        dir: 'out',
        mask: true,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          parent.setChildVisible(nextImage, false);
          currentImage.effect = currentImage.preFX.addPixelate(0);
          nextImage.effect = nextImage.preFX.addPixelate(0);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          if (t < 0.5) {
            t = Yoyo$1(t);
            var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
            currentImage.effect.amount = Math.ceil(maxAmount * t);
          } else {
            if (currentImage.visible) {
              parent.setChildVisible(currentImage, false);
            }
            if (!nextImage.visible) {
              parent.setChildVisible(nextImage, true);
            }
            t = Yoyo$1(t);
            var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
            nextImage.effect.amount = Math.ceil(maxAmount * t);
          }
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          currentImage.preFX.remove(currentImage.effect);
          delete currentImage.effect;
          parent.setChildVisible(currentImage, true);
          nextImage.preFX.remove(nextImage.effect);
          delete nextImage.effect;
        }
      });
    };
  
    // Reference: https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb
    var frag$1 = "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nfloat Perlin(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\n    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\n    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0); gx1 = fract(gx1);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n}\nfloat Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }\n";
  
    // https://github.com/ykob/glsl-dissolve/blob/master/src/glsl/dissolve.fs
  
    var frag = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision highmedp float;\n// Scene buffer\nuniform sampler2D uMainSampler;\nuniform sampler2D uMainSampler2;\n\nuniform int resizeMode;\nuniform float progress;\nuniform float fromRatio;\nuniform float toRatio;\nvarying vec2 outFragCoord;\n// Effect parameters\nuniform float noiseX;\nuniform float noiseY;\nuniform float noiseZ;\nuniform float fromEdgeStart;\nuniform float fromEdgeWidth;\nuniform float toEdgeStart;\nuniform float toEdgeWidth;\n\n".concat(frag$1, "\n\nvec4 getFromColor (vec2 uv) {\n  return texture2D(uMainSampler, uv);\n}\n\nvec4 getToColor (vec2 uv) {\n  if (resizeMode == 2) {\n    //  cover\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));\n  } else if (resizeMode == 1) {\n    //  contain\n    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));\n  } else {\n    //  stretch\n    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));\n  }\n}\n\nvec4 transition (vec2 uv) {    \n  vec4 colorFront = getFromColor(uv);\n  vec4 colorTo = getToColor(uv);\n\n  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0\n    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))\n    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;\n  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)\n    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));\n  return colorResult;\n}\n\nvoid main () {\n  vec2 uv = outFragCoord;\n  gl_FragColor = transition(uv);\n}\n");
  
    var PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
    var GetValue$21 = Phaser.Utils.Objects.GetValue;
    var Clamp$9 = Phaser.Math.Clamp;
    var DissolvePostFxPipeline = /*#__PURE__*/function (_PostFXPipeline) {
      _inherits(DissolvePostFxPipeline, _PostFXPipeline);
      function DissolvePostFxPipeline(game) {
        var _this;
        _classCallCheck(this, DissolvePostFxPipeline);
        _this = _callSuper(this, DissolvePostFxPipeline, [{
          name: 'rexDissolvePostFx',
          game: game,
          renderTarget: true,
          fragShader: frag
        }]);
        _this._progress = 0;
        _this.toFrame = null;
        _this.targetTexture = null;
        _this.resizeMode = 1;
        _this.toRatio = 1;
        _this.noiseX = 0;
        _this.noiseY = 0;
        _this.noiseZ = 0;
        _this.fromEdgeStart = 0.01;
        _this.fromEdgeWidth = 0.05;
        _this.toEdgeStart = 0.01;
        _this.toEdgeWidth = 0.05;
        return _this;
      }
      _createClass(DissolvePostFxPipeline, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setProgress(GetValue$21(o, 'progress', 0));
          this.setTransitionTargetTexture(GetValue$21(o, 'toTexture', '__DEFAULT'), GetValue$21(o, 'toFrame', undefined), GetValue$21(o, 'resizeMode', 1));
          this.setNoise(GetValue$21(o, 'noiseX', undefined), GetValue$21(o, 'noiseY', undefined), GetValue$21(o, 'noiseZ', undefined));
          this.setFromEdge(GetValue$21(o, 'fromEdgeStart', 0.01), GetValue$21(o, 'fromEdgeWidth', 0.05));
          this.setToEdge(GetValue$21(o, 'toEdgeStart', 0.01), GetValue$21(o, 'toEdgeWidth', 0.05));
          return this;
        }
      }, {
        key: "onBoot",
        value: function onBoot() {}
      }, {
        key: "onPreRender",
        value: function onPreRender() {
          this.set1f('progress', this.progress);
          this.set1i('resizeMode', this.resizeMode);
          this.set1f('noiseX', this.noiseX);
          this.set1f('noiseY', this.noiseY);
          this.set1f('noiseZ', this.noiseZ);
          this.set1f('fromEdgeStart', this.fromEdgeStart);
          this.set1f('fromEdgeWidth', this.fromEdgeWidth);
          this.set1f('toEdgeStart', this.toEdgeStart);
          this.set1f('toEdgeWidth', this.toEdgeWidth);
        }
      }, {
        key: "onDraw",
        value: function onDraw(renderTarget) {
          this.set1f('fromRatio', renderTarget.width / renderTarget.height);
          this.set1f('toRatio', this.toRatio);
          this.set1i('uMainSampler2', 1);
          this.bindTexture(this.targetTexture, 1);
          this.bindAndDraw(renderTarget);
        }
      }, {
        key: "progress",
        get: function get() {
          return this._progress;
        },
        set: function set(value) {
          this._progress = Clamp$9(value, 0, 1);
        }
      }, {
        key: "setProgress",
        value: function setProgress(value) {
          this.progress = value;
          return this;
        }
      }, {
        key: "setTransitionTargetTexture",
        value: function setTransitionTargetTexture(key, frame, resizeMode) {
          if (key === undefined) {
            key = '__DEFAULT';
          }
          var phaserTexture = this.game.textures.getFrame(key, frame);
          if (!phaserTexture) {
            phaserTexture = this.game.textures.getFrame('__DEFAULT');
          }
          this.toRatio = phaserTexture.width / phaserTexture.height;
          this.toFrame = phaserTexture;
          this.targetTexture = phaserTexture.glTexture;
          if (resizeMode !== undefined) {
            this.resizeMode = resizeMode;
          }
          return this;
        }
      }, {
        key: "setResizeMode",
        value: function setResizeMode(mode) {
          if (typeof mode === 'string') {
            mode = ResizeMode[mode];
          }
          this.resizeMode = mode;
          return this;
        }
      }, {
        key: "setNoise",
        value: function setNoise(x, y, z) {
          if (x === undefined) {
            x = 4 + Math.random() * 6;
          }
          if (y === undefined) {
            y = 4 + Math.random() * 6;
          }
          if (z === undefined) {
            z = Math.random() * 10;
          }
          this.noiseX = x;
          this.noiseY = y;
          this.noiseZ = z;
          return this;
        }
      }, {
        key: "setFromEdge",
        value: function setFromEdge(edgeStart, edgeWidth) {
          this.fromEdgeStart = edgeStart;
          this.fromEdgeWidth = edgeWidth;
          return this;
        }
      }, {
        key: "setToEdge",
        value: function setToEdge(edgeStart, edgeWidth) {
          this.toEdgeStart = edgeStart;
          this.toEdgeWidth = edgeWidth;
          return this;
        }
      }]);
      return DissolvePostFxPipeline;
    }(PostFXPipeline);
    /**
     * Set the resize mode of the target texture.
     * 
     * Can be either:
     * 
     * 0 - Stretch. The target texture is stretched to the size of the source texture.
     * 1 - Contain. The target texture is resized to fit the source texture. This is the default.
     * 2 - Cover. The target texture is resized to cover the source texture.
     * 
     * If the source and target textures are the same size, then use a resize mode of zero
     * for speed.
     *
     */
    var ResizeMode = {
      stretch: 0,
      contain: 1,
      cover: 2
    };
  
    var RegisterPostPipeline = function RegisterPostPipeline(game, postFxPipelineName, PostFxPipelineClass) {
      GetGame(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
    };
  
    var AddPostFxPipelineInstance = function AddPostFxPipelineInstance(gameObject, PostFxPipelineClass, config) {
      if (config === undefined) {
        config = {};
      }
      gameObject.setPostPipeline(PostFxPipelineClass);
      var pipeline = gameObject.postPipelines[gameObject.postPipelines.length - 1];
      pipeline.resetFromJSON(config);
      if (config.name) {
        pipeline.name = config.name;
      }
      return pipeline;
    };
  
    var SpliceOne$1 = Phaser.Utils.Array.SpliceOne;
    var RemovePostFxPipelineInstance = function RemovePostFxPipelineInstance(gameObject, PostFxPipelineClass, name) {
      if (name === undefined) {
        var pipelines = gameObject.postPipelines;
        for (var i = pipelines.length - 1; i >= 0; i--) {
          var instance = pipelines[i];
          if (instance instanceof PostFxPipelineClass) {
            instance.destroy();
            SpliceOne$1(pipelines, i);
          }
        }
      } else {
        var pipelines = gameObject.postPipelines;
        for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
          var instance = pipelines[i];
          if (instance instanceof PostFxPipelineClass && instance.name === name) {
            instance.destroy();
            SpliceOne$1(pipelines, i);
          }
        }
      }
    };
  
    var AddDissolveMode = function AddDissolveMode(image) {
      RegisterPostPipeline(image.scene.game, 'rexDissolvePostFx', DissolvePostFxPipeline);
      image.addTransitionMode(Dissolve, {
        ease: 'Linear',
        dir: 'out',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          currentImage.effect = AddPostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          currentImage.effect.setProgress(t);
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          RemovePostFxPipelineInstance(currentImage, DissolvePostFxPipeline);
          delete currentImage.effect;
        }
      });
    };
  
    var WipeWidth = 0.1;
    var DirLeftToRight = 0;
    var DirTopToBottom = 0;
    var DirRightToLeft = 1;
    var DirBottomToTop = 1;
    var AxisX = 0;
    var AxisY = 1;
    var AddRevealModes = function AddRevealModes(image) {
      image.addTransitionMode(RevealRight, {
        ease: 'Linear',
        dir: 'in',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          nextImage.effect.progress = t;
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          nextImage.preFX.remove(nextImage.effect);
          delete nextImage.effect;
        }
      }).addTransitionMode(RevealLeft, {
        ease: 'Linear',
        dir: 'in',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          nextImage.effect.progress = t;
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          nextImage.preFX.remove(nextImage.effect);
          delete nextImage.effect;
        }
      }).addTransitionMode(RevealDown, {
        ease: 'Linear',
        dir: 'in',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          nextImage.effect.progress = t;
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          nextImage.preFX.remove(nextImage.effect);
          delete nextImage.effect;
        }
      }).addTransitionMode(RevealUp, {
        ease: 'Linear',
        dir: 'in',
        mask: false,
        onStart: function onStart(parent, currentImage, nextImage, t) {
          nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
        },
        onProgress: function onProgress(parent, currentImage, nextImage, t) {
          nextImage.effect.progress = t;
        },
        onComplete: function onComplete(parent, currentImage, nextImage, t) {
          nextImage.preFX.remove(nextImage.effect);
          delete nextImage.effect;
        }
      });
    };
  
    var Modes = [AddSlideAwayModes, AddSlideModes, AddSliderModes, AddZoomModes, AddFadeModes, AddIrisModes, AddPieModes, AddWipeModes, AddBlindsModes, AddSquaresModes, AddDiamondsMode, AddCirclesMode, AddCurtainMode, AddPixellateMode, AddDissolveMode, AddRevealModes];
  
    var TransitionImagePack = /*#__PURE__*/function (_TransitionImage) {
      _inherits(TransitionImagePack, _TransitionImage);
      function TransitionImagePack(scene, x, y, texture, frame, config) {
        var _this;
        _classCallCheck(this, TransitionImagePack);
        _this = _callSuper(this, TransitionImagePack, [scene, x, y, texture, frame, config]);
        for (var i = 0, cnt = Modes.length; i < cnt; i++) {
          Modes[i](_assertThisInitialized(_this));
        }
        return _this;
      }
      return _createClass(TransitionImagePack);
    }(TransitionImage);
  
    ObjectFactory.register('transitionImagePack', function (x, y, texture, frame, config) {
      var gameObject = new TransitionImagePack(this.scene, x, y, texture, frame, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TransitionImagePack', TransitionImagePack);
  
    var ScaleImage = function ScaleImage() {
      var image = this.image;
      if (!this.scaleUp && image.width <= this.width && image.height <= this.height) {
        return this;
      }
      var result = FitTo(image, this, 'FIT', true);
      image.setDisplaySize(result.width, result.height);
      this.resetChildScaleState(image);
      return this;
    };
  
    var methods$q = {
      scaleImage: ScaleImage
    };
    Object.assign(methods$q, FlipMethods);
  
    var ResizeBackground = function ResizeBackground() {
      var background = this.background;
      if (!background) {
        return this;
      }
      background.setOrigin(this.originX, this.originY);
      background.setPosition(this.x, this.y);
      ResizeGameObject(background, this.displayWidth, this.displayHeight);
      this.resetChildScaleState(background);
      return this;
    };
  
    var IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$20 = Phaser.Utils.Objects.GetValue;
    var ImageBox = /*#__PURE__*/function (_Container) {
      _inherits(ImageBox, _Container);
      function ImageBox(scene, x, y, texture, frame, config) {
        var _this;
        _classCallCheck(this, ImageBox);
        if (IsPlainObject$n(x)) {
          config = x;
          x = GetValue$20(config, 'x', 0);
          y = GetValue$20(config, 'y', 0);
          texture = GetValue$20(config, 'key', undefined);
          frame = GetValue$20(config, 'frame', undefined);
        } else if (IsPlainObject$n(frame)) {
          config = frame;
          frame = undefined;
        }
        var image = GetValue$20(config, 'image');
        if (!image) {
          image = scene.add.image(x, y, texture, frame);
          if (texture === undefined) {
            image.setVisible(false);
          }
        } else {
          image.setPosition(x, y).setOrigin(0.5);
        }
        _this = _callSuper(this, ImageBox, [scene, x, y, 1, 1]);
        _this.type = 'rexImageBox';
        var background = GetValue$20(config, 'background');
        if (background) {
          _this.add(background);
        }
        _this.background = background;
        _this.add(image);
        _this.image = image;
        _this.scaleUp = GetValue$20(config, 'scaleUp', false);
        var width = GetValue$20(config, 'width', image.width);
        var height = GetValue$20(config, 'height', image.height);
        _this.resize(width, height);
        return _this;
      }
      _createClass(ImageBox, [{
        key: "texture",
        get: function get() {
          return this.image.texture;
        }
      }, {
        key: "frame",
        get: function get() {
          return this.image.frame;
        }
      }, {
        key: "flipX",
        get: function get() {
          return this._flipX;
        },
        set: function set(value) {
          if (this._flipX === value) {
            return;
          }
          this._flipX = value;
          this.image.setFlipX(value);
        }
      }, {
        key: "flipY",
        get: function get() {
          return this._flipY;
        },
        set: function set(value) {
          if (this._flipY === value) {
            return;
          }
          this._flipY = value;
          this.image.setFlipY(value);
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          _get(_getPrototypeOf(ImageBox.prototype), "resize", this).call(this, width, height);
          ResizeBackground.call(this);
          this.scaleImage();
          return this;
        }
      }, {
        key: "setTexture",
        value: function setTexture(texture, frame) {
          var image = this.image;
          image.setTexture(texture, frame);
          if (texture !== null) {
            this.setChildVisible(image, true);
            this.scaleImage();
          } else {
            this.setChildVisible(image, false);
          }
          return this;
        }
      }]);
      return ImageBox;
    }(ContainerLite);
    Object.assign(ImageBox.prototype, methods$q);
  
    ObjectFactory.register('imageBox', function (x, y, texture, frame, config) {
      var gameObject = new ImageBox(this.scene, x, y, texture, frame, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ImageBox', ImageBox);
  
    ObjectFactory.register('fullWindowRectangle', function (fillColor, fillAlpha) {
      var gameObject = new FullWindowRectangle(this.scene, fillColor, fillAlpha);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FullWindowRectangle', FullWindowRectangle);
  
    ObjectFactory.register('fullWindowZone', function () {
      var gameObject = new FullWindowRectangle$1(this.scene);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FullWindowZone', FullWindowRectangle$1);
  
    ObjectFactory.register('cover', function (config) {
      var gameObject = new Cover(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Cover', Cover);
  
    var Resize = function Resize(width, height) {
      if (this.scene.sys.scale.autoRound) {
        width = Math.floor(width);
        height = Math.floor(height);
      }
      if (this.width === width && this.height === height) {
        return this;
      }
      var style = this.node.style;
      style.width = "".concat(width, "px");
      style.height = "".concat(height, "px");
      this.updateSize();
      return this;
    };
  
    var ElementProperties = {
      id: ['id', undefined],
      text: ['value', undefined],
      maxLength: ['maxLength', undefined],
      minLength: ['minLength', undefined],
      placeholder: ['placeholder', undefined],
      tooltip: ['title', undefined],
      readOnly: ['readOnly', false],
      spellCheck: ['spellcheck', false],
      autoComplete: ['autocomplete', 'off']
    };
    var StyleProperties = {
      align: ['textAlign', undefined],
      paddingLeft: ['padding-left', undefined],
      paddingRight: ['padding-right', undefined],
      paddingTop: ['padding-top', undefined],
      paddingBottom: ['padding-bottom', undefined],
      fontFamily: ['fontFamily', undefined],
      fontSize: ['font-size', undefined],
      color: ['color', '#ffffff'],
      backgroundColor: ['backgroundColor', 'transparent'],
      border: ['border', 0],
      borderColor: ['borderColor', 'transparent'],
      borderRadius: ['border-radius', undefined],
      outline: ['outline', 'none'],
      direction: ['direction', undefined]
    };
    var ElementEvents = {
      input: 'textchange',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'pointerdown',
      mousemove: 'pointermove',
      mouseup: 'pointerup',
      touchstart: 'pointerdown',
      touchmove: 'pointermove',
      touchend: 'pointerup',
      keydown: 'keydown',
      keyup: 'keyup',
      keypress: 'keypress',
      compositionstart: 'compositionStart',
      compositionend: 'compositionEnd',
      compositionupdate: 'compositionUpdate',
      focus: 'focus',
      blur: 'blur',
      select: 'select'
    };
  
    var GetValue$1$ = Phaser.Utils.Objects.GetValue;
    var RouteEvents = function RouteEvents(gameObject, element, elementEvents, config) {
      var preventDefault = GetValue$1$(config, 'preventDefault', false);
      var preTest = GetValue$1$(config, 'preTest');
      var _loop = function _loop(elementEventName) {
        // Note: Don't use `var` here
        element.addEventListener(elementEventName, function (e) {
          if (!preTest || preTest(gameObject, elementEventName)) {
            gameObject.emit(elementEvents[elementEventName], gameObject, e);
          }
          if (preventDefault) {
            e.preventDefault();
          }
        });
      };
      for (var elementEventName in elementEvents) {
        _loop(elementEventName);
      }
    };
  
    var DOMElement$2 = Phaser.GameObjects.DOMElement;
    var IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1_ = Phaser.Utils.Objects.GetValue;
    var InputText = /*#__PURE__*/function (_DOMElement) {
      _inherits(InputText, _DOMElement);
      function InputText(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, InputText);
        if (IsPlainObject$m(x)) {
          config = x;
          x = GetValue$1_(config, 'x', 0);
          y = GetValue$1_(config, 'y', 0);
          width = GetValue$1_(config, 'width', 0);
          height = GetValue$1_(config, 'height', 0);
        } else if (IsPlainObject$m(width)) {
          config = width;
          width = GetValue$1_(config, 'width', 0);
          height = GetValue$1_(config, 'height', 0);
        }
        if (config === undefined) {
          config = {};
        }
        var element;
        var textType = GetValue$1_(config, 'inputType', undefined);
        if (textType === undefined) {
          textType = GetValue$1_(config, 'type', 'text');
        }
        if (textType === 'textarea') {
          element = document.createElement('textarea');
          element.style.resize = 'none';
        } else {
          element = document.createElement('input');
          element.type = textType;
        }
        SetProperties(ElementProperties, config, element);
        var style = GetValue$1_(config, 'style', undefined);
        style = SetProperties(StyleProperties, config, style);
        // Apply other style properties
        var elementStyle = element.style;
        for (var key in config) {
          if (key in ElementProperties || key in StyleProperties) {
            continue;
          } else if (key in elementStyle) {
            style[key] = config[key];
          }
        }
        style['box-sizing'] = 'border-box';
        _this = _callSuper(this, InputText, [scene, x, y, element, style]);
        _this.type = 'rexInputText';
        _this.resize(width, height);
  
        // Apply events
        RouteEvents(_assertThisInitialized(_this), element, ElementEvents);
  
        // Don't propagate touch/mouse events to parent(game canvas)
        StopPropagationTouchEvents(element);
        if (GetValue$1_(config, 'selectAll', false)) {
          _this.selectAll();
        }
        _this._isFocused = false;
        _this.on('focus', function () {
          this._isFocused = true;
        }, _assertThisInitialized(_this)).on('blur', function () {
          this._isFocused = false;
        }, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(InputText, [{
        key: "inputType",
        get: function get() {
          if (this.node.tagName.toLowerCase() === 'textarea') {
            return 'textarea';
          } else {
            return this.node.type;
          }
        }
      }, {
        key: "text",
        get: function get() {
          return this.node.value;
        },
        set: function set(value) {
          this.node.value = value;
        }
      }, {
        key: "setText",
        value: function setText(value) {
          // Override
          this.text = value;
          return this;
        }
      }, {
        key: "maxLength",
        get: function get() {
          return this.node.maxLength;
        },
        set: function set(value) {
          this.node.maxLength = value;
        }
      }, {
        key: "setMaxLength",
        value: function setMaxLength(value) {
          this.maxLength = value;
          return this;
        }
      }, {
        key: "minLength",
        get: function get() {
          return this.node.minLength;
        },
        set: function set(value) {
          this.node.minLength = value;
        }
      }, {
        key: "setMinLength",
        value: function setMinLength(value) {
          this.minLength = value;
          return this;
        }
      }, {
        key: "placeholder",
        get: function get() {
          return this.node.placeholder;
        },
        set: function set(value) {
          this.node.placeholder = value;
        }
      }, {
        key: "setPlaceholder",
        value: function setPlaceholder(value) {
          this.placeholder = value;
          return this;
        }
      }, {
        key: "selectText",
        value: function selectText(selectionStart, selectionEnd) {
          if (selectionStart === undefined) {
            this.node.select();
          } else {
            this.node.setSelectionRange(selectionStart, selectionEnd);
          }
          return this;
        }
      }, {
        key: "selectAll",
        value: function selectAll() {
          this.selectText();
          return this;
        }
      }, {
        key: "selectionStart",
        get: function get() {
          return this.node.selectionStart;
        }
      }, {
        key: "selectionEnd",
        get: function get() {
          return this.node.selectionEnd;
        }
      }, {
        key: "selectedText",
        get: function get() {
          var node = this.node;
          return node.value.substring(node.selectionStart, node.selectionEnd);
        }
      }, {
        key: "cursorPosition",
        get: function get() {
          return this.node.selectionStart;
        },
        set: function set(value) {
          this.node.setSelectionRange(value, value);
        }
      }, {
        key: "setCursorPosition",
        value: function setCursorPosition(value) {
          if (value === undefined) {
            value = this.text.length;
          } else if (value < 0) {
            value = this.text.length + value;
          }
          this.cursorPosition = value;
          return this;
        }
      }, {
        key: "tooltip",
        get: function get() {
          return this.node.title;
        },
        set: function set(value) {
          this.node.title = value;
        }
      }, {
        key: "setTooltip",
        value: function setTooltip(value) {
          this.tooltip = value;
          return this;
        }
      }, {
        key: "setTextChangedCallback",
        value: function setTextChangedCallback(callback) {
          this.onTextChanged = callback;
          return this;
        }
      }, {
        key: "readOnly",
        get: function get() {
          return this.node.readOnly;
        },
        set: function set(value) {
          this.node.readOnly = value;
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(value) {
          if (value === undefined) {
            value = true;
          }
          this.readOnly = value;
          return this;
        }
      }, {
        key: "spellCheck",
        get: function get() {
          return this.node.spellcheck;
        },
        set: function set(value) {
          this.node.spellcheck = value;
        }
      }, {
        key: "setSpellCheck",
        value: function setSpellCheck(value) {
          this.spellCheck = value;
          return this;
        }
      }, {
        key: "fontColor",
        get: function get() {
          return this.node.style.color;
        },
        set: function set(value) {
          this.node.style.color = value;
        }
      }, {
        key: "setFontColor",
        value: function setFontColor(value) {
          this.fontColor = value;
          return this;
        }
      }, {
        key: "setStyle",
        value: function setStyle(key, value) {
          this.node.style[key] = value;
          return this;
        }
      }, {
        key: "getStyle",
        value: function getStyle(key) {
          return this.node.style[key];
        }
      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          this.node.scrollTop = this.node.scrollHeight;
          return this;
        }
      }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.node.disabled = !enabled;
          return this;
        }
      }, {
        key: "setBlur",
        value: function setBlur() {
          this.node.blur();
          return this;
        }
      }, {
        key: "setFocus",
        value: function setFocus() {
          this.node.focus();
          return this;
        }
      }, {
        key: "isFocused",
        get: function get() {
          return this._isFocused;
        }
      }]);
      return InputText;
    }(DOMElement$2);
    var methods$p = {
      resize: Resize
    };
    Object.assign(InputText.prototype, methods$p);
  
    ObjectFactory.register('inputText', function (config) {
      var gameObject = new InputText(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.InputText', InputText);
  
    var GetValue$1Z = Phaser.Utils.Objects.GetValue;
    var CreateFileInput = function CreateFileInput(game, config) {
      var fileInput = document.createElement('input');
      fileInput.type = 'file';
      var accept = GetValue$1Z(config, 'accept', '');
      var multiple = GetValue$1Z(config, 'multiple', false);
      fileInput.setAttribute('accept', accept);
      if (multiple) {
        fileInput.setAttribute('multiple', '');
      } else {
        fileInput.removeAttribute('multiple');
      }
      return fileInput;
    };
  
    var Delay = function Delay(time, result) {
      if (time === undefined) {
        time = 0;
      }
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(result);
        }, time);
      });
    };
  
    var ClickPromise = function ClickPromise(_ref) {
      var game = _ref.game,
        fileInput = _ref.fileInput,
        closeDelay = _ref.closeDelay;
      return WaitEvent(GetGame(game).events, 'focus').then(function () {
        return Delay(closeDelay);
      }).then(function () {
        var result = {
          files: fileInput.files
        };
        return Promise.resolve(result);
      });
    };
  
    // Note: Not working in iOS9+
  
    var GetValue$1Y = Phaser.Utils.Objects.GetValue;
    var RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
    var Open$1 = function Open(game, config) {
      // game: game, scene, or game object
      var closeDelay = GetValue$1Y(config, 'closeDelay', 200);
      var fileInput = CreateFileInput(game, config);
      fileInput.click();
      return ClickPromise({
        game: game,
        fileInput: fileInput,
        closeDelay: closeDelay
      }).then(function (result) {
        RemoveFromDOM(fileInput);
        fileInput.remove();
        return Promise.resolve(result);
      });
    };
  
    var SyncTo = function SyncTo(gameObject) {
      this.setOrigin(gameObject.originX, gameObject.originY);
      this.setPosition(gameObject.x, gameObject.y);
      this.resize(gameObject.displayWidth, gameObject.displayHeight);
      return this;
    };
  
    var GetCache = function GetCache(game, loaderType, cacheType) {
      if (cacheType === undefined) {
        switch (loaderType) {
          case 'image':
          case 'svg':
            cacheType = 'textures';
            break;
          case 'animation':
            cacheType = 'json';
            break;
          case 'tilemapTiledJSON':
          case 'tilemapCSV':
            cacheType = 'tilemap';
            break;
          case 'glsl':
            cacheType = 'shader';
            break;
          default:
            cacheType = loaderType;
            break;
        }
      }
      game = GetGame(game);
      var cache;
      if (cacheType === 'textures') {
        cache = game.textures;
      } else {
        cache = game.cache[cacheType];
      }
      return cache;
    };
  
    var FileObjectToCache = function FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete) {
      // Remove data from cache
      if (cacheType === null || cacheType === false) ; else if (IsFunction(cacheType)) {
        cacheType();
      } else {
        var cache = GetCache(scene, loaderType, cacheType);
        if (cache.exists(key)) {
          cache.remove(key);
        }
      }
  
      // Add filecomplete event
      var loader = scene.load;
      if (onComplete) {
        loader.once("filecomplete-".concat(loaderType, "-").concat(key), function (key, type, data) {
          onComplete(data);
        });
      }
  
      // Load file from url
      if (IsFunction(file)) {
        file();
      } else {
        var url = window.URL.createObjectURL(file);
        loader[loaderType](key, url);
      }
      loader.start();
    };
  
    var LoadFile = function LoadFile(file, loaderType, key, cacheType, onComplete) {
      var scene = this.scene;
      FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);
      return this;
    };
    var LoadFilePromise = function LoadFilePromise(file, loaderType, key, cacheType) {
      var scene = this.scene;
      return new Promise(function (resolve, reject) {
        var onComplete = function onComplete(data) {
          resolve(data);
        };
        FileObjectToCache(scene, file, loaderType, key, cacheType, onComplete);
      });
    };
    var LoadFileMethods = {
      loadFile: LoadFile,
      loadFilePromise: LoadFilePromise
    };
  
    var DOMElement$1 = Phaser.GameObjects.DOMElement;
    var IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1X = Phaser.Utils.Objects.GetValue;
    var FileChooser = /*#__PURE__*/function (_DOMElement) {
      _inherits(FileChooser, _DOMElement);
      function FileChooser(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, FileChooser);
        if (IsPlainObject$l(x)) {
          config = x;
          x = GetValue$1X(config, 'x', 0);
          y = GetValue$1X(config, 'y', 0);
          width = GetValue$1X(config, 'width', 0);
          height = GetValue$1X(config, 'height', 0);
        } else if (IsPlainObject$l(width)) {
          config = width;
          width = GetValue$1X(config, 'width', 0);
          height = GetValue$1X(config, 'height', 0);
        }
  
        // Create a hidden file input
        var inputElement = document.createElement('input');
        inputElement.type = 'file';
        var inputStyle = inputElement.style;
        inputStyle.display = 'none';
  
        // Create a label parent
        var labelElement = document.createElement('label');
        labelElement.appendChild(inputElement);
        var style = GetValue$1X(config, 'style', undefined);
        _this = _callSuper(this, FileChooser, [scene, x, y, labelElement, style]);
        _this.type = 'rexFileChooser';
        _this.resetFromJSON(config);
        _this.resize(width, height);
  
        // Register events
        var self = _assertThisInitialized(_this);
        inputElement.onchange = function () {
          self.emit('change', self);
        };
        _this.setCloseDelay(GetValue$1X(config, 'closeDelay', 200));
        inputElement.onclick = function () {
          ClickPromise({
            game: scene,
            fileInput: inputElement,
            closeDelay: self.closeDelay
          }).then(function () {
            self.emit('select', self);
          });
        };
        return _this;
      }
      _createClass(FileChooser, [{
        key: "resetFromJSON",
        value: function resetFromJSON(config) {
          this.setAccept(GetValue$1X(config, 'accept', ''));
          this.setMultiple(GetValue$1X(config, 'multiple', false));
          return this;
        }
      }, {
        key: "setAccept",
        value: function setAccept(accept) {
          if (accept === undefined) {
            accept = '';
          }
          this.fileInput.setAttribute('accept', accept);
          return this;
        }
      }, {
        key: "setMultiple",
        value: function setMultiple(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          if (enabled) {
            this.fileInput.setAttribute('multiple', '');
          } else {
            this.fileInput.removeAttribute('multiple');
          }
          return this;
        }
      }, {
        key: "setCloseDelay",
        value: function setCloseDelay(delay) {
          if (delay === undefined) {
            delay = 200;
          }
          this.closeDelay = delay;
          return this;
        }
      }, {
        key: "fileInput",
        get: function get() {
          return this.node.children[0];
        }
      }, {
        key: "open",
        value: function open() {
          // Only work under any touch event
          this.fileInput.click();
          return this;
        }
      }, {
        key: "files",
        get: function get() {
          return this.fileInput.files;
        }
      }, {
        key: "setOpenEnable",
        value: function setOpenEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.fileInput.disabled = !enable;
          return this;
        }
      }]);
      return FileChooser;
    }(DOMElement$1);
    var methods$o = {
      resize: Resize,
      syncTo: SyncTo
    };
    Object.assign(FileChooser.prototype, methods$o, LoadFileMethods);
  
    ObjectFactory.register('fileChooser', function (config) {
      var gameObject = new FileChooser(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FileChooser', FileChooser);
  
    var DropEnableMethods = {
      setDropEnable: function setDropEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.dropEnable = enable;
        return this;
      },
      toggleDropEnable: function toggleDropEnable() {
        this.dropEnable = !this.dropEnable;
        return this;
      }
    };
  
    var FilterMethods = {
      addFilter: function addFilter(name, callback) {
        if (!this.filters) {
          this.filters = {};
        }
        this.filters[name] = callback;
        return this;
      },
      addFilters: function addFilters(filters) {
        if (!this.filters) {
          this.filters = {};
        }
        for (var name in filters) {
          this.filters[name] = filters[name];
        }
        return this;
      }
    };
  
    var Methods$9 = {
      resize: Resize,
      syncTo: SyncTo
    };
    Object.assign(Methods$9, DropEnableMethods, FilterMethods, LoadFileMethods);
  
    var DragDropEvents = {
      dragenter: 'dragenter',
      dragleave: 'dragleave',
      dragover: 'dragover',
      drop: 'drop'
    };
  
    var DOMElement = Phaser.GameObjects.DOMElement;
    var IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1W = Phaser.Utils.Objects.GetValue;
    var FileDropZone = /*#__PURE__*/function (_DOMElement) {
      _inherits(FileDropZone, _DOMElement);
      function FileDropZone(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, FileDropZone);
        if (IsPlainObject$k(x)) {
          config = x;
          x = GetValue$1W(config, 'x', 0);
          y = GetValue$1W(config, 'y', 0);
          width = GetValue$1W(config, 'width', 0);
          height = GetValue$1W(config, 'height', 0);
        } else if (IsPlainObject$k(width)) {
          config = width;
          width = GetValue$1W(config, 'width', 0);
          height = GetValue$1W(config, 'height', 0);
        }
        if (config === undefined) {
          config = {};
        }
        var element = document.createElement('div');
        var style = GetValue$1W(config, 'style', undefined);
        _this = _callSuper(this, FileDropZone, [scene, x, y, element, style]);
        _this.type = 'rexFileDropZone';
        _this.resize(width, height);
        _this._files = [];
        _this.setDropEnable(GetValue$1W(config, 'dropEnable', true));
        var filters = GetValue$1W(config, 'filters');
        if (filters) {
          _this.addFilters(filters);
        }
  
        // Apply events
        RouteEvents(_assertThisInitialized(_this), element, DragDropEvents, {
          preventDefault: true,
          preTest: function preTest(gameObject) {
            return gameObject.dropEnable;
          }
        });
        _this.on('drop', function (gameObject, e) {
          this._files = e.dataTransfer.files;
          var files = this._files;
          if (files && this.filters) {
            for (var filterType in this.filters) {
              var filterCallback = this.filters[filterType];
              var filteredFiles = [];
              for (var i = 0, cnt = files.length; i < cnt; i++) {
                var file = files[i];
                if (filterCallback(file, files)) {
                  filteredFiles.push(file);
                }
              }
              if (filteredFiles.length > 0) {
                this.emit("drop.".concat(filterType), filteredFiles);
              }
            }
          }
        }, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(FileDropZone, [{
        key: "files",
        get: function get() {
          return this._files;
        }
      }]);
      return FileDropZone;
    }(DOMElement);
    Object.assign(FileDropZone.prototype, Methods$9);
  
    ObjectFactory.register('fileDropZone', function (config) {
      var gameObject = new FileDropZone(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FileDropZone', FileDropZone);
  
    var GetChildrenWidth$3 = function GetChildrenWidth(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var result = 0;
      var children = this.sizerChildren;
      var child, sizerConfig, proportion, padding, childWidth;
      var hasUnknownChildWidth = false;
      this.childrenProportion; // To update this.hasProportion0Child member
  
      if (this.orientation === 0) {
        // x
        // Get summation of minimum width
        var itemSpace = this.space.item;
        var isFirstChild = true;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (!child.hasOwnProperty('rexSizer')) {
            continue;
          }
          sizerConfig = child.rexSizer;
          if (sizerConfig.hidden) {
            continue;
          }
          proportion = sizerConfig.proportion;
          if (proportion === 0 || minimumMode) {
            childWidth = this.getChildWidth(child);
            if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
              childWidth = undefined;
            }
            if (childWidth === undefined) {
              if (proportion !== 0 && !this.hasProportion0Child) {
                childWidth = 0;
              } else {
                hasUnknownChildWidth = true;
              }
            }
          } else {
            childWidth = 0;
          }
          if (hasUnknownChildWidth) {
            continue;
          }
          padding = child.rexSizer.padding;
          childWidth += padding.left + padding.right;
          if (isFirstChild) {
            isFirstChild = false;
          } else {
            childWidth += itemSpace;
          }
          result += childWidth;
        }
      } else {
        // Get maximun width
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (!child.hasOwnProperty('rexSizer')) {
            continue;
          }
          sizerConfig = child.rexSizer;
          if (sizerConfig.hidden) {
            continue;
          }
          childWidth = this.getChildWidth(child);
          if (childWidth === undefined) {
            hasUnknownChildWidth = true;
          }
          if (hasUnknownChildWidth) {
            continue;
          }
          padding = sizerConfig.padding;
          childWidth += padding.left + padding.right;
          result = Math.max(childWidth, result);
        }
      }
      if (hasUnknownChildWidth) {
        return undefined;
      }
      return result + this.space.left + this.space.right;
    };
  
    var GetChildrenHeight$3 = function GetChildrenHeight(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var result = 0;
      var children = this.sizerChildren;
      var child, sizerConfig, proportion, padding, childHeight;
      var hasUnknownChildHeight = false;
      this.childrenProportion; // To update this.hasProportion0Child member
  
      if (this.orientation === 0) {
        // x
        // Get maximun height
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (!child.hasOwnProperty('rexSizer')) {
            continue;
          }
          sizerConfig = child.rexSizer;
          if (sizerConfig.hidden) {
            continue;
          }
          childHeight = this.getChildHeight(child);
          if (childHeight === undefined) {
            hasUnknownChildHeight = true;
          }
          if (hasUnknownChildHeight) {
            continue;
          }
          padding = sizerConfig.padding;
          childHeight += padding.top + padding.bottom;
          result = Math.max(childHeight, result);
        }
      } else {
        // Get summation of minimum height
        var itemSpace = this.space.item;
        var isFirstChild = true;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (!child.hasOwnProperty('rexSizer')) {
            continue;
          }
          sizerConfig = child.rexSizer;
          if (sizerConfig.hidden) {
            continue;
          }
          proportion = sizerConfig.proportion;
          if (proportion === 0 || minimumMode) {
            childHeight = this.getChildHeight(child);
            if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
              childHeight = undefined;
            }
            if (childHeight === undefined) {
              if (proportion !== 0 && !this.hasProportion0Child) {
                childHeight = 0;
              } else {
                hasUnknownChildHeight = true;
              }
            }
          } else {
            childHeight = 0;
          }
          if (hasUnknownChildHeight) {
            continue;
          }
          padding = sizerConfig.padding;
          childHeight += padding.top + padding.bottom;
          if (isFirstChild) {
            isFirstChild = false;
          } else {
            childHeight += itemSpace;
          }
          result += childHeight;
        }
      }
      if (hasUnknownChildHeight) {
        return undefined;
      }
      return result + this.space.top + this.space.bottom;
    };
  
    var GetExpandedChildWidth$1 = function GetExpandedChildWidth(child, parentWidth) {
      if (parentWidth === undefined) {
        parentWidth = this.width;
      }
      var childWidth;
      var childConfig = child.rexSizer;
      if (this.orientation === 0) {
        // x
        if (childConfig.proportion > 0 && this.proportionLength > 0) {
          childWidth = childConfig.proportion * this.proportionLength;
        }
      } else {
        // y
        if (childConfig.expand) {
          var space = this.space;
          var innerWidth = parentWidth - space.left - space.right;
          var padding = childConfig.padding;
          childWidth = innerWidth - padding.left - padding.right;
        }
      }
      return childWidth;
    };
  
    var GetExpandedChildHeight$1 = function GetExpandedChildHeight(child, parentHeight) {
      if (parentHeight === undefined) {
        parentHeight = this.height;
      }
      var childHeight;
      var childConfig = child.rexSizer;
      if (this.orientation === 0) {
        // x
        if (childConfig.expand) {
          var space = this.space;
          var innerHeight = parentHeight - space.top - space.bottom;
          var padding = childConfig.padding;
          childHeight = innerHeight - padding.top - padding.bottom;
        }
      } else {
        // y
        if (childConfig.proportion > 0 && this.proportionLength > 0) {
          childHeight = childConfig.proportion * this.proportionLength;
        }
      }
      return childHeight;
    };
  
    var GetChildrenSizers$3 = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      var children = this.sizerChildren,
        child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.isRexSizer) {
          out.push(child);
        }
      }
      return out;
    };
  
    var PreLayout$3 = function PreLayout() {
      // Resize child to 1x1 for ratio-fit 
      this.hasRatioFitChild = false;
      var child, sizerConfig;
      var children = this.sizerChildren;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        if (sizerConfig.fitRatio > 0) {
          ResizeGameObject(child, 0, 0);
          sizerConfig.resolved = false;
          this.hasRatioFitChild = true;
        }
      }
      this._childrenProportion = undefined;
      this.hasProportion0Child = false;
      this.proportionLength = undefined;
      PreLayout$4.call(this);
      return this;
    };
  
    var Wrap = Phaser.Math.Wrap;
    var LayoutChildren$4 = function LayoutChildren() {
      var children = this.sizerChildren;
      var child, childConfig, padding;
      var startX = this.innerLeft,
        startY = this.innerTop;
      var innerWidth = this.innerWidth;
      var innerHeight = this.innerHeight;
      var itemX = startX,
        itemY = startY;
      var x, y, width, height; // Align zone
      var childWidth, childHeight;
      var childIndex,
        startChildIndex = this.startChildIndex;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        if (startChildIndex === 0) {
          childIndex = i;
        } else {
          childIndex = Wrap(i + startChildIndex, 0, cnt);
        }
        if (this.rtl) {
          childIndex = cnt - childIndex - 1;
        }
        child = children[childIndex];
        if (child.rexSizer.hidden) {
          continue;
        }
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        PreLayoutChild.call(this, child);
  
        // Set size
        if (child.isRexSpace) {
          childWidth = 0;
          childHeight = 0;
        } else {
          childWidth = this.getExpandedChildWidth(child);
          childHeight = this.getExpandedChildHeight(child);
        }
        if (child.isRexSizer) {
          child.runLayout(this, childWidth, childHeight);
          CheckSize(child, this);
        } else {
          ResizeGameObject(child, childWidth, childHeight);
        }
        if (childWidth === undefined) {
          childWidth = GetDisplayWidth(child);
        }
        if (childHeight === undefined) {
          childHeight = GetDisplayHeight(child);
        }
  
        // Set position
        if (this.orientation === 0) {
          // x
          x = itemX + padding.left;
          if (childConfig.proportion === 0 || this.proportionLength === 0) {
            width = childWidth;
          } else {
            width = childConfig.proportion * this.proportionLength;
          }
          y = itemY + padding.top;
          height = innerHeight - padding.top - padding.bottom;
        } else {
          // y
          x = itemX + padding.left;
          width = innerWidth - padding.left - padding.right;
          y = itemY + padding.top;
          if (childConfig.proportion === 0 || this.proportionLength === 0) {
            height = childHeight;
          } else {
            height = childConfig.proportion * this.proportionLength;
          }
        }
        LayoutChild.call(this, child, x, y, width, height, childConfig.align);
        if (this.orientation === 0) {
          // x
          itemX += width + padding.left + padding.right + this.space.item;
        } else {
          // y
          itemY += height + padding.top + padding.bottom + this.space.item;
        }
      }
    };
  
    var ResolveWidth$1 = function ResolveWidth(width) {
      var width = ResolveWidth$3.call(this, width);
  
      // Calculate proportionLength
      if (width !== undefined && this.orientation === 0 && this.proportionLength === undefined) {
        var remainder = width - this.childrenWidth;
        if (remainder > 0) {
          remainder = width - this.getChildrenWidth(false);
          this.proportionLength = remainder / this.childrenProportion;
        } else {
          this.proportionLength = 0;
        }
      }
      return width;
    };
  
    var ResolveHeight$1 = function ResolveHeight(height) {
      var height = ResolveHeight$3.call(this, height);
  
      // Get proportionLength
      if (height !== undefined && this.orientation === 1 && this.proportionLength === undefined) {
        var remainder = height - this.childrenHeight;
        if (remainder > 0) {
          remainder = height - this.getChildrenHeight(false);
          this.proportionLength = remainder / this.childrenProportion;
        } else {
          this.proportionLength = 0;
        }
      }
      return height;
    };
  
    var HasWidthWrap$1 = function HasWidthWrap() {
      if (this.hasRatioFitChild && this.orientation === 1) {
        return true;
      }
      return HasWidthWrap$2.call(this);
    };
  
    var ExpandFitRatioChildren = function ExpandFitRatioChildren(width, height) {
      if (!this.hasRatioFitChild) {
        return;
      }
      var innerHeight;
      if (this.orientation === 0) {
        innerHeight = height - this.getInnerPadding('top') - this.getInnerPadding('bottom');
      } else {
        width - this.getInnerPadding('left') - this.getInnerPadding('right');
      }
      var child, sizerConfig;
      var childWidth, childHeight;
      var children = this.sizerChildren;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        var sizerConfig = child.rexSizer;
        if (sizerConfig.hidden) {
          continue;
        }
        var fitRatio = sizerConfig.fitRatio;
        if (!fitRatio) {
          continue;
        }
        if (this.orientation === 0) {
          // Set child width by child height 
          childHeight = innerHeight - this.getChildOuterPadding(child, 'top') - this.getChildOuterPadding(child, 'bottom');
          childWidth = childHeight * fitRatio;
        } else {
          // Set child height by child width
          childWidth = innerHeight - this.getChildOuterPadding(child, 'top') - this.getChildOuterPadding(child, 'bottom');
          childHeight = childWidth / fitRatio;
        }
        ResizeGameObject(child, childWidth, childHeight);
        if (child.isRexSizer) {
          child.setMinSize(childWidth, childHeight);
        }
        sizerConfig.resolved = true;
      }
    };
  
    var RunWidthWrap$2 = function RunWidthWrap(width) {
      if (this.wrapResult) {
        // Already got wrapResult
        return;
      }
      if (this.orientation === 1) {
        ExpandFitRatioChildren.call(this, width, undefined);
      }
      RunWidthWrap$3.call(this, width);
    };
  
    var HasHeightWrap$1 = function HasHeightWrap() {
      if (this.hasRatioFitChild && this.orientation === 0) {
        return true;
      }
      return HasHeightWrap$2.call(this);
    };
  
    var RunHeightWrap$2 = function RunHeightWrap(height) {
      if (this.wrapResult) {
        // Already got wrapResult
        return;
      }
      if (this.orientation === 0) {
        ExpandFitRatioChildren.call(this, undefined, height);
      }
      RunHeightWrap$3.call(this, height);
    };
  
    var Zone = Phaser.GameObjects.Zone;
    var Space = /*#__PURE__*/function (_Zone) {
      _inherits(Space, _Zone);
      function Space(scene) {
        var _this;
        _classCallCheck(this, Space);
        _this = _callSuper(this, Space, [scene, 0, 0, 1, 1]);
        // Don't add Zone into scene
        _this.isRexSpace = true;
        return _this;
      }
      return _createClass(Space);
    }(Zone);
  
    var GetNearestChildIndex$1 = function GetNearestChildIndex(x, y) {
      var children = this.sizerChildren;
      if (children.length === 0) {
        return -1;
      }
      var nearestIndex = -1,
        minDistance = Infinity;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        var distance;
        if (this.orientation === 0) {
          // x
          distance = Math.abs(child.left - x);
        } else {
          distance = Math.abs(child.top - y);
        }
        if (minDistance > distance) {
          minDistance = distance;
          nearestIndex = i;
        }
      }
  
      // Check right bound of last child
      var child = children[children.length - 1];
      var distance;
      if (this.orientation === 0) {
        // x
        distance = Math.abs(child.right - x);
      } else {
        distance = Math.abs(child.bottom - y);
      }
      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i + 1;
      }
      return nearestIndex;
    };
  
    var IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1V = Phaser.Utils.Objects.GetValue;
    var ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;
    var PROPORTIONMODE = {
      min: 0,
      full: -1
    };
    var Add$6 = function Add(gameObject, proportion, align, paddingConfig, expand, childKey, index, minWidth, minHeight, fitRatio) {
      AddChild$1.call(this, gameObject);
      var isRexSpace = gameObject.isRexSpace;
      var proportionType = _typeof(proportion);
      if (proportion === null) {
        return this;
      } else if (proportionType === 'number') ; else if (proportionType === 'string') {
        proportion = PROPORTIONMODE[proportion];
      } else if (IsPlainObject$j(proportion)) {
        var config = proportion;
        proportion = GetValue$1V(config, 'proportion', undefined);
        align = GetValue$1V(config, 'align', ALIGN_CENTER$2);
        paddingConfig = GetValue$1V(config, 'padding', 0);
        expand = GetValue$1V(config, 'expand', false);
        childKey = GetValue$1V(config, 'key', undefined);
        index = GetValue$1V(config, 'index', undefined);
        if (!gameObject.isRexSizer) {
          minWidth = GetValue$1V(config, 'minWidth', undefined);
          minHeight = GetValue$1V(config, 'minHeight', undefined);
        }
        fitRatio = GetValue$1V(config, 'fitRatio', 0); // width/height
      }
      if (typeof align === 'string') {
        align = AlignConst[align];
      }
      if (proportion === undefined) {
        proportion = isRexSpace ? 1 : 0;
      }
      if (align === undefined) {
        align = ALIGN_CENTER$2;
      }
      if (paddingConfig === undefined) {
        paddingConfig = 0;
      }
      if (expand === undefined) {
        expand = false;
      }
      if (minWidth === undefined) {
        if (isRexSpace) {
          minWidth = 0;
        } else if (!gameObject.isRexSizer) {
          minWidth = gameObject._minWidth;
        }
      }
      if (minHeight === undefined) {
        if (isRexSpace) {
          minHeight = 0;
        } else if (!gameObject.isRexSizer) {
          minHeight = gameObject._minHeight;
        }
      }
      if (fitRatio === undefined || fitRatio === false) {
        fitRatio = 0;
      } else if (fitRatio === true) {
        fitRatio = GetDisplayWidth(gameObject) / GetDisplayHeight(gameObject);
      }
      var config = this.getSizerConfig(gameObject);
      config.proportion = proportion;
      config.align = align;
      config.padding = GetBoundsConfig(paddingConfig);
      config.expand = expand;
      config.fitRatio = proportion === 0 ? fitRatio : 0;
      if (index === undefined || index >= this.sizerChildren.length) {
        this.sizerChildren.push(gameObject);
      } else {
        this.sizerChildren.splice(index, 0, gameObject);
      }
      if (!gameObject.isRexSizer) {
        // Expand normal game object
        if (proportion > 0) {
          if (this.orientation === 0) {
            // x
            // minWidth is still undefined, uses current display width
            gameObject.minWidth = minWidth === undefined ? GetDisplayWidth(gameObject) : minWidth;
          } else {
            // minHeight is still undefined, uses current display height
            gameObject.minHeight = minHeight === undefined ? GetDisplayHeight(gameObject) : minHeight;
          }
        }
        if (expand) {
          if (this.orientation === 0) {
            // x
            // Might have minHeight value, or still undefined
            gameObject.minHeight = minHeight;
          } else {
            // Might have minWidth value, or still undefined
            gameObject.minWidth = minWidth;
          }
        }
      }
      if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
      }
      return this;
    };
    var AddChildMethods$6 = {
      add: Add$6,
      // sizer.add could be override
      addSpace: function addSpace(proportion) {
        this.insertSpace(undefined, proportion);
        return this;
      },
      insertSpace: function insertSpace(index, proportion) {
        if (proportion === undefined) {
          proportion = 1;
        }
        Add$6.call(this, new Space(this.scene), {
          proportion: proportion,
          minWidth: 0,
          minHeight: 0,
          index: index
        });
        // No problem if sizer.add is override
        return this;
      },
      insert: function insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
        if (IsPlainObject$j(proportion)) {
          proportion.index = index;
        }
        Add$6.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize);
        // No problem if sizer.add is override
        return this;
      },
      insertAtPosition: function insertAtPosition(x, y, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
        var index = GetNearestChildIndex$1.call(this, x, y);
        if (index === -1) {
          index = undefined;
        }
        this.insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize);
        return this;
      }
    };
  
    var RemoveItem$2 = Phaser.Utils.Array.Remove;
    var RemoveChildMethods$5 = {
      remove: function remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
          return this;
        }
        RemoveItem$2(this.sizerChildren, gameObject);
        RemoveChild.call(this, gameObject, destroyChild);
        return this;
      },
      removeAll: function removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
          this.remove(this.sizerChildren[i], destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        this.sizerChildren.length = 0;
        ClearChildren.call(this, destroyChild);
        return this;
      }
    };
  
    var AlignMethods = {
      getChildAlign: function getChildAlign(gameObject) {
        return this.getSizerConfig(gameObject).align;
      },
      setChildAlign: function setChildAlign(gameObject, align) {
        if (typeof align === 'string') {
          align = AlignConst[align];
        }
        this.getSizerConfig(gameObject).align = align;
        return this;
      }
    };
  
    var ProportionMethods = {
      getChildProportion: function getChildProportion(gameObject) {
        return this.getSizerConfig(gameObject).proportion;
      },
      setChildProportion: function setChildProportion(gameObject, proportion) {
        this.getSizerConfig(gameObject).proportion = proportion;
        return this;
      }
    };
  
    var ExpandMethods$1 = {
      getChildExpand: function getChildExpand(gameObject) {
        return this.getSizerConfig(gameObject).expand;
      },
      setChildExpand: function setChildExpand(gameObject, expand) {
        this.getSizerConfig(gameObject).expand = expand;
        return this;
      }
    };
  
    var SetChildrenAlignMode = function SetChildrenAlignMode(mode) {
      if (mode === undefined) {
        mode = 'left';
      }
      var children = this.sizerChildren;
      var firstChild = children[0];
      var isFirstChildASpace = firstChild && firstChild.isRexSpace;
      if (
      // Has left space
      mode === 'right' || mode === 'bottom' || mode === 'center') {
        if (!isFirstChildASpace) {
          this.insertSpace(0);
        }
      } else {
        // Does not have left space
        if (isFirstChildASpace) {
          this.remove(firstChild, true);
        }
      }
      var lastChildIndex = children.length - 1;
      var lastChild = children[lastChildIndex];
      var isLastChildASpace = lastChild && lastChild.isRexSpace;
      if (mode === 'center') {
        // Has right space
        if (!isLastChildASpace) {
          this.insertSpace(lastChildIndex + 1);
        }
      } else {
        // Does not have right space
        if (isLastChildASpace) {
          this.remove(lastChild, true);
        }
      }
      return this;
    };
  
    var SortChildrenMethods = {
      sortChildren: function sortChildren(callback) {
        this.sizerChildren.sort(callback);
        return this;
      },
      sortChildrenByData: function sortChildrenByData(key, descending) {
        this.sizerChildren.sort(function (childA, childB) {
          var valueA = childA.getData(key);
          var valueB = childB.getData(key);
          if (descending) {
            return valueB - valueA;
          } else {
            return valueA - valueB;
          }
        });
        return this;
      },
      sortChildrenByProperty: function sortChildrenByProperty(key, descending) {
        this.sizerChildren.sort(function (childA, childB) {
          var valueA = childA[key];
          var valueB = childB[key];
          if (descending) {
            return valueB - valueA;
          } else {
            return valueA - valueB;
          }
        });
        return this;
      }
    };
  
    var methods$n = {
      getChildrenWidth: GetChildrenWidth$3,
      getChildrenHeight: GetChildrenHeight$3,
      getExpandedChildWidth: GetExpandedChildWidth$1,
      getExpandedChildHeight: GetExpandedChildHeight$1,
      getChildrenSizers: GetChildrenSizers$3,
      preLayout: PreLayout$3,
      layoutChildren: LayoutChildren$4,
      resolveWidth: ResolveWidth$1,
      resolveHeight: ResolveHeight$1,
      hasWidthWrap: HasWidthWrap$1,
      runWidthWrap: RunWidthWrap$2,
      hasHeightWrap: HasHeightWrap$1,
      runHeightWrap: RunHeightWrap$2,
      setChildrenAlignMode: SetChildrenAlignMode
    };
    Object.assign(methods$n, AddChildMethods$6, RemoveChildMethods$5, AlignMethods, ProportionMethods, ExpandMethods$1, SortChildrenMethods);
  
    var GetChildrenProportion = function GetChildrenProportion() {
      var result = 0;
      var children = this.sizerChildren;
      var child, proportion;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.rexSizer.hidden) {
          continue;
        }
        proportion = child.rexSizer.proportion;
        if (proportion > 0) {
          result += proportion;
        } else if (proportion === 0) {
          this.hasProportion0Child = true;
        }
      }
      return result;
    };
  
    var OrientationMode = {
      x: 0,
      h: 0,
      horizontal: 0,
      'left-to-right': 0,
      y: 1,
      v: 1,
      vertical: 1,
      'top-to-bottom': 1
    };
    var GetOrientationMode = function GetOrientationMode(orientation) {
      if (typeof orientation === 'string') {
        orientation = OrientationMode[orientation];
      }
      return orientation;
    };
  
    var IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1U = Phaser.Utils.Objects.GetValue;
    var Sizer = /*#__PURE__*/function (_BaseSizer) {
      _inherits(Sizer, _BaseSizer);
      function Sizer(scene, x, y, minWidth, minHeight, orientation, config) {
        var _this;
        _classCallCheck(this, Sizer);
        if (IsPlainObject$i(x)) {
          config = x;
          x = GetValue$1U(config, 'x', 0);
          y = GetValue$1U(config, 'y', 0);
          minWidth = GetValue$1U(config, 'width', undefined);
          minHeight = GetValue$1U(config, 'height', undefined);
          orientation = GetValue$1U(config, 'orientation', 0);
        } else if (IsPlainObject$i(minWidth)) {
          config = minWidth;
          minWidth = GetValue$1U(config, 'width', undefined);
          minHeight = GetValue$1U(config, 'height', undefined);
          orientation = GetValue$1U(config, 'orientation', 0);
        } else if (IsPlainObject$i(orientation)) {
          config = orientation;
          orientation = GetValue$1U(config, 'orientation', 0);
        }
        if (orientation === undefined) {
          orientation = 0;
        }
        _this = _callSuper(this, Sizer, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexSizer';
        _this.sizerChildren = [];
        _this.setOrientation(orientation);
        _this.setItemSpacing(GetValue$1U(config, 'space.item', 0));
        _this.setStartChildIndex(GetValue$1U(config, 'startChildIndex', 0));
        _this.setRTL(GetValue$1U(config, 'rtl', false));
        _this.addChildrenMap('items', _this.sizerChildren);
        return _this;
      }
      _createClass(Sizer, [{
        key: "setOrientation",
        value: function setOrientation(orientation) {
          this.orientation = GetOrientationMode(orientation);
          return this;
        }
      }, {
        key: "setItemSpacing",
        value: function setItemSpacing(space) {
          this.space.item = space;
          return this;
        }
      }, {
        key: "setStartChildIndex",
        value: function setStartChildIndex(index) {
          this.startChildIndex = index;
          return this;
        }
      }, {
        key: "setRTL",
        value: function setRTL(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.rtl = enable;
          return this;
        }
      }, {
        key: "childrenProportion",
        get: function get() {
          if (this._childrenProportion === undefined) {
            this._childrenProportion = GetChildrenProportion.call(this);
          }
          return this._childrenProportion;
        }
      }]);
      return Sizer;
    }(Base);
    Object.assign(Sizer.prototype, methods$n);
  
    var SetDisplaySize = function SetDisplaySize(gameObject, width, height) {
      if (!gameObject) {
        return;
      }
      var unknownWidth = width == null;
      var unknownHeight = height == null;
      if (unknownWidth && unknownHeight) {
        return gameObject;
      }
      if (!unknownWidth) {
        gameObject.displayWidth = width;
      }
      if (!unknownHeight) {
        gameObject.displayHeight = height;
      }
      if (unknownWidth) {
        gameObject.scaleX = gameObject.scaleY;
      }
      if (unknownHeight) {
        gameObject.scaleY = gameObject.scaleX;
      }
      return gameObject;
    };
  
    var ResetDisplayContent$1 = function ResetDisplayContent(config) {
      if (config === undefined) {
        config = {};
      } else if (typeof config === 'string') {
        config = {
          text: config
        };
      }
      var text = config.text || '';
      this.setText(text);
      var iconGameObjct = this.childrenMap.icon;
      if (iconGameObjct) {
        if (!config.icon) {
          this.hide(iconGameObjct);
        } else {
          this.show(iconGameObjct);
        }
        var iconSize = config.iconSize;
        if (iconSize) {
          this.setChildDisplaySize(iconGameObjct, iconSize, iconSize);
          if (this.iconWidth !== undefined) {
            this.setIconSize(iconSize);
          }
        }
        if (config.icon !== true) {
          this.setIconTexture(config.icon, config.iconFrame);
        }
      }
      var actionGameObjct = this.childrenMap.action;
      if (actionGameObjct) {
        if (!config.action) {
          this.hide(actionGameObjct);
        } else {
          this.show(actionGameObjct);
        }
        var actionSize = config.actionSize;
        if (actionSize) {
          this.setChildDisplaySize(actionGameObjct, actionSize, actionSize);
          if (this.actionWidth !== undefined) {
            this.setActionSize(actionSize);
          }
        }
        if (config.action !== true) {
          this.setActionTexture(config.action, config.actionFrame);
        }
      }
      return this;
    };
  
    var methods$m = {
      appendText: AppendText$2,
      resetDisplayContent: ResetDisplayContent$1
    };
  
    var LabelBase = /*#__PURE__*/function (_Sizer) {
      _inherits(LabelBase, _Sizer);
      function LabelBase() {
        _classCallCheck(this, LabelBase);
        return _callSuper(this, LabelBase, arguments);
      }
      _createClass(LabelBase, [{
        key: "text",
        get:
        /*
        Elements in childrenMap: 
        
        - background
        - icon, iconMask
        - text, 
        - action, actionMask
        */
  
        // Access text game object
        function get() {
          var textObject = this.childrenMap.text;
          if (!textObject) {
            return '';
          }
          return textObject.text;
        },
        set: function set(value) {
          var textObject = this.childrenMap.text;
          if (!textObject) {
            return;
          }
          textObject.setText(value);
        }
      }, {
        key: "setText",
        value: function setText(value) {
          this.text = value;
          return this;
        }
  
        // Access icon game object
      }, {
        key: "setIconTexture",
        value: function setIconTexture(key, frame) {
          var imageObject = this.childrenMap.icon;
          if (!imageObject || !imageObject.setTexture) {
            return this;
          }
          imageObject.setTexture(key, frame);
          if (this.iconWidth !== undefined && this.iconHeight !== undefined) {
            SetDisplaySize(imageObject, this.iconWidth, this.iconHeight);
            this.resetChildScaleState(imageObject);
          }
          return this;
        }
      }, {
        key: "setTexture",
        value: function setTexture(key, frame) {
          this.setIconTexture(key, frame);
          return this;
        }
      }, {
        key: "setIconSize",
        value: function setIconSize(width, height) {
          if (height === undefined) {
            height = width;
          }
          this.iconWidth = width;
          this.iconHeight = height;
          return this;
        }
      }, {
        key: "texture",
        get: function get() {
          var imageObject = this.childrenMap.icon;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.texture;
        }
      }, {
        key: "frame",
        get: function get() {
          var imageObject = this.childrenMap.icon;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.frame;
        }
      }, {
        key: "setActionTexture",
        value: function setActionTexture(key, frame) {
          var imageObject = this.childrenMap.action;
          if (!imageObject || !imageObject.setTexture) {
            return this;
          }
          imageObject.setTexture(key, frame);
          if (this.actionWidth !== undefined && this.actionHeight !== undefined) {
            SetDisplaySize(imageObject, this.actionWidth, this.actionHeight);
            this.resetChildScaleState(imageObject);
          }
          return this;
        }
      }, {
        key: "actionTexture",
        get: function get() {
          var imageObject = this.childrenMap.action;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.texture;
        }
      }, {
        key: "actionFrame",
        get: function get() {
          var imageObject = this.childrenMap.action;
          if (!imageObject) {
            return undefined;
          }
          return imageObject.frame;
        }
      }, {
        key: "setActionSize",
        value: function setActionSize(width, height) {
          if (height === undefined) {
            height = width;
          }
          this.actionWidth = width;
          this.actionHeight = height;
          return this;
        }
      }, {
        key: "preLayout",
        value: function preLayout() {
          var icon = this.childrenMap.icon;
          if (icon && this.iconWidth !== undefined && this.iconHeight !== undefined) {
            SetDisplaySize(icon, this.iconWidth, this.iconHeight);
          }
          var action = this.childrenMap.action;
          if (action && this.actionWidth !== undefined && this.actionHeight !== undefined) {
            SetDisplaySize(action, this.actionWidth, this.actionHeight);
          }
          _get(_getPrototypeOf(LabelBase.prototype), "preLayout", this).call(this);
        }
      }, {
        key: "postLayout",
        value: function postLayout(parent, newWidth, newHeight) {
          // Pin icon-mask to icon game object
          var iconMask = this.childrenMap.iconMask;
          if (iconMask) {
            iconMask.setPosition();
            this.resetChildPositionState(iconMask);
          }
          // Pin action-mask to action game object
          var actionMask = this.childrenMap.actionMask;
          if (actionMask) {
            actionMask.setPosition();
            this.resetChildPositionState(actionMask);
          }
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          _get(_getPrototypeOf(LabelBase.prototype), "resize", this).call(this, width, height);
          // Resize icon-mask to icon game object
          var iconMask = this.childrenMap.iconMask;
          if (iconMask) {
            iconMask.resize();
          }
          // Resize action-mask to icon game object
          var actionMask = this.childrenMap.actionMask;
          if (actionMask) {
            actionMask.resize();
          }
          return this;
        }
      }]);
      return LabelBase;
    }(Sizer);
    Object.assign(LabelBase.prototype, methods$m);
  
    var AddChildMask = function AddChildMask(maskTarget, sizeTarget, shape, padding) {
      var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object
      if (maskTarget && !maskTarget.isRexSizer) {
        // Sizer game object can't apply mask
        var mask = maskGameObject.createGeometryMask();
        maskTarget.setMask(mask);
        this.once('destroy', function () {
          maskTarget.setMask();
          mask.destroy();
        });
      }
      this.pin(maskGameObject);
      return maskGameObject;
    };
  
    var TextClass = Phaser.GameObjects.Text;
    var IsTextGameObject = function IsTextGameObject(gameObject) {
      return gameObject instanceof TextClass;
    };
  
    var BitmapTextClass = Phaser.GameObjects.BitmapText;
    var IsBitmapTextGameObject = function IsBitmapTextGameObject(gameObject) {
      return gameObject instanceof BitmapTextClass;
    };
  
    var TextType = 0;
    var TagTextType = 1;
    var BitmapTextType = 2;
    var GetTextObjectType = function GetTextObjectType(textObject) {
      var textObjectType;
      if (IsBitmapTextGameObject(textObject)) {
        textObjectType = BitmapTextType;
      } else if (IsTextGameObject(textObject)) {
        textObjectType = TextType;
      } else {
        textObjectType = TagTextType;
      }
      return textObjectType;
    };
  
    var TextWrapByCharCallback = function TextWrapByCharCallback(text, textObject) {
      var output = [];
      var textLines = text.split('\n');
      var style = textObject.style;
      var wrapWidth = style.wordWrapWidth;
      var wrapMode = style.hasOwnProperty('wrapMode') ? style.wrapMode : 3;
      var context = textObject.context;
      for (var i = 0, cnt = textLines.length; i < cnt; i++) {
        WrapLine(context, textLines[i], wrapWidth, wrapMode, output);
      }
      return output;
    };
    var GetTokenArray = function GetTokenArray(text, wrapMode) {
      var tokenArray;
      if (wrapMode === 2) {
        // CHAR_WRAP
        tokenArray = text.split('');
      } else {
        // MIX_WRAP
        tokenArray = [];
        var words = text.split(' '),
          word;
        for (var i = 0, wordCount = words.length; i < wordCount; i++) {
          word = words[i];
          if (i < wordCount - 1) {
            if (IsASCIIString(word)) {
              tokenArray.push(word + ' ');
            } else {
              var _tokenArray;
              (_tokenArray = tokenArray).push.apply(_tokenArray, _toConsumableArray(word.split('')));
              // Add space as last token
              tokenArray.push(' ');
            }
          } else {
            // The last word
            if (word !== '') {
              if (IsASCIIString(word)) {
                tokenArray.push(word);
              } else {
                var _tokenArray2;
                (_tokenArray2 = tokenArray).push.apply(_tokenArray2, _toConsumableArray(word.split('')));
              }
            }
          }
        }
      }
      return tokenArray;
    };
    var WrapLine = function WrapLine(context, text, wrapWidth, wrapMode, output) {
      if (text.length <= 100) {
        var textWidth = context.measureText(text).width;
        if (textWidth <= wrapWidth) {
          output.push(text);
          return output;
        }
      }
      var tokenArray = GetTokenArray(text, wrapMode);
      var token, tokenWidth;
      var line = [],
        remainderLineWidth = wrapWidth;
      for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
        token = tokenArray[j];
        tokenWidth = context.measureText(token).width;
        remainderLineWidth -= tokenWidth;
        if (remainderLineWidth < 0) {
          output.push(line.join(''));
          line.length = 0;
          remainderLineWidth = wrapWidth - tokenWidth;
        }
        line.push(token);
      }
      if (line.length > 0) {
        output.push(line.join(''));
      }
      return output;
    };
  
    var SetWrapMode = function SetWrapMode(textObject, mode) {
      var textObjectType = GetTextObjectType(textObject);
      switch (textObjectType) {
        case TextType:
          if (typeof mode === 'string') {
            mode = WRAPMODE$1[mode] || 0;
          }
          textObject.style.wrapMode = mode;
          switch (mode) {
            case 2: // CHAR_WRAP
            case 3:
              // MIX_WRAP
              textObject.style.wordWrapCallback = TextWrapByCharCallback;
              break;
            case 1: // WORD_WRAP
            default:
              // NO_WRAP
              textObject.style.wordWrapCallback = null;
              break;
          }
          break;
        case TagTextType:
          if (typeof mode === 'string') {
            mode = WRAPMODE$1[mode] || 0;
          }
          textObject.style.wrapMode = mode;
          break;
      }
    };
  
    var TextRunWidthWrap = function TextRunWidthWrap(textObject) {
      var RunWidthWrap = function RunWidthWrap(width) {
        var padding = textObject.padding;
        var wrapWidth = width - padding.left - padding.right;
        var style = textObject.style;
        if (IsTextGameObject(textObject)) {
          style.wordWrapWidth = wrapWidth;
          style.maxLines = 0;
        } else {
          // BBCode text, Tag text
          if (style.wrapMode === 0) {
            // Turn no-wrap to word-wrap
            style.wrapMode = 1;
          }
          style.wrapWidth = wrapWidth;
          style.maxLines = 0;
        }
        style.fixedWidth = width;
        style.fixedHeight = 0;
        textObject.updateText(); // Redraw text
  
        textObject.minHeight = textObject.height;
        return textObject;
      };
      return RunWidthWrap;
    };
  
    var DynamicTextRunWidthWrap = function DynamicTextRunWidthWrap(textObject) {
      var RunWidthWrap = function RunWidthWrap(width) {
        textObject.setFixedSize(width, 0).runWordWrap();
        textObject.minHeight = textObject.height;
        return textObject;
      };
      return RunWidthWrap;
    };
  
    var BitmapTextRunWidthWrap = function BitmapTextRunWidthWrap(textObject) {
      var RunWidthWrap = function RunWidthWrap(width) {
        textObject.setMaxWidth(width);
        textObject.minHeight = textObject.height;
        return textObject;
      };
      return RunWidthWrap;
    };
  
    var IsDynamicTextGameObject = function IsDynamicTextGameObject(gameObject) {
      return gameObject instanceof DynamicText;
    };
    var WrapExpandText = function WrapExpandText(textObject, minWidth) {
      if (minWidth === undefined) {
        minWidth = 0;
      }
      textObject._minWidth = minWidth;
      textObject.runWidthWrap = IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) : IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) : TextRunWidthWrap(textObject);
      return textObject;
    };
  
    var GetValue$1T = Phaser.Utils.Objects.GetValue;
    var Label = /*#__PURE__*/function (_LabelBase) {
      _inherits(Label, _LabelBase);
      function Label(scene, config) {
        var _this;
        _classCallCheck(this, Label);
        if (config === undefined) {
          config = {};
        }
  
        // Create sizer
        _this = _callSuper(this, Label, [scene, config]);
        _this.type = 'rexLabel';
  
        // Add elements
        var background = GetValue$1T(config, 'background', undefined);
        var icon = GetValue$1T(config, 'icon', undefined);
        var iconMask = GetValue$1T(config, 'iconMask', undefined);
        var text = GetValue$1T(config, 'text', undefined);
        var action = GetValue$1T(config, 'action', undefined);
        var actionMask = GetValue$1T(config, 'actionMask', undefined);
        // Align
        var align = GetValue$1T(config, 'align', undefined); // undefined/left/top: no space
  
        if (background) {
          _this.addBackground(background);
        }
        if (icon) {
          var padding;
          if (_this.orientation === 0) {
            if (text || action) {
              padding = {
                right: GetValue$1T(config, 'space.icon', 0),
                top: GetValue$1T(config, 'space.iconTop', 0),
                bottom: GetValue$1T(config, 'space.iconBottom', 0),
                left: GetValue$1T(config, 'space.iconLeft', 0)
              };
            }
          } else {
            if (text || action) {
              padding = {
                bottom: GetValue$1T(config, 'space.icon', 0),
                left: GetValue$1T(config, 'space.iconLeft', 0),
                right: GetValue$1T(config, 'space.iconRight', 0),
                top: GetValue$1T(config, 'space.iconTop', 0)
              };
            }
          }
          var fitRatio = GetValue$1T(config, 'squareFitIcon', false) ? 1 : 0;
          _this.add(icon, {
            proportion: 0,
            padding: padding,
            fitRatio: fitRatio
          });
          if (iconMask) {
            iconMask = AddChildMask.call(_assertThisInitialized(_this), icon, icon, 1); // Circle mask
          }
          if (!fitRatio) {
            var iconSize = GetValue$1T(config, 'iconSize', undefined);
            _this.setIconSize(GetValue$1T(config, 'iconWidth', iconSize), GetValue$1T(config, 'iconHeight', iconSize));
          }
        }
        if (text) {
          var wrapText = GetValue$1T(config, 'wrapText', false);
          if (wrapText) {
            if (wrapText === true) {
              wrapText = 'word';
            }
            SetWrapMode(text, wrapText);
            config.expandTextWidth = true;
            WrapExpandText(text);
          }
          var textSpace = GetValue$1T(config, 'space.text', 0);
          var expandTextWidth = GetValue$1T(config, 'expandTextWidth', false);
          var expandTextHeight = GetValue$1T(config, 'expandTextHeight', false);
          var proportion, padding, expand;
          if (_this.orientation === 0) {
            proportion = expandTextWidth ? 1 : 0;
            if (action) {
              padding = {
                right: textSpace
              };
            }
            expand = expandTextHeight;
          } else {
            proportion = expandTextHeight ? 1 : 0;
            if (action) {
              padding = {
                bottom: textSpace
              };
            }
            expand = expandTextWidth;
          }
          _this.add(text, {
            proportion: proportion,
            expand: expand,
            padding: padding
          });
        }
        if (action) {
          var padding;
          if (_this.orientation === 0) {
            padding = {
              top: GetValue$1T(config, 'space.actionTop', 0),
              bottom: GetValue$1T(config, 'space.actionBottom', 0),
              right: GetValue$1T(config, 'space.actionRight', 0)
            };
          } else {
            padding = {
              left: GetValue$1T(config, 'space.actionLeft', 0),
              right: GetValue$1T(config, 'space.actionRight', 0),
              bottom: GetValue$1T(config, 'space.actionBottom', 0)
            };
          }
          var fitRatio = GetValue$1T(config, 'squareFitAction', false) ? 1 : 0;
          _this.add(action, {
            proportion: 0,
            padding: padding,
            fitRatio: fitRatio
          });
          if (actionMask) {
            actionMask = AddChildMask.call(_assertThisInitialized(_this), action, action, 1); // Circle mask
          }
          if (!fitRatio) {
            var actionSize = GetValue$1T(config, 'actionSize');
            _this.setActionSize(GetValue$1T(config, 'actionWidth', actionSize), GetValue$1T(config, 'actionHeight', actionSize));
          }
        }
        _this.setChildrenAlignMode(align);
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('icon', icon);
        _this.addChildrenMap('iconMask', iconMask);
        _this.addChildrenMap('text', text);
        _this.addChildrenMap('action', action);
        _this.addChildrenMap('actionMask', actionMask);
        return _this;
      }
      return _createClass(Label);
    }(LabelBase);
  
    var GetValue$1S = Phaser.Utils.Objects.GetValue;
    var CreateCanvas = function CreateCanvas(scene, config) {
      var canvasConfig = GetValue$1S(config, 'canvas');
      var width = GetValue$1S(canvasConfig, 'width', 128);
      var height = GetValue$1S(canvasConfig, 'height', 128);
      var canvas = new Canvas(scene, 0, 0, width, height);
      scene.add.existing(canvas);
      var key = GetValue$1S(canvasConfig, 'key');
      var frame = GetValue$1S(canvasConfig, 'frame');
      var fillColor = GetValue$1S(canvasConfig, 'fill');
      if (fillColor !== undefined) {
        canvas.fill(fillColor);
      } else if (key !== undefined) {
        canvas.loadTexture(key, frame);
      }
  
      // Compatible with Image game object for ImageBox
      canvas.setTexture = canvas.loadTexture.bind(canvas);
      return canvas;
    };
    var CreateImageBox = function CreateImageBox(scene, config) {
      var icon = new ImageBox(scene, {
        scaleUp: GetValue$1S(config, 'scaleUpIcon', false),
        background: GetValue$1S(config, 'iconBackground'),
        image: CreateCanvas(scene, config)
      });
      scene.add.existing(icon);
      return icon;
    };
  
    var GetValue$1R = Phaser.Utils.Objects.GetValue;
    var GetClickTarget = function GetClickTarget(parent, config) {
      var clickTarget = GetValue$1R(config, 'clickTarget', this);
      if (typeof clickTarget === 'string') {
        clickTarget = parent.getElement(clickTarget);
      }
      return clickTarget;
    };
  
    var GetValue$1Q = Phaser.Utils.Objects.GetValue;
    var CreateClickBehavior = function CreateClickBehavior(parent, config) {
      var clickTarget = GetClickTarget(parent, config);
      if (!clickTarget) {
        return undefined;
      }
      var clickConfig = GetValue$1Q(config, 'click');
      var clickBehavior = new Button(clickTarget, clickConfig);
      clickBehavior.on('click', parent.open, parent);
      return clickBehavior;
    };
  
    var Config = {
      accept: 'image/*',
      multiple: false
    };
  
    var OnSelectFile = function OnSelectFile(parent, files) {
      if (files.length === 0) {
        return;
      }
      var imageBox = parent.childrenMap.icon;
      var canvas = imageBox.image;
      var selectedFile = files[0];
      return canvas.loadFromFilePromise(selectedFile).then(function () {
        imageBox.scaleImage();
        parent.emit('select', selectedFile, parent);
        return Promise.resolve(selectedFile);
      });
    };
  
    var CreateFileChooser = function CreateFileChooser(parent, config) {
      var scene = parent.scene;
      var fileChooser = new FileChooser(scene, Config);
      scene.add.existing(fileChooser);
      parent.pin(fileChooser);
      fileChooser.on('change', function () {
        OnSelectFile(parent, fileChooser.files);
      });
      return fileChooser;
    };
  
    var OpenMethods = {
      openPromise: function openPromise() {
        var _this = this;
        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var self;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                self = _this;
                return _context.abrupt("return", Open$1(_this.scene.game, Config).then(function (result) {
                  return OnSelectFile(self, result.files);
                }));
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }))();
      },
      open: function open() {
        this.openPromise();
        return this;
      },
      setClickOpenEnable: function setClickOpenEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        if (this.clickBehavior) {
          this.clickBehavior.setEnable(enable);
        }
        if (this.fileChooser) {
          this.fileChooser.setOpenEnable(enable);
        }
        return this;
      }
    };
  
    var GetFileName = function GetFileName(file) {
      if (!file) {
        return null;
      }
      var name = file.name;
      return name.substr(0, name.lastIndexOf('.'));
    };
  
    var SaveTexture = function SaveTexture(key) {
      var canvas = this.childrenMap.canvas;
      canvas.generateTexture(key);
      return this;
    };
  
    var methods$l = {
      getFileName: GetFileName,
      saveTexture: SaveTexture
    };
    Object.assign(methods$l, OpenMethods);
  
    var GetValue$1P = Phaser.Utils.Objects.GetValue;
  
    /*
    Label :
        - icon : imageBox
            - image: canvas
    */
    var ImageInputLabel = /*#__PURE__*/function (_Label) {
      _inherits(ImageInputLabel, _Label);
      function ImageInputLabel(scene, config) {
        var _this;
        _classCallCheck(this, ImageInputLabel);
        var icon = CreateImageBox(scene, config);
        config.icon = icon;
        _this = _callSuper(this, ImageInputLabel, [scene, config]);
        _this.type = 'rexImageFileInputLabel';
  
        // Set initial size of icon(imageBox)
        var iconWidth = _this.iconWidth,
          iconHeight = _this.iconWidth;
        if (iconWidth !== undefined && iconHeight !== undefined) {
          icon.resize(iconWidth, iconHeight);
        }
        _this.clickTarget = GetClickTarget(_assertThisInitialized(_this), config);
        if (_this.clickTarget) {
          if (!GetValue$1P(config, 'domButton', true)) {
            _this.clickBehavior = CreateClickBehavior(_assertThisInitialized(_this), config);
          } else {
            _this.fileChooser = CreateFileChooser(_assertThisInitialized(_this));
          }
        }
        _this.addChildrenMap('canvas', icon.image);
        _this.addChildrenMap('iconBackground', icon.background);
        _this.addChildrenMap('fileChooser', _this.fileChooser);
        return _this;
      }
      _createClass(ImageInputLabel, [{
        key: "postLayout",
        value: function postLayout() {
          if (this.fileChooser) {
            this.fileChooser.syncTo(this.clickTarget);
            this.resetChildState(this.fileChooser);
          }
        }
      }]);
      return ImageInputLabel;
    }(Label);
    Object.assign(ImageInputLabel.prototype, methods$l);
  
    ObjectFactory.register('imageInputLabel', function (config) {
      var gameObject = new ImageInputLabel(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ImageInputLabel', ImageInputLabel);
  
    var Style$3 = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Style, _ComponentBase);
      function Style(gameObject, style) {
        var _this;
        _classCallCheck(this, Style);
        _this = _callSuper(this, Style, [gameObject]);
        // this.parent = gameObject;
  
        return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
      }
      _createClass(Style, [{
        key: "get",
        value: function get(target, prop) {
          if (HasProperty(target, prop)) {
            return target[prop];
          }
          var gameObject = target.parent;
          if (HasProperty(gameObject, prop)) {
            return gameObject[prop];
          }
        }
      }, {
        key: "set",
        value: function set(target, prop, value) {
          if (HasProperty(target, prop)) {
            target[prop] = value;
          } else if (HasProperty(target.parent, prop)) {
            target.parent[prop] = value;
          }
          return true;
        }
      }, {
        key: "key",
        get: function get() {
          return this.parent.texture.key;
        },
        set: function set(value) {
          this.parent.setTexture(value, this.frame);
        }
      }, {
        key: "frame",
        get: function get() {
          return this.parent.frame.name;
        },
        set: function set(value) {
          this.parent.setFrame(value);
        }
      }, {
        key: "scale",
        get: function get() {
          return this.parent.scaleX;
        },
        set: function set(value) {
          this.parent.setScale(value);
        }
      }]);
      return Style;
    }(ComponentBase);
  
    var GetValue$1O = Phaser.Utils.Objects.GetValue;
    var StyleManager = /*#__PURE__*/function (_ComponentBase) {
      _inherits(StyleManager, _ComponentBase);
      function StyleManager(gameObject, config) {
        var _this;
        _classCallCheck(this, StyleManager);
        _this = _callSuper(this, StyleManager, [gameObject, config]);
        // this.parent = gameObject;
  
        _this.style = GetValue$1O(config, 'style', _assertThisInitialized(_this));
        var propertiesMap = GetValue$1O(config, 'propertiesMap');
        _this.activeStyle = ExtractStyle(config, 'active', propertiesMap);
        _this.hoverStyle = ExtractStyle(config, 'hover', propertiesMap);
        _this.disableStyle = ExtractStyle(config, 'disable', propertiesMap);
        _this.onModifyStyle = GetValue$1O(config, 'onModifyStyle');
        return _this;
      }
      _createClass(StyleManager, [{
        key: "getStyle",
        value: function getStyle(keys) {
          return GetPartialData(this.style, keys);
        }
      }, {
        key: "modifyStyle",
        value: function modifyStyle(style) {
          for (var key in style) {
            this.style[key] = style[key];
          }
          if (this.onModifyStyle) {
            this.onModifyStyle(this.parent, style);
          }
          return this;
        }
      }, {
        key: "applyStyle",
        value: function applyStyle(newStyle) {
          if (!newStyle) {
            return undefined;
          }
          var currentStyle = this.getStyle(newStyle);
          if (!IsKeyValueEqual(currentStyle, newStyle)) {
            this.modifyStyle(newStyle);
            return currentStyle;
          } else {
            return undefined;
          }
        }
      }, {
        key: "setActiveState",
        value: function setActiveState(enable) {
          SetStateEnableMethod.call(this, 'active', enable);
          return this;
        }
      }, {
        key: "setHoverState",
        value: function setHoverState(enable) {
          SetStateEnableMethod.call(this, 'hover', enable);
          return this;
        }
      }, {
        key: "setDisableState",
        value: function setDisableState(enable) {
          SetStateEnableMethod.call(this, 'disable', enable);
          return this;
        }
      }]);
      return StyleManager;
    }(ComponentBase);
    var ExtractStyle = function ExtractStyle(config, prefix, propertiesMap) {
      var result = ExtractByPrefix(config, prefix);
      if (propertiesMap) {
        for (var name in result) {
          if (propertiesMap.hasOwnProperty(name)) {
            result[propertiesMap[name]] = result[name];
            delete result[name];
          }
        }
      }
      return result;
    };
    var SetStateEnableMethod = function SetStateEnableMethod(stateName, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var stateVarName = "".concat(stateName, "State");
      var styleVarName = "".concat(stateName, "Style");
      var styleSaveVarName = "".concat(stateName, "StyleSave");
      if (this[stateVarName] === enable) {
        return;
      }
      this[stateVarName] = enable;
      if (enable) {
        this[styleSaveVarName] = this.applyStyle(this[styleVarName]);
      } else {
        this.applyStyle(this[styleSaveVarName]);
        this[styleSaveVarName] = undefined;
      }
    };
  
    var HelperMethods = {
      addStyleManager: function addStyleManager(config) {
        this.styleManager = new StyleManager(this, config);
        return this;
      },
      setActiveState: function setActiveState(enable) {
        this.styleManager.setActiveState(enable);
        return this;
      },
      setHoverState: function setHoverState(enable) {
        this.styleManager.setHoverState(enable);
        return this;
      },
      setDisableState: function setDisableState(enable) {
        this.styleManager.setDisableState(enable);
        return this;
      }
    };
  
    var PhaserImage = Phaser.GameObjects.Image;
    var GetValue$1N = Phaser.Utils.Objects.GetValue;
    var StatesImage = /*#__PURE__*/function (_PhaserImage) {
      _inherits(StatesImage, _PhaserImage);
      function StatesImage(scene, config) {
        var _this;
        _classCallCheck(this, StatesImage);
        if (config === undefined) {
          config = {};
        }
        var x = GetValue$1N(config, 'x', 0);
        var y = GetValue$1N(config, 'y', 0);
        var key = GetValue$1N(config, 'key', '');
        var frame = GetValue$1N(config, 'frame', undefined);
        _this = _callSuper(this, StatesImage, [scene, x, y, key, frame]);
        _this.type = 'rexStatesImage';
        var effectConfig = GetValue$1N(config, 'effects', true);
        if (effectConfig) {
          AddEffectProperties(_assertThisInitialized(_this), effectConfig);
        }
        _this.style = new Style$3(_assertThisInitialized(_this), config);
        config.style = _this.style;
        _this.addStyleManager(config);
        delete config.style;
        return _this;
      }
      return _createClass(StatesImage);
    }(PhaserImage);
    Object.assign(StatesImage.prototype, HelperMethods);
  
    ObjectFactory.register('statesImage', function (config) {
      var gameObject = new StatesImage(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesImage', StatesImage);
  
    var StatesRoundRectangle = /*#__PURE__*/function (_RoundRectangle) {
      _inherits(StatesRoundRectangle, _RoundRectangle);
      function StatesRoundRectangle(scene, config) {
        var _this;
        _classCallCheck(this, StatesRoundRectangle);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, StatesRoundRectangle, [scene, config]);
        _this.type = 'rexStatesRoundRectangleShape';
        config.style = _assertThisInitialized(_this);
        config.propertiesMap = PropertiesMap;
        _this.addStyleManager(config);
        delete config.style;
        delete config.propertiesMap;
        return _this;
      }
      return _createClass(StatesRoundRectangle);
    }(RoundRectangle$2);
    var PropertiesMap = {
      color: 'fillColor',
      alpha: 'fillAlpha',
      // strokeColor: 'strokeColor',
      // strokeAlpha: 'strokeAlpha',
      strokeWidth: 'lineWidth'
    };
    Object.assign(StatesRoundRectangle.prototype, HelperMethods);
  
    ObjectFactory.register('statesRoundRectangle', function (config) {
      var gameObject = new StatesRoundRectangle(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesRoundRectangle', StatesRoundRectangle);
  
    var Style$2 = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Style, _ComponentBase);
      function Style(gameObject, style) {
        var _this;
        _classCallCheck(this, Style);
        _this = _callSuper(this, Style, [gameObject]);
        // this.parent = gameObject;
  
        return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
      }
      _createClass(Style, [{
        key: "get",
        value: function get(target, prop) {
          if (HasProperty(target, prop)) {
            return target[prop];
          }
          var gameObject = target.parent;
          if (HasProperty(gameObject, prop)) {
            return gameObject[prop];
          }
        }
      }, {
        key: "set",
        value: function set(target, prop, value) {
          if (HasProperty(target, prop)) {
            target[prop] = value;
          } else if (HasProperty(target.parent, prop)) {
            target.parent[prop] = value;
          }
          return true;
        }
      }, {
        key: "key",
        get: function get() {
          return this.parent.texture.key;
        },
        set: function set(value) {
          if (this.key === value) {
            return;
          }
          this.parent.setTexture(value, this.frame);
        }
      }, {
        key: "frame",
        get: function get() {
          return this.parent.frame.name;
        },
        set: function set(value) {
          if (this.frame === value) {
            return;
          }
          this.parent.setFrame(value);
        }
      }]);
      return Style;
    }(ComponentBase);
  
    var PhaserNineSlice = Phaser.GameObjects.NineSlice;
    var GetValue$1M = Phaser.Utils.Objects.GetValue;
    var StatesNineSlice = /*#__PURE__*/function (_PhaserNineSlice) {
      _inherits(StatesNineSlice, _PhaserNineSlice);
      function StatesNineSlice(scene, config) {
        var _this;
        _classCallCheck(this, StatesNineSlice);
        if (config === undefined) {
          config = {};
        }
        var x = GetValue$1M(config, 'x', 0);
        var y = GetValue$1M(config, 'y', 0);
        var key = GetValue$1M(config, 'key', null);
        var frame = GetValue$1M(config, 'frame', null);
        var width = GetValue$1M(config, 'width', 0);
        var height = GetValue$1M(config, 'height', 0);
        var leftWidth = GetValue$1M(config, 'leftWidth', 0);
        var rightWidth = GetValue$1M(config, 'rightWidth', 0);
        var topHeight = GetValue$1M(config, 'topHeight', 0);
        var bottomHeight = GetValue$1M(config, 'bottomHeight', 0);
        _this = _callSuper(this, StatesNineSlice, [scene, x, y, key, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight]);
        _this.type = 'rexStatesNineSlice';
        var effectConfig = GetValue$1M(config, 'effects', true);
        if (effectConfig) {
          AddEffectProperties(_assertThisInitialized(_this), effectConfig);
        }
        _this.style = new Style$2(_assertThisInitialized(_this), config);
        config.style = _this.style;
        _this.addStyleManager(config);
        delete config.style;
        return _this;
      }
      return _createClass(StatesNineSlice);
    }(PhaserNineSlice);
    Object.assign(StatesNineSlice.prototype, HelperMethods);
  
    ObjectFactory.register('statesNineSlice', function (config) {
      var gameObject = new StatesNineSlice(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesNineSlice', StatesNineSlice);
  
    var Style$1 = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Style, _ComponentBase);
      function Style(gameObject, style) {
        var _this;
        _classCallCheck(this, Style);
        _this = _callSuper(this, Style, [gameObject]);
        // this.parent = gameObject;
  
        return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
      }
      _createClass(Style, [{
        key: "get",
        value: function get(target, prop) {
          if (HasProperty(target, prop)) {
            return target[prop];
          }
          var gameObject = target.parent;
          if (HasProperty(gameObject, prop)) {
            return gameObject[prop];
          }
        }
      }, {
        key: "set",
        value: function set(target, prop, value) {
          if (HasProperty(target, prop)) {
            target[prop] = value;
          } else if (HasProperty(target.parent, prop)) {
            target.parent[prop] = value;
          }
          return true;
        }
      }, {
        key: "key",
        get: function get() {
          return this.parent.textureKey;
        },
        set: function set(value) {
          if (this.key === value) {
            return;
          }
          this.parent.setBaseTexture(value, this.baseFrameName);
        }
      }, {
        key: "frame",
        get: function get() {
          return this.parent.baseFrameName;
        },
        set: function set(value) {
          if (this.frame === value) {
            return;
          }
          this.parent.setBaseTexture(this.parent.textureKey, value);
        }
      }]);
      return Style;
    }(ComponentBase);
  
    var GetValue$1L = Phaser.Utils.Objects.GetValue;
    var StatesNinePatch = /*#__PURE__*/function (_NinePatch) {
      _inherits(StatesNinePatch, _NinePatch);
      function StatesNinePatch(scene, config) {
        var _this;
        _classCallCheck(this, StatesNinePatch);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, StatesNinePatch, [scene, config]);
        _this.type = 'rexStatesNinePatch';
        var effectConfig = GetValue$1L(config, 'effects', true);
        if (effectConfig) {
          AddEffectProperties(_assertThisInitialized(_this), effectConfig);
        }
        _this.style = new Style$1(_assertThisInitialized(_this), config);
        config.style = _this.style;
        _this.addStyleManager(config);
        delete config.style;
        return _this;
      }
      return _createClass(StatesNinePatch);
    }(NinePatch$1);
    Object.assign(StatesNinePatch.prototype, HelperMethods);
  
    ObjectFactory.register('statesNinePatch', function (config) {
      var gameObject = new StatesNinePatch(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesNinePatch', StatesNinePatch);
  
    var PhaserText = Phaser.GameObjects.Text;
    var GetValue$1K = Phaser.Utils.Objects.GetValue;
    var StatesText = /*#__PURE__*/function (_PhaserText) {
      _inherits(StatesText, _PhaserText);
      function StatesText(scene, config) {
        var _this;
        _classCallCheck(this, StatesText);
        if (config === undefined) {
          config = {};
        }
        var x = GetValue$1K(config, 'x', 0);
        var y = GetValue$1K(config, 'y', 0);
        var text = GetValue$1K(config, 'text', '');
        _this = _callSuper(this, StatesText, [scene, x, y, text, config]);
        _this.type = 'rexStatesText';
        config.style = _this.style;
        config.onModifyStyle = function (gameObject, style) {
          var recalculateMetrics = style.hasOwnProperty('fontStyle') || style.hasOwnProperty('fontSize') || style.hasOwnProperty('fontFamily');
          gameObject.style.update(recalculateMetrics);
        };
        _this.addStyleManager(config);
        delete config.style;
        return _this;
      }
      return _createClass(StatesText);
    }(PhaserText);
    Object.assign(StatesText.prototype, HelperMethods);
  
    ObjectFactory.register('statesText', function (config) {
      var gameObject = new StatesText(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesText', StatesText);
  
    var Style = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Style, _ComponentBase);
      function Style(gameObject, style) {
        var _this;
        _classCallCheck(this, Style);
        _this = _callSuper(this, Style, [gameObject]);
        // this.parent = gameObject;
  
        return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), _assertThisInitialized(_this)));
      }
      _createClass(Style, [{
        key: "get",
        value: function get(target, prop) {
          if (HasProperty(target, prop)) {
            return target[prop];
          }
          var gameObject = target.parent;
          if (HasProperty(gameObject, prop)) {
            return gameObject[prop];
          }
        }
      }, {
        key: "set",
        value: function set(target, prop, value) {
          if (HasProperty(target, prop)) {
            target[prop] = value;
          } else if (HasProperty(target.parent, prop)) {
            target.parent[prop] = value;
          }
          return true;
        }
      }, {
        key: "key",
        get: function get() {
          return this.parent.texture.key;
        },
        set: function set(value) {
          this.parent.setTexture(value, this.frame);
        }
      }, {
        key: "fontSize",
        get: function get() {
          return this.parent.fontSize;
        },
        set: function set(value) {
          this.parent.setFontSize(value);
        }
      }, {
        key: "tint",
        get: function get() {
          return this.parent.tintTopLeft;
        },
        set: function set(value) {
          this.parent.setTint(value);
        }
      }, {
        key: "letterSpacing",
        get: function get() {
          return this.parent.letterSpacing;
        },
        set: function set(value) {
          this.parent.setLetterSpacing(value);
        }
      }, {
        key: "lineSpacing",
        get: function get() {
          return this.parent.lineSpacing;
        },
        set: function set(value) {
          this.parent.setLineSpacing(value);
        }
      }]);
      return Style;
    }(ComponentBase);
  
    var PhaserBitmapText = Phaser.GameObjects.BitmapText;
    var GetValue$1J = Phaser.Utils.Objects.GetValue;
    var StatesBitmapText = /*#__PURE__*/function (_PhaserBitmapText) {
      _inherits(StatesBitmapText, _PhaserBitmapText);
      function StatesBitmapText(scene, config) {
        var _this;
        _classCallCheck(this, StatesBitmapText);
        if (config === undefined) {
          config = {};
        }
        var x = GetValue$1J(config, 'x', 0);
        var y = GetValue$1J(config, 'y', 0);
        var font = GetValue$1J(config, 'font', '');
        var size = GetValue$1J(config, 'fontSize', false);
        var align = GetValue$1J(config, 'align', 0);
        var tint = GetValue$1J(config, 'tint');
        _this = _callSuper(this, StatesBitmapText, [scene, x, y, font, '', size, align]);
        _this.type = 'rexStatesBitmapText';
        if (tint !== undefined) {
          _this.setTint(tint);
        }
        var effectConfig = GetValue$1J(config, 'effects', true);
        if (effectConfig) {
          AddEffectProperties(_assertThisInitialized(_this), effectConfig);
        }
        _this.style = new Style(_assertThisInitialized(_this), config);
        config.style = _this.style;
        _this.addStyleManager(config);
        delete config.style;
        return _this;
      }
      return _createClass(StatesBitmapText);
    }(PhaserBitmapText);
    Object.assign(StatesBitmapText.prototype, HelperMethods);
  
    ObjectFactory.register('statesBitmapText', function (config) {
      var gameObject = new StatesBitmapText(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.StatesBitmapText', StatesBitmapText);
  
    var SetChart = function SetChart(config) {
      if (!window.Chart) {
        var msg = "Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');";
        console.error(msg);
        return this;
      }
      if (this.chart) {
        this.chart.destroy();
      }
      this.chart = new Chart(this.context, FillConfig(this, config));
      return this;
    };
    var FillConfig = function FillConfig(canvas, config) {
      // Get options
      if (config === undefined) {
        config = {};
      }
      if (config.options === undefined) {
        config.options = {};
      }
      var options = config.options;
  
      // Fill options
      options.responsive = false;
      options.maintainAspectRatio = false;
      if (!options.hasOwnProperty('devicePixelRatio')) {
        options.devicePixelRatio = 1;
      }
  
      // Get animation config
      var noAnimation = false;
      if (options.animation === undefined) {
        options.animation = {};
      } else if (options.animation === false) {
        noAnimation = true;
        options.animation = {};
      }
      var animationConfig = options.animation;
  
      // Fill animation config
      if (noAnimation) {
        animationConfig.duration = 0;
      }
      var onProgress = animationConfig.onProgress;
      animationConfig.onProgress = function (animation) {
        if (onProgress) {
          onProgress(animation);
        }
        canvas.needRedraw();
      };
      var onComplete = animationConfig.onComplete;
      animationConfig.onComplete = function (animation) {
        if (onComplete) {
          onComplete(animation);
        }
        canvas.needRedraw();
      };
      return config;
    };
  
    var GetChartDataset = function GetChartDataset(datasetIndex) {
      if (this.chart === undefined) {
        return undefined;
      }
      if (typeof datasetIndex === 'string') {
        var datasets = this.chart.data.datasets,
          dataset;
        for (var i = 0, cnt = datasets.length; i < cnt; i++) {
          dataset = datasets[i];
          if (dataset.label === datasetIndex) {
            return dataset;
          }
        }
      } else {
        return this.chart.data.datasets[datasetIndex];
      }
      return undefined;
    };
  
    var GetChartData = function GetChartData(datasetIndex, dataIndex) {
      var dataset = this.getChartDataset(datasetIndex);
      if (dataset === undefined) {
        return undefined;
      }
      if (typeof dataIndex === 'string') {
        var labels = this.chart.data.labels;
        dataIndex = labels.indexOf(dataIndex);
        if (dataIndex === -1) {
          return undefined;
        }
      }
      return dataset.data[dataIndex];
    };
  
    var SetChartData = function SetChartData(datasetIndex, dataIndex, value) {
      if (this.chart === undefined) {
        return this;
      }
      var dataset = this.getChartDataset(datasetIndex);
      if (typeof dataIndex === 'string') {
        var labels = this.chart.data.labels;
        dataIndex = labels.indexOf(dataIndex);
        if (dataIndex === -1) {
          return this;
        }
      }
      dataset.data[dataIndex] = value;
      return this;
    };
  
    var UpdateChart = function UpdateChart() {
      if (this.chart === undefined) {
        return this;
      }
      this.chart.update();
      return this;
    };
  
    // This plugin does not contain chart.js
    // Load chart.js in preload stage -
    // scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');
    var Chart$1 = /*#__PURE__*/function (_Canvas) {
      _inherits(Chart, _Canvas);
      function Chart(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, Chart);
        _this = _callSuper(this, Chart, [scene, x, y, width, height]);
        _this.type = 'rexChart';
        _this.chart = undefined;
        if (config !== undefined) {
          _this.setChart(config);
        }
        return _this;
      }
      _createClass(Chart, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene) {
            return;
          }
          if (this.chart) {
            this.chart.destroy();
            this.chart = undefined;
          }
          _get(_getPrototypeOf(Chart.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          if (width === this.width && height === this.height) {
            return this;
          }
          _get(_getPrototypeOf(Chart.prototype), "resize", this).call(this, width, height);
          if (this.chart) {
            var chart = this.chart;
            chart.height = this.canvas.height;
            chart.width = this.canvas.width;
            chart.aspectRatio = chart.height ? chart.width / chart.height : null;
            chart.update();
          }
          return this;
        }
      }]);
      return Chart;
    }(Canvas);
    var methods$k = {
      setChart: SetChart,
      getChartDataset: GetChartDataset,
      getChartData: GetChartData,
      setChartData: SetChartData,
      updateChart: UpdateChart
    };
    Object.assign(Chart$1.prototype, methods$k);
  
    ObjectFactory.register('chart', function (x, y, width, height, config) {
      var gameObject = new Chart$1(this.scene, x, y, width, height, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Chart', Chart$1);
  
    ObjectFactory.register('container', function (x, y, width, height, children) {
      var gameObject = new ContainerLite(this.scene, x, y, width, height, children);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Container', ContainerLite);
  
    ObjectFactory.register('sizer', function (x, y, minWidth, minHeight, orientation, config) {
      var gameObject = new Sizer(this.scene, x, y, minWidth, minHeight, orientation, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Sizer', Sizer);
  
    var Sum = function Sum() {
      return Array.prototype.reduce.call(arguments, Add$5, 0);
    };
    var Add$5 = function Add(a, b) {
      return a + b;
    };
  
    var GetChildrenWidth$2 = function GetChildrenWidth(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var result = 0,
        columnWidth;
      var children = this.sizerChildren;
      var child, padding, childWidth, proportion;
      var hasUnknownChildWidth = false;
      this.totalColumnProportions; // To update this.hasColumnProportion0Child member
  
      for (var i = 0; i < this.columnCount; i++) {
        proportion = this.columnProportions[i];
        columnWidth = 0;
        if (proportion === 0 || minimumMode) {
          for (var j = 0; j < this.rowCount; j++) {
            child = children[j * this.columnCount + i];
            if (!child) {
              continue;
            }
            if (child.rexSizer.hidden) {
              continue;
            }
            childWidth = this.getChildWidth(child);
            if (childWidth === undefined) {
              if (proportion !== 0 && !this.hasColumnProportion0Child) {
                childWidth = 0;
              } else {
                hasUnknownChildWidth = true;
              }
            }
            if (hasUnknownChildWidth) {
              continue;
            }
            padding = child.rexSizer.padding;
            childWidth += padding.left + padding.right;
            columnWidth = Math.max(columnWidth, childWidth);
          }
          if (!hasUnknownChildWidth) {
            result += columnWidth;
          }
        }
  
        // else,(proportion > 0) : columnWidth is 0
        if (!hasUnknownChildWidth) {
          if (minimumMode) {
            this.columnWidth[i] = columnWidth;
          }
        }
      }
      if (hasUnknownChildWidth) {
        return undefined;
      }
      var space = this.space;
      var indentLeft = Math.max(space.indentLeftOdd, space.indentLeftEven);
      return result + Sum.apply(void 0, [space.left, indentLeft].concat(_toConsumableArray(space.column), [space.right]));
    };
  
    var GetChildrenHeight$2 = function GetChildrenHeight(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var result = 0,
        rowHeight;
      var children = this.sizerChildren;
      var child, padding, childHeight, proportion;
      var hasUnknownChildHeight = false;
      this.totalRowProportions; // To update this.hasColumnProportion0Child member
  
      for (var i = 0; i < this.rowCount; i++) {
        proportion = this.rowProportions[i];
        rowHeight = 0;
        if (proportion === 0 || minimumMode) {
          for (var j = 0; j < this.columnCount; j++) {
            child = children[i * this.columnCount + j];
            if (!child) {
              continue;
            }
            if (child.rexSizer.hidden) {
              continue;
            }
            childHeight = this.getChildHeight(child);
            if (childHeight === undefined) {
              if (proportion !== 0 && !this.hasRowProportion0Child) {
                childHeight = 0;
              } else {
                hasUnknownChildHeight = true;
              }
            }
            if (hasUnknownChildHeight) {
              continue;
            }
            padding = child.rexSizer.padding;
            childHeight += padding.top + padding.bottom;
            rowHeight = Math.max(rowHeight, childHeight);
          }
          if (!hasUnknownChildHeight) {
            result += rowHeight;
          }
        }
        // else,(proportion > 0) : rowHeight is 0
  
        if (!hasUnknownChildHeight) {
          if (minimumMode) {
            this.rowHeight[i] = rowHeight;
          }
        }
      }
      if (hasUnknownChildHeight) {
        return undefined;
      }
      var space = this.space;
      var indentTop = Math.max(space.indentTopOdd, space.indentTopEven);
      return result + Sum.apply(void 0, [space.top, indentTop].concat(_toConsumableArray(space.row), [space.bottom]));
    };
  
    var GetExpandedChildWidth = function GetExpandedChildWidth(child, colWidth) {
      var childWidth;
      var childConfig = child.rexSizer;
      if (childConfig.expandWidth) {
        var padding = childConfig.padding;
        childWidth = colWidth - padding.left - padding.right;
      }
      return childWidth;
    };
  
    var GetExpandedChildHeight = function GetExpandedChildHeight(child, rowHeight) {
      var childHeight;
      var childConfig = child.rexSizer;
      if (childConfig.expandHeight) {
        var padding = childConfig.padding;
        childHeight = rowHeight - padding.top - padding.bottom;
      }
      return childHeight;
    };
  
    var GetChildrenSizers$2 = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      var children = this.sizerChildren,
        child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child && child.isRexSizer) {
          out.push(child);
        }
      }
      return out;
    };
  
    var PreLayout$2 = function PreLayout() {
      this._totalColumnProportions = undefined;
      this._totalRowProportions = undefined;
      this.hasColumnProportion0Child = false;
      this.hasRowProportion0Child = false;
      this.proportionWidthLength = undefined;
      this.proportionHeightLength = undefined;
      PreLayout$4.call(this);
      return this;
    };
  
    var LayoutChildren$3 = function LayoutChildren() {
      var child, childConfig, padding;
      var startX = this.innerLeft,
        startY = this.innerTop;
      var itemX,
        itemY = startY;
      var x, y, width, height; // Align zone
      var childWidth, childHeight;
      // Layout grid children
      var columnSpace = this.space.column,
        rowSpace = this.space.row,
        indentLeftOdd = this.space.indentLeftOdd,
        indentLeftEven = this.space.indentLeftEven,
        indentTopOdd = this.space.indentTopOdd,
        indentTopEven = this.space.indentTopEven;
      var colWidth, rowHeight;
      var indentLeft, indentTop;
      for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
        rowHeight = this.getRowHeight(rowIndex);
        indentLeft = rowIndex % 2 ? indentLeftEven : indentLeftOdd;
        itemX = startX + indentLeft;
        for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
          colWidth = this.getColumnWidth(columnIndex);
          child = this.getChildAt(columnIndex, rowIndex);
          if (!child || child.rexSizer.hidden) {
            itemX += colWidth + columnSpace[columnIndex];
            continue;
          }
          PreLayoutChild.call(this, child);
          childWidth = this.getExpandedChildWidth(child, colWidth);
          childHeight = this.getExpandedChildHeight(child, rowHeight);
          if (child.isRexSizer) {
            child.runLayout(this, childWidth, childHeight);
            CheckSize(child, this);
          } else {
            ResizeGameObject(child, childWidth, childHeight);
          }
          childConfig = child.rexSizer;
          padding = childConfig.padding;
          x = itemX + padding.left;
          width = colWidth - padding.left - padding.right;
          indentTop = columnIndex % 2 ? indentTopEven : indentTopOdd;
          y = itemY + indentTop + padding.top;
          height = rowHeight - padding.top - padding.bottom;
          LayoutChild.call(this, child, x, y, width, height, childConfig.align);
          itemX += colWidth + columnSpace[columnIndex];
        }
        itemY += rowHeight + rowSpace[rowIndex];
      }
    };
  
    var ResolveWidth = function ResolveWidth(width) {
      var width = ResolveWidth$3.call(this, width);
  
      // Calculate proportionLength
      if (width !== undefined && this.proportionWidthLength === undefined) {
        var totalColumnProportions = this.totalColumnProportions;
        if (totalColumnProportions > 0) {
          var remainder = width - this.getChildrenWidth(false);
          if (remainder >= 0) {
            this.proportionWidthLength = remainder / totalColumnProportions;
          }
        } else {
          this.proportionWidthLength = 0;
        }
      }
      return width;
    };
  
    var ResolveHeight = function ResolveHeight(height) {
      var height = ResolveHeight$3.call(this, height);
  
      // Get proportionLength    
      if (height !== undefined && this.proportionHeightLength === undefined) {
        var totalRowProportions = this.totalRowProportions;
        if (totalRowProportions > 0) {
          var remainder = height - this.getChildrenHeight(false);
          if (remainder >= 0) {
            this.proportionHeightLength = remainder / totalRowProportions;
          }
        } else {
          this.proportionHeightLength = 0;
        }
      }
      return height;
    };
  
    var ResolveChildrenWidth = function ResolveChildrenWidth(parentWidth) {
      // Resolve width of sizer children
      var child, expandedChildWidth, childWidth;
      var colWidth;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (child && child.isRexSizer && !child.ignoreLayout) {
          colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
          expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
          childWidth = child.resolveWidth(expandedChildWidth);
          if (childWidth === undefined) {
            childWidth = expandedChildWidth;
          }
          child.resolveChildrenWidth(childWidth);
        }
      }
    };
  
    var ResolveChildrenHeight = function ResolveChildrenHeight(parentHeight) {
      // Resolve width of sizer children
      var child, expandedChildHeight, childHeight;
      var rowHeight;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (child && child.isRexSizer && !child.ignoreLayout) {
          rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
          expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
          childHeight = child.resolveHeight(expandedChildHeight);
          if (childHeight === undefined) {
            childHeight = expandedChildHeight;
          }
          child.resolveChildrenHeight(childHeight);
        }
      }
    };
  
    var RunWidthWrap$1 = function RunWidthWrap(width) {
      var child, expandedChildWidth, childWidth;
      var colWidth;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
          continue;
        }
        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
        expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
        if (child.isRexSizer) {
          childWidth = child.resolveWidth(expandedChildWidth);
          if (childWidth === undefined) {
            childWidth = expandedChildWidth;
          }
        }
        child.runWidthWrap(childWidth);
      }
      return this;
    };
  
    var RunHeightWrap$1 = function RunHeightWrap(height) {
      var child, expandedChildHeight, childHeight;
      var rowHeight;
      for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
          continue;
        }
        rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
        expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
        if (child.isRexSizer) {
          childHeight = child.resolveHeight(expandedChildHeight);
          if (childHeight === undefined) {
            childHeight = expandedChildHeight;
          }
        }
        child.runHeightWrap(childHeight);
      }
      return this;
    };
  
    var IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1I = Phaser.Utils.Objects.GetValue;
    var ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;
    var GetEmptyCellIndex = function GetEmptyCellIndex(columnIndex, rowIndex, cells, columnCount, rowCount) {
      if (typeof columnIndex === 'number' || typeof rowIndex === 'number') {
        if (columnIndex === undefined) {
          var idx;
          for (var i = 0; i < columnCount; i++) {
            idx = rowIndex * columnCount + i;
            if (!cells[idx]) {
              return idx;
            }
          }
        } else if (rowIndex === undefined) {
          var idx;
          for (var i = 0; i < rowCount; i++) {
            idx = i * columnCount + columnIndex;
            if (!cells[idx]) {
              return idx;
            }
          }
        } else {
          var idx = rowIndex * columnCount + columnIndex;
          if (!cells[idx]) {
            return idx;
          }
        }
      } else if (rowIndex === true) {
        var idx;
        for (var i = 0; i < columnCount; i++) {
          for (var j = 0; j < rowCount; j++) {
            idx = j * columnCount + i;
            if (!cells[idx]) {
              return idx;
            }
          }
        }
      } else {
        for (var i = 0, cnt = cells.length; i < cnt; i++) {
          if (!cells[i]) {
            return i;
          }
        }
      }
      return null;
    };
    var Add$4 = function Add(gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
      AddChild$1.call(this, gameObject);
      if (IsPlainObject$h(columnIndex)) {
        var config = columnIndex;
        columnIndex = GetValue$1I(config, 'column', undefined);
        rowIndex = GetValue$1I(config, 'row', undefined);
        align = GetValue$1I(config, 'align', ALIGN_CENTER$1);
        paddingConfig = GetValue$1I(config, 'padding', 0);
        expand = GetValue$1I(config, 'expand', false);
        childKey = GetValue$1I(config, 'key', undefined);
      }
  
      // Get insert index
      var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
      if (itemIndex === null) {
        // Specific index mode
        if (typeof columnIndex === 'number' && typeof rowIndex === 'number') {
          return this;
        }
        if (rowIndex === true || typeof rowIndex === 'number') {
          this.addEmptyColumn();
        } else {
          this.addEmptyRow();
        }
  
        // Get insert index again
        itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
      }
      if (typeof align === 'string') {
        align = AlignConst[align];
      }
      if (align === undefined) {
        align = ALIGN_CENTER$1;
      }
      if (paddingConfig === undefined) {
        paddingConfig = 0;
      }
      if (expand === undefined) {
        expand = true;
      }
      var config = this.getSizerConfig(gameObject);
      config.align = align;
      config.padding = GetBoundsConfig(paddingConfig);
      if (IsPlainObject$h(expand)) {
        config.expandWidth = GetValue$1I(expand, 'width', false);
        config.expandHeight = GetValue$1I(expand, 'height', false);
      } else {
        config.expandWidth = expand;
        config.expandHeight = expand;
      }
      this.sizerChildren[itemIndex] = gameObject;
      if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
      }
      return this;
    };
    var AddChildMethods$5 = {
      add: Add$4
    };
  
    var Fill = function Fill(arr, value, startIdx, endIdx) {
      if (startIdx === undefined) {
        startIdx = 0;
      }
      if (endIdx === undefined) {
        endIdx = arr.length - 1;
      }
      for (var i = startIdx; i <= endIdx; i++) {
        arr[i] = value;
      }
      return arr;
    };
  
    var RemoveChildMethods$4 = {
      remove: function remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
          return this;
        }
        var idx = this.sizerChildren.indexOf(gameObject);
        if (idx !== -1) {
          this.sizerChildren[idx] = null;
        }
        RemoveChild.call(this, gameObject, destroyChild);
        return this;
      },
      removeAt: function removeAt(columnIndex, rowIndex, destroyChild) {
        var child = this.getChildAt(columnIndex, rowIndex);
        if (child) {
          this.remove(child, destroyChild);
        }
        return this;
      },
      removeAll: function removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
          var child = this.sizerChildren[i];
          if (!child) {
            continue;
          }
          this.remove(child, destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        Fill(this.sizerChildren, null);
        ClearChildren.call(this, destroyChild);
        return this;
      }
    };
  
    var SetSpaceMethods = {
      setColumnSpace: function setColumnSpace(columnSpace) {
        if (!this.space.column) {
          this.space.column = [];
        }
        this.space.column.length = this.columnCount - 1;
        if (typeof columnSpace === 'number') {
          Fill(this.space.column, columnSpace);
        } else {
          for (var i = 0, cnt = this.columnCount - 1; i < cnt; i++) {
            this.space.column[i] = columnSpace[i] || 0;
          }
        }
        return this;
      },
      setRowSpace: function setRowSpace(rowSpace) {
        if (!this.space.row) {
          this.space.row = [];
        }
        this.space.row.length = this.rowCount - 1;
        if (typeof rowSpace === 'number') {
          Fill(this.space.row, rowSpace);
        } else {
          for (var i = 0, cnt = this.rowCount - 1; i < cnt; i++) {
            this.space.row[i] = rowSpace[i] || 0;
          }
        }
        return this;
      },
      setIndentLeft: function setIndentLeft(odd, even) {
        this.space.indentLeftOdd = odd;
        this.space.indentLeftEven = even;
        return this;
      },
      setIndentTop: function setIndentTop(odd, even) {
        this.space.indentTopOdd = odd;
        this.space.indentTopEven = even;
        return this;
      }
    };
  
    var GetValue$1H = Phaser.Utils.Objects.GetValue;
    var ResetGrid = function ResetGrid(columnCount, rowCount, columnProportions, rowProportions, space) {
      if (columnProportions === undefined) {
        columnProportions = 0;
      }
      if (rowProportions === undefined) {
        rowProportions = 0;
      }
      this.columnCount = columnCount;
      this.rowCount = rowCount;
      this.gridCount = columnCount * rowCount;
  
      // children
      this.removeAll();
      this.sizerChildren.length = columnCount * rowCount;
      Fill(this.sizerChildren, null);
  
      // proportions
      this.columnProportions = [];
      this.columnProportions.length = columnCount;
      if (typeof columnProportions === 'number') {
        Fill(this.columnProportions, columnProportions);
      } else {
        for (var i = 0; i < columnCount; i++) {
          this.columnProportions[i] = columnProportions[i] || 0;
        }
      }
      this.rowProportions = [];
      this.rowProportions.length = rowCount;
      if (typeof rowProportions === 'number') {
        Fill(this.rowProportions, rowProportions);
      } else {
        for (var i = 0; i < rowCount; i++) {
          this.rowProportions[i] = rowProportions[i] || 0;
        }
      }
  
      // width & height
      this.columnWidth = [];
      this.columnWidth.length = columnCount;
      this.rowHeight = [];
      this.rowHeight.length = rowCount;
  
      // space
      this.setColumnSpace(GetValue$1H(space, 'column', 0));
      this.setRowSpace(GetValue$1H(space, 'row', 0));
      var scene = this.scene;
      var createCellContainerCallback = this.createCellContainerCallback;
      if (createCellContainerCallback) {
        for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
          for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
            var addConfig = {
              column: x,
              row: y
            };
            var child = createCellContainerCallback(scene, x, y, addConfig);
            if (child) {
              this.add(child, addConfig);
            }
          }
        }
      }
      return this;
    };
  
    var InseryEmptyRow = function InseryEmptyRow(rowIndex, proportion, space) {
      if (proportion === undefined) {
        proportion = this.rowProportions[0] || 0;
      }
      if (space === undefined) {
        space = this.space.row[0] || 0;
      }
      this.rowCount += 1;
      this.gridCount += this.columnCount;
      var args = [rowIndex * this.columnCount, 0];
      for (var i = 0; i < this.columnCount; i++) {
        args.push(null);
      }
      this.sizerChildren.splice.apply(this.sizerChildren, args);
      this.rowProportions.push(proportion);
      this.rowHeight.length += 1; // this.rowHeight will be recalculated when layout()    
  
      this.space.row.splice(rowIndex, 0, space);
      return this;
    };
    var AddEmptyRow = function AddEmptyRow(proportion, space) {
      InseryEmptyRow.call(this, this.rowCount, proportion, space);
      return this;
    };
  
    var InsertEmptyColumn = function InsertEmptyColumn(colIndex, proportion, space) {
      if (proportion === undefined) {
        proportion = this.columnProportions[0] || 0;
      }
      if (space === undefined) {
        space = this.space.column[0] || 0;
      }
      this.columnCount += 1;
      this.gridCount += this.rowCount;
      for (var i = this.rowCount - 1; i >= 0; i--) {
        var insertIndex = i * this.columnCount + colIndex;
        this.sizerChildren.splice(insertIndex, 0, null);
      }
      this.columnProportions.push(proportion);
      this.columnWidth.length += 1; // this.columnWidth will be recalculated when layout()    
  
      this.space.column.splice(colIndex, 0, space);
      return this;
    };
    var AddEmptyColumn = function AddEmptyColumn(proportion, space) {
      InsertEmptyColumn.call(this, this.columnCount, proportion, space);
      return this;
    };
  
    var methods$j = {
      getChildrenWidth: GetChildrenWidth$2,
      getChildrenHeight: GetChildrenHeight$2,
      getExpandedChildWidth: GetExpandedChildWidth,
      getExpandedChildHeight: GetExpandedChildHeight,
      getChildrenSizers: GetChildrenSizers$2,
      preLayout: PreLayout$2,
      layoutChildren: LayoutChildren$3,
      resolveWidth: ResolveWidth,
      resolveHeight: ResolveHeight,
      resolveChildrenWidth: ResolveChildrenWidth,
      resolveChildrenHeight: ResolveChildrenHeight,
      runWidthWrap: RunWidthWrap$1,
      runHeightWrap: RunHeightWrap$1,
      resetGrid: ResetGrid,
      inseryEmptyRow: InseryEmptyRow,
      addEmptyRow: AddEmptyRow,
      insertEmptyColumn: InsertEmptyColumn,
      addEmptyColumn: AddEmptyColumn
    };
    Object.assign(methods$j, AddChildMethods$5, RemoveChildMethods$4, SetSpaceMethods, SortChildrenMethods);
  
    var GetTotalColumnProportions = function GetTotalColumnProportions() {
      var result = 0,
        proportion;
      for (var i = 0; i < this.columnCount; i++) {
        proportion = this.columnProportions[i];
        if (proportion > 0) {
          result += proportion;
        } else if (proportion === 0) {
          this.hasColumnProportion0Child = true;
        }
      }
      return result;
    };
  
    var GetTotalRowProportions = function GetTotalRowProportions() {
      var result = 0,
        proportion;
      for (var i = 0; i < this.rowCount; i++) {
        proportion = this.rowProportions[i];
        if (proportion > 0) {
          result += proportion;
        } else if (proportion === 0) {
          this.hasRowProportion0Child = true;
        }
      }
      return result;
    };
  
    var IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1G = Phaser.Utils.Objects.GetValue;
    var GridSizer = /*#__PURE__*/function (_BaseSizer) {
      _inherits(GridSizer, _BaseSizer);
      function GridSizer(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
        var _this;
        _classCallCheck(this, GridSizer);
        if (IsPlainObject$g(x)) {
          config = x;
          x = GetValue$1G(config, 'x', 0);
          y = GetValue$1G(config, 'y', 0);
          minWidth = GetValue$1G(config, 'width', undefined);
          minHeight = GetValue$1G(config, 'height', undefined);
          columnCount = GetValue$1G(config, 'column', config.col || 0);
          rowCount = GetValue$1G(config, 'row', 0);
          columnProportions = GetValue$1G(config, 'columnProportions', 0);
          rowProportions = GetValue$1G(config, 'rowProportions', 0);
        } else if (IsPlainObject$g(minWidth)) {
          config = minWidth;
          minWidth = GetValue$1G(config, 'width', undefined);
          minHeight = GetValue$1G(config, 'height', undefined);
          columnCount = GetValue$1G(config, 'column', config.col || 0);
          rowCount = GetValue$1G(config, 'row', 0);
          columnProportions = GetValue$1G(config, 'columnProportions', 0);
          rowProportions = GetValue$1G(config, 'rowProportions', 0);
        } else if (IsPlainObject$g(columnCount)) {
          config = columnCount;
          columnCount = GetValue$1G(config, 'column', config.col || 0);
          rowCount = GetValue$1G(config, 'row', 0);
          columnProportions = GetValue$1G(config, 'columnProportions', 0);
          rowProportions = GetValue$1G(config, 'rowProportions', 0);
        } else if (IsPlainObject$g(columnProportions)) {
          config = columnProportions;
          columnProportions = GetValue$1G(config, 'columnProportions', 0);
          rowProportions = GetValue$1G(config, 'rowProportions', 0);
        }
        _this = _callSuper(this, GridSizer, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexGridSizer';
        _this.sizerChildren = [];
        _this.addChildrenMap('items', _this.sizerChildren);
        _this.setCreateCellContainerCallback(GetValue$1G(config, 'createCellContainerCallback'));
        _this.setIndentLeft(GetValue$1G(config, 'space.indentLeftOdd', 0), GetValue$1G(config, 'space.indentLeftEven', 0));
        _this.setIndentTop(GetValue$1G(config, 'space.indentTopOdd', 0), GetValue$1G(config, 'space.indentTopEven', 0));
        _this.resetGrid(columnCount, rowCount, columnProportions, rowProportions, GetValue$1G(config, 'space', undefined));
        return _this;
      }
      _createClass(GridSizer, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(GridSizer.prototype), "destroy", this).call(this, fromScene);
  
          // More free resources
          this.columnProportions = undefined;
          this.rowProportions = undefined;
          this.columnWidth = undefined;
          this.rowHeight = undefined;
          this.createCellContainerCallback = undefined;
        }
      }, {
        key: "setColumnProportion",
        value: function setColumnProportion(columnIndex, proportion) {
          if (columnIndex >= this.columnProportions.length) {
            return this;
          }
          this.columnProportions[columnIndex] = proportion;
          return this;
        }
      }, {
        key: "setRowProportion",
        value: function setRowProportion(rowIndex, proportion) {
          if (rowIndex >= this.rowProportions.length) {
            return this;
          }
          this.rowProportions[rowIndex] = proportion;
          return this;
        }
      }, {
        key: "totalColumnProportions",
        get: function get() {
          if (this._totalColumnProportions === undefined) {
            this._totalColumnProportions = GetTotalColumnProportions.call(this);
          }
          return this._totalColumnProportions;
        }
      }, {
        key: "totalRowProportions",
        get: function get() {
          if (this._totalRowProportions === undefined) {
            this._totalRowProportions = GetTotalRowProportions.call(this);
          }
          return this._totalRowProportions;
        }
      }, {
        key: "getChildAt",
        value: function getChildAt(columnIndex, rowIndex) {
          return this.sizerChildren[rowIndex * this.columnCount + columnIndex];
        }
      }, {
        key: "childToGridIndex",
        value: function childToGridIndex(child, out) {
          if (!child) {
            return null;
          }
          var index = this.sizerChildren.indexOf(child);
          if (index === -1) {
            return null;
          }
          if (out === undefined) {
            out = {};
          }
          out.x = index % this.columnCount;
          out.y = Math.floor(index / this.columnCount);
          return out;
        }
      }, {
        key: "getColumnWidth",
        value: function getColumnWidth(columnIndex) {
          var colProportion = this.columnProportions[columnIndex];
          var colWidth = colProportion === 0 ? this.columnWidth[columnIndex] : colProportion * this.proportionWidthLength;
          return colWidth;
        }
      }, {
        key: "getRowHeight",
        value: function getRowHeight(rowIndex) {
          var rowProportion = this.rowProportions[rowIndex];
          var rowHeight = rowProportion === 0 ? this.rowHeight[rowIndex] : rowProportion * this.proportionHeightLength;
          return rowHeight;
        }
      }, {
        key: "setCreateCellContainerCallback",
        value: function setCreateCellContainerCallback(callback) {
          this.createCellContainerCallback = callback;
          return this;
        }
      }]);
      return GridSizer;
    }(Base);
    Object.assign(GridSizer.prototype, methods$j);
  
    ObjectFactory.register('gridSizer', function (x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config) {
      var gameObject = new GridSizer(this.scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.GridSizer', GridSizer);
  
    var GetChildrenWidth$1 = function GetChildrenWidth(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var childrenWidth;
      if (this.orientation === 0) {
        if (minimumMode) {
          childrenWidth = this.maxChildWidth;
        } else {
          childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : undefined;
        }
      } else {
        childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : undefined;
      }
      if (childrenWidth === undefined) {
        return undefined;
      }
      return childrenWidth + this.space.left + this.space.right;
    };
  
    var GetChildrenHeight$1 = function GetChildrenHeight(minimumMode) {
      if (this.rexSizer.hidden) {
        return 0;
      }
      if (minimumMode === undefined) {
        minimumMode = true;
      }
      var childrenHeight;
      if (this.orientation === 1) {
        if (minimumMode) {
          childrenHeight = this.maxChildHeight;
        } else {
          childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : undefined;
        }
      } else {
        childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : undefined;
      }
      if (childrenHeight === undefined) {
        return undefined;
      }
      return childrenHeight + this.space.top + this.space.bottom;
    };
  
    var GetChildrenSizers$1 = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      var children = this.sizerChildren,
        child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
          continue;
        }
        if (child.isRexSizer) {
          out.push(child);
        }
      }
      return out;
    };
  
    var PreLayout$1 = function PreLayout() {
      this._maxChildWidth = undefined;
      this._maxChildHeight = undefined;
      this.wrapResult = undefined;
      this.rexSizer.resolved = false;
      PreLayout$4.call(this);
      return this;
    };
  
    var LayoutChildren$2 = function LayoutChildren() {
      var horizontalWrap = this.orientation === 0;
      var innerLineWidth = horizontalWrap ? this.innerWidth : this.innerHeight;
      var justifyPercentage = this.justifyPercentage;
      var itemSpace = this.space.item,
        lineSpace = this.space.line,
        indentLeftOdd = this.space.indentLeftOdd,
        indentLeftEven = this.space.indentLeftEven,
        indentTopOdd = this.space.indentTopOdd,
        indentTopEven = this.space.indentTopEven;
      var child,
        childConfig,
        padding,
        justifySpace = 0,
        indentLeft,
        indentTop;
      var startX = this.innerLeft,
        startY = this.innerTop;
      var x, y, width, height; // Align zone
      var lines = this.wrapResult.lines; // Get this.wrapResult from RunChildrenWrap()
      var line, lineChlidren, remainderLineWidth;
      var itemX = startX,
        itemY = startY;
      for (var i = 0, icnt = lines.length; i < icnt; i++) {
        // Layout this line
        line = lines[i];
        lineChlidren = line.children;
        if (this.rtl) {
          lineChlidren.reverse();
        }
        if (horizontalWrap) {
          indentLeft = i % 2 ? indentLeftEven : indentLeftOdd;
          itemX = startX + indentLeft;
        } else {
          indentTop = i % 2 ? indentTopEven : indentTopOdd;
          itemY = startY + indentTop;
        }
        remainderLineWidth = innerLineWidth - (horizontalWrap ? line.width : line.height);
        switch (this.align) {
          case 0:
            // left
            break;
          case 1:
            // right
            if (horizontalWrap) {
              itemX += remainderLineWidth;
            } else {
              itemY += remainderLineWidth;
            }
            break;
          case 2:
            // center
            if (horizontalWrap) {
              itemX += remainderLineWidth / 2;
            } else {
              itemY += remainderLineWidth / 2;
            }
            break;
          case 3:
            // justify-left            
            justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
            break;
          case 4:
            // justify-right
            justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
            if (justifySpace === 0) {
              // Align right
              if (horizontalWrap) {
                itemX += remainderLineWidth;
              } else {
                itemY += remainderLineWidth;
              }
            }
            break;
          case 5:
            // justify-center
            justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
            if (justifySpace === 0) {
              // Align center
              if (horizontalWrap) {
                itemX += remainderLineWidth / 2;
              } else {
                itemY += remainderLineWidth / 2;
              }
            }
            break;
        }
        var isFirstChild = true;
        for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
          child = lineChlidren[j];
          if (child.rexSizer.hidden) {
            continue;
          }
          childConfig = child.rexSizer;
          padding = childConfig.padding;
          PreLayoutChild.call(this, child);
          if (horizontalWrap) {
            x = itemX + padding.left;
          } else {
            y = itemY + padding.top;
          }
          if (isFirstChild) {
            isFirstChild = false;
          } else {
            if (horizontalWrap) {
              x += itemSpace;
            } else {
              y += itemSpace;
            }
          }
          width = GetDisplayWidth(child);
          height = GetDisplayHeight(child);
          if (horizontalWrap) {
            indentTop = j % 2 ? indentTopEven : indentTopOdd;
            y = itemY + indentTop + padding.top;
            itemX = x + width + padding.right + justifySpace;
          } else {
            indentLeft = j % 2 ? indentLeftEven : indentLeftOdd;
            x = itemX + indentLeft + padding.left;
            itemY = y + height + padding.top + justifySpace;
          }
          LayoutChild.call(this, child, x, y, width, height, childConfig.align);
        }
        if (horizontalWrap) {
          itemY += line.height + lineSpace;
        } else {
          itemX += line.width + lineSpace;
        }
      }
    };
    var GetJustifySpace = function GetJustifySpace(total, remainder, justifyPercentage, childCount) {
      return remainder / total <= justifyPercentage ? remainder / (childCount - 1) : 0;
    };
  
    var HasWidthWrap = function HasWidthWrap() {
      if (this.orientation === 0) {
        return true;
      }
      return HasWidthWrap$2.call(this);
    };
  
    var RunChildrenWrap = function RunChildrenWrap(lineWidth) {
      var out = {
        lines: [],
        width: 0,
        height: 0
      };
      var children = this.sizerChildren;
      var itemSpace = this.space.item,
        lineSpace = this.space.line,
        indentLeftOdd = this.space.indentLeftOdd,
        indentLeftEven = this.space.indentLeftEven,
        indentTopOdd = this.space.indentTopOdd,
        indentTopEven = this.space.indentTopEven;
      var child,
        padding,
        childWidth,
        childHeight,
        remainder = 0,
        indentLeft,
        indentTop;
      var lines = out.lines,
        lastLine = undefined,
        newLine;
      if (this.orientation === 0) {
        // x
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (child === '\n') {
            child = undefined;
            childWidth = 0;
            newLine = true;
          } else {
            if (child.rexSizer.hidden) {
              continue;
            }
            if (child.isRexSizer) {
              child.layout(); // Use original size
            }
            childWidth = this.getChildWidth(child);
            padding = child.rexSizer.padding;
            childWidth += padding.left + padding.right;
            newLine = remainder < childWidth || lastLine === undefined;
          }
          // New line
          if (newLine) {
            if (lastLine) {
              lastLine.width = lineWidth - (remainder + itemSpace);
              out.width = Math.max(out.width, lastLine.width);
              out.height += lastLine.height + lineSpace;
            }
            lastLine = {
              children: [],
              width: 0,
              height: 0
            };
            lines.push(lastLine);
            indentLeft = lines.length % 2 ? indentLeftOdd : indentLeftEven;
            remainder = lineWidth - indentLeft;
          }
          remainder -= childWidth + itemSpace;
          if (child) {
            lastLine.children.push(child);
            childHeight = this.getChildHeight(child);
            padding = child.rexSizer.padding;
            childHeight += padding.top + padding.bottom;
            lastLine.height = Math.max(lastLine.height, childHeight);
          }
        }
        if (lastLine) {
          lastLine.width = lineWidth - (remainder + itemSpace);
          out.width = Math.max(out.width, lastLine.width);
          out.height += lastLine.height;
        }
        out.height += Math.max(indentTopOdd, indentTopEven);
      } else {
        var lineHeight = lineWidth;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = children[i];
          if (child === '\n') {
            child = undefined;
            childWidth = 0;
            newLine = true;
          } else {
            if (child.rexSizer.hidden) {
              continue;
            }
            if (child.isRexSizer) {
              child.layout(); // Use original size
            }
            childHeight = this.getChildHeight(child);
            padding = child.rexSizer.padding;
            childHeight += padding.top + padding.bottom;
            newLine = remainder < childHeight || lastLine === undefined;
          }
          // New line
          if (newLine) {
            if (lastLine) {
              lastLine.height = lineHeight - (remainder + itemSpace);
              out.height = Math.max(out.height, lastLine.height);
              out.width += lastLine.width + lineSpace;
            }
            lastLine = {
              children: [],
              width: 0,
              height: 0
            };
            lines.push(lastLine);
            indentTop = lines.length % 2 ? indentTopOdd : indentTopEven;
            remainder = lineHeight - indentTop;
          }
          remainder -= childHeight + itemSpace;
          if (child) {
            lastLine.children.push(child);
            childWidth = this.getChildWidth(child);
            padding = child.rexSizer.padding;
            childWidth += padding.left + padding.right;
            lastLine.width = Math.max(lastLine.width, childWidth);
          }
        }
        if (lastLine) {
          lastLine.height = lineHeight - (remainder + itemSpace);
          out.height = Math.max(out.height, lastLine.height);
          out.width += lastLine.width;
        }
        out.width += Math.max(indentLeftOdd, indentLeftEven);
      }
      return out;
    };
  
    var RunWidthWrap = function RunWidthWrap(width) {
      if (this.wrapResult) {
        // Already got wrapResult
        return;
      }
      if (this.orientation === 0) {
        var innerWidth = width - this.space.left - this.space.right;
        this.wrapResult = RunChildrenWrap.call(this, innerWidth);
        this.rexSizer.resolved = true;
        RunWidthWrap$3.call(this, width);
      }
    };
  
    var HasHeightWrap = function HasHeightWrap() {
      if (this.orientation === 1) {
        return true;
      }
      return HasHeightWrap$2.call(this);
    };
  
    var RunHeightWrap = function RunHeightWrap(height) {
      if (this.wrapResult) {
        // Already got wrapResult
        return;
      }
      if (this.orientation === 1) {
        var innerHeight = height - this.space.top - this.space.bottom;
        this.wrapResult = RunChildrenWrap.call(this, innerHeight);
        this.rexSizer.resolved = true;
        RunHeightWrap$3.call(this, height);
      }
    };
  
    var DistanceBetween$2 = Phaser.Math.Distance.Between;
    var GetNearestChildIndex = function GetNearestChildIndex(x, y) {
      var children = this.sizerChildren;
      if (children.length === 0) {
        return -1;
      }
      var nearestIndex = -1,
        minDistance = Infinity;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        // position is not at this line
        if (Math.abs(child.centerY - y) > child.height / 2) {
          continue;
        }
  
        // Check left bound
        var distance = DistanceBetween$2(child.left, child.centerY, x, y);
        if (minDistance > distance) {
          minDistance = distance;
          nearestIndex = i;
        }
  
        // Is last child of this line
        var nextChild = children[i + 1];
        if (nextChild && nextChild.y === child.y) {
          continue;
        }
        var distance = DistanceBetween$2(child.right, child.centerY, x, y);
        if (minDistance > distance) {
          minDistance = distance;
          nearestIndex = i + 1;
        }
      }
      return nearestIndex;
    };
  
    var IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1F = Phaser.Utils.Objects.GetValue;
    var ALIGN_CENTER = Phaser.Display.Align.CENTER;
    var Add$3 = function Add(gameObject, paddingConfig, childKey, index) {
      if (gameObject === '\n') {
        this.addNewLine();
        return this;
      }
      AddChild$1.call(this, gameObject);
      if (IsPlainObject$f(paddingConfig)) {
        var config = paddingConfig;
        paddingConfig = GetValue$1F(config, 'padding', 0);
        childKey = GetValue$1F(config, 'key', undefined);
        index = GetValue$1F(config, 'index', undefined);
      }
      if (paddingConfig === undefined) {
        paddingConfig = 0;
      }
      var config = this.getSizerConfig(gameObject);
      config.align = ALIGN_CENTER;
      config.padding = GetBoundsConfig(paddingConfig);
      if (index === undefined || index >= this.sizerChildren.length) {
        this.sizerChildren.push(gameObject);
      } else {
        this.sizerChildren.splice(index, 0, gameObject);
      }
      if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
      }
      return this;
    };
    var AddChildMethods$4 = {
      add: function add(gameObject, paddingConfig, childKey) {
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add$3.call(this, gameObjects[i], paddingConfig);
          }
        } else {
          Add$3.call(this, gameObject, paddingConfig, childKey);
        }
        return this;
      },
      addNewLine: function addNewLine() {
        this.sizerChildren.push('\n');
        return this;
      },
      insert: function insert(index, gameObject, paddingConfig, childKey) {
        Add$3.call(this, gameObject, paddingConfig, childKey, index);
        return this;
      },
      insertAtPosition: function insertAtPosition(x, y, gameObject, paddingConfig, childKey) {
        var index = GetNearestChildIndex.call(this, x, y);
        if (index === -1) {
          index = undefined;
        }
        this.insert(index, gameObject, paddingConfig, childKey);
        return this;
      }
    };
  
    var RemoveItem$1 = Phaser.Utils.Array.Remove;
    var RemoveChildMethods$3 = {
      remove: function remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
          return this;
        }
        RemoveItem$1(this.sizerChildren, gameObject);
        RemoveChild.call(this, gameObject, destroyChild);
        return this;
      },
      removeAll: function removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
          this.remove(this.sizerChildren[i], destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        this.sizerChildren.length = 0;
        ClearChildren.call(this, destroyChild);
        return this;
      }
    };
  
    var methods$i = {
      getChildrenWidth: GetChildrenWidth$1,
      getChildrenHeight: GetChildrenHeight$1,
      getChildrenSizers: GetChildrenSizers$1,
      preLayout: PreLayout$1,
      layoutChildren: LayoutChildren$2,
      hasWidthWrap: HasWidthWrap,
      runWidthWrap: RunWidthWrap,
      hasHeightWrap: HasHeightWrap,
      runHeightWrap: RunHeightWrap
    };
    Object.assign(methods$i, AddChildMethods$4, RemoveChildMethods$3, SortChildrenMethods);
  
    var GetMaxChildWidth = function GetMaxChildWidth(children) {
      if (children === undefined) {
        children = this.sizerChildren;
      }
      var result = 0;
      var child, childWidth;
      var hasUnknownChildWidth = false;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
          continue;
        }
        childWidth = this.getChildWidth(child);
        if (childWidth === undefined) {
          hasUnknownChildWidth = true;
        }
        if (hasUnknownChildWidth) {
          continue;
        }
        result = Math.max(childWidth, result);
      }
      if (hasUnknownChildWidth) {
        return undefined;
      }
      return result;
    };
  
    var GetMaxChildHeight = function GetMaxChildHeight(children) {
      if (children === undefined) {
        children = this.sizerChildren;
      }
      var result = 0;
      var child, childHeight;
      var hasUnknownChildHeight = false;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
          continue;
        }
        childHeight = this.getChildHeight(child);
        if (childHeight === undefined) {
          hasUnknownChildHeight = true;
        }
        if (hasUnknownChildHeight) {
          continue;
        }
        result = Math.max(childHeight, result);
      }
      if (hasUnknownChildHeight) {
        return undefined;
      }
      return result;
    };
  
    var IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1E = Phaser.Utils.Objects.GetValue;
    var FixWidthSizer = /*#__PURE__*/function (_BaseSizer) {
      _inherits(FixWidthSizer, _BaseSizer);
      function FixWidthSizer(scene, x, y, minWidth, minHeight, config) {
        var _this;
        _classCallCheck(this, FixWidthSizer);
        if (IsPlainObject$e(x)) {
          config = x;
          x = GetValue$1E(config, 'x', 0);
          y = GetValue$1E(config, 'y', 0);
          minWidth = GetValue$1E(config, 'width', undefined);
          minHeight = GetValue$1E(config, 'height', undefined);
        } else if (IsPlainObject$e(minWidth)) {
          config = minWidth;
          minWidth = GetValue$1E(config, 'width', undefined);
          minHeight = GetValue$1E(config, 'height', undefined);
        }
        _this = _callSuper(this, FixWidthSizer, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexFixWidthSizer';
        _this.sizerChildren = [];
        _this.setOrientation(GetValue$1E(config, 'orientation', 0));
        _this.setItemSpacing(GetValue$1E(config, 'space.item', 0));
        _this.setLineSpacing(GetValue$1E(config, 'space.line', 0));
        _this.setIntentLeft(GetValue$1E(config, 'space.indentLeftOdd', 0), GetValue$1E(config, 'space.indentLeftEven', 0));
        _this.setIntentTop(GetValue$1E(config, 'space.indentTopOdd', 0), GetValue$1E(config, 'space.indentTopEven', 0));
        _this.setAlign(GetValue$1E(config, 'align', 0));
        _this.setJustifyPercentage(GetValue$1E(config, 'justifyPercentage', 0.25));
        _this.setRTL(GetValue$1E(config, 'rtl', false));
        _this.wrapResult = undefined; // {lines, width, height}
  
        _this.addChildrenMap('items', _this.sizerChildren);
        return _this;
      }
      _createClass(FixWidthSizer, [{
        key: "setOrientation",
        value: function setOrientation(orientation) {
          this.orientation = GetOrientationMode(orientation);
          return this;
        }
      }, {
        key: "setItemSpacing",
        value: function setItemSpacing(space) {
          this.space.item = space;
          return this;
        }
      }, {
        key: "setLineSpacing",
        value: function setLineSpacing(space) {
          this.space.line = space;
          return this;
        }
      }, {
        key: "setIntentLeft",
        value: function setIntentLeft(odd, even) {
          this.space.indentLeftOdd = odd;
          this.space.indentLeftEven = even;
          return this;
        }
      }, {
        key: "setIntentTop",
        value: function setIntentTop(odd, even) {
          this.space.indentTopOdd = odd;
          this.space.indentTopEven = even;
          return this;
        }
      }, {
        key: "setAlign",
        value: function setAlign(align) {
          if (typeof align === 'string') {
            align = ALIGN[align];
          }
          this.align = align;
          return this;
        }
      }, {
        key: "setJustifyPercentage",
        value: function setJustifyPercentage(value) {
          this.justifyPercentage = value;
          return this;
        }
      }, {
        key: "setRTL",
        value: function setRTL(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.rtl = enabled;
          return this;
        }
      }, {
        key: "maxChildWidth",
        get: function get() {
          if (this._maxChildWidth === undefined) {
            this._maxChildWidth = GetMaxChildWidth.call(this);
          }
          return this._maxChildWidth;
        }
      }, {
        key: "maxChildHeight",
        get: function get() {
          if (this._maxChildHeight === undefined) {
            this._maxChildHeight = GetMaxChildHeight.call(this);
          }
          return this._maxChildHeight;
        }
      }]);
      return FixWidthSizer;
    }(Base);
    var ALIGN = {
      left: 0,
      top: 0,
      right: 1,
      bottom: 1,
      center: 2,
      justify: 3,
      'justify-left': 3,
      'justify-top': 3,
      'justify-right': 4,
      'justify-bottom': 4,
      'justify-center': 5
    };
    Object.assign(FixWidthSizer.prototype, methods$i);
  
    ObjectFactory.register('fixWidthSizer', function (x, y, minWidth, minHeight, config) {
      var gameObject = new FixWidthSizer(this.scene, x, y, minWidth, minHeight, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FixWidthSizer', FixWidthSizer);
  
    ObjectFactory.register('overlapSizer', function (x, y, minWidth, minHeight, config) {
      var gameObject = new OverlapSizer(this.scene, x, y, minWidth, minHeight, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.OverlapSizer', OverlapSizer);
  
    ObjectFactory.register('space', function () {
      var gameObject = new Space(this.scene);
      // Don't add Zone into scene
      // this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Space', Space);
  
    ObjectFactory.register('label', function (config) {
      var gameObject = new Label(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Label', Label);
  
    var Properties = ['alpha', 'tint', 'flipX', 'flipY'];
    var DecorateGameObject = function DecorateGameObject(gameObject, config) {
      if (!config) {
        return gameObject;
      }
      for (var i = 0, cnt = Properties.length; i < cnt; i++) {
        var propertyName = Properties[i];
        if (propertyName in config && propertyName in gameObject) {
          gameObject[propertyName] = config[propertyName];
        }
      }
      if ('origin' in config && 'originX' in gameObject) {
        gameObject.setOrigin(config.origin);
      } else {
        var originX, originY;
        if ('originX' in config && 'originX' in gameObject) {
          originX = config.originX;
        }
        if ('originY' in config && 'originY' in gameObject) {
          originY = config.originY;
        }
        if (originX !== undefined && originY !== undefined) {
          gameObject.setOrigin(originX, originY);
        }
      }
      return gameObject;
    };
  
    var CreateBackground$2 = function CreateBackground(scene, config) {
      var gameObjectType;
      if (config) {
        if (config.hasOwnProperty('$type')) {
          gameObjectType = config.$type;
        } else {
          if (config.hasOwnProperty('leftWidth')) {
            gameObjectType = 'nineSlice';
          } else if (config.hasOwnProperty('key')) {
            gameObjectType = 'image';
          }
        }
      }
      var gameObject;
      switch (gameObjectType) {
        case 'image':
          gameObject = new StatesImage(scene, config);
          break;
        case 'nineSlice':
          if (!config.hasOwnProperty('stretchMode')) {
            gameObject = new StatesNineSlice(scene, config);
          } else {
            gameObject = new StatesNinePatch(scene, config);
          }
          break;
        default:
          gameObject = new StatesRoundRectangle(scene, config);
          break;
      }
      DecorateGameObject(gameObject, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var SCROLLMODE$1 = {
      v: 0,
      vertical: 0,
      y: 0,
      h: 1,
      horizontal: 1,
      x: 1,
      xy: 2,
      vh: 2
    };
  
    var GetScrollMode = function GetScrollMode(config, key) {
      if (key === undefined) {
        key = 'scrollMode';
      }
      if (!config.hasOwnProperty(key)) {
        config[key] = GetDefaultScrollMode(config);
      }
      var scrollMode = config[key];
      if (typeof scrollMode === 'string') {
        scrollMode = SCROLLMODE$1[scrollMode];
      }
      return scrollMode;
    };
    var GetDefaultScrollMode = function GetDefaultScrollMode(config) {
      var hasSliderY = !!config.sliderY || !!config.scrollerY;
      var hasSliderX = !!config.sliderX || !!config.scrollerX;
      var scrollMode;
      if (hasSliderY && hasSliderX) {
        scrollMode = 2;
      } else if (hasSliderY) {
        scrollMode = 0;
      } else if (hasSliderX) {
        scrollMode = 1;
      } else {
        scrollMode = 0;
      }
      return scrollMode;
    };
  
    var GetValue$1D = Phaser.Utils.Objects.GetValue;
    var AddChild = function AddChild(topPatent, childParent, config) {
      var childConfig = GetValue$1D(config, 'child');
      var child = GetValue$1D(childConfig, 'gameObject', undefined);
      if (child) {
        var childSpace = GetValue$1D(config, 'space.child', 0);
        topPatent.childMargin = {};
        var childMargin = topPatent.childMargin;
        var childPadding = {};
        if (typeof childSpace === 'number') {
          // Legacy, add childSpace to slider
          switch (topPatent.scrollMode) {
            case 0:
            case 1:
              childMargin.top = 0;
              childMargin.bottom = 0;
              childMargin.left = 0;
              childMargin.right = 0;
              break;
            default:
              childMargin.top = childSpace;
              childMargin.bottom = childSpace;
              childMargin.left = childSpace;
              childMargin.right = childSpace;
              break;
          }
        } else {
          switch (topPatent.scrollMode) {
            case 0:
              childMargin.top = GetValue$1D(childSpace, 'top', 0);
              childMargin.bottom = GetValue$1D(childSpace, 'bottom', 0);
              childPadding.left = GetValue$1D(childSpace, 'left', 0);
              childPadding.right = GetValue$1D(childSpace, 'right', 0);
              break;
            case 1:
              childMargin.top = GetValue$1D(childSpace, 'left', 0);
              childMargin.bottom = GetValue$1D(childSpace, 'right', 0);
              childPadding.top = GetValue$1D(childSpace, 'top', 0);
              childPadding.bottom = GetValue$1D(childSpace, 'bottom', 0);
              break;
            default:
              // 2
              childMargin.top = GetValue$1D(childSpace, 'top', 0);
              childMargin.bottom = GetValue$1D(childSpace, 'bottom', 0);
              childMargin.left = GetValue$1D(childSpace, 'left', 0);
              childMargin.right = GetValue$1D(childSpace, 'right', 0);
              break;
          }
        }
        childParent.add(child, {
          column: 1,
          row: 1,
          align: GetValue$1D(childConfig, 'align', 'center'),
          padding: childPadding,
          expand: {
            width: GetValue$1D(childConfig, 'expandWidth', true),
            // Private
            height: GetValue$1D(childConfig, 'expandHeight', true) // Private
          }
        });
      }
      topPatent.addChildrenMap('child', child);
    };
  
    var Percent$3 = Phaser.Math.Percent;
    var PositionToPercent = function PositionToPercent(startPoint, endPoint, currentPoint) {
      var value;
      if (startPoint.y === endPoint.y) {
        value = Percent$3(currentPoint.x, startPoint.x, endPoint.x);
      } else if (startPoint.x === endPoint.x) {
        value = Percent$3(currentPoint.y, startPoint.y, endPoint.y);
      }
      return value;
    };
  
    var OnDragThumb = function OnDragThumb(pointer, dragX, dragY) {
      if (!this.enable) {
        return;
      }
      tmpPoint$4.x = dragX;
      tmpPoint$4.y = dragY;
      var startPoint, endPoint;
      if (!this.reverseAxis) {
        startPoint = this.getStartPoint();
        endPoint = this.getEndPoint();
      } else {
        startPoint = this.getEndPoint();
        endPoint = this.getStartPoint();
      }
      this.value = PositionToPercent(startPoint, endPoint, tmpPoint$4);
    };
    var tmpPoint$4 = {};
  
    var OnTouchTrack = function OnTouchTrack(pointer, localX, localY) {
      if (!this.enable) {
        return;
      }
      if (!pointer.isDown) {
        return;
      }
      tmpPoint$3.x = pointer.worldX;
      tmpPoint$3.y = pointer.worldY;
      var startPoint, endPoint;
      if (!this.reverseAxis) {
        startPoint = this.getStartPoint();
        endPoint = this.getEndPoint();
      } else {
        startPoint = this.getEndPoint();
        endPoint = this.getStartPoint();
      }
      var value = PositionToPercent(startPoint, endPoint, tmpPoint$3);
      this.stopEaseValue();
      if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
        this.value = value;
      } else {
        this.easeValueTo(value);
      }
    };
    var tmpPoint$3 = {};
  
    var GetThumbAlignPoint = function GetThumbAlignPoint(align, out) {
      if (out === undefined) {
        out = tmpPoint$2;
      }
      var thumb = this.childrenMap.thumb;
      var currentX = thumb.x;
      var currentY = thumb.y;
      AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
      out.x = thumb.x;
      out.y = thumb.y;
      thumb.x = currentX;
      thumb.y = currentY;
      return out;
    };
    var tmpPoint$2 = {};
  
    var AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
    var AlignTop$1 = Phaser.Display.Align.TOP_CENTER;
    var GetStartPoint = function GetStartPoint(out) {
      if (out === undefined) {
        out = tmpPoint$1;
      }
      if (this.childrenMap.thumb) {
        var align = this.orientation === 0 ? AlignLeft$1 : AlignTop$1;
        GetThumbAlignPoint.call(this, align, out);
      } else {
        if (this.orientation === 0) {
          out.x = this.innerLeft + 1; // Add 1 pixel margin
          out.y = this.centerY;
        } else {
          out.x = this.centerX;
          out.y = this.innerTop + 1; // Add 1 pixel margin
        }
      }
      return out;
    };
    var tmpPoint$1 = {};
  
    var AlignRight$1 = Phaser.Display.Align.RIGHT_CENTER;
    var AlignBottom$1 = Phaser.Display.Align.BOTTOM_CENTER;
    var GetEndoint = function GetEndoint(out) {
      if (out === undefined) {
        out = tmpPoint;
      }
      if (this.childrenMap.thumb) {
        var align = this.orientation === 0 ? AlignRight$1 : AlignBottom$1;
        GetThumbAlignPoint.call(this, align, out);
      } else {
        if (this.orientation === 0) {
          out.x = this.innerRight - 1; // Add 1 pixel margin
          out.y = this.centerY;
        } else {
          out.x = this.centerX;
          out.y = this.innerBottom - 1; // Add 1 pixel margin
        }
      }
      return out;
    };
    var tmpPoint = {};
  
    var Linear$3 = Phaser.Math.Linear;
    var PercentToPosition = function PercentToPosition(t, startPoint, endPoint, out) {
      if (out === undefined) {
        out = tmpOut;
      }
      out.x = Linear$3(startPoint.x, endPoint.x, t);
      out.y = Linear$3(startPoint.y, endPoint.y, t);
      return out;
    };
    var tmpOut = {};
  
    var UpdateThumb = function UpdateThumb(t) {
      var thumb = this.childrenMap.thumb;
      if (thumb === undefined) {
        return this;
      }
      if (t === undefined) {
        t = this.value;
      }
      var startPoint, endPoint;
      if (!this.reverseAxis) {
        startPoint = this.getStartPoint();
        endPoint = this.getEndPoint();
      } else {
        startPoint = this.getEndPoint();
        endPoint = this.getStartPoint();
      }
      PercentToPosition(t, startPoint, endPoint, thumb);
      thumb.x += this.thumbOffsetX;
      thumb.y += this.thumbOffsetY;
      this.resetChildPositionState(thumb);
      return this;
    };
  
    var AlignLeft = Phaser.Display.Align.LEFT_CENTER;
    var AlignTop = Phaser.Display.Align.TOP_CENTER;
    var AlignRight = Phaser.Display.Align.RIGHT_CENTER;
    var AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;
    var UpdateIndicator = function UpdateIndicator(t) {
      var indicator = this.childrenMap.indicator;
      if (indicator === undefined) {
        return this;
      }
      if (t === undefined) {
        t = this.value;
      }
      var reverseAxis = this.reverseAxis;
      var newWidth, newHeight;
      var thumb = this.childrenMap.thumb;
      if (thumb) {
        if (this.orientation === 0) {
          // x, extend width
          var thumbWidth = GetDisplayWidth(thumb);
          if (!reverseAxis) {
            var thumbLeft = thumb.x - thumbWidth * thumb.originX;
            var thumbRight = thumbLeft + thumbWidth;
            newWidth = thumbRight - this.left;
          } else {
            var thumbLeft = thumb.x - thumbWidth * thumb.originX;
            newWidth = this.right - thumbLeft;
          }
        } else {
          // y, extend height
          var thumbHeight = GetDisplayHeight(thumb);
          if (!reverseAxis) {
            var thumbTop = thumb.y - thumbHeight * thumb.originY;
            var thumbBottom = thumbTop + thumbHeight;
            newHeight = thumbBottom - this.top;
          } else {
            var thumbTop = thumb.y - thumbHeight * thumb.originY;
            newHeight = this.bottom - thumbTop;
          }
        }
      } else {
        if (this.orientation === 0) {
          // x, extend width
          newWidth = this.width * t;
        } else {
          // y, extend eight
          newHeight = this.height * t;
        }
      }
      ResizeGameObject(indicator, newWidth, newHeight);
      var align;
      if (!reverseAxis) {
        align = this.orientation === 0 ? AlignLeft : AlignTop;
      } else {
        align = this.orientation === 0 ? AlignRight : AlignBottom;
      }
      QuickSet(indicator, this, align);
      this.resetChildPositionState(indicator);
    };
  
    var GetValue$1C = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;
    var Clamp$8 = Phaser.Math.Clamp;
    var SnapTo = Phaser.Math.Snap.To;
    var Slider = /*#__PURE__*/function (_ProgressBase) {
      _inherits(Slider, _ProgressBase);
      function Slider(scene, config) {
        var _this;
        _classCallCheck(this, Slider);
        // Create sizer
        _this = _callSuper(this, Slider, [scene, config]);
        _this.type = 'rexSlider';
        _this.bootProgressBase(config);
        _this.reverseAxis = GetValue$1C(config, 'reverseAxis', false);
  
        // Add elements
        var background = GetValue$1C(config, 'background', undefined);
        var track = GetValue$1C(config, 'track', undefined);
        var indicator = GetValue$1C(config, 'indicator', undefined);
        var thumb = GetValue$1C(config, 'thumb', undefined);
        if (background) {
          if (IsPlainObject$d(background)) {
            background = CreateBackground$2(scene, background);
          }
          _this.addBackground(background);
        }
        if (track) {
          if (IsPlainObject$d(track)) {
            track = CreateBackground$2(scene, track);
          }
          _this.add(track, {
            proportion: 1,
            expand: true,
            minWidth: _this.orientation === 0 ? 0 : undefined,
            minHeight: _this.orientation === 1 ? 0 : undefined
          });
        }
        if (indicator) {
          if (IsPlainObject$d(indicator)) {
            indicator = CreateBackground$2(scene, indicator);
          }
          _this.pin(indicator); // Put into container but not layout it
        }
        if (thumb) {
          if (IsPlainObject$d(thumb)) {
            thumb = CreateBackground$2(scene, thumb);
          }
          _this.pin(thumb); // Put into container but not layout it
  
          var thumbOffsetX = GetValue$1C(config, 'thumbOffsetX', 0);
          var thumbOffsetY = GetValue$1C(config, 'thumbOffsetY', 0);
          _this.setThumbOffset(thumbOffsetX, thumbOffsetY);
        }
  
        // Input
        var inputMode = GetValue$1C(config, 'input', 0);
        if (typeof inputMode === 'string') {
          inputMode = INPUTMODE[inputMode];
        }
        switch (inputMode) {
          case 0:
            // 'drag'
            if (thumb) {
              thumb.setInteractive();
              _this.scene.input.setDraggable(thumb);
              thumb.on('drag', OnDragThumb, _assertThisInitialized(_this)).on('dragstart', function (pointer) {
                this.eventEmitter.emit('inputstart', pointer);
              }, _assertThisInitialized(_this)).on('dragend', function (pointer) {
                this.eventEmitter.emit('inputend', pointer);
              }, _assertThisInitialized(_this));
            }
            break;
          case 1:
            // 'click'
            _this.on('pointerdown', OnTouchTrack, _assertThisInitialized(_this)).on('pointermove', OnTouchTrack, _assertThisInitialized(_this)).on('pointerdown', function (pointer) {
              this.eventEmitter.emit('inputstart', pointer);
            }, _assertThisInitialized(_this)).on('pointerup', function (pointer) {
              this.eventEmitter.emit('inputend', pointer);
            }, _assertThisInitialized(_this)).on('pointerover', function (pointer) {
              if (pointer.isDown) {
                this.eventEmitter.emit('inputstart', pointer);
              }
            }, _assertThisInitialized(_this)).on('pointerout', function (pointer) {
              if (pointer.isDown) {
                this.eventEmitter.emit('inputend', pointer);
              }
            }, _assertThisInitialized(_this)).setInteractive();
            break;
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('track', track);
        _this.addChildrenMap('indicator', indicator);
        _this.addChildrenMap('thumb', thumb);
        _this.setEnable(GetValue$1C(config, 'enable', undefined));
        _this.setGap(GetValue$1C(config, 'gap', undefined));
        _this.setValue(GetValue$1C(config, 'value', 0), GetValue$1C(config, 'min', undefined), GetValue$1C(config, 'max', undefined));
        return _this;
      }
      _createClass(Slider, [{
        key: "setEnable",
        value: function setEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.enable = enable;
          return this;
        }
      }, {
        key: "setGap",
        value: function setGap(gap, min, max) {
          if (gap && min !== undefined) {
            gap = gap / (max - min);
          }
          this.gap = gap;
          return this;
        }
      }, {
        key: "setThumbOffset",
        value: function setThumbOffset(x, y) {
          this.thumbOffsetX = x;
          this.thumbOffsetY = y;
          return this;
        }
  
        // Override
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
  
        // Override
        ,
        set: function set(value) {
          if (this.gap !== undefined) {
            value = SnapTo(value, this.gap);
          }
          var oldValue = this._value;
          this._value = Clamp$8(value, 0, 1);
          if (oldValue !== this._value) {
            this.updateThumb(this._value);
            this.updateIndicator(this._value);
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
          }
        }
      }, {
        key: "postLayout",
        value: function postLayout(parent, newWidth, newHeight) {
          this.updateThumb();
          this.updateIndicator();
          return this;
        }
      }]);
      return Slider;
    }(ProgressBase(Sizer));
    var INPUTMODE = {
      pan: 0,
      drag: 0,
      click: 1,
      none: -1
    };
    var methods$h = {
      getStartPoint: GetStartPoint,
      getEndPoint: GetEndoint,
      updateThumb: UpdateThumb,
      updateIndicator: UpdateIndicator
    };
    Object.assign(Slider.prototype, methods$h);
  
    var GetValue$1B = Phaser.Utils.Objects.GetValue;
    var ScrollBar = /*#__PURE__*/function (_Sizer) {
      _inherits(ScrollBar, _Sizer);
      function ScrollBar(scene, config) {
        var _this;
        _classCallCheck(this, ScrollBar);
        // Create sizer
        _this = _callSuper(this, ScrollBar, [scene, config]);
        _this.type = 'rexScrollBar';
  
        // Add elements
        var background = GetValue$1B(config, 'background', undefined);
        var buttonsConfig = GetValue$1B(config, 'buttons', undefined);
        var button0 = GetValue$1B(buttonsConfig, 'top', GetValue$1B(buttonsConfig, 'left', undefined));
        var button1 = GetValue$1B(buttonsConfig, 'bottom', GetValue$1B(buttonsConfig, 'right', undefined));
        var slider,
          sliderConfig = GetValue$1B(config, 'slider', undefined);
        if (background) {
          _this.addBackground(background);
        }
        if (button0) {
          _this.add(button0);
          var inTouching = new InTouching(button0);
          inTouching.on('intouch', function () {
            if (!this.enable) {
              return;
            }
            var step = !slider.reverseAxis ? -this.scrollStep : this.scrollStep;
            this.value += step;
          }, _assertThisInitialized(_this));
        }
        if (sliderConfig) {
          sliderConfig.orientation = _this.orientation;
          sliderConfig.eventEmitter = _assertThisInitialized(_this);
          sliderConfig.value = null;
          var proportion;
          if (_this.orientation === 0) {
            var sliderWidth = GetValue$1B(sliderConfig, 'width', undefined);
            proportion = sliderWidth === undefined ? 1 : 0;
          } else {
            var sliderHeight = GetValue$1B(sliderConfig, 'height', undefined);
            proportion = sliderHeight === undefined ? 1 : 0;
          }
          slider = new Slider(scene, sliderConfig);
          scene.add.existing(slider);
          _this.add(slider, {
            proportion: proportion
          });
        }
        if (button1) {
          _this.add(button1);
          var inTouching = new InTouching(button1);
          inTouching.on('intouch', function () {
            if (!this.enable) {
              return;
            }
            var step = !slider.reverseAxis ? this.scrollStep : -this.scrollStep;
            this.value += step;
          }, _assertThisInitialized(_this));
        }
        var buttons = [button0, button1];
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('slider', slider);
        _this.addChildrenMap('buttons', buttons);
        var callback = GetValue$1B(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$1B(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        _this.setEnable(GetValue$1B(config, 'enable', undefined));
        _this.setValue(GetValue$1B(config, 'value', 0));
        _this.setScrollStep(GetValue$1B(buttonsConfig, 'step', 0.01));
        return _this;
      }
      _createClass(ScrollBar, [{
        key: "setScrollStep",
        value: function setScrollStep(value) {
          this.scrollStep = value;
          return this;
        }
      }, {
        key: "enable",
        get: function get() {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.enable;
          } else {
            return false;
          }
        },
        set: function set(value) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEnable(value);
          }
        }
      }, {
        key: "setEnable",
        value: function setEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.enable = enable;
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.value;
          } else {
            return 0;
          }
        },
        set: function set(value) {
          if (!this.childrenMap.slider) {
            return;
          }
          this.childrenMap.slider.value = value;
        }
      }, {
        key: "setValue",
        value: function setValue(value, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setValue(value, min, max);
          }
          return this;
        }
      }, {
        key: "addValue",
        value: function addValue(inc, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.addValue(inc, min, max);
          }
          return this;
        }
      }, {
        key: "getValue",
        value: function getValue(min, max) {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.getValue(min, max);
          } else {
            return 0;
          }
        }
      }, {
        key: "easeValueTo",
        value: function easeValueTo(value, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.easeValueTo(value, min, max);
          }
          return this;
        }
      }, {
        key: "stopEaseValue",
        value: function stopEaseValue() {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.stopEaseValue();
          }
          return this;
        }
      }, {
        key: "setEaseValueDuration",
        value: function setEaseValueDuration(duration) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueDuration(duration);
          }
          return this;
        }
      }, {
        key: "setEaseValueFunction",
        value: function setEaseValueFunction(ease) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueFunction(ease);
          }
          return this;
        }
      }]);
      return ScrollBar;
    }(Sizer);
  
    var CreateScrollbar = function CreateScrollbar(scene, config) {
      if (config === undefined) {
        config = {};
      }
      var sliderConfig = Clone$2(config);
      config = {
        slider: sliderConfig
      };
  
      // Move orientation parameter from sliderConfig to config
      config.orientation = sliderConfig.orientation;
      delete sliderConfig.orientation;
  
      // Move background parameter from sliderConfig to config
      config.background = sliderConfig.background;
      delete sliderConfig.background;
  
      // Move buttons parameter from sliderConfig to config
      config.buttons = sliderConfig.buttons;
      delete sliderConfig.buttons;
      config.value = null; // Don't assign initial value (0)
  
      var scrollBar = new ScrollBar(scene, config);
      scene.add.existing(scrollBar);
      var slider = scrollBar.childrenMap.slider;
      scrollBar.addChildrenMap('track', slider.childrenMap.track);
      scrollBar.addChildrenMap('indicator', slider.childrenMap.indicator);
      scrollBar.addChildrenMap('thumb', slider.childrenMap.thumb);
      return scrollBar;
    };
  
    var State = /*#__PURE__*/function (_FSM) {
      _inherits(State, _FSM);
      function State(parent, config) {
        var _this;
        _classCallCheck(this, State);
        _this = _callSuper(this, State, [config]);
        _this.parent = parent;
        _this.init();
        return _this;
      }
      _createClass(State, [{
        key: "init",
        value: function init() {
          this.start('IDLE');
        }
  
        // IDLE -> DRAGBEGIN|DRAG
      }, {
        key: "next_IDLE",
        value: function next_IDLE() {
          var nextState,
            parent = this.parent,
            dragState = parent.dragState;
          if (dragState.isDown) {
            nextState = parent.dragThreshold === 0 ? 'DRAG' : 'DRAGBEGIN';
          }
          return nextState;
        }
      }, {
        key: "update_IDLE",
        value: function update_IDLE(time, delta) {
          this.next();
        }
        // IDLE
  
        // DRAGBEGIN -> DRAG|IDLE
      }, {
        key: "next_DRAGBEGIN",
        value: function next_DRAGBEGIN() {
          var nextState,
            parent = this.parent,
            dragState = parent.dragState;
          if (dragState.isDown) {
            nextState = dragState.pointer.getDistance() >= parent.dragThreshold ? 'DRAG' : 'DRAGBEGIN';
          } else {
            // dragState.isUp
            nextState = 'IDLE';
          }
          return nextState;
        }
      }, {
        key: "update_DRAGBEGIN",
        value: function update_DRAGBEGIN(time, delta) {
          this.next();
        }
        // DRAGBEGIN
  
        // DRAG -> BACK|SLIDE|IDLE
      }, {
        key: "next_DRAG",
        value: function next_DRAG() {
          var nextState,
            parent = this.parent,
            dragState = parent.dragState;
          if (dragState.isUp) {
            if (parent.outOfBounds) {
              nextState = 'BACK';
            } else if (parent.slidingEnable) {
              nextState = 'SLIDE';
            } else {
              nextState = 'IDLE';
            }
          }
          return nextState;
        }
      }, {
        key: "update_DRAG",
        value: function update_DRAG(time, delta) {
          var parent = this.parent,
            dragState = parent.dragState;
          if (dragState.justMoved) {
            parent.dragging();
          }
          this.next();
        }
      }, {
        key: "enter_DRAG",
        value: function enter_DRAG() {
          this.parent.onDragStart();
        }
      }, {
        key: "exit_DRAG",
        value: function exit_DRAG() {
          this.parent.onDragEnd();
        }
        // DRAG    
  
        // SLIDE -> DRAG|IDLE
      }, {
        key: "next_SLIDE",
        value: function next_SLIDE() {
          var nextState,
            parent = this.parent,
            dragState = parent.dragState;
          if (dragState.isDown) {
            nextState = 'DRAG';
          } else if (!parent.isSliding) {
            nextState = 'IDLE';
          }
          return nextState;
        }
      }, {
        key: "enter_SLIDE",
        value: function enter_SLIDE() {
          this.parent.onSliding();
        }
      }, {
        key: "exit_SLIDE",
        value: function exit_SLIDE() {
          this.parent.stop();
        }
      }, {
        key: "update_SLIDE",
        value: function update_SLIDE(time, delta) {
          this.parent.sliding(time, delta);
          this.next();
        }
        // SLIDE    
  
        // BACK -> DRAG|IDLE
      }, {
        key: "next_BACK",
        value: function next_BACK() {
          var nextState,
            parent = this.parent,
            dragState = parent.dragState;
          if (dragState.isDown) {
            nextState = 'DRAG';
          } else if (!parent.isPullBack) {
            nextState = 'IDLE';
          }
          return nextState;
        }
      }, {
        key: "enter_BACK",
        value: function enter_BACK() {
          this.parent.onPullBack();
        }
      }, {
        key: "exit_BACK",
        value: function exit_BACK() {
          this.parent.stop();
        }
      }, {
        key: "update_BACK",
        value: function update_BACK(time, delta) {
          this.parent.pullBack(time, delta);
          this.next();
        }
        // BACK
      }]);
      return State;
    }(FSM);
  
    var GetValue$1A = Phaser.Utils.Objects.GetValue;
    var DistanceBetween$1 = Phaser.Math.Distance.Between;
    var DragSpeed = /*#__PURE__*/function (_ComponentBase) {
      _inherits(DragSpeed, _ComponentBase);
      function DragSpeed(gameObject, config) {
        var _this;
        _classCallCheck(this, DragSpeed);
        _this = _callSuper(this, DragSpeed, [gameObject, config]);
        // this.parent = gameObject;
  
        _this._enable = undefined;
        gameObject.setInteractive(GetValue$1A(config, "inputConfig", undefined));
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(DragSpeed, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.pointer = undefined;
          this.isInTouched = false;
          this.holdStartTime = undefined;
          this.x = undefined;
          this.y = undefined;
          this.preX = undefined;
          this.preY = undefined;
          this.localX = undefined;
          this.localY = undefined;
          this.justMoved = false;
          this.setEnable(GetValue$1A(o, 'enable', true));
          this.holdThreshold = GetValue$1A(o, 'holdThreshold', 50); // ms
          this.pointerOutReleaseEnable = GetValue$1A(o, 'pointerOutRelease', true);
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          // Drag start only when pointer down
          this.parent.on('pointerdown', this.onPointIn, this);
          // this.parent.on('pointerover', this.onPointIn, this);
  
          this.parent.on('pointerup', this.onPointOut, this);
          if (this.pointerOutReleaseEnable) {
            this.parent.on('pointerout', this.onPointOut, this);
          }
          this.parent.on('pointermove', this.onPointerMove, this);
          this.scene.sys.events.on('preupdate', this.preupdate, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // GameObject events will be removed when this gameObject destroyed 
          // this.parent.off('pointerdown', this.onPointIn, this);
          // this.parent.off('pointerup', this.onPointOut, this);
          // this.parent.off('pointerout', this.onPointOut, this);
          // this.parent.off('pointermove', this.onPointerMove, this);
  
          this.scene.sys.events.off('preupdate', this.preupdate, this);
          this.pointer = undefined;
          _get(_getPrototypeOf(DragSpeed.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.isInTouched = false;
            this.pointer = undefined;
          }
          this._enable = e;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "setPointerOutReleaseEnable",
        value: function setPointerOutReleaseEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.pointerOutReleaseEnable = enable;
          return this;
        }
      }, {
        key: "isDown",
        get: function get() {
          return this.pointer && this.pointer.isDown;
        }
      }, {
        key: "isUp",
        get: function get() {
          return !this.isDown;
        }
      }, {
        key: "dx",
        get: function get() {
          return this.x - this.preX;
        }
      }, {
        key: "dy",
        get: function get() {
          return this.y - this.preY;
        }
      }, {
        key: "dt",
        get: function get() {
          var delta = GetTickDelta(this.scene);
          return delta;
        }
      }, {
        key: "speed",
        get: function get() {
          if (this.x === this.preX && this.y === this.preY) {
            return 0;
          }
          var d = DistanceBetween$1(this.preX, this.preY, this.x, this.y);
          var speed = d / (this.dt * 0.001);
          return speed;
        }
      }, {
        key: "speedX",
        get: function get() {
          return this.dx / (this.dt * 0.001);
        }
      }, {
        key: "speedY",
        get: function get() {
          return this.dy / (this.dt * 0.001);
        }
  
        // internal
      }, {
        key: "onPointIn",
        value: function onPointIn(pointer, localX, localY) {
          if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
            return;
          }
          this.pointer = pointer;
          this.localX = localX;
          this.localY = localY;
        }
      }, {
        key: "onPointOut",
        value: function onPointOut(pointer) {
          if (!this.enable || this.pointer !== pointer) {
            return;
          }
          this.pointer = undefined;
        }
      }, {
        key: "onPointerMove",
        value: function onPointerMove(pointer, localX, localY) {
          if (!this.enable || !pointer.isDown || this.pointer !== pointer) {
            return;
          }
          this.localX = localX;
          this.localY = localY;
        }
      }, {
        key: "preupdate",
        value: function preupdate(time, delta) {
          if (!this.enable) {
            return;
          }
          var pointer = this.pointer;
          this.justMoved = false;
          if (pointer && !this.isInTouched) {
            // Touch start
            this.x = pointer.worldX;
            this.y = pointer.worldY;
            this.preX = pointer.worldX;
            this.preY = pointer.worldY;
            this.isInTouched = true;
            this.holdStartTime = undefined;
            this.emit('touchstart', pointer, this.localX, this.localY);
          } else if (pointer && this.isInTouched) {
            // In touch
            if (this.x === pointer.x && this.y === pointer.y) {
              // Hold
              if (this.holdStartTime === undefined) {
                this.holdStartTime = time;
              } else if (time - this.holdStartTime > this.holdThreshold) {
                this.preX = this.x;
                this.preY = this.y;
              }
            } else {
              // Move
              this.preX = this.x;
              this.preY = this.y;
              this.x = pointer.worldX;
              this.y = pointer.worldY;
              this.holdStartTime = undefined;
              this.justMoved = true;
              this.emit('touchmove', pointer, this.localX, this.localY);
            }
          } else if (!pointer && this.isInTouched) {
            // Touch end
            this.isInTouched = false;
            this.holdStartTime = undefined;
            this.emit('touchend', pointer);
          }
        }
      }]);
      return DragSpeed;
    }(ComponentBase);
  
    var GetValue$1z = Phaser.Utils.Objects.GetValue;
    var Movement = /*#__PURE__*/function () {
      function Movement(config) {
        _classCallCheck(this, Movement);
        this.resetFromJSON(config);
      }
      _createClass(Movement, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setValue(GetValue$1z(o, 'value', 0));
          this.setSpeed(GetValue$1z(o, 'speed', 0));
          this.setAcceleration(GetValue$1z(o, 'acceleration', 0));
          return this;
        }
      }, {
        key: "reset",
        value: function reset() {
          this.setValue(0);
          this.setSpeed(0);
          this.setAcceleration(0);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "setSpeed",
        value: function setSpeed(speed) {
          // speed == 0 : stop
          // speed  > 0 : move
          this.speed = speed;
          return this;
        }
      }, {
        key: "setAcceleration",
        value: function setAcceleration(acc) {
          // acc == 0 : constant speed
          // acc  > 0 : acceleration
          // acc  < 0 : deceleration
          this.acceleration = acc;
          return this;
        }
      }, {
        key: "updateSpeed",
        value: function updateSpeed(delta) {
          // delta in sec
          if (this.acceleration !== 0) {
            this.speed += this.acceleration * delta;
            if (this.speed < 0) {
              this.speed = 0;
            }
          }
          return this;
        }
      }, {
        key: "getDeltaValue",
        value: function getDeltaValue(delta) {
          // delta in sec
          this.updateSpeed(delta);
          if (this.speed <= 0) {
            return 0;
          }
          return this.speed * delta;
        }
      }, {
        key: "update",
        value: function update(delta) {
          // delta in sec
          this.updateSpeed(delta);
          if (this.speed > 0) {
            this.value += this.getDeltaValue(delta);
          }
          return this;
        }
      }, {
        key: "isMoving",
        get: function get() {
          return this.speed > 0;
        }
      }]);
      return Movement;
    }();
  
    var SlowDown = /*#__PURE__*/function () {
      function SlowDown() {
        _classCallCheck(this, SlowDown);
        this.value;
        this.dir; // true:+, false:-
        this.movement = new Movement();
      }
      _createClass(SlowDown, [{
        key: "init",
        value: function init(start, dir, speed, dec, end) {
          this.value = start;
          this.end = end;
          if (end !== undefined) {
            this.dir = start < end;
          } else {
            this.dir = dir;
          }
          this.movement.setSpeed(speed).setAcceleration(-dec);
          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.movement.reset();
        }
      }, {
        key: "update",
        value: function update(delta) {
          // delta in sec
          var d = this.movement.getDeltaValue(delta);
          if (!this.dir) {
            d = -d;
          }
          if (this.end === undefined) {
            this.value += d;
          } else {
            if (d === 0) {
              this.value = this.end;
            } else {
              this.value += d;
              if (this.dir) {
                // +
                if (this.value > this.end) {
                  this.value = this.end;
                }
              } else {
                // -
                if (this.value < this.end) {
                  this.value = this.end;
                }
              }
            }
          }
          return this;
        }
      }, {
        key: "isMoving",
        get: function get() {
          return this.movement.isMoving;
        }
      }]);
      return SlowDown;
    }();
  
    var GetValue$1y = Phaser.Utils.Objects.GetValue;
    var Clamp$7 = Phaser.Math.Clamp;
    var Scroller = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Scroller, _ComponentBase);
      function Scroller(gameObject, config) {
        var _this;
        _classCallCheck(this, Scroller);
        _this = _callSuper(this, Scroller, [gameObject, config]);
        // this.parent = gameObject;
  
        var enable = GetValue$1y(config, 'enable', true);
        _this._state = new State(_assertThisInitialized(_this), {
          enable: enable,
          eventEmitter: false
        });
        var drapSpeedConfig = {
          inputConfig: GetValue$1y(config, 'inputConfig', undefined),
          enable: enable,
          pointerOutRelease: GetValue$1y(config, 'pointerOutRelease', true),
          eventEmitter: false
        };
        _this.dragState = new DragSpeed(gameObject, drapSpeedConfig);
        _this._enable = undefined;
        _this._value = undefined;
        _this._slowDown = new SlowDown();
        var callback = GetValue$1y(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$1y(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        callback = GetValue$1y(config, 'overmaxCallback', null);
        if (callback !== null) {
          var scope = GetValue$1y(config, 'overmaxCallbackScope', undefined);
          _this.on('overmax', callback, scope);
        }
        callback = GetValue$1y(config, 'overminCallback', null);
        if (callback !== null) {
          var scope = GetValue$1y(config, 'overminCallbackScope', undefined);
          _this.on('overmin', callback, scope);
        }
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Scroller, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setOrientationMode(GetValue$1y(o, 'orientation', 0));
          this.setDragThreshold(GetValue$1y(o, 'threshold', 10));
          this.setSlidingDeceleration(GetValue$1y(o, 'slidingDeceleration', 5000));
          this.setBackDeceleration(GetValue$1y(o, 'backDeceleration', 2000));
          var dragRate = GetValue$1y(o, 'dragRate', 1);
          dragRate = dragRate * (GetValue$1y(o, 'dragReverse', false) ? -1 : 1);
          this.setDragRate(dragRate);
          var bounds = GetValue$1y(o, 'bounds', undefined);
          if (bounds) {
            this.setBounds(bounds);
          } else {
            this.setBounds(GetValue$1y(o, 'max', 0), GetValue$1y(o, 'min', 0));
          }
          this.setValue(GetValue$1y(o, 'value', this.maxValue || 0));
          this.setEnable(GetValue$1y(o, "enable", true));
          return this;
        }
      }, {
        key: "boot",
        value: function boot() {
          this.scene.sys.events.on('preupdate', this._state.update, this._state);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.scene.sys.events.off('preupdate', this._state.update, this._state);
          this._state.destroy(fromScene);
          this.dragState.destroy(fromScene);
          this._state = undefined;
          this.dragState = undefined;
          _get(_getPrototypeOf(Scroller.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          this._enable = e;
          this._state.setEnable(e);
          this.dragState.setEnable(e);
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "setOrientationMode",
        value: function setOrientationMode(m) {
          if (typeof m === 'string') {
            m = ORIENTATIONMODE$2[m];
          }
          this.orientationMode = m;
          return this;
        }
      }, {
        key: "setDragThreshold",
        value: function setDragThreshold(distance) {
          this.dragThreshold = distance;
          return this;
        }
      }, {
        key: "setSlidingDeceleration",
        value: function setSlidingDeceleration(dec) {
          this.slidingDeceleration = dec;
          return this;
        }
      }, {
        key: "setBackDeceleration",
        value: function setBackDeceleration(dec) {
          this.backDeceleration = dec;
          return this;
        }
      }, {
        key: "setDragRate",
        value: function setDragRate(ratio) {
          this.dragRate = ratio;
          return this;
        }
      }, {
        key: "setBounds",
        value: function setBounds(value0, value1) {
          if (Array.isArray(value0)) {
            var bounds = value0;
            value0 = bounds[0];
            value1 = bounds[1];
          }
          if (value0 < value1) {
            this.minValue = value0;
            this.maxValue = value1;
          } else {
            this.minValue = value1;
            this.maxValue = value0;
          }
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (value === this._value) {
            return;
          }
          var oldValue = this._value;
          var isOverMax = this.overMax(value);
          var isOverMin = this.overMin(value);
          if (isOverMax) {
            this.emit('overmax', value, oldValue);
          }
          if (isOverMin) {
            this.emit('overmin', value, oldValue);
          }
          if (!this.backEnable) {
            if (isOverMax) {
              value = this.maxValue;
            }
            if (isOverMin) {
              value = this.minValue;
            }
          }
          this._value = value;
          this.emit('valuechange', value, oldValue);
        }
      }, {
        key: "setValue",
        value: function setValue(value, clamp) {
          if (clamp === undefined) {
            clamp = false;
          }
          if (clamp) {
            value = Clamp$7(value, this.minValue, this.maxValue);
          }
          this.value = value;
          return this;
        }
      }, {
        key: "addValue",
        value: function addValue(inc, clamp) {
          this.setValue(this.value + inc, clamp);
          return this;
        }
      }, {
        key: "state",
        get: function get() {
          return this._state.state;
        }
      }, {
        key: "isDragging",
        get: function get() {
          return this.dragState.isInTouched;
        }
      }, {
        key: "outOfMaxBound",
        get: function get() {
          return this.overMax(this.value);
        }
      }, {
        key: "outOfMinBound",
        get: function get() {
          return this.overMin(this.value);
        }
      }, {
        key: "outOfBounds",
        get: function get() {
          return this.outOfMinBound || this.outOfMaxBound;
        }
  
        // internal
      }, {
        key: "overMax",
        value: function overMax(value) {
          return this.maxValue != null && value > this.maxValue;
        }
      }, {
        key: "overMin",
        value: function overMin(value) {
          return this.minValue != null && value < this.minValue;
        }
      }, {
        key: "backEnable",
        get: function get() {
          return typeof this.backDeceleration === 'number';
        }
      }, {
        key: "isPullBack",
        get: function get() {
          return this._slowDown.isMoving;
        }
      }, {
        key: "slidingEnable",
        get: function get() {
          return typeof this.slidingDeceleration === 'number';
        }
      }, {
        key: "isSliding",
        get: function get() {
          return this._slowDown.isMoving;
        }
      }, {
        key: "dragDelta",
        get: function get() {
          var delta;
          if (this.orientationMode === 0) {
            // y
            delta = this.dragState.dy;
          } else if (this.orientationMode === 1) {
            // x
            delta = this.dragState.dx;
          } else {
            delta = 0;
          }
          delta *= this.dragRate;
          return delta;
        }
      }, {
        key: "dragSpeed",
        get: function get() {
          var speed;
          if (this.orientationMode === 0) {
            // y
            speed = this.dragState.speedY;
          } else if (this.orientationMode === 1) {
            // x
            speed = this.dragState.speedX;
          } else {
            speed = 0;
          }
          speed *= this.dragRate;
          return speed;
        }
  
        // enter_DRAG
      }, {
        key: "onDragStart",
        value: function onDragStart() {
          this.emit('dragstart');
        }
  
        // exit_DRAG
      }, {
        key: "onDragEnd",
        value: function onDragEnd() {
          this.emit('dragend');
        }
  
        // everyTick_DRAG
      }, {
        key: "dragging",
        value: function dragging() {
          this.value += this.dragDelta;
        }
  
        // enter_SLIDE 
      }, {
        key: "onSliding",
        value: function onSliding() {
          var start = this.value;
          var speed = this.dragSpeed;
          if (speed === 0) {
            this._slowDown.stop();
            this._state.next();
            return;
          }
          var dec = this.slidingDeceleration;
          this._slowDown.init(start, speed > 0, Math.abs(speed), dec);
        }
  
        // everyTick_SLIDE
      }, {
        key: "sliding",
        value: function sliding(time, delta) {
          delta *= 0.001;
          var newValue = this._slowDown.update(delta).value;
          if (this.overMax(newValue)) {
            this.value = this.maxValue;
            this._slowDown.stop();
          } else if (this.overMin(newValue)) {
            this.value = this.minValue;
            this._slowDown.stop();
          } else {
            this.value = newValue;
          }
        }
  
        // enter_BACK
      }, {
        key: "onPullBack",
        value: function onPullBack() {
          var start = this.value;
          var end = this.outOfMinBound ? this.minValue : this.maxValue;
          var dist = Math.abs(end - start);
          var dec = this.backDeceleration;
          var speed = Math.sqrt(2 * dec * dist);
          this._slowDown.init(start, undefined, speed, dec, end);
        }
  
        // everyTick_BACK
      }, {
        key: "pullBack",
        value: function pullBack(time, delta) {
          delta *= 0.001;
          this.value = this._slowDown.update(delta).value;
          if (!this._slowDown.isMoving) {
            this._state.next();
          }
        }
  
        // exit_SLIDE, exit_BACK
      }, {
        key: "stop",
        value: function stop() {
          this._slowDown.stop();
        }
      }]);
      return Scroller;
    }(ComponentBase);
    var ORIENTATIONMODE$2 = {
      y: 0,
      v: 0,
      vertical: 0,
      x: 1,
      h: 1,
      horizontal: 1
    };
  
    var GetValue$1x = Phaser.Utils.Objects.GetValue;
    var MouseWheelScroller = /*#__PURE__*/function (_ComponentBase) {
      _inherits(MouseWheelScroller, _ComponentBase);
      function MouseWheelScroller(gameObject, config) {
        var _this;
        _classCallCheck(this, MouseWheelScroller);
        _this = _callSuper(this, MouseWheelScroller, [gameObject, config]);
        // this.parent = gameObject;
  
        if (_this.parent !== _this.scene) {
          _this.focusMode = GetValue$1x(config, 'focus', true);
        } else {
          _this.focusMode = false;
        }
        _this.setSpeed(GetValue$1x(config, 'speed', 0.1));
        _this.setEnable(GetValue$1x(config, 'enable', true));
        if (!_this.focusMode) {
          // Register on scene
          _this.scene.input.on('wheel', _this.onSceneScroll, _assertThisInitialized(_this));
        } else {
          var gameObject = _this.parent;
          gameObject.setInteractive(GetValue$1x(config, "inputConfig", undefined)).on('wheel', function (pointer, dx, dy, dz, event) {
            if (!this.enable) {
              return;
            }
            this.scroll(dy);
          }, _assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(MouseWheelScroller, [{
        key: "destroy",
        value: function destroy() {
          if (!this.focusMode) {
            this.scene.input.off('wheel', this.onSceneScroll, this);
          }
        }
      }, {
        key: "onSceneScroll",
        value: function onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
          if (!this.enable) {
            return;
          }
          this.scroll(dy);
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "setSpeed",
        value: function setSpeed(speed) {
          this.speed = speed;
          return this;
        }
      }, {
        key: "scroll",
        value: function scroll(dy) {
          dy *= this.speed;
          this.emit('scroll', dy, this.parent, this);
        }
      }]);
      return MouseWheelScroller;
    }(ComponentBase);
  
    var GetValue$1w = Phaser.Utils.Objects.GetValue;
    var AddSlider = function AddSlider(topPatent, sliderParent, axis, config) {
      axis = axis.toUpperCase();
      var isAxisY = axis === 'Y';
      var isScrollXYMode = topPatent.scrollMode === 2;
      var child = topPatent.childrenMap.child;
      var sliderConfig, slider;
      var sliderConfigKey = "slider".concat(axis);
      if (isScrollXYMode) {
        sliderConfig = GetValue$1w(config, sliderConfigKey, undefined);
      } else {
        if (config.hasOwnProperty(sliderConfigKey)) {
          sliderConfig = GetValue$1w(config, sliderConfigKey, undefined);
        } else {
          sliderConfig = GetValue$1w(config, 'slider', undefined);
        }
      }
      if (sliderConfig) {
        if (sliderConfig === true) {
          sliderConfig = {};
        }
        sliderConfig.orientation = isAxisY ? 1 : 0;
        slider = CreateScrollbar(topPatent.scene, sliderConfig);
        var column, row, padding;
        var sliderPosition = GetValue$1w(sliderConfig, 'position', 0);
        if (typeof sliderPosition === 'string') {
          sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
        }
  
        /*
        1. space.sliderX, space.sliderY
        2. space.slider
        3. space.child
        */
        var sliderPadding = GetValue$1w(config, "space.slider".concat(axis), undefined);
        var childPadding; // Legacy
        if (sliderPadding === undefined) {
          sliderPadding = GetValue$1w(config, 'space.slider', undefined);
          if (sliderPadding === undefined) {
            if (isScrollXYMode) {
              sliderPadding = 0;
            } else {
              childPadding = GetValue$1w(config, 'space.child', 0);
            }
          }
        }
        var isNumberSliderPadding;
        if (childPadding === undefined) {
          isNumberSliderPadding = typeof sliderPadding === 'number';
        } else {
          isNumberSliderPadding = typeof childPadding === 'number';
        }
        if (isAxisY) {
          if (sliderPosition === 0) {
            // right
            column = 2;
            row = 1;
            if (childPadding === undefined) {
              padding = isNumberSliderPadding ? {
                left: sliderPadding
              } : sliderPadding;
            } else {
              padding = {
                left: GetValue$1w(childPadding, 'right', childPadding)
              };
            }
          } else {
            // left
            column = 0;
            row = 1;
            if (childPadding === undefined) {
              padding = isNumberSliderPadding ? {
                right: sliderPadding
              } : sliderPadding;
            } else {
              padding = {
                right: GetValue$1w(childPadding, 'left', childPadding)
              };
            }
          }
        } else {
          if (sliderPosition === 0) {
            // bottom
            column = 1;
            row = 2;
            if (childPadding === undefined) {
              padding = isNumberSliderPadding ? {
                top: sliderPadding
              } : sliderPadding;
            } else {
              padding = {
                top: GetValue$1w(childPadding, 'bottom', childPadding)
              };
            }
          } else {
            // top
            column = 1;
            row = 0;
            if (childPadding === undefined) {
              padding = isNumberSliderPadding ? {
                bottom: sliderPadding
              } : sliderPadding;
            } else {
              padding = {
                bottom: GetValue$1w(childPadding, 'top', childPadding)
              };
            }
          }
        }
        sliderParent.add(slider, {
          column: column,
          row: row,
          align: 'center',
          padding: padding,
          expand: true
        });
        topPatent["hideUnscrollableSlider".concat(axis)] = GetValue$1w(sliderConfig, 'hideUnscrollableSlider', false);
        topPatent["adaptThumb".concat(axis, "SizeMode")] = GetValue$1w(sliderConfig, 'adaptThumbSize', false);
        topPatent["minThumb".concat(axis, "Size")] = GetValue$1w(sliderConfig, 'minThumbSize', undefined);
      } else {
        topPatent["hideUnscrollableSlider".concat(axis)] = false;
        topPatent["adaptThumb".concat(axis, "SizeMode")] = false;
        topPatent["minThumb".concat(axis, "Size")] = undefined;
      }
      var scrollerConfig, scroller;
      var scrollerConfigKey = "scroller".concat(axis);
      if (isScrollXYMode) {
        scrollerConfig = GetValue$1w(config, scrollerConfigKey, true);
      } else {
        if (config.hasOwnProperty(scrollerConfigKey)) {
          scrollerConfig = GetValue$1w(config, scrollerConfigKey, true);
        } else {
          scrollerConfig = GetValue$1w(config, 'scroller', true);
        }
      }
      if (scrollerConfig && child) {
        if (scrollerConfig === true) {
          scrollerConfig = {};
        }
        scrollerConfig.orientation = isAxisY ? 0 : 1;
        scroller = new Scroller(child, scrollerConfig);
      }
      var mouseWheelScrollerConfig = GetValue$1w(config, isScrollXYMode ? "mouseWheelScroller".concat(axis) : 'mouseWheelScroller', false),
        mouseWheelScroller;
      if (mouseWheelScrollerConfig && child) {
        mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
      }
      topPatent.addChildrenMap("slider".concat(axis), slider);
      topPatent.addChildrenMap("scroller".concat(axis), scroller);
      topPatent.addChildrenMap("mouseWheelScroller".concat(axis), mouseWheelScroller);
      if (!isScrollXYMode || isAxisY) {
        topPatent['hideUnscrollableSlider'] = topPatent["hideUnscrollableSlider".concat(axis)];
        topPatent['adaptThumbSizeMode'] = topPatent["adaptThumb".concat(axis, "SizeMode")];
        topPatent['minThumbSize'] = topPatent["minThumb".concat(axis, "Size")];
        topPatent.addChildrenMap('slider', slider);
        topPatent.addChildrenMap('scroller', scroller);
        topPatent.addChildrenMap('mouseWheelScroller', mouseWheelScroller);
      }
  
      // Control
      if (slider) {
        var keyST, eventName;
        if (isScrollXYMode) {
          keyST = isAxisY ? 't' : 's';
          eventName = "scroll".concat(axis);
        } else {
          keyST = 't';
          eventName = 'scroll';
        }
        slider.on('valuechange', function (newValue) {
          topPatent[keyST] = newValue;
          topPatent.emit(eventName, topPatent);
        });
      }
      if (scroller) {
        var keyChildOXY, eventName;
        if (isScrollXYMode) {
          keyChildOXY = "childO".concat(axis);
          eventName = "scroll".concat(axis);
        } else {
          keyChildOXY = 'childOY';
          eventName = 'scroll';
        }
        scroller.on('valuechange', function (newValue) {
          topPatent[keyChildOXY] = newValue;
          topPatent.emit(eventName, topPatent);
        });
      }
      if (mouseWheelScroller) {
        var methodAddChildOXY;
        if (isScrollXYMode) {
          methodAddChildOXY = "addChildO".concat(axis);
        } else {
          methodAddChildOXY = 'addChildOY';
        }
        mouseWheelScroller.on('scroll', function (incValue) {
          topPatent[methodAddChildOXY](-incValue, true);
        });
      }
    };
    var SLIDER_POSITION_MAP = {
      right: 0,
      left: 1,
      bottom: 0,
      top: 1
    };
  
    var GetValue$1v = Phaser.Utils.Objects.GetValue;
    var CreateScrollableSizer = function CreateScrollableSizer(parent, config) {
      var scene = parent.scene;
      var columnProportions = [0, 1, 0],
        rowProportions = [0, 1, 0];
      var parentMinWidth = GetValue$1v(config, 'width');
      var parentMinHeight = GetValue$1v(config, 'height');
      if (!parentMinWidth) {
        var expandChildWidth = GetValue$1v(config, 'child.expandWidth', true);
        if (!expandChildWidth) {
          columnProportions[1] = 0; // Calculate parent's width by child's width
        }
      }
      if (!parentMinHeight) {
        var expandChildHeight = GetValue$1v(config, 'child.expandHeight', true);
        if (!expandChildHeight) {
          rowProportions[1] = 0; // Calculate parent's height by child's height
        }
      }
      var scrollableSizer = new GridSizer(scene, {
        column: 3,
        row: 3,
        columnProportions: columnProportions,
        rowProportions: rowProportions
      });
      AddChild(parent, scrollableSizer, config);
      switch (parent.scrollMode) {
        case 0:
          // y
          AddSlider(parent, scrollableSizer, 'y', config);
          break;
        case 1:
          // x
          AddSlider(parent, scrollableSizer, 'x', config);
          break;
        default:
          // xy
          AddSlider(parent, scrollableSizer, 'y', config);
          AddSlider(parent, scrollableSizer, 'x', config);
          break;
      }
      return scrollableSizer;
    };
  
    var ResizeController = function ResizeController() {
      switch (this.scrollMode) {
        case 0:
        case 1:
          SetControllerBounds.call(this);
          this.updateController();
          HideUnscrollableSlider.call(this);
          AdaptThumbSize.call(this);
          break;
        default:
          // 2
          SetControllerBounds.call(this, 'y');
          SetControllerBounds.call(this, 'x');
          this.updateController();
          HideUnscrollableSlider.call(this, 'y');
          HideUnscrollableSlider.call(this, 'x');
          AdaptThumbSize.call(this, 'y');
          AdaptThumbSize.call(this, 'x');
          break;
      }
      return this;
    };
    var SetControllerBounds = function SetControllerBounds(axis) {
      var bound0, bound1;
      var scroller, slider;
      switch (this.scrollMode) {
        case 0:
        case 1:
          bound0 = this.topChildOY;
          bound1 = this.bottomChildOY;
          scroller = this.childrenMap.scroller;
          slider = this.childrenMap.slider;
          break;
        default:
          // 2
          axis = axis.toUpperCase();
          if (axis === 'Y') {
            bound0 = this.topChildOY;
            bound1 = this.bottomChildOY;
          } else {
            bound0 = this.leftChildOX;
            bound1 = this.rightChildOX;
          }
          scroller = this.childrenMap["scroller".concat(axis)];
          slider = this.childrenMap["slider".concat(axis)];
      }
      if (scroller) {
        scroller.setBounds(bound0, bound1);
      }
      if (slider) {
        slider.setEnable(bound0 !== bound1);
      }
    };
    var HideUnscrollableSlider = function HideUnscrollableSlider(axis) {
      switch (this.scrollMode) {
        case 0:
        case 1:
          var slider = this.childrenMap.slider;
          if (slider && this.hideUnscrollableSlider) {
            this.setChildVisible(slider, this.isOverflow);
          }
          break;
        default:
          axis = axis.toUpperCase();
          var slider = this.childrenMap["slider".concat(axis)];
          var hideUnscrollableSlider = this["hideUnscrollableSlider".concat(axis)];
          var isOverflow = this["isOverflow".concat(axis)];
          if (slider && hideUnscrollableSlider) {
            this.setChildVisible(slider, isOverflow);
          }
          break;
      }
    };
    var AdaptThumbSize = function AdaptThumbSize(axis) {
      switch (this.scrollMode) {
        case 0:
        case 1:
          if (!this.adaptThumbSizeMode) {
            return;
          }
          var slider = this.childrenMap.slider;
          if (!slider) {
            return;
          }
  
          // Change slider size according to visible ratio
          var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
          var track = slider.childrenMap.track;
          var thumb = slider.childrenMap.thumb;
          var minThumbSize = this.minThumbSize;
          if (this.scrollMode === 0) {
            var newHeight = track.displayHeight * ratio;
            if (minThumbSize !== undefined && newHeight < minThumbSize) {
              newHeight = minThumbSize;
            }
            ResizeGameObject(thumb, undefined, newHeight);
          } else {
            var newWidth = track.displayWidth * ratio;
            if (minThumbSize !== undefined && newWidth < minThumbSize) {
              newWidth = minThumbSize;
            }
            ResizeGameObject(thumb, newWidth, undefined);
          }
          LayoutSlider(slider);
          break;
        default:
          // TODO
          axis = axis.toUpperCase();
          var adaptThumbSizeMode = this["adaptThumb".concat(axis, "SizeMode")];
          if (!adaptThumbSizeMode) {
            return;
          }
          var slider = this.childrenMap["slider".concat(axis)];
          if (!slider) {
            return;
          }
  
          // Change slider size according to visible ratio            
          var track = slider.childrenMap.track;
          var thumb = slider.childrenMap.thumb;
          var minThumbSize = this["minThumb".concat(axis, "Size")];
          if (axis === 'Y') {
            var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
            var newHeight = track.displayHeight * ratio;
            if (minThumbSize !== undefined && newHeight < minThumbSize) {
              newHeight = minThumbSize;
            }
            ResizeGameObject(thumb, undefined, newHeight);
          } else {
            var ratio = Math.min(this.childVisibleWidth / this.childWidth, 1);
            var newWidth = track.displayWidth * ratio;
            if (minThumbSize !== undefined && newWidth < minThumbSize) {
              newWidth = minThumbSize;
            }
            ResizeGameObject(thumb, newWidth, undefined);
          }
          LayoutSlider(slider);
          break;
      }
    };
    var LayoutSlider = function LayoutSlider(slider) {
      // Save minSize
      var minWidthSave = slider.minWidth;
      var minHeightSave = slider.minHeight;
      // Set minSize to current size
      slider.minWidth = slider.width;
      slider.minHeight = slider.height;
      // Layout slider
      slider.layout();
      // Restore minSize
      slider.minWidth = minWidthSave;
      slider.minHeight = minHeightSave;
    };
  
    var UpdateController = function UpdateController() {
      switch (this.scrollMode) {
        case 0:
        case 1:
          var scroller = this.childrenMap.scroller;
          var slider = this.childrenMap.slider;
          if (scroller) {
            scroller.setValue(this.childOY);
          }
          if (slider) {
            slider.setValue(this.t);
          }
          break;
        default:
          var scrollerY = this.childrenMap.scrollerY;
          var sliderY = this.childrenMap.sliderY;
          var scrollerX = this.childrenMap.scrollerX;
          var sliderX = this.childrenMap.sliderX;
          if (scrollerY) {
            scrollerY.setValue(this.childOY);
          }
          if (sliderY) {
            sliderY.setValue(this.t);
          }
          if (scrollerX) {
            scrollerX.setValue(this.childOX);
          }
          if (sliderX) {
            sliderX.setValue(this.s);
          }
          break;
      }
    };
  
    var GetValue$1u = Phaser.Utils.Objects.GetValue;
    var Clamp$6 = Phaser.Math.Clamp;
    var Scrollable = /*#__PURE__*/function (_Sizer) {
      _inherits(Scrollable, _Sizer);
      function Scrollable(scene, config) {
        var _this;
        _classCallCheck(this, Scrollable);
        if (config === undefined) {
          config = {};
        }
        var scrollMode = GetScrollMode(config); // 0:y, 1:x, 2:xy
        // Create sizer
        var isRevererXY = scrollMode === 1;
        config.orientation = !isRevererXY ? 1 : 0;
        _this = _callSuper(this, Scrollable, [scene, config]);
        _this.type = GetValue$1u(config, 'type', 'rexScrollable');
        _this.scrollMode = scrollMode;
  
        // Add elements
        // Background
        var background = GetValue$1u(config, 'background', undefined);
        if (background) {
          _this.addBackground(background);
        }
        var header = GetValue$1u(config, 'header', undefined);
        if (header) {
          var align = GetValue$1u(config, 'align.header', 'center');
          var headerSpace = GetValue$1u(config, 'space.header', 0);
          var padding;
          if (!isRevererXY) {
            padding = {
              bottom: headerSpace
            };
          } else {
            padding = {
              right: headerSpace
            };
          }
          _this.add(header, {
            proportion: 0,
            align: align,
            padding: padding,
            expand: GetValue$1u(config, 'expand.header', true)
          });
        }
        var scrollableSizer = CreateScrollableSizer(_assertThisInitialized(_this), config);
        if (scrollableSizer) {
          _this.add(scrollableSizer, {
            proportion: 1,
            align: 'center',
            padding: 0,
            expand: true
          });
        }
        var footer = GetValue$1u(config, 'footer', undefined);
        if (footer) {
          var align = GetValue$1u(config, 'align.footer', 'center');
          var footerSpace = GetValue$1u(config, 'space.footer', 0);
          var padding;
          if (!isRevererXY) {
            padding = {
              top: footerSpace
            };
          } else {
            padding = {
              left: footerSpace
            };
          }
          _this.add(footer, {
            proportion: 0,
            align: align,
            padding: padding,
            expand: GetValue$1u(config, 'expand.footer', true)
          });
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('header', header);
        _this.addChildrenMap('footer', footer);
        _this.runLayoutFlag = false;
  
        /* 
        Necessary properties of child object :
          - child.t (RW), 
        - child.childOY (RW)        
        - child.topChildOY (R)
        - child.bottomChildOY (R)
        - child.childVisibleHeight (R)
        - child.childHeight (R)
          - child.s (RW), 
        - child.childOX (RW)
        - child.leftChildOX (R)
        - child.rightChildOX (R)
        - child.childVisibleWidth (R)
        - child.childWidth (R)        
        */
        return _this;
      }
      _createClass(Scrollable, [{
        key: "postLayout",
        value: function postLayout(parent, newWidth, newHeight) {
          var s = 0,
            t = 0;
          if (!this.runLayoutFlag) {
            this.runLayoutFlag = true;
          } else {
            t = this.t;
            if (this.scrollMode === 2) {
              s = this.s;
            }
          }
          this.resizeController();
          this.setT(t);
          if (this.scrollMode === 2) {
            this.setS(s);
          }
          return this;
        }
      }, {
        key: "t",
        get: function get() {
          var t = this.childrenMap.child.t;
  
          // Get outer childT
          var childMargin = this.childMargin;
          if (childMargin.top !== 0 || childMargin.bottom !== 0) {
            var child = this.childrenMap.child;
            var innerHeight = child.topChildOY - child.bottomChildOY;
            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
            var outerChildOY = innerHeight * t + childMargin.top;
            t = outerHeight !== 0 ? outerChildOY / outerHeight : 0;
          }
          return t;
        },
        set: function set(value) {
          // Get inner childT
          var childMargin = this.childMargin;
          if (childMargin.top !== 0 || childMargin.bottom !== 0) {
            var child = this.childrenMap.child;
            var innerHeight = child.topChildOY - child.bottomChildOY;
            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
            var innerChildOY = outerHeight * value - childMargin.top;
            value = innerHeight !== 0 ? innerChildOY / innerHeight : 0;
          }
          this.childrenMap.child.t = value;
          this.updateController();
        }
      }, {
        key: "s",
        get: function get() {
          var s = this.childrenMap.child.s;
  
          // Get outer childT
          var childMargin = this.childMargin;
          if (childMargin.left !== 0 || childMargin.right !== 0) {
            var child = this.childrenMap.child;
            var innerWidth = child.leftChildOX - child.rightChildOX;
            var outerWidth = innerWidth + childMargin.left + childMargin.right;
            var outerChildOX = innerWidth * s + childMargin.left;
            s = outerWidth !== 0 ? outerChildOX / outerWidth : 0;
          }
          return s;
        },
        set: function set(value) {
          // Get inner childS
          var childMargin = this.childMargin;
          if (childMargin.left !== 0 || childMargin.right !== 0) {
            var child = this.childrenMap.child;
            var innerWidth = child.leftChildOX - child.rightChildOX;
            var outerWidth = innerWidth + childMargin.left + childMargin.right;
            var innerChildOX = outerWidth * value - childMargin.left;
            value = innerWidth !== 0 ? innerChildOX / innerWidth : 0;
          }
          this.childrenMap.child.s = value;
          this.updateController();
        }
      }, {
        key: "childOY",
        get: function get() {
          return this.childrenMap.child.childOY;
        },
        set: function set(value) {
          this.childrenMap.child.childOY = value;
          this.updateController();
        }
      }, {
        key: "childOX",
        get: function get() {
          return this.childrenMap.child.childOX;
        },
        set: function set(value) {
          this.childrenMap.child.childOX = value;
          this.updateController();
        }
      }, {
        key: "topChildOY",
        get: function get() {
          return this.childrenMap.child.topChildOY + this.childMargin.top;
        }
      }, {
        key: "bottomChildOY",
        get: function get() {
          return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
        }
      }, {
        key: "leftChildOX",
        get: function get() {
          return this.childrenMap.child.leftChildOX + this.childMargin.left;
        }
      }, {
        key: "rightChildOX",
        get: function get() {
          return this.childrenMap.child.rightChildOX - this.childMargin.right;
        }
      }, {
        key: "childVisibleHeight",
        get: function get() {
          return this.childrenMap.child.childVisibleHeight;
        }
      }, {
        key: "childHeight",
        get: function get() {
          return this.childrenMap.child.childHeight;
        }
      }, {
        key: "childVisibleWidth",
        get: function get() {
          return this.childrenMap.child.childVisibleWidth;
        }
      }, {
        key: "childWidth",
        get: function get() {
          return this.childrenMap.child.childWidth;
        }
      }, {
        key: "isOverflow",
        get: function get() {
          var child = this.childrenMap.child;
          return child.topChildOY !== child.bottomChildOY;
        }
      }, {
        key: "isOverflowY",
        get: function get() {
          return this.isOverflow;
        }
      }, {
        key: "isOverflowX",
        get: function get() {
          var child = this.childrenMap.child;
          return child.leftChildOX !== child.rightChildOX;
        }
      }, {
        key: "setChildOY",
        value: function setChildOY(value, clamp) {
          if (clamp === undefined) {
            clamp = false;
          }
          if (clamp) {
            value = Clamp$6(value, this.bottomChildOY, this.topChildOY);
          }
          this.childOY = value;
          return this;
        }
      }, {
        key: "addChildOY",
        value: function addChildOY(inc, clamp) {
          this.setChildOY(this.childOY + inc, clamp);
          return this;
        }
      }, {
        key: "setT",
        value: function setT(value, clamp) {
          if (clamp === undefined) {
            clamp = false;
          }
          if (clamp) {
            value = Clamp$6(value, 0, 1);
          }
          this.t = value;
          return this;
        }
      }, {
        key: "addT",
        value: function addT(inc, clamp) {
          this.setT(this.t + inc, clamp);
          return this;
        }
      }, {
        key: "scrollToTop",
        value: function scrollToTop() {
          this.t = 0;
          return this;
        }
      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          this.t = 1;
          // t will be 0 if panel/table does not exceed visible area
          if (this.t === 0) {
            return this;
          }
  
          // Panel/Table height might be expanded while cells are visible        
          do {
            this.t = 1;
          } while (this.t !== 1);
          return this;
        }
      }, {
        key: "setChildOX",
        value: function setChildOX(value, clamp) {
          if (clamp === undefined) {
            clamp = false;
          }
          if (clamp) {
            value = Clamp$6(value, this.leftChildOX, this.rightChildOX);
          }
          this.childOX = value;
          return this;
        }
      }, {
        key: "addChildOX",
        value: function addChildOX(inc, clamp) {
          this.setChildOX(this.childOX + inc, clamp);
          return this;
        }
      }, {
        key: "setS",
        value: function setS(value, clamp) {
          if (clamp === undefined) {
            clamp = false;
          }
          if (clamp) {
            value = Clamp$6(value, 0, 1);
          }
          this.s = value;
          return this;
        }
      }, {
        key: "addS",
        value: function addS(inc, clamp) {
          this.setS(this.s + inc, clamp);
          return this;
        }
      }, {
        key: "scrollToLeft",
        value: function scrollToLeft() {
          this.s = 0;
          return this;
        }
      }, {
        key: "scrollToRight",
        value: function scrollToRight() {
          this.s = 1;
          // s will be 0 if panel/table does not exceed visible area
          if (this.s === 0) {
            return this;
          }
  
          // Panel/Table height might be expanded while cells are visible        
          do {
            this.s = 1;
          } while (this.s !== 1);
          return this;
        }
      }, {
        key: "sliderEnable",
        get: function get() {
          var slider = this.childrenMap.slider;
          if (!slider) {
            return false;
          }
          return slider.enable;
        },
        set: function set(value) {
          var slider = this.childrenMap.slider;
          if (!slider) {
            return;
          }
          slider.setEnable(value);
        }
      }, {
        key: "setSliderEnable",
        value: function setSliderEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.sliderEnable = enabled;
          return this;
        }
      }, {
        key: "sliderYEnable",
        get: function get() {
          return this.sliderEnable;
        },
        set: function set(value) {
          this.sliderEnable = value;
        }
      }, {
        key: "setSliderYEnable",
        value: function setSliderYEnable(enabled) {
          this.setSliderEnable(enabled);
          return this;
        }
      }, {
        key: "sliderXEnable",
        get: function get() {
          var slider = this.childrenMap.sliderX;
          if (!slider) {
            return false;
          }
          return slider.enable;
        },
        set: function set(value) {
          var slider = this.childrenMap.sliderX;
          if (!slider) {
            return;
          }
          slider.setEnable(value);
        }
      }, {
        key: "setSliderXEnable",
        value: function setSliderXEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.sliderXEnable = enabled;
          return this;
        }
      }, {
        key: "scrollerEnable",
        get: function get() {
          var scroller = this.childrenMap.scroller;
          if (!scroller) {
            return false;
          }
          return scroller.enable;
        },
        set: function set(value) {
          var scroller = this.childrenMap.scroller;
          if (!scroller) {
            return;
          }
          scroller.setEnable(value);
        }
      }, {
        key: "setScrollerEnable",
        value: function setScrollerEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.scrollerEnable = enabled;
          return this;
        }
      }, {
        key: "scrollerYEnable",
        get: function get() {
          return this.scrollerEnable;
        },
        set: function set(value) {
          this.scrollerEnable = value;
        }
      }, {
        key: "setScrollerYEnable",
        value: function setScrollerYEnable(enabled) {
          this.setScrollerEnable(enabled);
          return this;
        }
      }, {
        key: "scrollerXEnable",
        get: function get() {
          var scroller = this.childrenMap.scrollerX;
          if (!scroller) {
            return false;
          }
          return scroller.enable;
        },
        set: function set(value) {
          var scroller = this.childrenMap.scrollerX;
          if (!scroller) {
            return;
          }
          scroller.setEnable(value);
        }
      }, {
        key: "setScrollerXEnable",
        value: function setScrollerXEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.scrollerXEnable = enabled;
          return this;
        }
      }, {
        key: "mouseWheelScrollerEnable",
        get: function get() {
          var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
          if (!mouseWheelScroller) {
            return false;
          }
          return mouseWheelScroller.enable;
        },
        set: function set(value) {
          var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
          if (!mouseWheelScroller) {
            return;
          }
          mouseWheelScroller.setEnable(value);
        }
      }, {
        key: "setMouseWheelScrollerEnable",
        value: function setMouseWheelScrollerEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.mouseWheelScrollerEnable = enabled;
          return this;
        }
      }, {
        key: "mouseWheelScrollerYEnable",
        get: function get() {
          return this.mouseWheelScrollerEnable;
        },
        set: function set(value) {
          this.mouseWheelScrollerEnable = value;
        }
      }, {
        key: "setMouseWheelScrollerYEnable",
        value: function setMouseWheelScrollerYEnable(enabled) {
          this.setMouseWheelScrollerEnable(enabled);
          return this;
        }
      }, {
        key: "mouseWheelScrollerXEnable",
        get: function get() {
          var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
          if (!mouseWheelScroller) {
            return false;
          }
          return mouseWheelScroller.enable;
        },
        set: function set(value) {
          var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
          if (!mouseWheelScroller) {
            return;
          }
          mouseWheelScroller.setEnable(value);
        }
      }, {
        key: "setMouseWheelScrollerXEnable",
        value: function setMouseWheelScrollerXEnable(enabled) {
          if (enabled === undefined) {
            enabled = true;
          }
          this.mouseWheelScrollerXEnable = enabled;
          return this;
        }
      }, {
        key: "setDropZoneEnable",
        value: function setDropZoneEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          var child = this.childrenMap.child;
          child.setInteractive();
          child.input.dropZone = enable;
          return this;
        }
      }]);
      return Scrollable;
    }(Sizer);
    var Methods$8 = {
      resizeController: ResizeController,
      updateController: UpdateController
    };
  
    // mixin
    Object.assign(Scrollable.prototype, Methods$8);
  
    var TextToLines = function TextToLines(textObject, text, lines) {
      var textObjectType = GetTextObjectType(textObject);
      switch (textObjectType) {
        case TextType:
          lines = textObject.getWrappedText(text); // Array of string
          break;
        case TagTextType:
          lines = textObject.getPenManager(text, lines); // Pens-manager
          break;
        case BitmapTextType:
          if (textObject.maxWidth > 0) {
            lines = textObject.setText(text).getTextBounds().wrappedText.split('\n');
          } else {
            lines = text.split('\n');
          }
          break;
      }
      return lines;
    };
  
    var SetText = function SetText(text) {
      if (text !== undefined) {
        this.text = text;
      }
  
      // Wrap content in lines
      this.lines = TextToLines(this.textObject, this.text, this.lines);
  
      // Get lines count
      this.linesCount = this.lines.length;
  
      // Re-calculate these values later
      this._textHeight = undefined;
      this._textVisibleHeight = undefined;
      this.updateTextObject();
      return this;
    };
  
    var TextHeightToLinesCount$1 = function TextHeightToLinesCount(height) {
      // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
      return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
    };
  
    var LinesCountToTextHeight = function LinesCountToTextHeight(linesCount) {
      // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
      return linesCount * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing;
    };
  
    var GetLines$1 = function GetLines(startLineIdx) {
      var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
      var text;
      switch (this.textObjectType) {
        case TextType:
          text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
          break;
        case TagTextType:
          var startIdx = this.lines.getLineStartIndex(startLineIdx);
          var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
          text = this.lines.getSliceTagText(startIdx, endIdx, true);
          break;
        case BitmapTextType:
          text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
          break;
      }
      return text;
    };
  
    var SetNoWrapText = function SetNoWrapText(textObject, text) {
      var textObjectType = GetTextObjectType(textObject);
      switch (textObjectType) {
        case TextType:
          // Store wrap properties
          var style = textObject.style;
          var wordWrapWidth = style.wordWrapWidth;
          var wordWrapCallback = style.wordWrapCallback;
          // Disable wrap
          style.wordWrapWidth = 0;
          style.wordWrapCallback = undefined;
          // Set text
          textObject.setText(text);
          // Restore wrap
          style.wordWrapWidth = wordWrapWidth;
          style.wordWrapCallback = wordWrapCallback;
          break;
        case TagTextType:
          // Store wrap properties
          var style = textObject.style;
          var wrapMode = style.wrapMode;
          // Disable wrap
          style.wrapMode = 0;
          // Set text
          textObject.setText(text);
          // Restore wrap
          style.wrapMode = wrapMode;
          break;
        case BitmapTextType:
          // Store wrap properties
          var maxWidth = textObject._maxWidth;
          // Disable wrap
          textObject._maxWidth = 0;
          // Set text
          textObject.setText(text);
          // Restore wrap
          textObject._maxWidth = maxWidth;
          break;
      }
    };
  
    var ResetTextObjectPosition = function ResetTextObjectPosition() {
      var config = this.textObject.rexSizer;
      this.textObject.y += config.offsetY - config.preOffsetY;
      config.preOffsetY = config.offsetY;
      this.resetChildPositionState(this.textObject);
      if (this.textCropEnable) {
        CropTextObject.call(this);
      }
    };
    var CropTextObject = function CropTextObject() {
      // Don't have setCrop method, return
      if (!this.textObject.setCrop) {
        return;
      }
      var offsetY = this.textObject.rexSizer.offsetY;
      var cropY, cropHeight;
      if (offsetY <= 0) {
        cropY = -offsetY;
        cropHeight = this.height;
      } else {
        cropY = 0;
        cropHeight = this.height - offsetY;
      }
      this.textObject.setCrop(0, cropY, this.width, cropHeight);
    };
  
    var UpdateTextObject = function UpdateTextObject() {
      var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount$1.call(this, -this.textOY)), 0);
      var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;
  
      // Grab visible lines
      var text = GetLines$1.call(this, startLineIndex);
  
      // Display visible content
      SetNoWrapText(this.textObject, text);
      this.textObject.rexSizer.offsetY = textOffset;
      ResetTextObjectPosition.call(this);
      return this;
    };
  
    var PreLayout = function PreLayout() {
      // Style of text
      this._textLineHeight = undefined;
      this._textLineSpacing = undefined;
      // Style of text, width of text
      this._visibleLinesCount = undefined;
      // Style of text, total lines of content
      this._textHeight = undefined;
      this._textVisibleHeight = undefined;
      PreLayout$4.call(this);
      return this;
    };
  
    var ResizeText = function ResizeText(textObject, width, height) {
      height += this.textLineHeight + this.textLineSpacing; // Add 1 line
      if (this.textObjectWidth === width && this._textObjectRealHeight === height) {
        return;
      }
      this.textObjectWidth = width;
      this._textObjectRealHeight = height;
      switch (this.textObjectType) {
        case TextType:
        case TagTextType:
          textObject.setFixedSize(width, height);
          var style = textObject.style;
          var wrapWidth = Math.max(width, 0);
          if (this.textObjectType === TextType) {
            // Built-in text
            style.wordWrapWidth = wrapWidth;
          } else {
            // BBCode text, Tag text
            if (style.wrapMode === 0) {
              // Turn no-wrap to word-wrap
              style.wrapMode = 1;
            }
            style.wrapWidth = wrapWidth;
          }
          break;
        case BitmapTextType:
          textObject.setMaxWidth(width);
          break;
      }
  
      // Render content again
      this.setText();
    };
  
    var LayoutChildren$1 = function LayoutChildren() {
      var child, childConfig, padding;
      var startX = this.left,
        startY = this.top;
      var x, y, width, height; // Align zone
  
      // LayoutChildren text child
      // Skip invisible child
      child = this.textObject;
      if (!child.rexSizer.hidden) {
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        x = startX + padding.left;
        y = startY + padding.top;
        width = this.width - padding.left - padding.right;
        height = this.height - padding.top - padding.bottom;
        ResizeText.call(this, child, width, height);
        AlignIn(child, x, y, width, height, childConfig.align);
        childConfig.preOffsetY = 0; // Clear preOffsetY
        ResetTextObjectPosition.call(this);
        if (this.textMask) {
          this.textMask.setPosition().resize();
          this.resetChildPositionState(this.textMask);
        }
      }
    };
  
    var Methods$7 = {
      setText: SetText,
      updateTextObject: UpdateTextObject,
      preLayout: PreLayout,
      layoutChildren: LayoutChildren$1
    };
  
    var IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$1t = Phaser.Utils.Objects.GetValue;
    var ALIGN_LEFTTOP$1 = Phaser.Display.Align.TOP_LEFT;
    var TextBlock = /*#__PURE__*/function (_BaseSizer) {
      _inherits(TextBlock, _BaseSizer);
      function TextBlock(scene, x, y, minWidth, minHeight, config) {
        var _this;
        _classCallCheck(this, TextBlock);
        if (IsPlainObject$c(x)) {
          config = x;
          x = GetValue$1t(config, 'x', 0);
          y = GetValue$1t(config, 'y', 0);
          minWidth = GetValue$1t(config, 'width', undefined);
          minHeight = GetValue$1t(config, 'height', undefined);
        } else if (IsPlainObject$c(minWidth)) {
          config = minWidth;
          minWidth = GetValue$1t(config, 'width', undefined);
          minHeight = GetValue$1t(config, 'height', undefined);
        }
        _this = _callSuper(this, TextBlock, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexTextBlock';
        _this.textObject = undefined;
        _this.linesCount = 0;
        _this.textMask = undefined;
        _this.textObjectType = undefined;
        _this._textLineHeight = undefined;
        _this._textLineSpacing = undefined;
        _this._visibleLinesCount = undefined;
        _this._textHeight = undefined;
        _this._textVisibleHeight = undefined;
        _this._textObjectRealHeight = 0;
        _this.lines = undefined;
        // Text object : array of string
        // Tag text object : pens-manager
        // Bitmap text object : array of string
  
        _this.text = GetValue$1t(config, 'content', '');
        _this._textOY = 0;
        _this.execeedTopState = false;
        _this.execeedBottomState = false;
        _this.setClampMode(GetValue$1t(config, 'clamplTextOY', true));
        _this.alwaysScrollable = GetValue$1t(config, 'alwaysScrollable', false);
  
        // Add elements
        var background = GetValue$1t(config, 'background', undefined);
        var textObject = GetValue$1t(config, 'text', undefined);
        if (textObject === undefined) {
          textObject = CreateDefaultTextObject(scene);
        }
        _this.textCropEnable = GetValue$1t(config, 'textCrop', !!textObject.setCrop);
        var textMaskEnable = GetValue$1t(config, 'textMask', !_this.textCropEnable);
        if (background) {
          _this.addBackground(background);
        }
        _this.add(textObject);
        _this.sizerChildren = [textObject];
        var sizerConfig = _this.getSizerConfig(textObject);
        sizerConfig.align = ALIGN_LEFTTOP$1;
        sizerConfig.padding = GetBoundsConfig(0);
        sizerConfig.expand = true;
        _this.textObject = textObject;
        _this.textObjectType = GetTextObjectType(textObject);
  
        // Add more variables
        sizerConfig.preOffsetY = 0;
        sizerConfig.offsetY = 0;
  
        // Create mask of text object
        if (textMaskEnable) {
          _this.textMask = AddChildMask.call(_assertThisInitialized(_this), _this.textObject, _assertThisInitialized(_this));
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('text', textObject);
        return _this;
      }
      _createClass(TextBlock, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.textObject = undefined;
          this.textMask = undefined;
          if (this.lines) {
            switch (this.textObjectType) {
              case TextType:
                this.lines.length = 0;
                break;
              case TagTextType:
                this.lines.destroy();
                break;
              case BitmapTextType:
                this.lines.length = 0;
                break;
            }
            this.lines = undefined;
          }
          _get(_getPrototypeOf(TextBlock.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setClampMode",
        value: function setClampMode(mode) {
          if (mode === undefined) {
            mode = true;
          }
          this.clampTextOY = mode;
          return this;
        }
      }, {
        key: "textLineHeight",
        get: function get() {
          if (this._textLineHeight === undefined) {
            var lineHeight;
            switch (this.textObjectType) {
              case TextType:
              case TagTextType:
                var style = this.textObject.style;
                lineHeight = style.metrics.fontSize + style.strokeThickness;
                break;
              case BitmapTextType:
                var scale = this.textObject.fontSize / this.textObject.fontData.size;
                lineHeight = this.textObject.fontData.lineHeight * scale;
                break;
            }
            this._textLineHeight = lineHeight;
          }
          return this._textLineHeight;
        }
      }, {
        key: "textLineSpacing",
        get: function get() {
          if (this._textLineSpacing === undefined) {
            var lineSpacing;
            switch (this.textObjectType) {
              case TextType:
              case TagTextType:
                lineSpacing = this.textObject.lineSpacing;
                break;
              case BitmapTextType:
                lineSpacing = 0;
                break;
            }
            this._textLineSpacing = lineSpacing;
          }
          return this._textLineSpacing;
        }
      }, {
        key: "visibleLinesCount",
        get: function get() {
          if (this._visibleLinesCount === undefined) {
            this._visibleLinesCount = Math.floor(TextHeightToLinesCount$1.call(this, this._textObjectRealHeight));
          }
          return this._visibleLinesCount;
        }
      }, {
        key: "topTextOY",
        get: function get() {
          return 0;
        }
      }, {
        key: "bottomTextOY",
        get: function get() {
          return -this.textVisibleHeight;
        }
      }, {
        key: "textHeight",
        get: function get() {
          if (this._textHeight === undefined) {
            this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
          }
          return this._textHeight;
        }
      }, {
        key: "textObjectHeight",
        get: function get() {
          return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing); // Remove 1 text line
        }
      }, {
        key: "textVisibleHeight",
        get: function get() {
          if (this._textVisibleHeight === undefined) {
            var h = this.textHeight - this.textObjectHeight;
            if (!this.alwaysScrollable && h < 0) {
              h = 0;
            }
            this._textVisibleHeight = h;
          }
          return this._textVisibleHeight;
        }
      }, {
        key: "textOYExceedTop",
        value: function textOYExceedTop(oy) {
          if (oy === undefined) {
            oy = this.textOY;
          }
          return oy > this.topTextOY;
        }
      }, {
        key: "textOYExeceedBottom",
        value: function textOYExeceedBottom(oy) {
          if (oy === undefined) {
            oy = this.textOY;
          }
          return oy < this.bottomTextOY;
        }
      }, {
        key: "textOY",
        get: function get() {
          return this._textOY;
        },
        set: function set(oy) {
          var topTextOY = this.topTextOY;
          var bottomTextOY = this.bottomTextOY;
          var textOYExceedTop = this.textOYExceedTop(oy);
          var textOYExeceedBottom = this.textOYExeceedBottom(oy);
          if (this.clampTextOY) {
            if (this.visibleLinesCount > this.linesCount) {
              oy = 0;
            } else if (textOYExceedTop) {
              oy = topTextOY;
            } else if (textOYExeceedBottom) {
              oy = bottomTextOY;
            }
          }
          if (this._textOY !== oy) {
            this._textOY = oy;
            this.updateTextObject();
          }
          if (textOYExceedTop) {
            if (!this.execeedTopState) {
              this.emit('execeedtop', this, oy, topTextOY);
            }
          }
          this.execeedTopState = textOYExceedTop;
          if (textOYExeceedBottom) {
            if (!this.execeedBottomState) {
              this.emit('execeedbottom', this, oy, bottomTextOY);
            }
          }
          this.execeedBottomState = textOYExeceedBottom;
        }
      }, {
        key: "setTextOY",
        value: function setTextOY(oy) {
          this.textOY = oy;
          return this;
        }
      }, {
        key: "t",
        get: function get() {
          var textVisibleHeight = this.textVisibleHeight;
          if (textVisibleHeight === 0) {
            return 0;
          }
          return this.textOY / -textVisibleHeight;
        },
        set: function set(value) {
          this.textOY = -this.textVisibleHeight * value;
        }
      }, {
        key: "setTextOYByPercentage",
        value: function setTextOYByPercentage(percentage) {
          this.t = percentage;
          return this;
        }
      }]);
      return TextBlock;
    }(Base);
    var CreateDefaultTextObject = function CreateDefaultTextObject(scene) {
      return scene.add.text(0, 0, '');
    };
    Object.assign(TextBlock.prototype, Methods$7);
  
    var InjectProperties$2 = function InjectProperties(textBlock) {
      Object.defineProperty(textBlock, 'childOY', {
        configurable: true,
        get: function get() {
          return textBlock.textOY;
        },
        set: function set(value) {
          textBlock.textOY = value;
        }
      });
      Object.defineProperty(textBlock, 'topChildOY', {
        get: function get() {
          return textBlock.topTextOY;
        }
      });
      Object.defineProperty(textBlock, 'bottomChildOY', {
        get: function get() {
          return textBlock.bottomTextOY;
        }
      });
      Object.defineProperty(textBlock, 'childVisibleHeight', {
        get: function get() {
          return textBlock.textObjectHeight;
        }
      });
      Object.defineProperty(textBlock, 'childHeight', {
        get: function get() {
          return textBlock.textHeight;
        }
      });
    };
  
    var SetTextMethods$1 = {
      setText: function setText(text) {
        var textBlock = this.childrenMap.child;
        textBlock.setText(text);
        this.resizeController();
        return this;
      },
      appendText: function appendText(text) {
        this.setText(this.text + text);
        return this;
      }
    };
  
    var ScrollMethods$2 = {
      scrollToLine: function scrollToLine(lineIndex) {
        this.setChildOY(-this.lineHeight * lineIndex);
        return this;
      },
      scrollToNextLine: function scrollToNextLine(lineCount) {
        if (lineCount === undefined) {
          lineCount = 1;
        }
        var lineIndex = this.lineIndex + lineCount;
        this.scrollToLine(lineIndex);
        return this;
      }
    };
  
    var GetValue$1s = Phaser.Utils.Objects.GetValue;
    var TextArea = /*#__PURE__*/function (_Scrollable) {
      _inherits(TextArea, _Scrollable);
      function TextArea(scene, config) {
        var _this;
        _classCallCheck(this, TextArea);
        if (config === undefined) {
          config = {};
        }
  
        // Create text-block
        var textObject = GetValue$1s(config, 'text', undefined);
        var textWidth = GetValue$1s(config, 'textWidth', undefined);
        var textHeight = GetValue$1s(config, 'textHeight', undefined);
        var textCrop = GetValue$1s(config, 'textCrop', !!textObject.setCrop);
        var textMask = GetValue$1s(config, 'textMask', !textCrop);
        var content = GetValue$1s(config, 'content', '');
        var textBlock = new TextBlock(scene, {
          width: textWidth,
          height: textHeight,
          text: textObject,
          textMask: textMask,
          textCrop: textCrop && !textMask,
          content: content,
          clamplTextOY: GetValue$1s(config, 'clamplChildOY', false),
          alwaysScrollable: GetValue$1s(config, 'alwaysScrollable', false)
        });
        scene.add.existing(textBlock); // Important: Add to display list for touch detecting
        // Inject properties for scrollable interface
        InjectProperties$2(textBlock);
  
        // Fill config of scrollable
        config.scrollMode = 0; // Vertical
        config.type = 'rexTextArea';
        config.child = {
          gameObject: textBlock,
          expandWidth: textWidth === undefined,
          expandHeight: textHeight === undefined
        };
        var spaceConfig = GetValue$1s(config, 'space', undefined);
        if (spaceConfig) {
          spaceConfig.child = GetValue$1s(spaceConfig, 'text', 0);
        }
        _this = _callSuper(this, TextArea, [scene, config]);
        _this.addChildrenMap('text', textObject);
        return _this;
      }
      _createClass(TextArea, [{
        key: "text",
        get: function get() {
          return this.childrenMap.child.text;
        }
      }, {
        key: "lineHeight",
        get: function get() {
          var textBlock = this.childrenMap.child;
          return textBlock.textLineHeight + textBlock.textLineSpacing;
        }
      }, {
        key: "lineIndex",
        get: function get() {
          return Math.floor(-this.childOY / this.lineHeight);
        }
      }, {
        key: "linesCount",
        get: function get() {
          var textBlock = this.childrenMap.child;
          return textBlock.linesCount;
        }
      }, {
        key: "contentHeight",
        get: function get() {
          var textBlock = this.childrenMap.child;
          return textBlock.textHeight;
        }
      }]);
      return TextArea;
    }(Scrollable);
    Object.assign(TextArea.prototype, SetTextMethods$1, ScrollMethods$2);
  
    var GetValue$1r = Phaser.Utils.Objects.GetValue;
    var CreateTextArea = function CreateTextArea(scene, config, creators) {
      config = config ? DeepClone(config) : {};
      var createBackground = GetValue$1r(creators, 'background', CreateBackground$2);
      var createText = GetValue$1r(creators, 'text', CreateText);
      var createTrack = GetValue$1r(creators, 'track', CreateBackground$2);
      var createThumb = GetValue$1r(creators, 'thumb', CreateBackground$2);
      if (createBackground) {
        config.background = createBackground(scene, config.background);
      } else {
        delete config.background;
      }
      if (createText) {
        config.text = createText(scene, config.text);
      } else {
        delete config.text;
      }
      var sliderConfig = config.slider;
      if (sliderConfig !== false && sliderConfig !== null) {
        if (sliderConfig === undefined) {
          sliderConfig = {};
        }
        if (createTrack) {
          sliderConfig.track = createTrack(scene, sliderConfig.track);
        } else {
          delete sliderConfig.track;
        }
        if (createThumb) {
          sliderConfig.thumb = createThumb(scene, sliderConfig.thumb);
        } else {
          delete sliderConfig.thumb;
        }
        config.slider = sliderConfig;
      }
  
      // No header
      // No footer
  
      var gameObject = new TextArea(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var CreateText = function CreateText(scene, config) {
      var gameObjectType;
      if (config) {
        if (config.hasOwnProperty('$type')) {
          gameObjectType = config.$type;
        } else {
          if (config.hasOwnProperty('key')) {
            gameObjectType = 'bitmaptext';
          }
        }
      }
      var gameObject;
      switch (gameObjectType) {
        case 'bitmaptext':
        case 'bitmap':
          gameObject = new StatesBitmapText(scene, config);
          break;
        case 'bbcodetext':
        case 'bbcode':
          gameObject = new BBCodeText(scene, 0, 0, '', config);
          break;
        case 'label':
          gameObject = new SimpleLabel(scene, config);
          break;
        case 'textarea':
          gameObject = CreateTextArea(scene, config);
          break;
        default:
          gameObject = new StatesText(scene, config);
          break;
      }
      DecorateGameObject(gameObject, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var CreateImage = function CreateImage(scene, config) {
      var gameObjectType;
      if (config) {
        if (config.hasOwnProperty('$type')) {
          gameObjectType = config.$type;
        } else {
          if (config.hasOwnProperty('leftWidth')) {
            gameObjectType = 'nineSlice';
          } else if (config.hasOwnProperty('color') || config.hasOwnProperty('strokeColor')) {
            gameObjectType = 'roundRectangle';
          }
        }
      }
      var gameObject;
      switch (gameObjectType) {
        case 'nineSlice':
          if (!config.hasOwnProperty('stretchMode')) {
            gameObject = new StatesNineSlice(scene, config);
          } else {
            gameObject = new StatesNinePatch(scene, config);
          }
          break;
        case 'roundRectangle':
          gameObject = new StatesRoundRectangle(scene, config);
          break;
        default:
          gameObject = new StatesImage(scene, config);
          break;
      }
      DecorateGameObject(gameObject, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$1q = Phaser.Utils.Objects.GetValue;
    var BuildLabelConfig = function BuildLabelConfig(scene, config, creators) {
      config = config ? DeepClone(config) : {};
      var createBackground = GetValue$1q(creators, 'background', CreateBackground$2);
      var createText = GetValue$1q(creators, 'text', CreateText);
      var createIcon = GetValue$1q(creators, 'icon', CreateImage);
      var createAction = GetValue$1q(creators, 'action', CreateImage);
      if (config.background !== null && createBackground) {
        config.background = createBackground(scene, config.background);
      } else {
        delete config.background;
      }
      if (config.text !== null && createText) {
        config.text = createText(scene, config.text);
      } else {
        delete config.text;
      }
      if (config.icon !== null && createIcon) {
        config.icon = createIcon(scene, config.icon);
      } else {
        delete config.icon;
      }
      if (config.action !== null && createAction) {
        config.action = createAction(scene, config.action);
      } else {
        delete config.action;
      }
      return config;
    };
  
    var SimpleLabel = /*#__PURE__*/function (_Label) {
      _inherits(SimpleLabel, _Label);
      function SimpleLabel(scene, config, creators) {
        var _this;
        _classCallCheck(this, SimpleLabel);
        config = BuildLabelConfig(scene, config, creators);
        _this = _callSuper(this, SimpleLabel, [scene, config]);
        _this.type = 'rexSimpleLabel';
        return _this;
      }
      _createClass(SimpleLabel, [{
        key: "setActiveState",
        value: function setActiveState(enable) {
          RunMethod$1(this.getChildren(), 'setActiveState', enable);
          return this;
        }
      }, {
        key: "setHoverState",
        value: function setHoverState(enable) {
          RunMethod$1(this.getChildren(), 'setHoverState', enable);
          return this;
        }
      }, {
        key: "setDisableState",
        value: function setDisableState(enable) {
          RunMethod$1(this.getChildren(), 'setDisableState', enable);
          return this;
        }
      }]);
      return SimpleLabel;
    }(Label);
    var RunMethod$1 = function RunMethod(children, methodName, enable) {
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var gameObject = children[i];
        if (gameObject && gameObject[methodName]) {
          gameObject[methodName](enable);
        }
      }
    };
  
    ObjectFactory.register('simpleLabel', function (config, creators) {
      var gameObject = new SimpleLabel(this.scene, config, creators);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.SimpleLabel', SimpleLabel);
  
    /*
    Elements:
  
    Icon  Title      ActionIcon
    Icon  Separator  ActionIcon
    Icon  Text       ActionIcon
  
    */
  
    var GetValue$1p = Phaser.Utils.Objects.GetValue;
    var LayoutMode0$2 = function LayoutMode0(config) {
      var scene = this.scene;
      var orientation = GetValue$1p(config, 'orientation', 0);
      this.setOrientation(orientation);
  
      // Add elements
      var icon = GetValue$1p(config, 'icon', undefined);
      var iconMask = GetValue$1p(config, 'iconMask', undefined);
      var innerBackground = GetValue$1p(config, 'innerBackground', undefined);
      var title = GetValue$1p(config, 'title', undefined);
      var separator = GetValue$1p(config, 'separator', undefined);
      var text = GetValue$1p(config, 'text', undefined);
      var action = GetValue$1p(config, 'action', undefined);
      var actionMask = GetValue$1p(config, 'actionMask', undefined);
      if (icon) {
        var padding;
        if (this.orientation === 0) {
          padding = {
            right: GetValue$1p(config, 'space.icon', 0),
            top: GetValue$1p(config, 'space.iconTop', 0),
            bottom: GetValue$1p(config, 'space.iconBottom', 0),
            left: GetValue$1p(config, 'space.iconLeft', 0)
          };
        } else {
          padding = {
            bottom: GetValue$1p(config, 'space.icon', 0),
            left: GetValue$1p(config, 'space.iconLeft', 0),
            right: GetValue$1p(config, 'space.iconRight', 0),
            top: GetValue$1p(config, 'space.iconTop', 0)
          };
        }
        var fitRatio = GetValue$1p(config, 'squareFitIcon', false) ? 1 : 0;
        this.add(icon, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (iconMask) {
          iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
        }
        if (!fitRatio) {
          var iconSize = GetValue$1p(config, 'iconSize', undefined);
          this.setIconSize(GetValue$1p(config, 'iconWidth', iconSize), GetValue$1p(config, 'iconHeight', iconSize));
        }
      }
  
      // InnerSizer : title, separator, text
      var innerSizer = new Sizer(scene, {
        orientation: 1
      });
      if (innerBackground) {
        innerSizer.addBackground(innerBackground);
      }
      var separatorSpace = GetValue$1p(config, 'space.separator', 0);
      if (title) {
        var align = GetValue$1p(config, 'align.title', 'left');
        var expandTitleWidth = GetValue$1p(config, 'expandTitleWidth', false);
        var expandTitleHeight = GetValue$1p(config, 'expandTitleHeight', false);
        var proportion, padding, expand;
        proportion = expandTitleHeight ? 1 : 0;
        expand = expandTitleWidth;
        padding = {
          bottom: !separator && text ? separatorSpace : 0,
          left: GetValue$1p(config, 'space.titleLeft', 0),
          right: GetValue$1p(config, 'space.titleRight', 0)
        };
        innerSizer.add(title, {
          proportion: proportion,
          expand: expand,
          align: align,
          padding: padding
        });
      }
      if (separator) {
        var padding = {
          top: title ? separatorSpace : 0,
          bottom: text ? separatorSpace : 0,
          left: GetValue$1p(config, 'space.separatorLeft', 0),
          right: GetValue$1p(config, 'space.separatorRight', 0)
        };
        innerSizer.add(separator, {
          expand: true,
          padding: padding
        }
        // Fixed height, expand width
        );
      }
      if (text) {
        var align = GetValue$1p(config, 'align.text', 'left');
        var expandTextWidth = GetValue$1p(config, 'expandTextWidth', false);
        var expandTextHeight = GetValue$1p(config, 'expandTextHeight', false);
        var proportion, padding, expand;
        proportion = expandTextHeight ? 1 : 0;
        expand = expandTextWidth;
        padding = {
          left: GetValue$1p(config, 'space.textLeft', 0),
          right: GetValue$1p(config, 'space.textRight', 0)
        };
        innerSizer.add(text, {
          proportion: proportion,
          expand: expand,
          align: align,
          padding: padding
        });
      }
      var padding = undefined;
      if (action) {
        padding = {
          right: GetValue$1p(config, 'space.text', 0)
        };
      }
      this.add(innerSizer, {
        proportion: 1,
        padding: padding
      });
      // InnerSizer : title, separator, text
  
      if (action) {
        var padding;
        if (this.orientation === 0) {
          padding = {
            top: GetValue$1p(config, 'space.actionTop', 0),
            bottom: GetValue$1p(config, 'space.actionBottom', 0),
            right: GetValue$1p(config, 'space.actionRight', 0)
          };
        } else {
          padding = {
            left: GetValue$1p(config, 'space.actionLeft', 0),
            right: GetValue$1p(config, 'space.actionRight', 0),
            bottom: GetValue$1p(config, 'space.actionBottom', 0)
          };
        }
        var fitRatio = GetValue$1p(config, 'squareFitAction', false) ? 1 : 0;
        this.add(action, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (actionMask) {
          actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
        }
        if (!fitRatio) {
          var actionSize = GetValue$1p(config, 'actionSize');
          this.setActionSize(GetValue$1p(config, 'actionWidth', actionSize), GetValue$1p(config, 'actionHeight', actionSize));
        }
      }
      this.addChildrenMap('icon', icon);
      this.addChildrenMap('iconMask', iconMask);
      this.addChildrenMap('innerSizer', innerSizer);
      this.addChildrenMap('innerBackground', innerBackground);
      this.addChildrenMap('title', title);
      this.addChildrenMap('separator', separator);
      this.addChildrenMap('text', text);
      this.addChildrenMap('action', action);
      this.addChildrenMap('actionMask', actionMask);
    };
  
    /*
    Elements:
  
    Title      Title       Title
    Separator  Separator   Separator
    Icon       Text        ActionIcon 
  
    */
  
    var GetValue$1o = Phaser.Utils.Objects.GetValue;
    var LayoutMode1$1 = function LayoutMode1(config) {
      this.setOrientation(1);
      this.setRTL(false);
      var scene = this.scene;
  
      // Add elements
      var title = GetValue$1o(config, 'title', undefined);
      var separator = GetValue$1o(config, 'separator', undefined);
      var innerBackground = GetValue$1o(config, 'innerBackground', undefined);
      var icon = GetValue$1o(config, 'icon', undefined);
      var iconMask = GetValue$1o(config, 'iconMask', undefined);
      var text = GetValue$1o(config, 'text', undefined);
      var action = GetValue$1o(config, 'action', undefined);
      var actionMask = GetValue$1o(config, 'actionMask', undefined);
      if (title) {
        var align = GetValue$1o(config, 'align.title', 'left');
        var expandTitleWidth = GetValue$1o(config, 'expandTitleWidth', false);
        var expandTitleHeight = GetValue$1o(config, 'expandTitleHeight', false);
        var proportion, padding, expand;
        proportion = expandTitleHeight ? 1 : 0;
        expand = expandTitleWidth;
        padding = {
          bottom: GetValue$1o(config, 'space.title', 0),
          left: GetValue$1o(config, 'space.titleLeft', 0),
          right: GetValue$1o(config, 'space.titleRight', 0)
        };
        this.add(title, {
          proportion: proportion,
          expand: expand,
          align: align,
          padding: padding
        });
      }
      if (separator) {
        var separatorSpace = GetValue$1o(config, 'space.separator', 0);
        var padding = {
          top: title ? separatorSpace : 0,
          bottom: text ? separatorSpace : 0,
          left: GetValue$1o(config, 'space.separatorLeft', 0),
          right: GetValue$1o(config, 'space.separatorRight', 0)
        };
        this.add(separator, {
          proportion: 0,
          expand: true,
          padding: padding
        }
        // Fixed height, expand width
        );
      }
      var orientation = GetValue$1o(config, 'orientation', 0);
      var innerSizer = new Sizer(scene, {
        orientation: orientation,
        rtl: GetValue$1o(config, 'rtl', false),
        space: {
          left: GetValue$1o(config, 'space.innerLeft', 0),
          right: GetValue$1o(config, 'space.innerRight', 0),
          top: GetValue$1o(config, 'space.innerTop', 0),
          bottom: GetValue$1o(config, 'space.innerBottom', 0)
        }
      });
      if (innerBackground) {
        innerSizer.addBackground(innerBackground);
      }
      this.add(innerSizer, {
        proportion: 1,
        expand: true
      });
      if (icon) {
        var padding = undefined;
        if (innerSizer.orientation === 0) {
          padding = {
            right: GetValue$1o(config, 'space.icon', 0),
            top: GetValue$1o(config, 'space.iconTop', 0),
            bottom: GetValue$1o(config, 'space.iconBottom', 0),
            left: GetValue$1o(config, 'space.iconLeft', 0)
          };
        } else {
          padding = {
            bottom: GetValue$1o(config, 'space.icon', 0),
            left: GetValue$1o(config, 'space.iconLeft', 0),
            right: GetValue$1o(config, 'space.iconRight', 0),
            top: GetValue$1o(config, 'space.iconTop', 0)
          };
        }
        var fitRatio = GetValue$1o(config, 'squareFitIcon', false) ? 1 : 0;
        innerSizer.add(icon, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (iconMask) {
          iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
        }
        if (!fitRatio) {
          var iconSize = GetValue$1o(config, 'iconSize', undefined);
          this.setIconSize(GetValue$1o(config, 'iconWidth', iconSize), GetValue$1o(config, 'iconHeight', iconSize));
        }
      }
      if (text) {
        var align = GetValue$1o(config, 'align.text', 'left');
        var textSpace = GetValue$1o(config, 'space.text', 0);
        var expandTextWidth = GetValue$1o(config, 'expandTextWidth', false);
        var expandTextHeight = GetValue$1o(config, 'expandTextHeight', false);
        var proportion, padding, expand;
        if (innerSizer.orientation === 0) {
          proportion = expandTextWidth ? 1 : 0;
          if (action) {
            padding = {
              right: textSpace
            };
          }
          expand = expandTextHeight;
        } else {
          proportion = expandTextHeight ? 1 : 0;
          if (action) {
            padding = {
              bottom: textSpace
            };
          }
          expand = expandTextWidth;
        }
        innerSizer.add(text, {
          proportion: proportion,
          expand: expand,
          align: align,
          padding: padding
        });
      }
      if (action) {
        var padding;
        if (innerSizer.orientation === 0) {
          padding = {
            top: GetValue$1o(config, 'space.actionTop', 0),
            bottom: GetValue$1o(config, 'space.actionBottom', 0),
            right: GetValue$1o(config, 'space.actionRight', 0)
          };
        } else {
          padding = {
            left: GetValue$1o(config, 'space.actionLeft', 0),
            right: GetValue$1o(config, 'space.actionRight', 0),
            bottom: GetValue$1o(config, 'space.actionBottom', 0)
          };
        }
        var fitRatio = GetValue$1o(config, 'squareFitAction', false) ? 1 : 0;
        innerSizer.add(action, {
          proportion: 0,
          padding: padding,
          fitRatio: fitRatio
        });
        if (actionMask) {
          actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
        }
        if (!fitRatio) {
          var actionSize = GetValue$1o(config, 'actionSize');
          this.setActionSize(GetValue$1o(config, 'actionWidth', actionSize), GetValue$1o(config, 'actionHeight', actionSize));
        }
      }
      this.addChildrenMap('title', title);
      this.addChildrenMap('separator', separator);
      this.addChildrenMap('innerSizer', innerSizer);
      this.addChildrenMap('innerBackground', innerBackground);
      this.addChildrenMap('icon', icon);
      this.addChildrenMap('iconMask', iconMask);
      this.addChildrenMap('text', text);
      this.addChildrenMap('action', action);
      this.addChildrenMap('actionMask', actionMask);
    };
  
    var GetValue$1n = Phaser.Utils.Objects.GetValue;
    var LayoutCallbacks$1 = [LayoutMode0$2, LayoutMode1$1];
    var TitleLabel = /*#__PURE__*/function (_LabelBase) {
      _inherits(TitleLabel, _LabelBase);
      function TitleLabel(scene, config) {
        var _this;
        _classCallCheck(this, TitleLabel);
        if (config === undefined) {
          config = {};
        }
  
        // Create sizer
        _this = _callSuper(this, TitleLabel, [scene, config]);
        _this.type = 'rexTitleLabel';
  
        // Add Background
        var background = GetValue$1n(config, 'background', undefined);
        if (background) {
          _this.addBackground(background);
        }
  
        // Wrap title, text
        var title = GetValue$1n(config, 'title', undefined);
        var text = GetValue$1n(config, 'text', undefined);
        if (title) {
          var wrapTitle = GetValue$1n(config, 'wrapTitle', false);
          if (wrapTitle) {
            if (wrapTitle === true) {
              wrapTitle = 'word';
            }
            SetWrapMode(title, wrapTitle);
            config.expandTitleWidth = true;
            WrapExpandText(title);
          }
        }
        if (text) {
          var wrapText = GetValue$1n(config, 'wrapText', false);
          if (wrapText) {
            if (wrapText === true) {
              wrapText = 'word';
            }
            SetWrapMode(text, wrapText);
            config.expandTextWidth = true;
            WrapExpandText(text);
          }
        }
        var layoutMode = GetValue$1n(config, 'layoutMode', 0);
        var layoutCallback = LayoutCallbacks$1[layoutMode] || LayoutCallbacks$1[0];
        layoutCallback.call(_assertThisInitialized(_this), config);
  
        // Elements : title, separator, innerBackground,
        //            icon, iconMask, text, action, actionMask, background
        //            innerSizer
        _this.addChildrenMap('background', config.background);
        return _this;
      }
  
      // Access title game object
      _createClass(TitleLabel, [{
        key: "title",
        get: function get() {
          var textObject = this.childrenMap.title;
          if (!textObject) {
            return '';
          }
          return textObject.title;
        },
        set: function set(value) {
          var textObject = this.childrenMap.title;
          if (!textObject) {
            return;
          }
          textObject.setText(value);
        }
      }, {
        key: "setTitle",
        value: function setTitle(value) {
          this.title = value;
          return this;
        }
      }, {
        key: "resetDisplayContent",
        value: function resetDisplayContent(config) {
          if (config === undefined) {
            config = {};
          } else if (typeof config === 'string') {
            config = {
              text: config
            };
          }
          _get(_getPrototypeOf(TitleLabel.prototype), "resetDisplayContent", this).call(this, config);
          var textObject = this.childrenMap.title;
          if (textObject) {
            if (config.title === undefined) ; else if (config.title) {
              this.show(textObject);
              this.setTitle(config.title);
            } else {
              // false, null
              this.hide(textObject);
            }
          }
          return this;
        }
      }]);
      return TitleLabel;
    }(LabelBase);
  
    ObjectFactory.register('titleLabel', function (config) {
      var gameObject = new TitleLabel(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TitleLabel', TitleLabel);
  
    var GetValue$1m = Phaser.Utils.Objects.GetValue;
    var BuildTitleLabelConfig = function BuildTitleLabelConfig(scene, config, creators) {
      var createInnerBackground = GetValue$1m(creators, 'innerBackground', CreateBackground$2);
      var createSeparator = GetValue$1m(creators, 'separator', CreateBackground$2);
      var createTitle = GetValue$1m(creators, 'title', CreateText);
      var innerBackground, separator;
  
      // Create innerBackground before background
      if (config.innerBackground !== null && createInnerBackground) {
        innerBackground = createInnerBackground(scene, config.innerBackground);
      }
  
      // Create separator before background
      if (config.separator !== null && createSeparator) {
        separator = createSeparator(scene, config.separator);
      }
      config = BuildLabelConfig(scene, config, creators);
      if (innerBackground) {
        config.innerBackground = innerBackground;
      } else {
        delete config.innerBackground;
      }
      if (separator) {
        config.separator = separator;
      } else {
        delete config.separator;
      }
      if (config.title !== null && createTitle) {
        config.title = createTitle(scene, config.title);
      } else {
        delete config.title;
      }
  
      // Keep background as the bottom element
      var background = config.background;
      if (background) {
        if (innerBackground) {
          scene.children.moveBelow(background, innerBackground); // Move child1 below child2
        } else if (separator) {
          scene.children.moveBelow(background, separator); // Move child1 below child2
        }
      }
      return config;
    };
  
    var SimpleTitleLabel = /*#__PURE__*/function (_TitleLabel) {
      _inherits(SimpleTitleLabel, _TitleLabel);
      function SimpleTitleLabel(scene, config, creators) {
        var _this;
        _classCallCheck(this, SimpleTitleLabel);
        config = BuildTitleLabelConfig(scene, config, creators);
        _this = _callSuper(this, SimpleTitleLabel, [scene, config]);
        _this.type = 'rexSimpleTitleLabel';
        return _this;
      }
      _createClass(SimpleTitleLabel, [{
        key: "setActiveState",
        value: function setActiveState(enable) {
          RunMethod(this.getChildren(), 'setActiveState', enable);
          return this;
        }
      }, {
        key: "setHoverState",
        value: function setHoverState(enable) {
          RunMethod(this.getChildren(), 'setHoverState', enable);
          return this;
        }
      }, {
        key: "setDisableState",
        value: function setDisableState(enable) {
          RunMethod(this.getChildren(), 'setDisableState', enable);
          return this;
        }
      }]);
      return SimpleTitleLabel;
    }(TitleLabel);
    var RunMethod = function RunMethod(children, methodName, enable) {
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var gameObject = children[i];
        if (gameObject && gameObject[methodName]) {
          gameObject[methodName](enable);
        }
      }
    };
  
    ObjectFactory.register('simpleTitleLabel', function (config, creators) {
      var gameObject = new SimpleTitleLabel(this.scene, config, creators);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.SimpleTitleLabel', SimpleTitleLabel);
  
    var GetValue$1l = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;
    var Build$1 = function Build(scene, config) {
      // Add elements
      var background = GetValue$1l(config, 'background', undefined);
      var icon = GetValue$1l(config, 'icon', undefined);
      var iconMask = GetValue$1l(config, 'iconMask', undefined);
      var nameText = GetValue$1l(config, 'nameText', undefined);
      var valueText = GetValue$1l(config, 'valueText', undefined);
      var bar = GetValue$1l(config, 'bar', undefined);
      var action = GetValue$1l(config, 'action', undefined);
      var actionMask = GetValue$1l(config, 'actionMask', undefined);
      var isLineBar = GetValue$1l(config, 'barShape', 'line') === 'line';
      if (IsPlainObject$b(bar)) {
        var BarClass = isLineBar ? LineProgress : CircularProgress;
        bar = new BarClass(scene, bar);
        scene.add.existing(bar);
        // Move bar game object below nameText and valueText
        if (nameText) {
          scene.children.moveBelow(bar, nameText);
        }
        if (valueText) {
          scene.children.moveBelow(bar, valueText);
        }
      }
      var hasTextSizer = nameText || valueText || bar;
      if (background) {
        this.addBackground(background);
      }
      if (icon) {
        var padding = undefined;
        if (this.orientation === 0) {
          if (hasTextSizer || action) {
            padding = {
              right: GetValue$1l(config, 'space.icon', 0),
              top: GetValue$1l(config, 'space.iconTop', 0),
              bottom: GetValue$1l(config, 'space.iconBottom', 0)
            };
          }
        } else {
          if (hasTextSizer || action) {
            padding = {
              bottom: GetValue$1l(config, 'space.icon', 0),
              left: GetValue$1l(config, 'space.iconLeft', 0),
              right: GetValue$1l(config, 'space.iconRight', 0)
            };
          }
        }
        this.add(icon, {
          proportion: 0,
          padding: padding
        });
        if (iconMask) {
          iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
        }
      }
      if (hasTextSizer) {
        var textSizer = new Sizer(scene, {
          orientation: 1
        });
        var nameValueSizer;
        if (nameText || valueText) {
          nameValueSizer = new Sizer(scene, {
            orientation: 0
          });
          if (nameText) {
            // A space character to reserve text height
            if (nameText.text === '') {
              nameText.setText(' ');
            }
            nameText.setOrigin(0, nameText.originY);
            var padding = {
              left: GetValue$1l(config, 'space.name', 0)
            };
            nameValueSizer.add(nameText, {
              padding: padding
            });
          }
          if (valueText) {
            // A space character to reserve text height
            if (valueText.text === '') {
              valueText.setText(' ');
            }
            valueText.setOrigin(1, valueText.originY);
            nameValueSizer.addSpace();
            var padding = {
              right: GetValue$1l(config, 'space.value', 0)
            };
            nameValueSizer.add(valueText, {
              padding: padding
            });
            this.setValueTextFormatCallback(GetValue$1l(config, 'valueTextFormatCallback', DefaultValueTextFormatCallback), GetValue$1l(config, 'valueTextFormatCallbackScope', undefined));
          }
          textSizer.add(nameValueSizer, {
            expand: true
          });
        }
        if (bar) {
          if (isLineBar) {
            var paddingTop = nameValueSizer ? GetValue$1l(config, 'space.bar') : 0;
            if (paddingTop === undefined) {
              paddingTop = GetValue$1l(config, 'space.barTop', 0);
            }
            var padding = {
              top: paddingTop,
              bottom: GetValue$1l(config, 'space.barBottom', 0),
              left: GetValue$1l(config, 'space.barLeft', 0),
              right: GetValue$1l(config, 'space.barRight', 0)
            };
            textSizer.add(bar, {
              expand: true,
              padding: padding
            });
          } else {
            var padding = {
              top: GetValue$1l(config, 'space.barTop', 0),
              bottom: GetValue$1l(config, 'space.barBottom', 0),
              left: GetValue$1l(config, 'space.barLeft', 0),
              right: GetValue$1l(config, 'space.barRight', 0)
            };
            this.addBackground(bar, padding);
          }
        }
        var padding = undefined;
        if (action) {
          padding = {
            right: GetValue$1l(config, 'space.text', 0)
          };
        }
        var textAlign = GetValue$1l(config, 'align.text', 'bottom');
        this.add(textSizer, {
          proportion: 1,
          align: textAlign,
          padding: padding
        });
      }
      if (action) {
        var padding;
        if (this.orientation === 0) {
          padding = {
            top: GetValue$1l(config, 'space.actionTop', 0),
            bottom: GetValue$1l(config, 'space.actionBottom', 0)
          };
        } else {
          padding = {
            left: GetValue$1l(config, 'space.actionLeft', 0),
            right: GetValue$1l(config, 'space.actionRight', 0)
          };
        }
        this.add(action, {
          proportion: 0,
          padding: padding
        });
        if (actionMask) {
          actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
        }
      }
      this.addChildrenMap('background', background);
      this.addChildrenMap('icon', icon);
      this.addChildrenMap('iconMask', iconMask);
      this.addChildrenMap('name', nameText);
      this.addChildrenMap('value', valueText);
      this.addChildrenMap('bar', bar);
      this.addChildrenMap('action', action);
      this.addChildrenMap('actionMask', actionMask);
    };
    var DefaultValueTextFormatCallback = function DefaultValueTextFormatCallback(value, min, max) {
      return value.toString();
    };
  
    var Clamp$5 = Phaser.Math.Clamp;
    var SetValueMethods = {
      setValueTextFormatCallback: function setValueTextFormatCallback(callback, scope) {
        this.valueTextFormatCallback = callback;
        this.valueTextFormatCallbackScope = scope;
        return this;
      },
      getFormatValueText: function getFormatValueText(value, min, max) {
        if (value === undefined) {
          value = this.value;
        }
        if (min === undefined) {
          min = this.minValue;
        }
        if (max === undefined) {
          max = this.maxValue;
        }
        var text;
        if (this.valueTextFormatCallbackScope) {
          text = this.valueTextFormatCallback(value, min, max);
        } else {
          text = this.valueTextFormatCallback.call(this.valueTextFormatCallbackScope, value, min, max);
        }
        return text;
      },
      updateValueText: function updateValueText(value, min, max) {
        var textObject = this.childrenMap.value;
        if (textObject && this.valueTextFormatCallback) {
          textObject.setText(this.getFormatValueText(value, min, max));
          if (textObject.layout) {
            textObject.layout();
          }
        }
        return this;
      },
      setValue: function setValue(value, min, max) {
        if (min === undefined) {
          min = this.minValue;
        } else {
          this.minValue = min;
        }
        if (max === undefined) {
          max = this.maxValue;
        } else {
          this.maxValue = max;
        }
        value = Clamp$5(value, min, max);
        this.value = value;
        this.updateValueText(value, min, max);
        this.setBarValue(value, min, max);
        return this;
      },
      setEaseValueDuration: function setEaseValueDuration(duration) {
        this.easeValueDuration = duration;
        return this;
      },
      easeValueTo: function easeValueTo(value, min, max) {
        if (min === undefined) {
          min = this.minValue;
        } else {
          this.minValue = min;
        }
        if (max === undefined) {
          max = this.maxValue;
        } else {
          this.maxValue = max;
        }
        if (this.easeValueTask === undefined) {
          this.easeValueTask = new EaseValueTask(this);
          this.easeValueTask.on('update', function () {
            this.setValue(this.value, this.minValue, this.maxValue);
          }, this);
        }
        this.easeValueTask.restart({
          key: 'value',
          to: value,
          duration: this.easeValueDuration
        });
        return this;
      }
    };
  
    var NameValueLabel = /*#__PURE__*/function (_Sizer) {
      _inherits(NameValueLabel, _Sizer);
      function NameValueLabel(scene, config) {
        var _this;
        _classCallCheck(this, NameValueLabel);
        // Create sizer
        _this = _callSuper(this, NameValueLabel, [scene, config]);
        _this.type = 'rexNameValueLabel';
        Build$1.call(_assertThisInitialized(_this), scene, config);
        _this.setEaseValueDuration(1000);
        return _this;
      }
  
      // Access nameText game object
      _createClass(NameValueLabel, [{
        key: "nameText",
        get: function get() {
          var textObject = this.childrenMap.name;
          if (textObject === undefined) {
            return '';
          }
          return textObject.text;
        },
        set: function set(value) {
          var textObject = this.childrenMap.name;
          if (textObject === undefined) {
            return;
          }
          textObject.setText(value);
        }
      }, {
        key: "setNameText",
        value: function setNameText(value) {
          this.nameText = value;
          return this;
        }
  
        // Access valueText game object
      }, {
        key: "valueText",
        get: function get() {
          var textObject = this.childrenMap.value;
          if (textObject === undefined) {
            return '';
          }
          return textObject.text;
        },
        set: function set(value) {
          var textObject = this.childrenMap.value;
          if (textObject === undefined) {
            return;
          }
          textObject.setText(value);
        }
      }, {
        key: "setValueText",
        value: function setValueText(value) {
          this.valueText = value;
          return this;
        }
  
        // Accrss bar game object
      }, {
        key: "barValue",
        get: function get() {
          var bar = this.childrenMap.bar;
          if (bar === undefined) {
            return;
          }
          return bar.value;
        },
        set: function set(value) {
          var bar = this.childrenMap.bar;
          if (bar === undefined) {
            return;
          }
          bar.setValue(value);
        }
      }, {
        key: "setBarValue",
        value: function setBarValue(value, min, max) {
          var bar = this.childrenMap.bar;
          if (bar === undefined) {
            return this;
          }
          bar.setValue(value, min, max);
          return this;
        }
      }, {
        key: "easeBarValueTo",
        value: function easeBarValueTo(value, min, max) {
          var bar = this.childrenMap.bar;
          if (bar === undefined) {
            return this;
          }
          bar.easeValueTo(value, min, max);
          return this;
        }
  
        // Access icon game object
      }, {
        key: "setTexture",
        value: function setTexture(key, frame) {
          var imageObject = this.childrenMap.icon;
          if (imageObject === undefined) {
            return;
          }
          imageObject.setTexture(key, frame);
          return this;
        }
      }, {
        key: "texture",
        get: function get() {
          var imageObject = this.childrenMap.icon;
          if (imageObject === undefined) {
            return undefined;
          }
          return imageObject.texture;
        }
      }, {
        key: "frame",
        get: function get() {
          var imageObject = this.childrenMap.icon;
          if (imageObject === undefined) {
            return undefined;
          }
          return imageObject.frame;
        }
      }, {
        key: "postLayout",
        value: function postLayout(parent, newWidth, newHeight) {
          // Pin icon-mask to icon game object
          var iconMask = this.childrenMap.iconMask;
          if (iconMask) {
            iconMask.setPosition();
            this.resetChildPositionState(iconMask);
          }
          // Pin action-mask to action game object
          var actionMask = this.childrenMap.actionMask;
          if (actionMask) {
            actionMask.setPosition();
            this.resetChildPositionState(actionMask);
          }
          return this;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          _get(_getPrototypeOf(NameValueLabel.prototype), "resize", this).call(this, width, height);
          // Resize icon-mask to icon game object
          var iconMask = this.childrenMap.iconMask;
          if (iconMask) {
            iconMask.resize();
          }
          // Resize action-mask to icon game object
          var actionMask = this.childrenMap.actionMask;
          if (actionMask) {
            actionMask.resize();
          }
          return this;
        }
      }]);
      return NameValueLabel;
    }(Sizer);
    Object.assign(NameValueLabel.prototype, SetValueMethods);
  
    ObjectFactory.register('nameValueLabel', function (config) {
      var gameObject = new NameValueLabel(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.NameValueLabel', NameValueLabel);
  
    var LevelCounter = /*#__PURE__*/function (_EventEmitter) {
      _inherits(LevelCounter, _EventEmitter);
      function LevelCounter(config) {
        var _this;
        _classCallCheck(this, LevelCounter);
        _this = _callSuper(this, LevelCounter);
        _this.setTable(GetValue$3G(config, 'table'));
        _this.setMaxLevel(GetValue$3G(config, 'maxLevel'));
        var exp = GetValue$3G(config, 'exp', 0);
        var level = GetValue$3G(config, 'level', undefined);
        if (level !== undefined && !_this.checkLevel(level, exp)) {
          console.error("Level ".concat(level, " and Exp ").concat(exp, " are mismatch"));
          level = undefined;
        }
        _this.resetExp(exp, level);
        return _this;
      }
  
      // Configuration
      _createClass(LevelCounter, [{
        key: "setTable",
        value: function setTable(table) {
          this.levelTable = table;
          this.isLevelMapFunction = IsFunction(table);
          return this;
        }
      }, {
        key: "setMaxLevel",
        value: function setMaxLevel(maxLevel) {
          if (maxLevel === undefined) {
            if (Array.isArray(this.levelTable)) {
              maxLevel = this.levelTable.length - 1;
            } else {
              maxLevel = -1;
            }
          }
          var maxExp;
          if (maxLevel !== -1) {
            maxExp = this.getExp(maxLevel);
          } else {
            maxExp = -1;
          }
          this.hasMaxLevel = maxLevel !== -1;
          this.maxLevel = maxLevel;
          this.maxExp = maxExp;
          return this;
        }
      }, {
        key: "resetExp",
        value: function resetExp(exp, level) {
          if (this.hasMaxLevel && exp > this.maxExp) {
            exp = this.maxExp;
          }
          if (level === undefined) {
            level = this.getLevel(exp);
          }
          this._exp = exp;
          this._level = level;
          this._requiredExp = this.getRequiredExpToNextLevel(level, exp);
          // Won't fire `levelup` event
          return this;
        }
      }, {
        key: "exp",
        get: function get() {
          return this._exp;
        },
        set: function set(exp) {
          if (this.hasMaxLevel && exp > this.maxExp) {
            exp = this.maxExp;
          }
          if (exp < this._exp) {
            this.resetExp(exp);
            return;
          }
          if (exp === this._exp) {
            return;
          }
          var level = this.getLevel(exp, this._level);
  
          // Emit levelup event
          var prevLevel = this._level;
          var fromExp = this._exp,
            toExp;
          while (1) {
            var levelStartExp = this.getExp(prevLevel);
            var levelEndExp = this.getExp(prevLevel + 1);
            toExp = Math.min(levelEndExp, exp);
            this.emit('levelup', prevLevel, fromExp, toExp, levelStartExp, levelEndExp);
            if (prevLevel === level && toExp === exp) {
              break;
            }
            prevLevel++;
            fromExp = levelEndExp;
          }
          this.resetExp(exp, level);
        }
      }, {
        key: "level",
        get: function get() {
          return this._level;
        },
        set: function set(value) {
          if (this.hasMaxLevel && value > this.maxLevel) {
            this.exp = this.maxExp;
          } else {
            this.exp = this.getExp(value);
          }
        }
      }, {
        key: "requiredExp",
        get: function get() {
          return this._requiredExp;
        }
      }, {
        key: "getExp",
        value: function getExp(level) {
          if (level === undefined) {
            return this._exp;
          }
          if (this.isLevelMapFunction) {
            return this.levelTable(level);
          } else {
            if (this.hasMaxLevel && level > this.maxLevel) {
              level = this.maxLevel;
            }
            return this.levelTable[level];
          }
        }
      }, {
        key: "getLevel",
        value: function getLevel(exp, level) {
          if (exp === undefined) {
            return this._level;
          }
          if (level === undefined) {
            level = 0;
          }
          while (1) {
            var nextLevelExp = this.getExp(level + 1);
            if (nextLevelExp > exp) {
              break;
            }
            level++;
            if (this.hasMaxLevel && nextLevelExp === this.maxExp) {
              break;
            }
          }
          return level;
        }
      }, {
        key: "getRequiredExpToNextLevel",
        value: function getRequiredExpToNextLevel(level, exp) {
          if (level === undefined) {
            level = this.level;
          }
          if (exp === undefined) {
            exp = this.exp;
          }
          return this.getExp(level + 1) - exp;
        }
      }, {
        key: "checkLevel",
        value: function checkLevel(level, exp) {
          return exp >= this.getExp(level) && exp < this.getExp(level + 1);
        }
      }, {
        key: "gainExp",
        value: function gainExp(incExp, callback, scope) {
          if (callback) {
            this.on('levelup', callback, scope);
          }
          this.exp += incExp;
          if (callback) {
            this.off('levelup', callback, scope);
          }
          return this;
        }
      }, {
        key: "setExp",
        value: function setExp(exp, callback, scope) {
          if (callback) {
            this.on('levelup', callback, scope);
          }
          this.exp = exp;
          if (callback) {
            this.off('levelup', callback, scope);
          }
          return this;
        }
      }, {
        key: "setLevel",
        value: function setLevel(level, callback, scope) {
          if (callback) {
            this.on('levelup', callback, scope);
          }
          this.level = level;
          if (callback) {
            this.off('levelup', callback, scope);
          }
          return this;
        }
      }]);
      return LevelCounter;
    }(EventEmitter);
  
    var RunCommands = function RunCommands(queue, scope, config) {
      var reverse = GetValue$3G(config, 'reverse', false);
      var retVal;
      if (IsArray(queue[0])) {
        if (!reverse) {
          for (var i = 0, len = queue.length; i < len; i++) {
            retVal = RunCommands(queue[i], scope, config);
          }
        } else {
          for (var len = queue.length, i = len - 1; i >= 0; i--) {
            retVal = RunCommands(queue[i], scope, config);
          }
        }
      } else {
        retVal = RunCommand(queue, scope, config);
      }
      return retVal;
    };
    var RunCommand = function RunCommand(cmd, scope, config) {
      var argsConvert = GetValue$3G(config, 'argsConvert', undefined);
      var argsConvertScope = GetValue$3G(config, 'argsConvertScope', undefined);
      var fnName = cmd[0];
      ARGS = Copy(ARGS, cmd, 1);
      if (argsConvert) {
        // convert string to floating number, boolean, null, or string        
        if (argsConvert === true) {
          argsConvert = TypeConvert;
          argsConvertScope = undefined;
        }
        for (var i = 0, len = ARGS.length; i < len; i++) {
          if (argsConvertScope) {
            ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
          } else {
            ARGS[i] = argsConvert(ARGS[i], cmd);
          }
        }
      }
      var fn;
      if (typeof fnName === 'string') {
        fn = scope[fnName];
        if (fn == null) {
          fn = GetValue$3G(scope, fnName, null);
        }
      } else {
        fn = fnName;
      }
      var retValue = fn.apply(scope, ARGS);
      return retValue;
    };
    var ARGS = []; // reuse this array
  
    var GetValue$1k = Phaser.Utils.Objects.GetValue;
    var Player = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Player, _ComponentBase);
      function Player(parent, config) {
        var _this;
        _classCallCheck(this, Player);
        _this = _callSuper(this, Player, [parent, config]);
        var clock = GetValue$1k(config, 'clock', undefined);
        if (!clock) {
          clock = new Clock(parent);
        }
        _this.clock = clock;
        _this.clock.on('update', _this.update, _assertThisInitialized(_this));
        _this.commands = [];
        _this.resetFromJSON(config); // this function had been called in super(config)
        return _this;
      }
      _createClass(Player, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.clock.resetFromJSON(GetValue$1k(o, 'clock', undefined));
          this.state = GetValue$1k(o, 'state', 0); // 0=idle, 1=run, 2=completed
          this.commands = GetValue$1k(o, 'commands', []); // [[time, cmds], [time, cmds], ...]
          this.scope = GetValue$1k(o, 'scope', undefined);
          this.setTimeUnit(GetValue$1k(o, 'timeUnit', 0));
          this.setDtMode(GetValue$1k(o, 'dtMode', 0));
          this.index = GetValue$1k(o, 'index', 0);
          this.nextTime = GetValue$1k(o, 'nextTime', 0);
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            clock: this.clock.toJSON(),
            state: this.state,
            commands: this.commands,
            scope: this.scope,
            timeUnit: this.timeUnit,
            dtMode: this.dtMode,
            index: this.index,
            nextTime: this.nextTime
          };
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.clock.shutdown(fromScene);
          this.commands = undefined;
          _get(_getPrototypeOf(Player.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "load",
        value: function load(commands, scope, config) {
          this.stop();
          var timeUnit = GetValue$1k(config, 'timeUnit', undefined);
          if (timeUnit !== undefined) {
            this.setTimeUnit(timeUnit);
          }
          var dtMode = GetValue$1k(config, 'dtMode', undefined);
          if (dtMode !== undefined) {
            this.setDtMode(dtMode);
          }
          commands = commands.filter(function (item) {
            var dt = item[0];
            return !isNaN(dt);
          }).map(function (item) {
            var dt = item[0];
            if (typeof dt === 'string') {
              item[0] = parseFloat(item[0]);
            }
            return item;
          });
          if (this.dtMode === 0) {
            commands.sort(function (itemA, itemB) {
              var dtA = itemA[0],
                dtB = itemB[0];
              return dtA > dtB ? 1 : dtA < dtB ? -1 : 0;
            });
          }
          Copy(this.commands, commands);
          this.scope = scope;
          return this;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.commands.length = 0;
          return this;
        }
      }, {
        key: "append",
        value: function append(time, fn) {
          var command;
          if (Array.isArray(fn)) {
            command = fn;
          } else {
            for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              params[_key - 2] = arguments[_key];
            }
            command = [fn].concat(params);
          }
          this.commands.push([time, command]);
          return this;
        }
      }, {
        key: "start",
        value: function start(startAt) {
          if (startAt === undefined) {
            startAt = 0;
          }
          this.stop();
          this.index = 0;
          this.state = 1;
          this.nextTime = this.getNextDt(0);
          this.clock.start(startAt);
          this.update(startAt);
          this.emit('start', this.parent, this);
          return this;
        }
      }, {
        key: "pause",
        value: function pause() {
          this.clock.pause();
          this.emit('pause', this.parent, this);
          return this;
        }
      }, {
        key: "resume",
        value: function resume() {
          this.clock.resume();
          this.emit('resume', this.parent, this);
          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          this.clock.stop();
          this.state = 0;
          this.emit('stop', this.parent, this);
          return this;
        }
      }, {
        key: "seek",
        value: function seek(time) {
          this.clock.seek(time);
          return this;
        }
      }, {
        key: "seekToNext",
        value: function seekToNext() {
          this.seek(this.nextTime);
          return this;
        }
      }, {
        key: "isPlaying",
        get: function get() {
          return this.clock.isRunning;
        }
      }, {
        key: "completed",
        get: function get() {
          return this.state === 2;
        }
      }, {
        key: "timeScale",
        get: function get() {
          return this.clock.timeScale;
        },
        set: function set(timeScale) {
          this.clock.timeScale = timeScale;
        }
      }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
          this.timeScale = timeScale;
          return this;
        }
      }, {
        key: "now",
        get: function get() {
          return this.clock.now;
        }
      }, {
        key: "update",
        value: function update(now) {
          if (this.nextTime > now) {
            return this;
          }
          var commands = this.commands;
          while (1) {
            // Execute a command
            var item = commands[this.index];
            var command = item[1];
            if (!IsArray(command)) {
              // [dt, fnName, param0, param1, ...]
              command = Copy(CMD, item, 1);
            }
            RunCommands(command, this.scope);
            this.emit('runcommand', command, this.scope);
            // Execute a command
  
            if (this.index >= commands.length - 1) {
              this.nextTime = 0;
              this.complete();
              return this;
            } else {
              // Get next time
              this.index++; // Point to next command
              this.nextTime = this.getNextDt(this.nextTime);
              if (this.nextTime > now) {
                return this;
              }
              // Get next time
            }
          }
        }
      }, {
        key: "complete",
        value: function complete() {
          this.clock.stop();
          this.state = 2;
          this.emit('complete', this.parent, this);
        }
      }, {
        key: "getNextDt",
        value: function getNextDt(currentDt) {
          var time = this.commands[this.index][0];
          if (this.timeUnit === 1) {
            // Second mode
            time = time * 1000;
          }
          if (this.dtMode === 1) {
            time += currentDt;
          }
          return time;
        }
      }, {
        key: "setDtMode",
        value: function setDtMode(dtMode) {
          if (typeof dtMode === 'string') {
            dtMode = DTMODE[dtMode];
          }
          this.dtMode = dtMode;
          return this;
        }
      }, {
        key: "setTimeUnit",
        value: function setTimeUnit(timeUnit) {
          if (typeof timeUnit === 'string') {
            timeUnit = TIMEUNITMODE[timeUnit];
          }
          this.timeUnit = timeUnit;
          return this;
        }
      }]);
      return Player;
    }(ComponentBase);
    var CMD = []; // reuse this array
  
    var TIMEUNITMODE = {
      ms: 0,
      s: 1,
      sec: 1
    };
    var DTMODE = {
      abs: 0,
      absolute: 0,
      inc: 1,
      increment: 1
    };
  
    var OnLevelUp = function OnLevelUp(level, fromExp, toExp, levelStartExp, levelEndExp) {
      var time = (toExp - fromExp) / (levelEndExp - levelStartExp) * this.totalEaseDuration;
      var levelEnd = toExp === levelEndExp ? level + 1 : level;
      this.player
      //.append(0, this.setValue, fromExp, levelStartExp, levelEndExp)
      .append(0, this.setEaseValueDuration, time).append(0, this.easeValueTo, toExp, levelStartExp, levelEndExp).append(0, this.emit, 'levelup.start', level, fromExp, toExp, this).append(time, NOOP).append(0, this.emit, 'levelup.end', levelEnd, fromExp, toExp, this);
      if (!this.player.isPlaying) {
        this.player.start();
      }
    };
  
    var ExpMethods = {
      setExpTable: function setExpTable(table) {
        this.levelCounter.setTable(table);
        return this;
      },
      resetExp: function resetExp(exp) {
        this.levelCounter.resetExp(exp);
        this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
        return this;
      },
      getExp: function getExp(level) {
        return this.levelCounter.getExp(level);
      },
      getLevel: function getLevel(exp, level) {
        return this.levelCounter.getLevel(exp, level);
      },
      getRequiredExpToNextLevel: function getRequiredExpToNextLevel(level, exp) {
        return this.levelCounter.getRequiredExpToNextLevel(level, exp);
      },
      gainExp: function gainExp(exp) {
        this.levelCounter.gainExp(exp);
        return this;
      },
      setExp: function setExp(exp) {
        this.levelCounter.setExp(exp);
        return this;
      },
      setLevel: function setLevel(level) {
        this.levelCounter.setLevel(level);
        return this;
      }
    };
  
    var GetValue$1j = Phaser.Utils.Objects.GetValue;
    var ExpBar = /*#__PURE__*/function (_NameValueLabel) {
      _inherits(ExpBar, _NameValueLabel);
      function ExpBar(scene, config) {
        var _this;
        _classCallCheck(this, ExpBar);
        _this = _callSuper(this, ExpBar, [scene, config]);
        _this.type = 'rexExpBar';
        _this.setTotalEaseDuration(GetValue$1j(config, 'easeDuration', 1000));
        _this.levelCounter = new LevelCounter(GetValue$1j(config, 'levelCounter'));
        _this.player = new Player(_assertThisInitialized(_this), {
          scope: _assertThisInitialized(_this),
          dtMode: 1
        });
        _this.levelCounter.on('levelup', OnLevelUp, _assertThisInitialized(_this));
        _this.player.on('complete', function () {
          this.player.clear();
          this.emit('levelup.complete', this.level, this);
        }, _assertThisInitialized(_this));
        _this.setValue(_this.exp, _this.getExp(_this.level), _this.getExp(_this.level + 1));
        return _this;
      }
      _createClass(ExpBar, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.levelCounter.destroy();
          this.levelCounter = undefined;
          this.player.destroy();
          this.player = undefined;
          _get(_getPrototypeOf(ExpBar.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "exp",
        get: function get() {
          return this.levelCounter.exp;
        },
        set: function set(value) {
          this.levelCounter.exp = value;
        }
      }, {
        key: "level",
        get: function get() {
          return this.levelCounter.level;
        },
        set: function set(value) {
          this.levelCounter.level = value;
        }
      }, {
        key: "requiredExp",
        get: function get() {
          return this.levelCounter.requiredExp;
        }
      }, {
        key: "setTotalEaseDuration",
        value: function setTotalEaseDuration(duration) {
          this.totalEaseDuration = duration;
          return this;
        }
      }]);
      return ExpBar;
    }(NameValueLabel);
    Object.assign(ExpBar.prototype, ExpMethods);
  
    ObjectFactory.register('expBar', function (config) {
      var gameObject = new ExpBar(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ExpBar', ExpBar);
  
    var SizerAdd$3 = Sizer.prototype.add;
    var SizerAddSpace = Sizer.prototype.addSpace;
    var Add$2 = function Add(gameObject) {
      var isNormalGameObject = !gameObject.isRexSpace;
      var proportion = !isNormalGameObject || this.buttonsExpand ? 1 : 0;
      if (this.sizerChildren.length === 0) {
        // First element
        if (isNormalGameObject) {
          // Add space at head
          var hasHeadSpace = !this.buttonsExpand && (this.buttonsAlign === 'right' || this.buttonsAlign === 'center' || this.buttonsAlign === 'bottom');
          if (hasHeadSpace) {
            SizerAddSpace.call(this);
          }
          SizerAdd$3.call(this, gameObject, {
            proportion: proportion,
            expand: true
          });
  
          // Add space at tail
          var hasTailSpace = !this.buttonsExpand && this.buttonsAlign === 'center';
          if (hasTailSpace) {
            SizerAddSpace.call(this);
          }
          this.hasTailSpace = hasTailSpace;
        } else {
          // A space
          SizerAdd$3.call(this, gameObject, {
            proportion: proportion,
            expand: true
          });
          this.hasTailSpace = false;
        }
      } else {
        // Others
        if (this.hasTailSpace) {
          var lastIndex = this.sizerChildren.length - 1;
          SizerAdd$3.call(this, gameObject, {
            index: lastIndex,
            proportion: proportion,
            expand: true
          });
        } else {
          SizerAdd$3.call(this, gameObject, {
            proportion: proportion,
            expand: true
          });
        }
      }
  
      // Space or other game object as button
      if (isNormalGameObject) {
        this.buttonGroup.add(gameObject);
      }
      return this;
    };
    var AddChildMethods$3 = {
      addButton: function addButton(gameObject) {
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add$2.call(this, gameObjects[i]);
          }
        } else {
          Add$2.call(this, gameObject);
        }
        return this;
      },
      addButtons: function addButtons(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$2.call(this, gameObjects[i]);
        }
        return this;
      }
    };
  
    var SizerRmove$2 = Sizer.prototype.remove;
    var SizerClear$2 = Sizer.prototype.clear;
    var Remove$3 = function Remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }
      this.buttonGroup.remove(gameObject);
      SizerRmove$2.call(this, gameObject, destroyChild);
      return this;
    };
    var RemoveChildMethods$2 = {
      remove: function remove(gameObject, destroyChild) {
        // Remove gameObject no matter it is a button or not
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Remove$3.call(this, gameObjects[i], destroyChild);
          }
        } else {
          Remove$3.call(this, gameObject, destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear$2.call(this, destroyChild);
        return this;
      },
      removeButton: function removeButton(gameObject, destroyChild) {
        var gameObject = this.getButton(gameObject);
        // Don't remove this gameObject, it is not a button
        if (!gameObject) {
          return this;
        }
        this.remove(gameObject, destroyChild);
        return this;
      },
      clearButtons: function clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
          Remove$3.call(this, buttons[i], destroyChild);
        }
        return this;
      }
    };
  
    var OnButtonStateChange = function OnButtonStateChange(button, value, previousValue) {
      if (!button) {
        return;
      }
      var callback = this.setValueCallback;
      var scope = this.setValueCallbackScope;
      if (callback) {
        if (scope) {
          callback.call(scope, button, value, previousValue);
        } else {
          callback(button, value, previousValue);
        }
      }
      this.fireEvent('button.statechange', button, value, previousValue);
    };
  
    var InjectSelectedProperty = function InjectSelectedProperty(gameObject) {
      var self = this;
      gameObject._selected = undefined;
      Object.defineProperty(gameObject, 'selected', {
        get: function get() {
          return gameObject._selected;
        },
        set: function set(newValue) {
          if (gameObject._selected === newValue) {
            return;
          }
          var previousValue = gameObject._selected;
          gameObject._selected = newValue;
          OnButtonStateChange.call(self, gameObject, newValue, previousValue);
        },
        enumerable: true,
        configurable: true
      });
      gameObject.selected = false;
    };
  
    var AddMethods = {
      add: function add(gameObject) {
        this.buttons.push(gameObject);
  
        //Default: Fire 'click' event when touch released after pressed.
        if (!gameObject._click) {
          gameObject._click = new Button(gameObject, this.clickConfig);
          gameObject._click.on('click', function (buttonBehavior, gameObject, pointer, event) {
            this.fireEvent('button.click', gameObject, pointer, event);
          }, this).on('enable', function (buttonBehavior, gameObject) {
            this.fireEvent('button.enable', gameObject);
          }, this).on('disable', function (buttonBehavior, gameObject) {
            this.fireEvent('button.disable', gameObject);
          }, this).on('over', function (buttonBehavior, gameObject, pointer, event) {
            this.fireEvent('button.over', gameObject, pointer, event);
          }, this).on('out', function (buttonBehavior, gameObject, pointer, event) {
            this.fireEvent('button.out', gameObject, pointer, event);
          }, this).on('down', function (buttonBehavior, gameObject, pointer, event) {
            this.fireEvent('button.down', gameObject, pointer, event);
          }, this).on('up', function (buttonBehavior, gameObject, pointer, event) {
            this.fireEvent('button.up', gameObject, pointer, event);
          }, this);
        }
        if (this.buttonsType) {
          if (gameObject.name === undefined) {
            console.error("".concat(this.parent.constructor.name, ": Option button miss value"));
          }
          InjectSelectedProperty.call(this, gameObject);
        }
        return this;
      },
      addMultiple: function addMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          this.add(gameObjects[i]);
        }
        return this;
      }
    };
  
    var RemoveItem = Phaser.Utils.Array.Remove;
    var RemoveMethods = {
      remove: function remove(gameObject) {
        if (this.buttonsType) {
          delete gameObject.selected;
        }
        RemoveItem(this.buttons, gameObject);
        return this;
      },
      clear: function clear() {
        if (this.buttonsType) {
          var buttons = this.buttons;
          for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            delete buttons[i].selected;
          }
        }
        this.buttons.length = 0;
        return this;
      }
    };
  
    var FireEvent = function FireEvent(eventName, button) {
      if (!this.buttons) {
        // ButtonGroup has been destroyed
        return;
      }
      var index;
      if (typeof button === 'number') {
        index = button;
        button = this.buttons[index];
        if (!button) {
          return;
        }
      } else {
        index = this.buttons.indexOf(button);
        if (index === -1) {
          return;
        }
      }
  
      // Buttons is a child. Fire internal events.
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      if (this.eventEmitter !== this.parent) {
        var _this$parent;
        (_this$parent = this.parent).emit.apply(_this$parent, [eventName, button, index].concat(args));
      }
      if (this.groupName !== undefined) {
        var _this$eventEmitter;
        (_this$eventEmitter = this.eventEmitter).emit.apply(_this$eventEmitter, [eventName, button, this.groupName, index].concat(args));
      } else {
        var _this$eventEmitter2;
        (_this$eventEmitter2 = this.eventEmitter).emit.apply(_this$eventEmitter2, [eventName, button, index].concat(args));
      }
    };
  
    var GetValue$1i = Phaser.Utils.Objects.GetValue;
    var ButtonsTypeMethods = {
      setButtonsType: function setButtonsType(config) {
        if (config === undefined) {
          config = {};
        }
        var buttonsType = GetValue$1i(config, 'buttonsType', config.type);
        this.buttonsType = buttonsType;
        if (!this.buttonsType) {
          return this;
        }
  
        // Assign this.setValueCallback, this.setValueCallbackScope
        var setValueCallback, setValueCallbackScope;
        setValueCallback = GetValue$1i(config, 'setValueCallback', undefined);
        setValueCallbackScope = GetValue$1i(config, 'setValueCallbackScope', undefined);
        if (setValueCallback === undefined) {
          setValueCallback = GetValue$1i(config, 'setButtonStateCallback', undefined);
          setValueCallbackScope = GetValue$1i(config, 'setButtonStateCallbackScope', undefined);
        }
        this.setValueCallback = setValueCallback;
        this.setValueCallbackScope = setValueCallbackScope;
        switch (buttonsType) {
          case 'radio':
            this.setRadioType();
            break;
          case 'checkboxes':
            this.setCheckboxesType();
            break;
        }
        return this;
      },
      setRadioType: function setRadioType() {
        var parent = this.parent,
          buttons = this.buttons;
        parent._value = undefined;
        var selectedIndex = undefined;
        Object.defineProperty(parent, 'value', {
          get: function get() {
            return parent._value;
          },
          set: function set(newValue) {
            if (parent._value === newValue) {
              return;
            }
            parent._value = newValue;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
              var button = buttons[i];
              if (button.rexSizer.hidden) {
                continue;
              }
              if (selectedIndex === undefined) {
                if (button.name === newValue) {
                  button.selected = true;
                } else {
                  button.selected = false;
                }
              } else {
                if (selectedIndex === i) {
                  button.selected = true;
                } else {
                  button.selected = false;
                }
              }
            }
          },
          enumerable: true,
          configurable: true
        });
        parent.on('button.click', function (button) {
          selectedIndex = this.buttons.indexOf(button);
          parent.value = button.name;
          selectedIndex = undefined;
        }, this);
        return this;
      },
      setCheckboxesType: function setCheckboxesType() {
        var parent = this.parent;
        parent.on('button.click', function (button) {
          button.selected = !button.selected;
        });
        return this;
      },
      // Common
      clearAllButtonsState: function clearAllButtonsState() {
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          button.selected = false;
        }
        return this;
      },
      getAllButtonsState: function getAllButtonsState() {
        var states = {};
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          if (button.rexSizer.hidden) {
            continue;
          }
          states[button.name] = button.selected;
        }
        return states;
      },
      // For radio
      setSelectedButtonName: function setSelectedButtonName(name) {
        this.parent.value = name;
        return this;
      },
      getSelectedButtonName: function getSelectedButtonName() {
        return this.parent.value;
      },
      // For checkboxes
      setButtonState: function setButtonState(name, state) {
        if (state === undefined) {
          state = true;
        }
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          if (button.rexSizer.hidden) {
            continue;
          }
          if (button.name === name) {
            button.selected = state;
            break;
          }
        }
        return this;
      },
      getButtonState: function getButtonState(name) {
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          if (button.rexSizer.hidden) {
            continue;
          }
          if (button.name === name) {
            return button.selected;
          }
        }
        return undefined;
      }
    };
  
    var GetGameObjectByName = function GetGameObjectByName(children, name) {
      if (!children) {
        return null;
      } else if (IsArray(children)) {
        var child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          child = TestName(children[i], name);
          if (child) {
            return child;
          }
        }
      } else {
        // Is plain object
        var child;
        for (var key in children) {
          child = TestName(children[key], name);
          if (child) {
            return child;
          }
        }
      }
    };
    var TestName = function TestName(gameObject, name) {
      if (!gameObject) {
        return null;
      } else if (gameObject.hasOwnProperty('name')) {
        return gameObject.name === name ? gameObject : null;
      } else {
        // Array, or plain object
        return GetElementByName(gameObject, name);
      }
    };
  
    var ButtonMethods$2 = {
      getButton: function getButton(index) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons,
          button;
        var indexType = _typeof(index);
        switch (indexType) {
          case 'number':
            button = buttons[index];
            break;
          case 'string':
            button = GetGameObjectByName(buttons, index);
            break;
          default:
            button = index;
            if (buttons.indexOf(button) === -1) {
              button = undefined;
            }
            break;
        }
        return button;
      },
      getButtons: function getButtons() {
        return this.buttons;
      },
      hasAnyButton: function hasAnyButton() {
        return this.buttons.length > 0;
      },
      setButtonEnable: function setButtonEnable(index, enabled) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        if (index === undefined || typeof index === 'boolean') {
          enabled = index;
          for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            buttons[i]._click.setEnable(enabled);
          }
        } else {
          this.getButton(index)._click.setEnable(enabled);
        }
        return this;
      },
      toggleButtonEnable: function toggleButtonEnable(index) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        if (index === undefined || typeof index === 'boolean') {
          for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            buttons[i]._click.toggleEnable();
          }
        } else {
          this.getButton(index)._click.toggleEnable();
        }
        return this;
      },
      getButtonEnable: function getButtonEnable(index) {
        if (index === undefined) {
          index = 0;
        }
        return this.getButton(index)._click.enable;
      },
      emitButtonClick: function emitButtonClick(index) {
        // index or button game object
        // this: buttonGroup or button-sizer
        var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
        buttonGroup.fireEvent('button.click', index);
        return this;
      },
      emitButtonOver: function emitButtonOver(index) {
        // this: buttonGroup or button-sizer
        var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
        var buttons = this.buttons;
  
        // Fire 'button.out' of overed button(s)
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          if (!button._click.isOver) {
            continue;
          }
          button._click.isOver = false;
          buttonGroup.fireEvent('button.out', button);
        }
  
        // Fire 'button.over'
        var button = this.getButton(index);
        if (button) {
          button._click.isOver = true;
          buttonGroup.fireEvent('button.over', button);
        }
        return this;
      },
      showButton: function showButton(index) {
        Show(this.getButton(index));
        return this;
      },
      hideButton: function hideButton(index) {
        Hide(this.getButton(index));
        return this;
      },
      isButtonShown: function isButtonShown(index) {
        IsShown(this.getButton(index));
        return this;
      },
      forEachButtton: function forEachButtton(callback, scope) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          if (scope) {
            callback.call(scope, buttons[i], i, buttons);
          } else {
            callback(buttons[i], i, buttons);
          }
        }
        return this;
      }
    };
  
    var ButtonGroup = /*#__PURE__*/function () {
      function ButtonGroup(config) {
        _classCallCheck(this, ButtonGroup);
        this.parent = config.parent;
        this.eventEmitter = config.eventEmitter;
        this.groupName = config.groupName;
        this.clickConfig = config.clickConfig;
        this.buttonsType = undefined;
        this.buttons = [];
      }
      _createClass(ButtonGroup, [{
        key: "destroy",
        value: function destroy() {
          this.parent = undefined;
          this.eventEmitter = undefined;
          this.clickConfig = undefined;
          this.buttons = undefined; // GameObjects will be destroyed outside
        }
      }]);
      return ButtonGroup;
    }();
    var methods$g = {
      fireEvent: FireEvent
    };
    Object.assign(ButtonGroup.prototype, AddMethods, RemoveMethods, ButtonsTypeMethods, ButtonMethods$2, methods$g);
  
    // Include in Buttons/GridButtons/FixedWidthButtons class
  
    var ButtonStateMethods = {
      // Common
      clearAllButtonsState: function clearAllButtonsState() {
        this.buttonGroup.clearAllButtonsState();
        return this;
      },
      getAllButtonsState: function getAllButtonsState() {
        return this.buttonGroup.getAllButtonsState();
      },
      // For radio
      setSelectedButtonName: function setSelectedButtonName(name) {
        this.buttonGroup.setSelectedButtonName(name);
        return this;
      },
      getSelectedButtonName: function getSelectedButtonName() {
        return this.buttonGroup.getSelectedButtonName();
      },
      // For checkboxes
      setButtonState: function setButtonState(name, state) {
        this.buttonGroup.setButtonState(name, state);
        return this;
      },
      getButtonState: function getButtonState(name) {
        return this.buttonGroup.getButtonState(name);
      }
    };
  
    var GetValue$1h = Phaser.Utils.Objects.GetValue;
    var Buttons$1 = /*#__PURE__*/function (_Sizer) {
      _inherits(Buttons, _Sizer);
      function Buttons(scene, config) {
        var _this;
        _classCallCheck(this, Buttons);
        if (config === undefined) {
          config = {};
        }
        var buttonSpace = config.space;
        if (typeof buttonSpace === 'number') {
          config.space = {
            item: buttonSpace
          };
        }
  
        // Create
        _this = _callSuper(this, Buttons, [scene, config]);
        _this.type = 'rexButtons';
        _this.buttonGroup = new ButtonGroup({
          parent: _assertThisInitialized(_this),
          eventEmitter: GetValue$1h(config, 'eventEmitter', _assertThisInitialized(_this)),
          groupName: GetValue$1h(config, 'groupName', undefined),
          clickConfig: GetValue$1h(config, 'click', undefined)
        }).setButtonsType(config);
  
        // Add elements
        var background = GetValue$1h(config, 'background', undefined);
        var buttons = GetValue$1h(config, 'buttons', undefined);
  
        // Buttons properties
        _this.buttonsExpand = GetValue$1h(config, 'expand', false);
        _this.buttonsAlign = GetValue$1h(config, 'align', undefined); // undefined/left/top: no space                
  
        if (background) {
          _this.addBackground(background);
        }
        if (buttons) {
          _this.addButtons(buttons);
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
        return _this;
      }
      _createClass(Buttons, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);
          this.buttonGroup.destroy();
          this.buttonGroup = undefined;
        }
      }, {
        key: "buttons",
        get: function get() {
          return this.buttonGroup.buttons;
        }
      }, {
        key: "groupName",
        get: function get() {
          return this.buttonGroup.groupName;
        },
        set: function set(value) {
          this.buttonGroup.groupName = value;
        }
      }, {
        key: "eventEmitter",
        get: function get() {
          return this.buttonGroup.eventEmitter;
        }
      }]);
      return Buttons;
    }(Sizer);
    Object.assign(Buttons$1.prototype, AddChildMethods$3, RemoveChildMethods$2, ButtonMethods$2, ButtonStateMethods);
  
    ObjectFactory.register('buttons', function (config) {
      var gameObject = new Buttons$1(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Buttons', Buttons$1);
  
    var SizerAdd$2 = GridSizer.prototype.add;
    var AddChildMethods$2 = {
      addButton: function addButton(gameObject, columnIndex, rowIndex) {
        SizerAdd$2.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
        this.buttonGroup.add(gameObject);
        return this;
      },
      addButtons: function addButtons(gameObjects, rowThenColumn) {
        for (var i = 0, cnt = gameObjects; i < cnt; i++) {
          this.addButton(gameObjects[i], undefined, rowThenColumn);
        }
        return this;
      }
    };
  
    var SizerRmove$1 = GridSizer.prototype.remove;
    var SizerClear$1 = GridSizer.prototype.clear;
    var Remove$2 = function Remove(gameObject, destroyChild) {
      var gameObject = this.getButton(gameObject);
      if (!gameObject) {
        return this;
      }
      this.buttonGroup.remove(gameObject);
      SizerRmove$1.call(this, gameObject, destroyChild);
      return this;
    };
    var RemoveChildMethods$1 = {
      remove: function remove(gameObject, destroyChild) {
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Remove$2.call(this, gameObjects[i], destroyChild);
          }
        } else {
          Remove$2.call(this, gameObject, destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear$1.call(this, destroyChild);
        return this;
      },
      removeButton: function removeButton(gameObject, destroyChild) {
        this.remove(gameObject, destroyChild);
        return this;
      },
      clearButtons: function clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
          Remove$2.call(this, buttons[i], destroyChild);
        }
        return this;
      }
    };
  
    var GetValue$1g = Phaser.Utils.Objects.GetValue;
    var GridButtons = /*#__PURE__*/function (_GridSizer) {
      _inherits(GridButtons, _GridSizer);
      function GridButtons(scene, config) {
        var _this;
        _classCallCheck(this, GridButtons);
        if (config === undefined) {
          config = {};
        }
        var rowCount = GetValue$1g(config, 'row', 0);
        var columnCount = GetValue$1g(config, 'column', config.col || 0);
        var createCellContainerCallback = GetValue$1g(config, 'createCellContainerCallback');
        var buttons = GetValue$1g(config, 'buttons', undefined);
        var buttonsExpand = GetValue$1g(config, 'expand', true);
        var buttonProportion = buttonsExpand ? 1 : 0;
        if (createCellContainerCallback) {
          config.createCellContainerCallback = undefined;
        }
        if (buttons !== undefined) {
          rowCount = Math.max(rowCount, buttons.length);
          for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            columnCount = Math.max(columnCount, buttons[i].length);
          }
        }
        config.row = rowCount;
        config.column = columnCount;
        config.columnProportions = buttonProportion;
        config.rowProportions = buttonProportion;
  
        // Create
        _this = _callSuper(this, GridButtons, [scene, config]);
        _this.type = 'rexGridButtons';
        _this.buttonGroup = new ButtonGroup({
          parent: _assertThisInitialized(_this),
          eventEmitter: GetValue$1g(config, 'eventEmitter', _assertThisInitialized(_this)),
          groupName: GetValue$1g(config, 'groupName', undefined),
          clickConfig: GetValue$1g(config, 'click', undefined)
        }).setButtonsType(config);
  
        // Add elements
        var background = GetValue$1g(config, 'background', undefined);
  
        // Buttons properties
        _this.buttonsExpand = buttonsExpand;
        GetValue$1g(config, 'space', undefined);
        if (background) {
          _this.addBackground(background);
        }
        if (buttons) {
          var rowButtons, button;
          for (var r = 0, rcnt = buttons.length; r < rcnt; r++) {
            // row
            rowButtons = buttons[r];
            for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) {
              // col
              button = rowButtons[c];
              if (button) {
                _this.addButton(button, c, r);
              }
            }
          }
        } else if (createCellContainerCallback) {
          for (var y = 0; y < rowCount; y++) {
            for (var x = 0; x < columnCount; x++) {
              var button = createCellContainerCallback(scene, x, y);
              if (button) {
                _this.addButton(button, x, y);
              }
            }
          }
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
        return _this;
      }
      _createClass(GridButtons, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(GridButtons.prototype), "destroy", this).call(this, fromScene);
          this.buttonGroup.destroy();
          this.buttonGroup = undefined;
        }
      }, {
        key: "buttons",
        get: function get() {
          return this.buttonGroup.buttons;
        }
      }, {
        key: "groupName",
        get: function get() {
          return this.buttonGroup.groupName;
        },
        set: function set(value) {
          this.buttonGroup.groupName = value;
        }
      }, {
        key: "eventEmitter",
        get: function get() {
          return this.buttonGroup.eventEmitter;
        }
      }]);
      return GridButtons;
    }(GridSizer);
    Object.assign(GridButtons.prototype, AddChildMethods$2, RemoveChildMethods$1, ButtonMethods$2, ButtonStateMethods);
  
    ObjectFactory.register('gridButtons', function (config) {
      var gameObject = new GridButtons(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.GridButtons', GridButtons);
  
    var SizerAdd$1 = FixWidthSizer.prototype.add;
    var Add$1 = function Add(gameObject) {
      SizerAdd$1.call(this, gameObject);
      this.buttonGroup.add(gameObject);
      return this;
    };
    var AddChildMethods$1 = {
      addButton: function addButton(gameObject) {
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add$1.call(this, gameObjects[i]);
          }
        } else {
          Add$1.call(this, gameObject);
        }
        return this;
      },
      addButtons: function addButtons(gameObjects) {
        if (IsArray(gameObjects[0])) {
          // 2d array
          var lines = gameObjects,
            line;
          for (var lineIdx = 0, lastLineIdx = lines.length - 1; lineIdx <= lastLineIdx; lineIdx++) {
            line = lines[lineIdx];
            for (var i = 0, cnt = line.length; i < cnt; i++) {
              Add$1.call(this, line[i]);
            }
            if (lineIdx > lastLineIdx) {
              SizerAdd$1.addNewLine(this);
            }
          }
        } else {
          // 1d array
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add$1.call(this, gameObjects[i]);
          }
        }
        return this;
      }
    };
  
    var SizerRmove = FixWidthSizer.prototype.remove;
    var SizerClear = FixWidthSizer.prototype.clear;
    var Remove$1 = function Remove(gameObject, destroyChild) {
      var gameObject = this.getButton(gameObject);
      if (!gameObject) {
        return this;
      }
      this.buttonGroup.remove(gameObject);
      SizerRmove.call(this, gameObject, destroyChild);
      return this;
    };
    var RemoveChildMethods = {
      remove: function remove(gameObject, destroyChild) {
        if (IsArray(gameObject)) {
          var gameObjects = gameObject;
          for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Remove$1.call(this, gameObjects[i], destroyChild);
          }
        } else {
          Remove$1.call(this, gameObject, destroyChild);
        }
        return this;
      },
      clear: function clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear.call(this, destroyChild);
        return this;
      },
      removeButton: function removeButton(gameObject, destroyChild) {
        this.remove(gameObject, destroyChild);
        return this;
      },
      clearButtons: function clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
          Remove$1.call(this, buttons[i], destroyChild);
        }
        return this;
      }
    };
  
    var GetValue$1f = Phaser.Utils.Objects.GetValue;
    var Buttons = /*#__PURE__*/function (_FixWidthSizer) {
      _inherits(Buttons, _FixWidthSizer);
      function Buttons(scene, config) {
        var _this;
        _classCallCheck(this, Buttons);
        if (config === undefined) {
          config = {};
        }
        var buttonSpace = config.space;
        if (typeof buttonSpace === 'number') {
          config.space = {
            item: buttonSpace,
            line: buttonSpace
          };
        }
  
        // Create
        _this = _callSuper(this, Buttons, [scene, config]);
        _this.type = 'rexFixWidthButtons';
        _this.buttonGroup = new ButtonGroup({
          parent: _assertThisInitialized(_this),
          eventEmitter: GetValue$1f(config, 'eventEmitter', _assertThisInitialized(_this)),
          groupName: GetValue$1f(config, 'groupName', undefined),
          clickConfig: GetValue$1f(config, 'click', undefined)
        }).setButtonsType(config);
  
        // Add elements
        var background = GetValue$1f(config, 'background', undefined);
        var buttons = GetValue$1f(config, 'buttons', undefined);
  
        // Buttons properties
        _this.buttonsAlign = GetValue$1f(config, 'align', undefined);
        if (background) {
          _this.addBackground(background);
        }
        if (buttons) {
          _this.addButtons(buttons);
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('buttons', _this.buttonGroup.buttons);
        return _this;
      }
      _createClass(Buttons, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);
          this.buttonGroup.destroy();
          this.buttonGroup = undefined;
        }
      }, {
        key: "buttons",
        get: function get() {
          return this.buttonGroup.buttons;
        }
      }, {
        key: "groupName",
        get: function get() {
          return this.buttonGroup.groupName;
        },
        set: function set(value) {
          this.buttonGroup.groupName = value;
        }
      }, {
        key: "eventEmitter",
        get: function get() {
          return this.buttonGroup.eventEmitter;
        }
      }]);
      return Buttons;
    }(FixWidthSizer);
    Object.assign(Buttons.prototype, AddChildMethods$1, RemoveChildMethods, ButtonMethods$2, ButtonStateMethods);
  
    ObjectFactory.register('fixWidthButtons', function (config) {
      var gameObject = new Buttons(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FixWidthButtons', Buttons);
  
    var FileChooserMethods = {
      setAccept: function setAccept(accept) {
        this.childrenMap.fileChooser.setAccept(accept);
        return this;
      },
      setMultiple: function setMultiple(enabled) {
        this.childrenMap.fileChooser.setMultiple(enabled);
        return this;
      },
      loadFile: function loadFile(file, loaderType, key, cacheType, onComplete) {
        this.childrenMap.fileChooser.loadFile(file, loaderType, key, cacheType, onComplete);
        return this;
      },
      loadFilePromise: function loadFilePromise(file, loaderType, key, cacheType) {
        return this.childrenMap.fileChooser.loadFilePromise(file, loaderType, key, cacheType);
      }
    };
  
    var GetValue$1e = Phaser.Utils.Objects.GetValue;
    var FileSelectorButton = /*#__PURE__*/function (_Label) {
      _inherits(FileSelectorButton, _Label);
      function FileSelectorButton(scene, config) {
        var _this;
        _classCallCheck(this, FileSelectorButton);
        _this = _callSuper(this, FileSelectorButton, [scene, config]);
        _this.type = 'rexFileSelectorButton';
        var fileChooser = new FileChooser(scene);
        scene.add.existing(fileChooser);
        _this.addBackground(fileChooser);
        _this.addChildrenMap('fileChooser', fileChooser);
        _this.setAccept(GetValue$1e(config, 'accept', ''));
        _this.setMultiple(GetValue$1e(config, 'multiple', false));
        fileChooser.on('change', function (gameObject) {
          var files = gameObject.files;
          if (files.length === 0) {
            return;
          }
          files = Array.from(files);
          this.emit('select', files, this);
        }, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(FileSelectorButton, [{
        key: "files",
        get: function get() {
          return this.childrenMap.fileChooser.files;
        }
      }]);
      return FileSelectorButton;
    }(Label);
    Object.assign(FileSelectorButton.prototype, FileChooserMethods);
  
    ObjectFactory.register('fileSelectorButton', function (config) {
      var gameObject = new FileSelectorButton(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.FileSelectorButton', FileSelectorButton);
  
    var ButtonMethods$1 = {
      getChoice: function getChoice(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          return choicesSizer.getButton(index);
        } else {
          return undefined;
        }
      },
      getAction: function getAction(index) {
        return this.childrenMap.actionsSizer.getButton(index);
      },
      getToolbar: function getToolbar(index) {
        return this.childrenMap.toolbarSizer.getButton(index);
      },
      getLeftToolbar: function getLeftToolbar(index) {
        return this.childrenMap.leftToolbarSizer.getButton(index);
      },
      setChoiceEnable: function setChoiceEnable(index, enabled) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.setButtonEnable(index, enabled);
        }
        return this;
      },
      setActionEnable: function setActionEnable(index, enabled) {
        this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
        return this;
      },
      setToolbarEnable: function setToolbarEnable(index, enabled) {
        this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
        return this;
      },
      setLeftToolbarEnable: function setLeftToolbarEnable(index, enabled) {
        this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
        return this;
      },
      toggleChoiceEnable: function toggleChoiceEnable(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.toggleButtonEnable(index);
        }
        return this;
      },
      toggleActionEnable: function toggleActionEnable(index) {
        this.childrenMap.actionsSizer.toggleButtonEnable(index);
        return this;
      },
      toggleToolbarEnable: function toggleToolbarEnable(index) {
        this.childrenMap.toolbarSizer.toggleButtonEnable(index);
        return this;
      },
      toggleLeftToolbarEnable: function toggleLeftToolbarEnable(index) {
        this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
        return this;
      },
      getChoiceEnable: function getChoiceEnable(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          return choicesSizer.getButtonEnable(index);
        } else {
          return false;
        }
      },
      getActionEnable: function getActionEnable(index) {
        return this.childrenMap.actionsSizer.getButtonEnable(index);
      },
      getToolbarEnable: function getToolbarEnable(index) {
        return this.childrenMap.toolbarSizer.getButtonEnable(index);
      },
      getLeftToolbarEnable: function getLeftToolbarEnable(index) {
        return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
      },
      emitChoiceClick: function emitChoiceClick(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.emitButtonClick(index);
        }
        return this;
      },
      emitActionClick: function emitActionClick(index) {
        this.childrenMap.actionsSizer.emitButtonClick(index);
        return this;
      },
      emitToolbarClick: function emitToolbarClick(index) {
        this.childrenMap.toolbarSizer.emitButtonClick(index);
        return this;
      },
      emitLeftToolbarClick: function emitLeftToolbarClick(index) {
        this.childrenMap.leftToolbarSizer.emitButtonClick(index);
        return this;
      },
      showChoice: function showChoice(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.showButton(index);
        }
        return this;
      },
      showAction: function showAction(index) {
        this.childrenMap.actionsSizer.showButton(index);
        return this;
      },
      showToolbar: function showToolbar(index) {
        this.childrenMap.toolbarSizer.showButton(index);
        return this;
      },
      showLeftToolbar: function showLeftToolbar(index) {
        this.childrenMap.leftToolbarSizer.showButton(index);
        return this;
      },
      hideChoice: function hideChoice(index) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.hideButton(index);
        }
        return this;
      },
      hideAction: function hideAction(index) {
        this.childrenMap.actionsSizer.hideButton(index);
        return this;
      },
      hideToolbar: function hideToolbar(index) {
        this.childrenMap.toolbarSizer.hideButton(index);
        return this;
      },
      hideLeftToolbar: function hideLeftToolbar(index) {
        this.childrenMap.leftToolbarSizer.hideButton(index);
        return this;
      },
      addChoice: function addChoice(gameObject) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.addButton(gameObject);
        }
        return this;
      },
      addAction: function addAction(gameObject) {
        this.childrenMap.actionsSizer.addButton(gameObject);
        return this;
      },
      addToolbar: function addToolbar(gameObject) {
        this.childrenMap.toolbarSizer.addButton(gameObject);
        return this;
      },
      addLeftToolbar: function addLeftToolbar(gameObject) {
        this.childrenMap.leftToolbarSizer.addButton(gameObject);
        return this;
      },
      removeChoice: function removeChoice(index, destroyChild) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.removeButton(index, destroyChild);
        }
        return this;
      },
      removeAction: function removeAction(index, destroyChild) {
        this.childrenMap.actionsSizer.removeButton(index, destroyChild);
        return this;
      },
      removeToolbar: function removeToolbar(index, destroyChild) {
        this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
        return this;
      },
      removeLeftToolbar: function removeLeftToolbar(index, destroyChild) {
        this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
        return this;
      },
      clearChoices: function clearChoices(destroyChild) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.clearButtons(destroyChild);
        }
        return this;
      },
      clearActions: function clearActions(destroyChild) {
        this.childrenMap.actionsSizer.clearButtons(destroyChild);
        return this;
      },
      clearToolbar: function clearToolbar(destroyChild) {
        this.childrenMap.toolbarSizer.clearButtons(destroyChild);
        return this;
      },
      clearLeftToolbar: function clearLeftToolbar(destroyChild) {
        this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
        return this;
      },
      forEachChoice: function forEachChoice(callback, scope) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.forEachButtton(callback, scope);
        }
        return this;
      },
      forEachAction: function forEachAction(callback, scope) {
        this.childrenMap.actionsSizer.forEachButtton(callback, scope);
        return this;
      },
      forEachToolbar: function forEachToolbar(callback, scope) {
        this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
        return this;
      },
      forEachLeftToolbar: function forEachLeftToolbar(callback, scope) {
        this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
        return this;
      },
      setAllButtonsEnable: function setAllButtonsEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }
        if (this.childrenMap.toolbarSizer) {
          this.setToolbarEnable(enabled);
        }
        if (this.childrenMap.leftToolbarSizer) {
          this.setLeftToolbarEnable(enabled);
        }
        if (this.childrenMap.actionsSizer) {
          this.setActionEnable(enabled);
        }
        if (this.childrenMap.choicesSizer) {
          this.setChoiceEnable(enabled);
        }
        return this;
      },
      // Checkboxes
      getChoicesButtonStates: function getChoicesButtonStates() {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          return choicesSizer.getAllButtonsState();
        } else {
          return {};
        }
      },
      getChoicesButtonState: function getChoicesButtonState(name) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (name === undefined) {
          if (choicesSizer) {
            return choicesSizer.getAllButtonsState();
          } else {
            return {};
          }
        } else {
          if (choicesSizer) {
            return choicesSizer.getButtonState(name);
          } else {
            return false;
          }
        }
      },
      setChoicesButtonState: function setChoicesButtonState(name, state) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.setButtonState(name, state);
        }
        return this;
      },
      clearChoicesButtonStates: function clearChoicesButtonStates() {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.clearAllButtonsState();
        }
        return this;
      },
      // Radio buttons
      getChoicesSelectedButtonName: function getChoicesSelectedButtonName() {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          return choicesSizer.getSelectedButtonName();
        } else {
          return '';
        }
      },
      setChoicesSelectedButtonName: function setChoicesSelectedButtonName(name) {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          choicesSizer.setSelectedButtonName(name);
        }
        return this;
      },
      hasAnyChoice: function hasAnyChoice() {
        var choicesSizer = this.childrenMap.choicesSizer;
        if (choicesSizer) {
          return choicesSizer.hasAnyButton();
        }
        return false;
      },
      hasAnyAction: function hasAnyAction() {
        var actionsSizer = this.childrenMap.actionsSizer;
        if (actionsSizer) {
          return actionsSizer.hasAnyButton();
        }
        return false;
      },
      hasAnyToolbar: function hasAnyToolbar() {
        var toolbarSizer = this.childrenMap.toolbarSizer;
        if (toolbarSizer) {
          return toolbarSizer.hasAnyButton();
        }
        return false;
      },
      hasAnyLeftToolbar: function hasAnyLeftToolbar() {
        var leftToolbarSizer = this.childrenMap.leftToolbarSizer;
        if (leftToolbarSizer) {
          return leftToolbarSizer.hasAnyButton();
        }
        return false;
      }
    };
  
    var ModalMethods = {
      onCreateModalBehavior: function onCreateModalBehavior(self) {
        self.on('button.click', function (button, groupName, index, pointer, event) {
          var canClose = false;
          switch (groupName) {
            case 'actions':
              // Click any action button
              canClose = true;
              break;
            case 'choices':
              // Click any choice button, and no action button in this dialog
              if (!self.hasAnyAction()) {
                canClose = true;
              }
              break;
          }
          if (!canClose) {
            return;
          }
          var closeEventData = {
            index: index,
            text: button.text,
            button: button,
            dialog: self
          };
          switch (self.buttonsType) {
            case 'radio':
              closeEventData.value = self.getChoicesSelectedButtonName();
              break;
            case 'checkboxes':
              closeEventData.value = self.getChoicesButtonStates();
              break;
            default:
              closeEventData.value = undefined;
          }
          self.modalClose(closeEventData);
        });
      },
      modal: function modal(config, onClose) {
        if (config && config.defaultBehavior === false) {
          this.onCreateModalBehavior = false;
        } else {
          delete this.onCreateModalBehavior;
        }
        ModalMethods$1.modal.call(this, config, onClose);
        return this;
      }
    };
  
    var Methods$6 = {};
    Object.assign(Methods$6, ButtonMethods$1, ModalMethods);
  
    var GetValue$1d = Phaser.Utils.Objects.GetValue;
    var Dialog = /*#__PURE__*/function (_Sizer) {
      _inherits(Dialog, _Sizer);
      function Dialog(scene, config) {
        var _this;
        _classCallCheck(this, Dialog);
        if (config === undefined) {
          config = {};
        }
        // Create sizer        
        config.orientation = 1; // Top to bottom
        _this = _callSuper(this, Dialog, [scene, config]);
        _this.type = 'rexDialog';
        _this.eventEmitter = GetValue$1d(config, 'eventEmitter', _assertThisInitialized(_this));
  
        // Add elements
        var background = GetValue$1d(config, 'background', undefined);
        var title = GetValue$1d(config, 'title', undefined);
        var toolbar = GetValue$1d(config, 'toolbar', undefined);
        var toolbarBackground = GetValue$1d(config, 'toolbarBackground', undefined);
        var leftToolbar = GetValue$1d(config, 'leftToolbar', undefined);
        var leftToolbarBackground = GetValue$1d(config, 'leftToolbarBackground', undefined);
        var content = GetValue$1d(config, 'content', undefined);
        var description = GetValue$1d(config, 'description', undefined);
        var choicesSizer;
        var choices = GetValue$1d(config, 'choices', undefined);
        var choicesBackground = GetValue$1d(config, 'choicesBackground', undefined);
        var actionsSizer;
        var actions = GetValue$1d(config, 'actions', undefined);
        var actionsBackground = GetValue$1d(config, 'actionsBackground', undefined);
        var clickConfig = GetValue$1d(config, 'click', undefined);
        if (background) {
          _this.addBackground(background);
        }
        var toolbarSizer;
        if (toolbar) {
          toolbarSizer = new Buttons$1(scene, {
            groupName: 'toolbar',
            background: toolbarBackground,
            buttons: toolbar,
            orientation: 0,
            // Left-right
            space: {
              item: GetValue$1d(config, 'space.toolbarItem', 0)
            },
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          scene.add.existing(toolbarSizer);
        }
        var leftToolbarSizer;
        if (leftToolbar) {
          leftToolbarSizer = new Buttons$1(scene, {
            groupName: 'leftToolbar',
            background: leftToolbarBackground,
            buttons: leftToolbar,
            orientation: 0,
            // Left-right
            space: {
              item: GetValue$1d(config, 'space.leftToolbarItem', 0)
            },
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          scene.add.existing(leftToolbarSizer);
        }
  
        // title or toolbar or leftToolbar
        if (title || toolbar || leftToolbar) {
          var titleExpandWidth = !!title && GetValue$1d(config, 'expand.title', true);
          var titleAlign = GetValue$1d(config, 'align.title', 'center');
          var useOverlapSizer =
          // Has title, title is not exapnd-width, title align to center
          title && !titleExpandWidth && titleAlign === 'center' ||
          // No title
          !title && (toolbar || leftToolbar);
          var useSizer = !useOverlapSizer;
          var titleSizer;
          if (useSizer) {
            titleSizer = new Sizer(scene, {
              orientation: 0
            });
          } else {
            titleSizer = new OverlapSizer(scene);
          }
          scene.add.existing(titleSizer);
          var titleChildExpand = useSizer ? true : {
            height: true
          };
  
          // Add leftToolbar
          if (leftToolbarSizer) {
            titleSizer.add(leftToolbarSizer, {
              align: 'left',
              expand: titleChildExpand
            });
          }
  
          // Add title
          if (title) {
            // Add space if not expand, align to right
            if (useSizer && !titleExpandWidth && titleAlign === 'right') {
              titleSizer.addSpace();
            }
            var padding = {
              left: GetValue$1d(config, 'space.titleLeft', 0),
              right: GetValue$1d(config, 'space.titleRight', 0)
            };
            var proportion = titleExpandWidth ? 1 : 0;
            titleSizer.add(title, {
              align: titleAlign,
              proportion: proportion,
              expand: titleChildExpand,
              padding: padding
            });
  
            // Add space if not expand, align to left
            if (useSizer && !titleExpandWidth && titleAlign === 'left') {
              titleSizer.addSpace();
            }
          }
  
          // Add toolbar
          if (toolbarSizer) {
            // Add space if not title
            if (useSizer && !title) {
              titleSizer.addSpace();
            }
            titleSizer.add(toolbarSizer, {
              align: 'right',
              expand: titleChildExpand
            });
          }
  
          // Add sizer to dialog
          var padding;
          if (content || description || choices || actions) {
            padding = {
              bottom: GetValue$1d(config, 'space.title', 0),
              top: GetValue$1d(config, 'space.titleTop', 0)
            };
          }
          var proportion = GetValue$1d(config, 'proportion.title', 0);
          _this.add(titleSizer, {
            padding: padding,
            proportion: proportion,
            expand: true
          });
        }
        if (content) {
          var align = GetValue$1d(config, 'align.content', 'center');
          var contentSpace = GetValue$1d(config, 'space.content', 0);
          var padding = {
            left: GetValue$1d(config, 'space.contentLeft', 0),
            right: GetValue$1d(config, 'space.contentRight', 0),
            bottom: description || choices || actions ? contentSpace : 0
          };
          var proportion = GetValue$1d(config, 'proportion.content', 0);
          var expand = GetValue$1d(config, 'expand.content', true);
          _this.add(content, {
            align: align,
            padding: padding,
            proportion: proportion,
            expand: expand
          });
        }
        if (description) {
          var align = GetValue$1d(config, 'align.description', 'center');
          var descriptionSpace = GetValue$1d(config, 'space.description', 0);
          var padding = {
            left: GetValue$1d(config, 'space.descriptionLeft', 0),
            right: GetValue$1d(config, 'space.descriptionRight', 0),
            bottom: choices || actions ? descriptionSpace : 0
          };
          var proportion = GetValue$1d(config, 'proportion.description', 0);
          var expand = GetValue$1d(config, 'expand.description', true);
          _this.add(description, {
            align: align,
            padding: padding,
            proportion: proportion,
            expand: expand
          });
        }
        if (choices) {
          var choicesType = GetValue$1d(config, 'choicesType', '').split('-');
          var ButtonsClass = Contains(choicesType, 'wrap') ? Buttons : Contains(choicesType, 'grid') ? GridButtons : Buttons$1;
          var buttonsType = Contains(choicesType, 'radio') ? 'radio' : Contains(choicesType, 'checkboxes') ? 'checkboxes' : undefined;
          var space = {
            left: GetValue$1d(config, 'space.choicesBackgroundLeft', 0),
            right: GetValue$1d(config, 'space.choicesBackgroundRight', 0),
            top: GetValue$1d(config, 'space.choicesBackgroundTop', 0),
            bottom: GetValue$1d(config, 'space.choicesBackgroundBottom', 0)
          };
          var itemSpace = GetValue$1d(config, 'space.choice', 0);
          if (ButtonsClass === Buttons$1) {
            space.item = itemSpace;
          } else if (ButtonsClass === Buttons) {
            space.item = itemSpace;
            space.line = GetValue$1d(config, 'space.choiceLine', itemSpace);
          } else {
            // GridButtons
            space.column = GetValue$1d(config, 'space.choiceColumn', itemSpace);
            space.row = GetValue$1d(config, 'space.choiceRow', itemSpace);
          }
          var choicesConfig = {
            width: GetValue$1d(config, 'choicesWidth', undefined),
            height: GetValue$1d(config, 'choicesHeight', undefined),
            groupName: 'choices',
            buttonsType: buttonsType,
            background: choicesBackground,
            buttons: choices,
            space: space,
            click: clickConfig,
            eventEmitter: _this.eventEmitter,
            setValueCallback: GetValue$1d(config, 'choicesSetValueCallback', undefined),
            setValueCallbackScope: GetValue$1d(config, 'choicesSetValueCallbackScope', undefined)
          };
          if (ButtonsClass === Buttons$1) {
            choicesConfig.orientation = Contains(choicesType, 'x') ? 0 : 1;
          }
          choicesSizer = new ButtonsClass(scene, choicesConfig);
          scene.add.existing(choicesSizer);
          var choicesSpace = GetValue$1d(config, 'space.choices', 0);
          var padding = {
            left: GetValue$1d(config, 'space.choicesLeft', 0),
            right: GetValue$1d(config, 'space.choicesRight', 0),
            bottom: actions ? choicesSpace : 0
          };
          var align = GetValue$1d(config, 'align.choices', 'center');
          var proportion = GetValue$1d(config, 'proportion.choices', 0);
          var expand = GetValue$1d(config, 'expand.choices', true);
          _this.add(choicesSizer, {
            align: align,
            padding: padding,
            proportion: proportion,
            expand: expand
          });
          _this.buttonsType = buttonsType;
        }
        if (actions) {
          actionsSizer = new Buttons$1(scene, {
            groupName: 'actions',
            background: actionsBackground,
            buttons: actions,
            orientation: 0,
            // Left-right
            space: {
              item: GetValue$1d(config, 'space.action', 0)
            },
            expand: GetValue$1d(config, 'expand.actions', false),
            align: GetValue$1d(config, 'align.actions', 'center'),
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          scene.add.existing(actionsSizer);
          var padding = {
            left: GetValue$1d(config, 'space.actionsLeft', 0),
            right: GetValue$1d(config, 'space.actionsRight', 0),
            bottom: GetValue$1d(config, 'space.actionsBottom', 0)
          };
          var proportion = GetValue$1d(config, 'proportion.action', 0);
          _this.add(actionsSizer, {
            align: 'center',
            padding: padding,
            proportion: proportion,
            expand: true
          });
        }
        EmitButtonEvent(_assertThisInitialized(_this), 'click');
        EmitButtonEvent(_assertThisInitialized(_this), 'over');
        EmitButtonEvent(_assertThisInitialized(_this), 'out');
        EmitButtonEvent(_assertThisInitialized(_this), 'enable');
        EmitButtonEvent(_assertThisInitialized(_this), 'disable');
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('title', title);
        _this.addChildrenMap('toolbar', toolbar);
        _this.addChildrenMap('leftToolbar', leftToolbar);
        _this.addChildrenMap('content', content);
        _this.addChildrenMap('description', description);
        _this.addChildrenMap('choices', choicesSizer ? choicesSizer.buttons : undefined);
        _this.addChildrenMap('actions', actionsSizer ? actionsSizer.buttons : undefined);
        _this.addChildrenMap('choicesSizer', choicesSizer);
        _this.addChildrenMap('actionsSizer', actionsSizer);
        _this.addChildrenMap('toolbarSizer', toolbarSizer);
        _this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);
        return _this;
      }
      return _createClass(Dialog);
    }(Sizer);
    var Contains = function Contains(arr, item) {
      return arr.indexOf(item) !== -1;
    };
    var ButtonsGroupEventNameMap = {
      actions: 'action',
      choices: 'choice',
      toolbar: 'toolbar',
      leftToolbar: 'leftToolbar'
    };
    var EmitButtonEvent = function EmitButtonEvent(dialog, postEventName) {
      dialog.on("button.".concat(postEventName), function (button, groupName, index, pointer, event) {
        if (!ButtonsGroupEventNameMap.hasOwnProperty(groupName)) {
          return;
        }
        dialog.emit("".concat(ButtonsGroupEventNameMap[groupName], ".").concat(postEventName), button, index, pointer, event);
      });
    };
    Object.assign(Dialog.prototype, Methods$6);
  
    ObjectFactory.register('dialog', function (config) {
      var gameObject = new Dialog(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Dialog', Dialog);
  
    var CreateLabel = function CreateLabel(scene, config, creators) {
      var gameObject = new SimpleLabel(scene, config, creators);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var ResetDisplayContent = function ResetDisplayContent(config) {
      if (config === undefined) {
        config = {};
      }
      ResetTitle.call(this, config);
      ResetContent.call(this, config);
      ResetActions.call(this, config);
      ResetChoices.call(this, config);
      return this;
    };
    var ResetTitle = function ResetTitle(config) {
      var title = this.childrenMap.title;
      config = config.title;
      if (config === null) {
        title.hide();
      } else {
        title.show();
        title.resetDisplayContent(config);
      }
    };
    var ResetContent = function ResetContent(config) {
      var content = this.childrenMap.content;
      config = config.content;
      if (config === null) {
        content.hide();
      } else {
        content.show();
        if (content.resetDisplayContent) {
          // Label
          content.resetDisplayContent(config);
        } else {
          // TextArea
          var text = config || '';
          content.setText(text);
        }
      }
    };
    var ResetActions = function ResetActions(config) {
      var actionButtons = this.childrenMap.actions;
      if (!actionButtons) {
        return;
      }
      var buttonContentArray = config.buttons;
      if (!buttonContentArray) {
        var buttonA = actionButtons[0];
        if (buttonA) {
          if (config.buttonA === null) {
            buttonA.hide();
          } else {
            buttonA.show();
            buttonA.resetDisplayContent(config.buttonA);
          }
        }
        var buttonB = actionButtons[1];
        if (buttonB) {
          if (config.buttonB === null) {
            buttonB.hide();
          } else {
            buttonB.show();
            buttonB.resetDisplayContent(config.buttonB);
          }
        }
      } else {
        var scene = this.scene;
        var defaultActionConfig = this.defaultActionConfig;
        var defaultActionButtonCreator = this.defaultActionButtonCreator;
        for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
          var buttonContent = buttonContentArray[i];
          var button = actionButtons[i];
          if (!button) {
            button = CreateLabel(scene, defaultActionConfig, defaultActionButtonCreator);
            this.addAction(button);
          }
          button.show().resetDisplayContent(buttonContent);
        }
        this.buttonMode = buttonContentArray.length;
        for (var i = buttonContentArray.length, cnt = actionButtons.length; i < cnt; i++) {
          actionButtons[i].hide();
        }
      }
    };
    var ResetChoices = function ResetChoices(config) {
      var choices = this.childrenMap.choices;
      if (!choices) {
        return;
      }
      var buttonContentArray = config.choices;
      if (!buttonContentArray) {
        buttonContentArray = [];
      }
      var scene = this.scene;
      var defaultChoiceConfig = this.defaultChoiceConfig;
      var defaultActionButtonCreator = this.defaultActionButtonCreator;
      for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
        var buttonContent = buttonContentArray[i];
        if (typeof buttonContent === 'string') {
          buttonContent = {
            text: buttonContent
          };
        }
        var button = choices[i];
        if (!button) {
          button = CreateLabel(scene, defaultChoiceConfig, defaultActionButtonCreator);
          this.addChoice(button);
        }
        button.show().resetDisplayContent(buttonContent);
        var optionValue;
        if (buttonContent.hasOwnProperty('value')) {
          optionValue = buttonContent.value;
        } else {
          optionValue = buttonContent.text;
        }
        button.setName(optionValue);
      }
      for (var i = buttonContentArray.length, cnt = choices.length; i < cnt; i++) {
        choices[i].hide();
      }
    };
  
    Phaser.Utils.Objects.GetValue;
    var Merge$2 = Phaser.Utils.Objects.Merge;
    var Modal = function Modal(config, onClose) {
      if (IsFunction(config)) {
        onClose = config;
        config = undefined;
      }
      if (config === undefined) {
        config = {};
      }
      config = Merge$2(config, this.modalStyle);
      var zeroButtonMode;
      if (this.buttonMode === 0) {
        if (this.hasAnyChoice()) {
          zeroButtonMode = false;
        } else {
          zeroButtonMode = true;
        }
      } else {
        zeroButtonMode = false;
      }
      if (!config.hasOwnProperty('anyTouchClose')) {
        config.anyTouchClose = zeroButtonMode;
      }
      if (!config.hasOwnProperty('manualClose')) {
        config.manualClose = !zeroButtonMode;
      }
      var self = this;
      var onCloseWrap = function onCloseWrap(data) {
        var buttonIndex = data.index;
        if (buttonIndex === self.confirmButtonIndex) {
          self.emit('confirm', data);
        } else if (buttonIndex === self.cancelButtonIndex) {
          self.emit('cancel', data);
        }
        if (onClose) {
          onClose(data);
        }
      };
      ModalMethods$1.modal.call(this, config, onCloseWrap);
      return this;
    };
  
    var SetButtonIndexMethods = {
      setConfirmButtonIndex: function setConfirmButtonIndex(index) {
        this.confirmButtonIndex = index;
        return this;
      },
      setCancelButtonIndex: function setCancelButtonIndex(index) {
        this.cancelButtonIndex = index;
        return this;
      }
    };
  
    var Methods$5 = {
      resetDisplayContent: ResetDisplayContent,
      modal: Modal
    };
    Object.assign(Methods$5, SetButtonIndexMethods);
  
    var OnPointerOverCallback = function OnPointerOverCallback(button) {
      if (button.setHoverState) {
        button.setHoverState(true);
      }
    };
    var OnPointerOutCallback = function OnPointerOutCallback(button) {
      if (button.setHoverState) {
        button.setHoverState(false);
      }
    };
    var OnChoiceButtonStateChange = function OnChoiceButtonStateChange(button, groupName, index, value) {
      if (button.setActiveState) {
        button.setActiveState(value);
      }
    };
    var OnButtonEnable = function OnButtonEnable(button) {
      if (button.setDisableState) {
        button.setDisableState(false);
      }
    };
    var OnButtonDisable = function OnButtonDisable(button) {
      if (button.setDisableState) {
        button.setDisableState(true);
      }
    };
    var RegisterEvents = function RegisterEvents() {
      this.on('button.over', OnPointerOverCallback).on('button.out', OnPointerOutCallback).on('button.enable', OnButtonEnable).on('button.disable', OnButtonDisable).on('button.statechange', OnChoiceButtonStateChange);
    };
  
    var GetValue$1c = Phaser.Utils.Objects.GetValue;
    var CreateContent = function CreateContent(scene, config, creators) {
      var type = GetValue$1c(config, '$type');
      if (type === undefined) {
        if (config && (config.hasOwnProperty('slider') || config.hasOwnProperty('scroller'))) {
          type = 'textarea';
        }
      }
      var gameObject;
      switch (type) {
        case 'textarea':
          gameObject = new CreateTextArea(scene, config, creators);
          break;
        default:
          gameObject = new CreateLabel(scene, config, creators);
          break;
      }
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$1b = Phaser.Utils.Objects.GetValue;
    var ConfirmDialog = /*#__PURE__*/function (_Dialog) {
      _inherits(ConfirmDialog, _Dialog);
      function ConfirmDialog(scene, config, creators) {
        var _this;
        _classCallCheck(this, ConfirmDialog);
        config = config ? DeepClone(config) : {};
        if (creators === undefined) {
          creators = {};
        }
        var createBackground = GetValue$1b(creators, 'background', CreateBackground$2);
        if (createBackground) {
          config.background = createBackground(scene, config.background);
        } else {
          delete config.background;
        }
        config.title = CreateLabel(scene, config.title, creators.title);
        config.content = CreateContent(scene, config.content, creators.content);
        if (config.content instanceof TextArea) {
          if (HasValue(config, 'height') && !HasValue(config, 'proportion.content')) {
            SetValue(config, 'proportion.content', 1);
          }
        }
        var defaultButtonConfig = config.button;
        var buttonAConfig = config.buttonA || defaultButtonConfig;
        var buttonBConfig = config.buttonB || defaultButtonConfig;
        var buttonMode = config.buttonMode;
        if (buttonMode === undefined) {
          buttonMode = !!buttonAConfig && !!buttonBConfig ? 2 : !!buttonAConfig ? 1 : 0;
        }
        var defaultButtonCreator = creators.button;
        var buttonACreators = creators.buttonA || defaultButtonCreator;
        var buttonBCreators = creators.buttonB || defaultButtonCreator;
        switch (buttonMode) {
          case 2:
            config.actions = [CreateLabel(scene, buttonAConfig, buttonACreators), CreateLabel(scene, buttonBConfig, buttonBCreators)];
            break;
          case 1:
            config.actions = [CreateLabel(scene, buttonAConfig, buttonACreators)];
            break;
          case 0:
            break;
          default:
            config.actions = [];
            break;
        }
        var defaultChoiceConfig = config.choice;
        if (defaultChoiceConfig) {
          config.choices = [];
        }
        _this = _callSuper(this, ConfirmDialog, [scene, config]);
        _this.type = 'rexConfirmDialog';
        _this.buttonMode = buttonMode;
        _this.defaultActionConfig = defaultButtonConfig;
        _this.defaultActionButtonCreator = defaultButtonCreator;
        _this.defaultChoiceConfig = defaultChoiceConfig;
        _this.defaultChoiceCreator = creators.choice;
        var buttons = _this.childrenMap.actions;
        _this.addChildrenMap('buttonA', buttons ? buttons[0] : null);
        _this.addChildrenMap('buttonB', buttons ? buttons[1] : null);
  
        // Interactive
        RegisterEvents.call(_assertThisInitialized(_this));
  
        // Assign button index for comfirm, cancel events
        _this.setConfirmButtonIndex(GetValue$1b(config, 'confirmButtonIndex', 0));
        _this.setCancelButtonIndex(GetValue$1b(config, 'cancelButtonIndex', 1));
        _this.modalStyle = config.modal || {};
        return _this;
      }
      return _createClass(ConfirmDialog);
    }(Dialog);
    Object.assign(ConfirmDialog.prototype, Methods$5);
  
    ObjectFactory.register('confirmDialog', function (config, creators) {
      var gameObject = new ConfirmDialog(this.scene, config, creators);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ConfirmDialog', ConfirmDialog);
  
    var GetValue$1a = Phaser.Utils.Objects.GetValue;
    var ConfirmAction = function ConfirmAction(scene, config) {
      var dialog = config.dialog;
      var newDialogMode = !dialog;
      if (newDialogMode) {
        var dialogStyle = config.style;
        dialogStyle.buttonMode = 2;
        dialog = new ConfirmDialog(scene, dialogStyle, config.creators);
        scene.add.existing(dialog);
      }
      dialog.setConfirmButtonIndex(GetValue$1a(config, 'confirmButtonIndex', 0)).setCancelButtonIndex(GetValue$1a(config, 'cancelButtonIndex', 1)).resetDisplayContent(config.content).layout();
      if (newDialogMode && config.onCreateDialog) {
        config.onCreateDialog(dialog);
      }
      var modalConfig = config.modal;
      if (modalConfig && !modalConfig.hasOwnProperty('destroy')) {
        modalConfig.destroy = newDialogMode;
      }
      var confirmCallback = config.confirm;
      var cancelCallback = config.cancel;
      var confirmScope = config.confirmScope;
      var cancelScope = config.cancelScope;
      if (confirmCallback) {
        dialog.once('confirm', confirmCallback, confirmScope);
      }
      if (cancelCallback) {
        dialog.once('cancel', cancelCallback, cancelScope);
      }
      var onClose = function onClose(data) {
        dialog.off('confirm', confirmCallback, confirmScope);
        dialog.off('cancel', cancelCallback, cancelScope);
      };
      dialog.modal(modalConfig, onClose);
      return dialog;
    };
  
    var ConfirmActionButton = /*#__PURE__*/function (_Label) {
      _inherits(ConfirmActionButton, _Label);
      function ConfirmActionButton(scene, config) {
        var _this;
        _classCallCheck(this, ConfirmActionButton);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, ConfirmActionButton, [scene, config]);
        _this.type = 'rexConfirmActionButton';
        _this.setConfirmDialogEnable();
        _this.confirmActionConfig = Clone$2(config.confirmDialog || {});
        if (config.confirm) {
          _this.setConfirmCallback(config.confirm, config.confirmScope);
        }
        if (config.cancel) {
          _this.setCancelCallback(config.cancel, config.cancelScope);
        }
        _this.onClickCallback = function () {
          if (this.confirmDialogEnable) {
            if (this.confirmDialog) {
              return;
            }
            this.confirmDialog = ConfirmAction(scene, this.confirmActionConfig);
            this.confirmDialog.once('destroy', function () {
              this.confirmDialog = undefined;
            }, this);
          } else {
            this.runConfirmCallback();
          }
        };
        _this.onClick(_this.onClickCallback, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(ConfirmActionButton, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (this.confirmDialog) {
            this.confirmDialog.destroy();
          }
          _get(_getPrototypeOf(ConfirmActionButton.prototype), "destroy", this).call(this, fromScene);
          this.confirmActionConfig = undefined;
          this.onClickCallback = undefined;
          this.confirmDialog = undefined;
        }
      }, {
        key: "setConfirmCallback",
        value: function setConfirmCallback(callback, scope) {
          this.confirmActionConfig.confirm = callback;
          this.confirmActionConfig.confirmScope = scope;
          return this;
        }
      }, {
        key: "setCancelCallback",
        value: function setCancelCallback(callback, scope) {
          this.confirmActionConfig.cancel = callback;
          this.confirmActionConfig.cancelScope = scope;
          return this;
        }
      }, {
        key: "setConfirmDialogContent",
        value: function setConfirmDialogContent(content) {
          this.confirmActionConfig.content = content;
          return this;
        }
      }, {
        key: "setConfitmDialogStyle",
        value: function setConfitmDialogStyle(style) {
          this.confirmActionConfig.style = style;
          return this;
        }
      }, {
        key: "setConfitmDialogModalConfig",
        value: function setConfitmDialogModalConfig(config) {
          this.confirmActionConfig.modal = config;
          return this;
        }
      }, {
        key: "setConfirmDialogEnable",
        value: function setConfirmDialogEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.confirmDialogEnable = enable;
          return this;
        }
      }, {
        key: "runConfirmCallback",
        value: function runConfirmCallback() {
          var callback = this.confirmActionConfig.confirm;
          var scope = this.confirmActionConfig.confirmScope;
          if (callback) {
            callback.call(scope);
          }
          return this;
        }
      }]);
      return ConfirmActionButton;
    }(Label);
  
    ObjectFactory.register('confirmActionButton', function (config) {
      var gameObject = new ConfirmActionButton(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ConfirmActionButton', ConfirmActionButton);
  
    var RemoveFromParent = function RemoveFromParent(gameObject, destroyChild) {
      if (!gameObject) {
        return;
      }
      var parent = GetParent$1(gameObject);
      if (!parent) {
        return;
      }
      parent.remove(gameObject, destroyChild);
    };
  
    var GetValue$19 = Phaser.Utils.Objects.GetValue;
    var GetAddChildConfig = function GetAddChildConfig(config, key, defaultValues) {
      var proportion = GetValue$19(config, "proportion.".concat(key), defaultValues.proportion);
      var align = GetValue$19(config, "align.".concat(key), 'center');
      var padding = GetValue$19(config, "space.".concat(key), undefined);
      if (typeof padding === 'number' && defaultValues.paddingKey) {
        var paddingNum = padding;
        padding = {};
        padding[defaultValues.paddingKey] = paddingNum;
      }
      var expand = GetValue$19(config, "expand.".concat(key), true);
      return {
        proportion: proportion,
        align: align,
        padding: padding,
        expand: expand
      };
    };
    var GetAddHeaderConfig = function GetAddHeaderConfig(config) {
      return GetAddChildConfig(config, 'header', {
        proportion: 0,
        paddingKey: 'bottom'
      });
    };
    var GetAddLeftSideConfig = function GetAddLeftSideConfig(config) {
      return GetAddChildConfig(config, 'leftSide', {
        proportion: 0,
        paddingKey: 'right'
      });
    };
    var GetAddContentConfig = function GetAddContentConfig(config) {
      return GetAddChildConfig(config, 'content', {
        proportion: 1
      });
    };
    var GetAddRightSideConfig = function GetAddRightSideConfig(config) {
      return GetAddChildConfig(config, 'rightSide', {
        proportion: 0,
        paddingKey: 'left'
      });
    };
    var GetAddFooterConfig = function GetAddFooterConfig(config) {
      return GetAddChildConfig(config, 'footer', {
        proportion: 0,
        paddingKey: 'top'
      });
    };
    var GetAddContainerConfig = function GetAddContainerConfig(config) {
      return {
        proportion: 1,
        align: 'center',
        padding: 0,
        expand: true
      };
    };
  
    var CreatExpandContainer = function CreatExpandContainer(scene, orientation) {
      var container = new Sizer(scene, {
        orientation: orientation
      });
      scene.add.existing(container);
      return container;
    };
  
    /*
    Elements:
        ```
        HHH
        LCR
        FFF
        ```
    */
  
    var LayoutMode0$1 = function LayoutMode0(config) {
      var scene = this.scene;
  
      // Add Header
      var header = config.header;
      if (header) {
        this.add(header, GetAddHeaderConfig(config));
      }
  
      /*
      L C R
      */
      var bodySizer = CreatExpandContainer(scene, 0);
      this.add(bodySizer, GetAddContainerConfig());
  
      // Add Left-side
      var leftSide = config.leftSide;
      if (leftSide) {
        bodySizer.add(leftSide, GetAddLeftSideConfig(config));
      }
  
      // Add content
      var content = config.content;
      if (content) {
        bodySizer.add(content, GetAddContentConfig(config));
      }
  
      // Add Right-side
      var rightSide = config.rightSide;
      if (rightSide) {
        bodySizer.add(rightSide, GetAddRightSideConfig(config));
      }
  
      // Add Footer
      var footer = config.footer;
      if (footer) {
        this.add(footer, GetAddFooterConfig(config));
      }
    };
  
    /*
    Elements:
        ```
        HHH
        LCR
        LFF
        ```
    */
  
    var LayoutMode1 = function LayoutMode1(config) {
      var scene = this.scene;
  
      // Add Header
      var header = config.header;
      if (header) {
        this.add(header, GetAddHeaderConfig(config));
      }
  
      /*
      L CR
      L FF
      */
      var bodySizer0 = CreatExpandContainer(scene, 0);
      this.add(bodySizer0, GetAddContainerConfig());
  
      // Add Left-side
      var leftSide = config.leftSide;
      if (leftSide) {
        bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
      }
  
      /*
      CR
        FF
      */
      var bodySizer1 = CreatExpandContainer(scene, 1);
      bodySizer0.add(bodySizer1, GetAddContainerConfig());
  
      /*
      C R
      */
      var bodySizer2 = CreatExpandContainer(scene, 0);
      bodySizer1.add(bodySizer2, GetAddContainerConfig());
  
      // Add content
      var content = config.content;
      if (content) {
        bodySizer2.add(content, GetAddContentConfig(config));
      }
  
      // Add Right-side
      var rightSide = config.rightSide;
      if (rightSide) {
        bodySizer2.add(rightSide, GetAddRightSideConfig(config));
      }
  
      // Add Footer
      var footer = config.footer;
      if (footer) {
        bodySizer1.add(footer, GetAddFooterConfig(config));
      }
    };
  
    /*
    Elements:
        ```
        HHH
        LCR
        FFR
        ```
    */
  
    var LayoutMode2 = function LayoutMode2(config) {
      var scene = this.scene;
  
      // Add Header
      var header = config.header;
      if (header) {
        this.add(header, GetAddHeaderConfig(config));
      }
  
      /*
      LC R
      FF R
      */
      var bodySizer0 = CreatExpandContainer(scene, 0);
      this.add(bodySizer0, GetAddContainerConfig());
  
      /*
      LC
        FF
      */
      var bodySizer1 = CreatExpandContainer(scene, 1);
      bodySizer0.add(bodySizer1, GetAddContainerConfig());
  
      /*
      L C
      */
      var bodySizer2 = CreatExpandContainer(scene, 0);
      bodySizer1.add(bodySizer2, GetAddContainerConfig());
  
      // Add Left-side
      var leftSide = config.leftSide;
      if (leftSide) {
        bodySizer2.add(leftSide, GetAddLeftSideConfig(config));
      }
  
      // Add content
      var content = config.content;
      if (content) {
        bodySizer2.add(content, GetAddContentConfig(config));
      }
  
      // Add Footer
      var footer = config.footer;
      if (footer) {
        bodySizer1.add(footer, GetAddFooterConfig(config));
      }
  
      // Add Right-side
      var rightSide = config.rightSide;
      if (rightSide) {
        bodySizer0.add(rightSide, GetAddRightSideConfig(config));
      }
    };
  
    /*
    Elements:
        ```
        HHH
        LCR
        LFR
        ```
    */
  
    var LayoutMode0 = function LayoutMode0(config) {
      var scene = this.scene;
  
      // Add Header
      var header = config.header;
      if (header) {
        this.add(header, GetAddHeaderConfig(config));
      }
  
      /*
      L C R
      L F R
      */
      var bodySizer0 = CreatExpandContainer(scene, 0);
      this.add(bodySizer0, GetAddContainerConfig());
  
      // Add Left-side
      var leftSide = config.leftSide;
      if (leftSide) {
        bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
      }
  
      /*
      C
        F
      */
      var bodySizer1 = CreatExpandContainer(scene, 1);
      bodySizer0.add(bodySizer1, GetAddContainerConfig());
  
      // Add content
      var content = config.content;
      if (content) {
        bodySizer1.add(content, GetAddContentConfig(config));
      }
  
      // Add Footer
      var footer = config.footer;
      if (footer) {
        bodySizer1.add(footer, GetAddFooterConfig(config));
      }
  
      // Add Right-side
      var rightSide = config.rightSide;
      if (rightSide) {
        bodySizer0.add(rightSide, GetAddRightSideConfig(config));
      }
    };
  
    var GetValue$18 = Phaser.Utils.Objects.GetValue;
    var LayoutCallbacks = [LayoutMode0$1, LayoutMode1, LayoutMode2, LayoutMode0];
    var Build = function Build(config) {
      if (config === undefined) {
        config = {};
      }
      var background = config.background;
      var header = config.header;
      var leftSide = config.leftSide;
      var content = config.content;
      var rightSide = config.rightSide;
      var footer = config.footer;
  
      // Remove from parent
      RemoveFromParent(background);
      RemoveFromParent(header);
      RemoveFromParent(leftSide);
      RemoveFromParent(content);
      RemoveFromParent(rightSide);
      RemoveFromParent(footer);
      this.clear(true);
  
      // Add Background
      if (background) {
        this.addBackground(background);
      }
      var layoutMode = GetValue$18(config, 'layoutMode', 0);
      if (typeof layoutMode === 'string') {
        layoutMode = LayoutModesMap[layoutMode.toUpperCase()];
      }
      var layoutCallback = LayoutCallbacks[layoutMode] || LayoutCallbacks[0];
      layoutCallback.call(this, config);
      this.addChildrenMap('background', background);
      this.addChildrenMap('header', header);
      this.addChildrenMap('leftSide', leftSide);
      this.addChildrenMap('content', content);
      this.addChildrenMap('rightSide', rightSide);
      this.addChildrenMap('footer', footer);
      return this;
    };
    var LayoutModesMap = {
      'FFF': 0,
      'LFF': 1,
      'FFR': 2,
      'LFR': 3
    };
  
    var HolyGrail = /*#__PURE__*/function (_Sizer) {
      _inherits(HolyGrail, _Sizer);
      function HolyGrail(scene, config) {
        var _this;
        _classCallCheck(this, HolyGrail);
        if (config === undefined) {
          config = {};
        }
        config.orientation = 1; // top-to-bottom
        // Create sizer
        _this = _callSuper(this, HolyGrail, [scene, config]);
        _this.type = 'rexHolyGrail';
        _this.build(config);
        return _this;
      }
      return _createClass(HolyGrail);
    }(Sizer);
    var methods$f = {
      build: Build
    };
    Object.assign(HolyGrail.prototype, methods$f);
  
    ObjectFactory.register('holyGrail', function (config) {
      var gameObject = new HolyGrail(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.HolyGrail', HolyGrail);
  
    var ButtonMethods = {
      getButtonsSizer: function getButtonsSizer(groupName) {
        return this.childrenMap["".concat(groupName, "ButtonsSizer")];
      },
      getButton: function getButton(groupName, index) {
        var buttonsSizer = this.getButtonsSizer(groupName);
        return buttonsSizer ? buttonsSizer.getButton(index) : undefined;
      },
      setButtonEnable: function setButtonEnable(groupName, index, enabled) {
        this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
        return this;
      },
      setLeftButtonEnable: function setLeftButtonEnable(index, enabled) {
        this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
        return this;
      },
      setRightButtonEnable: function setRightButtonEnable(index, enabled) {
        this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
        return this;
      },
      setTopButtonEnable: function setTopButtonEnable(index, enabled) {
        this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
        return this;
      },
      setBottomButtonEnable: function setBottomButtonEnable(index, enabled) {
        this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
        return this;
      },
      toggleButtonEnable: function toggleButtonEnable(groupName, index) {
        this.getButtonsSizer(groupName).toggleButtonEnable(index);
        return this;
      },
      toggleLeftButtonEnable: function toggleLeftButtonEnable(index) {
        this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
        return this;
      },
      toggleRightButtonEnable: function toggleRightButtonEnable(index) {
        this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
        return this;
      },
      toggleTopButtonEnable: function toggleTopButtonEnable(index) {
        this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
        return this;
      },
      toggleBottomButtonEnable: function toggleBottomButtonEnable(index) {
        this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
        return this;
      },
      getButtonEnable: function getButtonEnable(groupName, index) {
        return this.getButtonsSizer(groupName).getButtonEnable(index);
      },
      getLeftButtonEnable: function getLeftButtonEnable(index) {
        return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
      },
      getRightButtonEnable: function getRightButtonEnable(index) {
        return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
      },
      getTopButtonEnable: function getTopButtonEnable(index) {
        return this.childrenMap.topButtonsSizer.getButtonEnable(index);
      },
      getBottomButtonEnable: function getBottomButtonEnable(index) {
        return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
      },
      emitButtonClick: function emitButtonClick(groupName, index) {
        var buttonsSizer = this.getButtonsSizer(groupName);
        if (!buttonsSizer) {
          return this;
        }
        buttonsSizer.emitButtonClick(index);
        return this;
      },
      emitLeftButtonClick: function emitLeftButtonClick(index) {
        this.childrenMap.leftButtonsSizer.emitButtonClick(index);
        return this;
      },
      emitRightButtonClick: function emitRightButtonClick(index) {
        this.childrenMap.rightButtonsSizer.emitButtonClick(index);
        return this;
      },
      emitTopButtonClick: function emitTopButtonClick(index) {
        this.childrenMap.topButtonsSizer.emitButtonClick(index);
        return this;
      },
      emitBottomButtonClick: function emitBottomButtonClick(index) {
        this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
        return this;
      },
      getLeftButton: function getLeftButton(index) {
        return this.childrenMap.leftButtonsSizer.getButton(index);
      },
      getRightButton: function getRightButton(index) {
        return this.childrenMap.rightButtonsSizer.getButton(index);
      },
      getTopButton: function getTopButton(index) {
        return this.childrenMap.topButtonsSizer.getButton(index);
      },
      getBottomButton: function getBottomButton(index) {
        return this.childrenMap.bottomButtonsSizer.getButton(index);
      },
      showButton: function showButton(groupName, index) {
        Show(this.getButton(groupName, index));
        return this;
      },
      showLeftButton: function showLeftButton(index) {
        Show(this.getLeftButton(index));
        return this;
      },
      showRightButton: function showRightButton(index) {
        Show(this.getRightButton(index));
        return this;
      },
      showTopButton: function showTopButton(index) {
        Show(this.getTopButton(index));
        return this;
      },
      showBottomButton: function showBottomButton(index) {
        Show(this.getBottomButton(index));
        return this;
      },
      hideButton: function hideButton(groupName, index) {
        Hide(this.getButton(groupName, index));
        return this;
      },
      hideLeftButton: function hideLeftButton(index) {
        Hide(this.getLeftButton(index));
        return this;
      },
      hideRightButton: function hideRightButton(index) {
        Hide(this.getRightButton(index));
        return this;
      },
      hideTopButton: function hideTopButton(index) {
        Hide(this.getTopButton(index));
        return this;
      },
      hideBottomButton: function hideBottomButton(index) {
        Hide(this.getBottomButton(index));
        return this;
      },
      addButton: function addButton(groupName, gameObject) {
        this.getButtonsSizer(groupName).addButton(gameObject);
        return this;
      },
      addLeftButton: function addLeftButton(gameObject) {
        this.addButton('left', gameObject);
        return this;
      },
      addRightButton: function addRightButton(gameObject) {
        this.addButton('right', gameObject);
        return this;
      },
      addTopButton: function addTopButton(gameObject) {
        this.addButton('top', gameObject);
        return this;
      },
      removeButton: function removeButton(groupName, index, destroyChild) {
        this.getButtonsSizer(groupName).removeButton(index, destroyChild);
        return this;
      },
      removeLeftButton: function removeLeftButton(index, destroyChild) {
        this.removeButton('left', index, destroyChild);
        return this;
      },
      removeRightButton: function removeRightButton(index, destroyChild) {
        this.removeButton('right', index, destroyChild);
        return this;
      },
      removeTopButton: function removeTopButton(index, destroyChild) {
        this.removeButton('top', index, destroyChild);
        return this;
      },
      removeBottomButton: function removeBottomButton(index, destroyChild) {
        this.removeButton('bottom', index, destroyChild);
        return this;
      },
      clearButtons: function clearButtons(groupName, destroyChild) {
        this.getButtonsSizer(groupName).clearButtons(destroyChild);
        return this;
      },
      clearLeftButtons: function clearLeftButtons(destroyChild) {
        this.clearButtons('left', destroyChild);
        return this;
      },
      clearRightButtons: function clearRightButtons(destroyChild) {
        this.clearButtons('right', destroyChild);
        return this;
      },
      clearTopButtons: function clearTopButtons(destroyChild) {
        this.clearButtons('top', destroyChild);
        return this;
      },
      clearBottomButtonss: function clearBottomButtonss(destroyChild) {
        this.clearButtons('bottom', destroyChild);
        return this;
      },
      forEachButton: function forEachButton(groupName, callback, scope) {
        this.getButtonsSizer(groupName).forEachButtton(callback, scope);
        return this;
      },
      forEachLeftButton: function forEachLeftButton(callback, scope) {
        this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
        return this;
      },
      forEachRightButton: function forEachRightButton(callback, scope) {
        this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
        return this;
      },
      forEachTopButton: function forEachTopButton(callback, scope) {
        this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
        return this;
      },
      forEachBottomButton: function forEachBottomButton(callback, scope) {
        this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
        return this;
      }
    };
  
    var GetValue$17 = Phaser.Utils.Objects.GetValue;
    var Tabs = /*#__PURE__*/function (_GridSizer) {
      _inherits(Tabs, _GridSizer);
      function Tabs(scene, config) {
        var _this;
        _classCallCheck(this, Tabs);
        if (config === undefined) {
          config = {};
        }
        // Create sizer
        config.column = 3;
        config.row = 3;
        config.columnProportions = [0, 0, 0];
        config.rowProportions = [0, 0, 0];
        var expandPanel = GetValue$17(config, 'expand.panel', false);
        if (expandPanel) {
          config.columnProportions[1] = 1;
          config.rowProportions[1] = 1;
        }
        _this = _callSuper(this, Tabs, [scene, config]);
        _this.type = 'rexTabs';
        _this.eventEmitter = GetValue$17(config, 'eventEmitter', _assertThisInitialized(_this));
  
        // Add elements
        var background = GetValue$17(config, 'background', undefined);
        var panel = GetValue$17(config, 'panel', undefined);
        var leftButtons = GetValue$17(config, 'leftButtons', undefined);
        var leftButtonsBackground = GetValue$17(config, 'leftButtonsBackground', undefined);
        var leftButtonsSizer;
        var rightButtons = GetValue$17(config, 'rightButtons', undefined);
        var rightButtonsBackground = GetValue$17(config, 'rightButtonsBackground', undefined);
        var rightButtonsSizer;
        var topButtons = GetValue$17(config, 'topButtons', undefined);
        var topButtonsBackground = GetValue$17(config, 'topButtonsBackground', undefined);
        var topButtonsSizer;
        var bottomButtons = GetValue$17(config, 'bottomButtons', undefined);
        var bottomButtonsBackground = GetValue$17(config, 'bottomButtonsBackground', undefined);
        var bottomButtonsSizer;
        var clickConfig = GetValue$17(config, 'click', undefined);
        if (background) {
          _this.addBackground(background);
        }
        if (panel) {
          _this.add(panel, {
            column: 1,
            row: 1,
            expand: expandPanel
          });
        }
        if (leftButtons) {
          var leftButtonsOffset = GetValue$17(config, 'space.leftButtonsOffset', 0);
          var leftButtonSpace = GetValue$17(config, 'space.leftButton', 0);
          var leftButtonExpand = GetValue$17(config, 'expand.leftButtons', false);
          var leftButtonsAlign = GetValue$17(config, 'align.leftButtons', 'top');
          leftButtonsSizer = new Buttons$1(scene, {
            groupName: 'left',
            background: leftButtonsBackground,
            buttons: leftButtons,
            orientation: 'y',
            // Top-Bottom
            space: {
              item: leftButtonSpace
            },
            expand: leftButtonExpand,
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          _this.add(leftButtonsSizer, {
            column: 0,
            row: 1,
            align: leftButtonsAlign,
            padding: {
              top: leftButtonsOffset
            },
            expand: leftButtonExpand
          });
        }
        if (rightButtons) {
          var rightButtonsOffset = GetValue$17(config, 'space.rightButtonsOffset', 0);
          var rightButtonSpace = GetValue$17(config, 'space.rightButton', 0);
          var rightButtonExpand = GetValue$17(config, 'expand.rightButtons', false);
          var rightButtonsAlign = GetValue$17(config, 'align.rightButtons', 'top');
          rightButtonsSizer = new Buttons$1(scene, {
            groupName: 'right',
            background: rightButtonsBackground,
            buttons: rightButtons,
            orientation: 'y',
            // Top-Bottom
            space: {
              item: rightButtonSpace
            },
            expand: rightButtonExpand,
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          _this.add(rightButtonsSizer, {
            column: 2,
            row: 1,
            align: rightButtonsAlign,
            padding: {
              top: rightButtonsOffset
            },
            expand: rightButtonExpand
          });
        }
        if (topButtons) {
          var toptButtonsOffset = GetValue$17(config, 'space.topButtonsOffset', 0);
          var topButtonSpace = GetValue$17(config, 'space.topButton', 0);
          var topButtonExpand = GetValue$17(config, 'expand.topButtons', false);
          var topButtonsAlign = GetValue$17(config, 'align.topButtons', 'left');
          topButtonsSizer = new Buttons$1(scene, {
            groupName: 'top',
            background: topButtonsBackground,
            buttons: topButtons,
            orientation: 'x',
            // Left-Right
            space: {
              item: topButtonSpace
            },
            expand: topButtonExpand,
            align: GetValue$17(config, 'align.topButtons', undefined),
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          _this.add(topButtonsSizer, {
            column: 1,
            row: 0,
            align: topButtonsAlign,
            padding: {
              left: toptButtonsOffset
            },
            expand: topButtonExpand
          });
        }
        if (bottomButtons) {
          var bottomButtonsOffset = GetValue$17(config, 'space.bottomButtonsOffset', 0);
          var bottomButtonSpace = GetValue$17(config, 'space.bottomButton', 0);
          var bottomButtonExpand = GetValue$17(config, 'expand.bottomButtons', false);
          var bottomButtonsAlign = GetValue$17(config, 'align.bottomButtons', 'left');
          bottomButtonsSizer = new Buttons$1(scene, {
            groupName: 'bottom',
            background: bottomButtonsBackground,
            buttons: bottomButtons,
            orientation: 'x',
            // Left-Right
            space: {
              item: bottomButtonSpace
            },
            expand: bottomButtonExpand,
            align: GetValue$17(config, 'align.bottomButtons', undefined),
            click: clickConfig,
            eventEmitter: _this.eventEmitter
          });
          _this.add(bottomButtonsSizer, {
            column: 1,
            row: 2,
            align: bottomButtonsAlign,
            padding: {
              left: bottomButtonsOffset
            },
            expand: bottomButtonExpand
          });
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('panel', panel);
        _this.addChildrenMap('leftButtons', leftButtons);
        _this.addChildrenMap('rightButtons', rightButtons);
        _this.addChildrenMap('topButtons', topButtons);
        _this.addChildrenMap('bottomButtons', bottomButtons);
        _this.addChildrenMap('leftButtonsSizer', leftButtonsSizer);
        _this.addChildrenMap('rightButtonsSizer', rightButtonsSizer);
        _this.addChildrenMap('topButtonsSizer', topButtonsSizer);
        _this.addChildrenMap('bottomButtonsSizer', bottomButtonsSizer);
        return _this;
      }
      return _createClass(Tabs);
    }(GridSizer);
    Object.assign(Tabs.prototype, ButtonMethods);
  
    ObjectFactory.register('tabs', function (config) {
      var gameObject = new Tabs(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Tabs', Tabs);
  
    ObjectFactory.register('slider', function (config) {
      var gameObject = new Slider(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Slider', Slider);
  
    var Cell = /*#__PURE__*/function () {
      function Cell(parent, config) {
        _classCallCheck(this, Cell);
        this.container = null;
        this._deltaHeight = 0;
        this.setParent(parent);
        // this.resetFromJSON(config);
      }
      _createClass(Cell, [{
        key: "setParent",
        value: function setParent(parent) {
          this.parent = parent; // parent: table
          this.parentContainer = parent.getParentContainer();
        }
  
        // resetFromJSON(o) {
        //     return this;
        // }
      }, {
        key: "destroy",
        value: function destroy(fromScene) {
          if (fromScene === undefined) {
            fromScene = false;
          }
          if (!fromScene) {
            this.destroyContainer();
          }
          this.deltaHeight = 0;
          this.data = undefined;
          this.container = null;
          this.parent = undefined;
          this.parentContainer = undefined;
        }
      }, {
        key: "table",
        get: function get() {
          return this.parent;
        }
      }, {
        key: "scrollMode",
        get: function get() {
          return this.parentContainer.scrollMode;
        }
      }, {
        key: "colIndx",
        get: function get() {
          return this.parent.cellIndxeToColIndex(this.index);
        }
      }, {
        key: "rowIndx",
        get: function get() {
          return this.parent.cellIndxeToRowIndex(this.index);
        }
      }, {
        key: "getContainer",
        value: function getContainer() {
          return this.container;
        }
      }, {
        key: "setContainer",
        value: function setContainer(container) {
          if (!container) {
            this.destroyContainer();
            return this;
          }
          if (this.container) {
            this.container.destroy();
          }
          this.container = container;
          this.parentContainer.add(container);
          return this;
        }
      }, {
        key: "destroyContainer",
        value: function destroyContainer() {
          if (this.container) {
            this.container.destroy();
            this.container = null;
          }
          return this;
        }
      }, {
        key: "popContainer",
        value: function popContainer() {
          if (this.container) {
            var container = this.container;
            this.container = null;
            this.parentContainer.remove(container);
            return container;
          } else {
            return null;
          }
        }
      }, {
        key: "setXY",
        value: function setXY(x, y) {
          if (this.container) {
            this.parentContainer.setChildLocalPosition(this.container, x, y);
          }
          return this;
        }
      }, {
        key: "setCellContainerAlign",
        value: function setCellContainerAlign(align) {
          if (typeof align === 'string') {
            align = AlignConst[align];
          }
          this.cellContainerAlign = align;
          return this;
        }
      }, {
        key: "deltaHeight",
        get: function get() {
          return this._deltaHeight;
        },
        set: function set(deltaHeight) {
          if (deltaHeight == null) {
            deltaHeight = 0;
          }
          var table = this.parent;
          if (this._deltaHeight === 0 && deltaHeight !== 0) {
            table.nonZeroDeltaHeightCount++;
          } else if (this._deltaHeight !== 0 && deltaHeight === 0) {
            table.nonZeroDeltaHeightCount--;
          }
          var isTableHeightChanged = this._deltaHeight !== deltaHeight;
          this._deltaHeight = deltaHeight;
          if (isTableHeightChanged) {
            table.resetTotalRowsHeight();
            var eventName = this.scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
            this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
          }
        }
      }, {
        key: "deltaWidth",
        get: function get() {
          return this.deltaHeight;
        },
        set: function set(deltaWidth) {
          this.deltaHeight = deltaWidth;
        }
      }, {
        key: "setDeltaHeight",
        value: function setDeltaHeight(deltaHeight) {
          this.deltaHeight = deltaHeight;
          return this;
        }
      }, {
        key: "setDeltaWidth",
        value: function setDeltaWidth(deltaWidth) {
          this.deltaHeight = deltaWidth;
          return this;
        }
      }, {
        key: "height",
        get: function get() {
          if (this.scrollMode === 0) {
            return this.deltaHeight + this.parent.defaultCellHeight;
          } else {
            return this.parent.defaultCellWidth;
          }
        },
        set: function set(height) {
          // Only worked when scrollMode is 0
          if (this.scrollMode === 1) {
            return;
          }
          this.setDeltaHeight(height - this.parent.defaultCellHeight);
        }
      }, {
        key: "setHeight",
        value: function setHeight(height) {
          // Only worked when scrollMode is 0
          this.height = height;
          return this;
        }
      }, {
        key: "width",
        get: function get() {
          if (this.scrollMode === 0) {
            return this.parent.defaultCellWidth;
          } else {
            return this.deltaHeight + this.parent.defaultCellHeight;
          }
        },
        set: function set(width) {
          // Only worked when scrollMode is 1
          if (this.scrollMode === 0) {
            return;
          }
          this.setDeltaHeight(width - this.parent.defaultCellHeight);
        }
      }, {
        key: "setWidth",
        value: function setWidth(width) {
          this.width = width;
          return this;
        }
      }, {
        key: "scene",
        get: function get() {
          return this.parentContainer.scene;
        }
      }]);
      return Cell;
    }();
    Object.assign(Cell.prototype, DataMethods$2);
  
    var GetValue$16 = Phaser.Utils.Objects.GetValue;
    var SpliceOne = Phaser.Utils.Array.SpliceOne;
    var Table = /*#__PURE__*/function () {
      function Table(parent, config) {
        _classCallCheck(this, Table);
        this.parent = parent; // parent: GridTable game object (Container)
        this.cells = [];
        this.cellPool = new Stack();
        this.resetFromJSON(config);
      }
      _createClass(Table, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          if (o === undefined) {
            o = {};
          }
          this.colCount = undefined;
          this.nonZeroDeltaHeightCount = 0;
          this.resetTotalRowsHeight();
          var cellHeight = o.cellHeight;
          if (cellHeight === undefined) {
            cellHeight = 30;
          }
          var cellWidth = o.cellWidth;
          if (cellWidth === undefined) {
            cellWidth = 30;
          }
          this.setDefaultCellHeight(cellHeight);
          this.setDefaultCellWidth(cellWidth);
          this.initCells(GetValue$16(o, 'cellsCount', 0));
          this.setColumnCount(GetValue$16(o, 'columns', 1));
          return this;
        }
      }, {
        key: "destroy",
        value: function destroy(fromScene) {
          // GridTable is destroyed, all cell containers will also be destroyed too
          // Don't have to freeCell
          this.cellPool.destroy();
          this.cells = undefined;
          this.parent = undefined;
        }
      }, {
        key: "defaultCellHeightMode",
        get: function get() {
          return this.nonZeroDeltaHeightCount === 0;
        }
      }, {
        key: "setDefaultCellHeight",
        value: function setDefaultCellHeight(height) {
          this.defaultCellHeight = height;
          return this;
        }
      }, {
        key: "setDefaultCellWidth",
        value: function setDefaultCellWidth(width) {
          this.defaultCellWidth = width;
          return this;
        }
      }, {
        key: "initCells",
        value: function initCells(size) {
          var cells = this.cells;
          cells.length = size;
          for (var i = 0; i < size; i++) {
            cells[i] = null;
          }
          return this;
        }
      }, {
        key: "insertNewCells",
        value: function insertNewCells(cellIdx, count) {
          var cells = this.cells;
          if (cellIdx === cells.length) {
            // append at end of array
            var endIdx = cellIdx + count;
            cells.legth = endIdx;
            for (var i = cellIdx; i < endIdx; i++) {
              cells[i] = null;
            }
          } else {
            var _this$cells;
            var newCells = [];
            newCells.length = count;
            for (var i = 0; i < count; i++) {
              newCells[i] = null;
            }
            (_this$cells = this.cells).splice.apply(_this$cells, [cellIdx, 0].concat(newCells));
          }
          this.resetTotalRowsHeight();
          return this;
        }
      }, {
        key: "removeCells",
        value: function removeCells(cellIdx, count) {
          var endIdx = cellIdx + count;
          for (var i = cellIdx; i < endIdx; i++) {
            this.freeCell(i);
          }
          if (endIdx === this.cells.length) {
            // remove until end of array
            this.cells.length = cellIdx;
          } else {
            if (count === 1) {
              SpliceOne(this.cells, cellIdx);
            } else {
              this.cells.splice(cellIdx, count);
            }
            this.buildCellIndex(cellIdx);
          }
          this.resetTotalRowsHeight();
          return this;
        }
      }, {
        key: "setColumnCount",
        value: function setColumnCount(columns) {
          this.colCount = columns;
          this.resetTotalRowsHeight();
  
          // Set cellWith according to parent width/height and columns
          var parent = this.parent;
          if (parent.expandCellSize) {
            var width = parent.scrollMode === 0 ? parent.width : parent.height;
            var cellWidth = width / columns;
            this.setDefaultCellWidth(cellWidth);
          }
          return this;
        }
      }, {
        key: "rowCount",
        get: function get() {
          return Math.ceil(this.cells.length / this.colCount);
        }
      }, {
        key: "cellsCount",
        get: function get() {
          return this.cells.length;
        }
      }, {
        key: "isValidCellIdx",
        value: function isValidCellIdx(idx) {
          return idx >= 0 && idx < this.cells.length;
        }
      }, {
        key: "heightToRowIndex",
        value: function heightToRowIndex(height, roundMode) {
          if (roundMode === undefined) {
            roundMode = 0;
          }
          /*
          roundMode:
          - 0 : floor
          - 1 : ceil
          - 2 :             
              - Default : floor
              - Vary : plus one if rowIdx is an integer, else floor
          */
  
          if (height === 0) {
            return 0;
          }
  
          // defaultCellHeightMode
          if (this.defaultCellHeightMode) {
            var rowIdx = height / this.defaultCellHeight;
            switch (roundMode) {
              case 1:
                rowIdx = Math.ceil(rowIdx);
                break;
              default:
                // 0, 2
                rowIdx = Math.floor(rowIdx);
                break;
            }
            return rowIdx;
          }
  
          // count cell height one by one
          var rowCount = this.rowCount;
          var remainder = height,
            isValidIdx;
          var rowHeight,
            rowIdx = 0;
          while (1) {
            rowHeight = this.getRowHeight(rowIdx);
            remainder -= rowHeight;
            isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
            if (remainder > 0 && isValidIdx) {
              rowIdx += 1;
            } else if (remainder === 0) {
              if (roundMode === 2) {
                rowIdx += 1;
              }
              return rowIdx;
            } else {
              if (roundMode === 1) {
                var preRowIdx = rowIdx;
                rowIdx += 1;
                isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
                if (!isValidIdx) {
                  rowIdx = preRowIdx;
                }
              }
              return rowIdx;
            }
          }
        }
      }, {
        key: "widthToColIndex",
        value: function widthToColIndex(width, isCeil) {
          if (width === 0) {
            return 0;
          }
          var colIdx = width / this.defaultCellWidth;
          if (isCeil) {
            colIdx = Math.ceil(colIdx);
          } else {
            colIdx = Math.floor(colIdx);
          }
          return colIdx;
        }
      }, {
        key: "colRowToCellIndex",
        value: function colRowToCellIndex(colIdx, rowIdx) {
          if (colIdx >= this.colCount) {
            return null;
          }
          return rowIdx * this.colCount + colIdx;
        }
      }, {
        key: "rowIndexToHeight",
        value: function rowIndexToHeight(start, end) {
          // defaultCellHeightMode
          if (this.defaultCellHeightMode) {
            return (end - start + 1) * this.defaultCellHeight;
          }
          var h,
            sum = 0;
          for (var i = start; i <= end; i++) {
            h = this.getRowHeight(i);
            sum += h;
          }
          return sum;
        }
      }, {
        key: "colIndexToWidth",
        value: function colIndexToWidth(start, end) {
          return (end - start + 1) * this.defaultCellWidth;
        }
      }, {
        key: "getRowHeight",
        value: function getRowHeight(rowIdx) {
          var cnt = this.colCount;
          // single column
          if (cnt <= 1) {
            return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
          }
  
          // multiple columns, get the maximum height
          var maxHeight = 0,
            cellHeight;
          for (var i = 0; i < cnt; i++) {
            cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
            if (maxHeight < cellHeight) maxHeight = cellHeight;
          }
          return maxHeight;
        }
      }, {
        key: "getColWidth",
        value: function getColWidth(idx) {
          return this.defaultCellWidth;
        }
      }, {
        key: "getCellHeight",
        value: function getCellHeight(cellIdx) {
          if (!this.isValidCellIdx(cellIdx)) {
            return 0;
          }
          var cellHeight;
          if (this.defaultCellHeightMode) cellHeight = this.defaultCellHeight;else {
            var cell = this.getCell(cellIdx, false);
            var deltaHeight = cell ? cell.deltaHeight : 0;
            cellHeight = this.defaultCellHeight + deltaHeight;
          }
          return cellHeight;
        }
      }, {
        key: "resetTotalRowsHeight",
        value: function resetTotalRowsHeight() {
          this._totalRowsHeight = null;
        }
      }, {
        key: "totalRowsHeight",
        get: function get() {
          if (this._totalRowsHeight === null) {
            this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
          }
          return this._totalRowsHeight;
        }
      }, {
        key: "totalColumnWidth",
        get: function get() {
          return this.colCount * this.defaultCellWidth;
        }
      }, {
        key: "cellIndxeToColIndex",
        value: function cellIndxeToColIndex(cellIdx) {
          return cellIdx % this.colCount;
        }
      }, {
        key: "cellIndxeToRowIndex",
        value: function cellIndxeToRowIndex(cellIdx) {
          return Math.floor(cellIdx / this.colCount);
        }
      }, {
        key: "getCell",
        value: function getCell(cellIdx, createNewCell) {
          if (!this.isValidCellIdx(cellIdx)) {
            return null;
          }
          if (createNewCell === undefined) {
            createNewCell = true;
          }
          if (this.cells[cellIdx] === null && createNewCell) {
            var cell = this.newCell(cellIdx);
            this.cells[cellIdx] = cell;
          }
          return this.cells[cellIdx];
        }
      }, {
        key: "newCell",
        value: function newCell(cellIdx) {
          var cell = this.cellPool.pop();
          if (cell === null) {
            cell = new Cell(this);
          } else {
            cell.setParent(this);
          }
          cell.index = cellIdx;
          return cell;
        }
      }, {
        key: "buildCellIndex",
        value: function buildCellIndex(startIdx) {
          if (startIdx === undefined) {
            startIdx = 0;
          }
          var cells = this.cells,
            cell;
          for (var i = startIdx, len = cells.length; i < len; i++) {
            cell = cells[i];
            if (cell) {
              cell.index = i;
            }
          }
          return this;
        }
      }, {
        key: "getParentContainer",
        value: function getParentContainer() {
          return this.parent;
        }
      }, {
        key: "freeCell",
        value: function freeCell(cell) {
          if (typeof cell === 'number') {
            cell = this.cells[cell];
          }
          if (!cell) {
            return this;
          }
          cell.destroy();
          this.cellPool.push(cell);
          return this;
        }
      }]);
      return Table;
    }();
  
    var SetTableOY = function SetTableOY(oy) {
      var table = this.table;
      var topTableOY = this.topTableOY;
      var bottomTableOY = this.bottomTableOY;
      var tableOYExceedTop = oy > this.topTableOY;
      var tableOYExeceedBottom = oy < this.bottomTableOY;
      if (this.clampTableOXY) {
        var rowCount = table.rowCount;
        var visibleRowCount = table.heightToRowIndex(this.instHeight, 1);
  
        // less then 1 page
        if (rowCount < visibleRowCount) {
          oy = 0;
        } else if (tableOYExceedTop) {
          oy = topTableOY;
        } else if (tableOYExeceedBottom) {
          oy = bottomTableOY;
        }
      }
      if (this._tableOY !== oy) {
        this._tableOY = oy;
      }
      if (tableOYExceedTop) {
        if (!this.execeedTopState) {
          this.emit('execeedtop', this, oy, topTableOY);
        }
      }
      this.execeedTopState = tableOYExceedTop;
      if (tableOYExeceedBottom) {
        if (!this.execeedBottomState) {
          this.emit('execeedbottom', this, oy, bottomTableOY);
        }
      }
      this.execeedBottomState = tableOYExeceedBottom;
      return this;
    };
  
    var SetTableOX = function SetTableOX(ox) {
      var table = this.table;
      var leftTableOX = this.leftTableOX;
      var rightTableOX = this.rightTableOX;
      var tableOXExeceedLeft = ox > this.leftTableOX;
      var tableOXExeceedRight = ox < this.rightTableOX;
      if (this.clampTableOXY) {
        var colCount = table.colCount;
        var visibleColCount = table.widthToColIndex(this.instWidth, true);
  
        // less then 1 page            
        if (colCount < visibleColCount) {
          ox = 0;
        } else if (tableOXExeceedLeft) {
          ox = leftTableOX;
        } else {
          // var tableVisibleWidth = this.tableVisibleWidth;
          if (tableOXExeceedRight) ox = rightTableOX;
        }
      }
      if (this._tableOX !== ox) {
        this._tableOX = ox;
      }
      if (tableOXExeceedLeft) {
        if (!this.execeedLeftState) {
          this.emit('execeedleft', this, ox, leftTableOX);
        }
      }
      this.execeedLeftState = tableOXExeceedLeft;
      if (tableOXExeceedRight) {
        if (!this.execeedRightState) {
          this.emit('execeedright', this, ox, rightTableOX);
        }
      }
      this.execeedRightState = tableOXExeceedRight;
      return this;
    };
  
    var MaskToGameObject = function MaskToGameObject(mask) {
      return mask.hasOwnProperty('geometryMask') ? mask.geometryMask : mask.bitmapMask;
    };
  
    var Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
    var Overlaps = Phaser.Geom.Rectangle.Overlaps;
    var MaskChildren = function MaskChildren(parent, mask, children) {
      if (!mask) {
        return;
      }
      if (children === undefined) {
        children = parent.getAllChildren();
      }
      var parentBounds = parent.getBounds();
      var maskGameObject = MaskToGameObject(mask);
      var child, childBounds, visiblePointsNumber;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === maskGameObject) {
          continue;
        }
        if (!IsVisible(child)) {
          // Child is invisible before masking
          continue;
        }
        if (child.getBounds) {
          childBounds = child.getBounds(childBounds);
          visiblePointsNumber = ContainsPoints(parentBounds, childBounds);
          switch (visiblePointsNumber) {
            case 4:
              // 4 points are all inside visible window, set visible
              ShowAll(parent, child);
              break;
            case 0:
              // No point is inside visible window
              // Parent intersects with child, or parent is inside child, set visible, and apply mask
              if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
                ShowSome(parent, child, mask);
              } else {
                // Set invisible
                ShowNone(parent, child);
              }
              break;
            default:
              // Part of points are inside visible window, set visible, and apply mask
              ShowSome(parent, child, mask);
              break;
          }
        } else {
          ShowSome(parent, child, mask);
        }
      }
    };
    var IsVisible = function IsVisible(gameObject) {
      if (!gameObject.displayList) {
        return false;
      }
      while (1) {
        var localState = gameObject.rexContainer;
        if (!localState) {
          // Top game object
          return gameObject.visible;
        } else if (localState.visible) {
          var parent = localState.parent;
          if (parent) {
            // Test parent's visible
            gameObject = parent;
            continue;
          } else {
            // Top visible game object
            return true;
          }
        } else {
          // Current game object is invisible
          return false;
        }
      }
    };
    var ContainsPoints = function ContainsPoints(rectA, rectB) {
      var top = rectB.top,
        bottom = rectB.bottom,
        left = rectB.left,
        right = rectB.right;
      var result = 0;
      result += rectA.contains(left, top) ? 1 : 0;
      result += rectA.contains(left, bottom) ? 1 : 0;
      result += rectA.contains(right, top) ? 1 : 0;
      result += rectA.contains(right, bottom) ? 1 : 0;
      return result;
    };
    var ShowAll = function ShowAll(parent, child, mask) {
      if (!child.hasOwnProperty('isRexContainerLite')) {
        if (child.clearMask) {
          child.clearMask();
        }
        parent.setChildMaskVisible(child, true);
      } else {
        child.syncChildrenEnable = false;
        parent.setChildMaskVisible(child, true);
        child.syncChildrenEnable = true;
      }
    };
    var ShowSome = function ShowSome(parent, child, mask) {
      if (!child.hasOwnProperty('isRexContainerLite')) {
        if (child.setMask) {
          child.setMask(mask);
        }
        parent.setChildMaskVisible(child, true);
      } else {
        child.syncChildrenEnable = false;
        parent.setChildMaskVisible(child, true);
        child.syncChildrenEnable = true;
      }
    };
    var ShowNone = function ShowNone(parent, child, mask) {
      if (!child.hasOwnProperty('isRexContainerLite')) {
        if (child.clearMask) {
          child.clearMask();
        }
        parent.setChildMaskVisible(child, false);
      } else {
        child.syncChildrenEnable = false;
        parent.setChildMaskVisible(child, false);
        child.syncChildrenEnable = true;
      }
    };
  
    var GetValue$15 = Phaser.Utils.Objects.GetValue;
    var MASKUPDATEMODE = {
      update: 0,
      everyTick: 1
    };
    var ChildrenMaskMethods = {
      setupChildrenMask: function setupChildrenMask(config) {
        if (config === false) {
          // No children mask
          return this;
        }
        this.setMaskUpdateMode(GetValue$15(config, 'updateMode', 0));
        this.enableChildrenMask(GetValue$15(config, 'padding', 0));
        this.setMaskLayer(GetValue$15(config, 'layer', undefined));
        this.startMaskUpdate();
        return this;
      },
      destroyChildrenMask: function destroyChildrenMask() {
        if (!this.childrenMask) {
          return this;
        }
        this.stopMaskUpdate();
        this.childrenMask.destroy();
        this.childrenMask = undefined;
        return this;
      },
      setMaskUpdateMode: function setMaskUpdateMode(mode) {
        if (typeof mode === 'string') {
          mode = MASKUPDATEMODE[mode];
        }
        this.maskUpdateMode = mode;
        return this;
      },
      startMaskUpdate: function startMaskUpdate() {
        this.scene.game.events.on('poststep', this.maskChildren, this);
      },
      stopMaskUpdate: function stopMaskUpdate() {
        this.scene.game.events.off('poststep', this.maskChildren, this);
      },
      enableChildrenMask: function enableChildrenMask(maskPadding) {
        var maskGameObject = AddChildMask.call(this, null, this, 0, maskPadding);
        this.childrenMask = maskGameObject.createGeometryMask();
        // this.childrenMask is a mask object, not a (Graphics) game object
        return this;
      },
      setMaskChildrenFlag: function setMaskChildrenFlag(value) {
        if (value === undefined) {
          value = true;
        }
        this.maskChildrenFlag = value;
        return this;
      },
      setMaskLayer: function setMaskLayer(layer) {
        // To reduce amount of masked game object
        this.maskLayer = layer;
        return this;
      },
      maskChildren: function maskChildren() {
        if (!this.childrenMask ||
        // No childrenMask
        !this.maskChildrenFlag ||
        // No maskChildrenFlag set
        this.alpha === 0 || !this.visible // Parent is not visible
        ) {
          return this;
        }
        if (this.privateRenderLayer) {
          this.privateRenderLayer.setMask(this.childrenMask);
        } else if (this.maskLayer) {
          // 1. Add parent and children into layer
          this.addToLayer(this.maskLayer);
          // 2. Mask this layer
          this.maskLayer.setMask(this.childrenMask);
        } else {
          MaskChildren(this, this.childrenMask);
        }
        if (this.maskUpdateMode === 0) {
          this.maskChildrenFlag = false;
        }
        return this;
      },
      layoutChildrenMask: function layoutChildrenMask() {
        if (!this.childrenMask) {
          return this;
        }
        var maskGameObject = MaskToGameObject(this.childrenMask);
        maskGameObject.setPosition().resize();
        this.resetChildPositionState(maskGameObject);
        return this;
      }
    };
  
    var ShowCells = function ShowCells() {
      if (this.cellsCount === 0) {
        return;
      }
  
      // Save scale
      var scaleXSave = this.scaleX;
      var scaleYSave = this.scaleY;
      var scale1 = scaleXSave === 1 && scaleYSave === 1;
      if (!scale1) {
        this.setScale(1);
      }
      var table = this.table;
      this.startRowIndex = Math.max(table.heightToRowIndex(-this.tableOY, 2), 0);
      var rowIndex = this.startRowIndex;
      var startColumnIndex = Math.max(table.widthToColIndex(-this.tableOX), 0);
      var columnIndex = startColumnIndex;
      var cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
      var bottomBound = this.bottomBound;
      var rightBound = this.rightBound;
      var lastIdx = table.cellsCount - 1;
      var lastColIdx = table.colCount - 1;
      var startCellTLX = this.getCellTLX(columnIndex),
        cellTLX = startCellTLX;
      var cellTLY = this.getCellTLY(rowIndex);
      while (cellTLY < bottomBound && cellIdx <= lastIdx) {
        if (this.table.isValidCellIdx(cellIdx)) {
          var cell = table.getCell(cellIdx, true);
          this.visibleCells.set(cell);
          if (!this.preVisibleCells.contains(cell)) {
            this.showCell(cell);
          }
          var x, y;
          if (this.scrollMode === 0) {
            x = cellTLX;
            y = cellTLY;
          } else {
            x = cellTLY;
            y = cellTLX;
          }
          if (cell.cellContainerAlign == null) {
            cell.setXY(x, y);
          } else {
            var cellContainer = cell.getContainer();
            AlignIn(cellContainer, x, y, cell.width, cell.height, cell.cellContainerAlign);
            cell.setXY(cellContainer.x, cellContainer.y);
          }
        }
        if (cellTLX < rightBound && columnIndex < lastColIdx) {
          cellTLX += table.getColWidth(columnIndex);
          columnIndex += 1;
        } else {
          cellTLX = startCellTLX;
          cellTLY += table.getRowHeight(rowIndex);
          columnIndex = startColumnIndex;
          rowIndex += 1;
        }
        cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
      }
  
      // Restore scale
      if (!scale1) {
        this.setScale(scaleXSave, scaleYSave);
      }
    };
  
    var ShowCell = function ShowCell(cell) {
      // Attach container to cell by cell.setContainer(container) under this event
      var reusedCellContainer = null;
      var cellContainer = cell.getContainer();
      if (cellContainer) {
        reusedCellContainer = cellContainer;
        cell.popContainer();
      } else if (this.cellContainersPool) {
        reusedCellContainer = this.cellContainersPool.getFirstDead();
        if (reusedCellContainer !== null) {
          // Reuse this game object
          reusedCellContainer.setActive(true).setVisible(true);
        }
      }
      this.emit('cellvisible', cell, reusedCellContainer, this);
      if (this.cellContainersPool) {
        var cellContainer = cell.getContainer();
        if (cellContainer) {
          if (reusedCellContainer === null) {
            this.cellContainersPool.add(cellContainer); // New cell container, add to pool
          } else if (reusedCellContainer !== cellContainer) {
            // Why reusedCellContainer is not equal to cellContainer?
            this.cellContainersPool.add(cellContainer); // New cell container, add to pool
            this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
          }
        } else {
          // No cell container added
          if (reusedCellContainer !== null) {
            this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
          }
        }
      }
    };
  
    var GetCellTLX = function GetCellTLX(colIdx) {
      var ox = this.scrollMode === 0 ? this.topLeftX : this.topLeftY;
      var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
      return x;
    };
  
    var GetCellTLY = function GetCellTLY(rowIdx) {
      var oy = this.scrollMode === 0 ? this.topLeftY : this.topLeftX;
      var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
      return y;
    };
  
    var HideCells = function HideCells() {
      var preList = this.preVisibleCells;
      var curList = this.visibleCells;
      preList.iterate(function (cell) {
        if (!curList.contains(cell)) {
          this.hideCell(cell);
        }
      }, this);
    };
  
    var HideCell = function HideCell(cell) {
      // Option: pop container of cell by cell.popContainer() under this event 
      this.emit('cellinvisible', cell);
      if (this.cellContainersPool) {
        var cellContainer = cell.popContainer(); // null if already been removed
        if (cellContainer) {
          cellContainer.setScale(1).setAlpha(1);
          this.cellContainersPool.killAndHide(cellContainer);
        }
      }
      cell.destroyContainer(); // Destroy container of cell
    };
  
    var UpdateTable = function UpdateTable(refresh) {
      if (refresh === undefined) {
        refresh = false;
      }
      if (refresh) {
        ClearVisibleCellIndexes.call(this);
        this.hideCells();
      }
      ClearVisibleCellIndexes.call(this);
      this.showCells();
      this.hideCells();
      this.setMaskChildrenFlag();
      return this;
    };
    var ClearVisibleCellIndexes = function ClearVisibleCellIndexes() {
      var tmp = this.preVisibleCells;
      this.preVisibleCells = this.visibleCells;
      this.visibleCells = tmp;
      this.visibleCells.clear();
    };
  
    var IsCellVisible = function IsCellVisible(cellIdx) {
      var cell = this.table.getCell(cellIdx, false);
      return cell && this.visibleCells.contains(cell);
    };
  
    var PointToCellIndex = function PointToCellIndex(x, y) {
      y -= this.y + this.topLeftY;
      x -= this.x + this.topLeftX;
      var offsetTableOY = this.tableOY - (this.scrollMode === 0 ? y : x);
      var offsetTableOX = this.tableOX - (this.scrollMode === 0 ? x : y);
      var table = this.table;
      var rowIdx = table.heightToRowIndex(-offsetTableOY, 0);
      var colIdx = table.widthToColIndex(-offsetTableOX);
      var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
      if (cellIdx === null) {
        return null;
      }
      if (!this.isCellVisible(cellIdx)) {
        return null;
      }
      return cellIdx;
    };
    var PointToCellContainer = function PointToCellContainer(x, y) {
      var cellIdx = PointToCellIndex.call(this, x, y);
      if (cellIdx === null) {
        return undefined;
      }
      return this.getCellContainer(cellIdx);
    };
  
    // For when you know this Set will be modified during the iteration
    var EachVisibleCell = function EachVisibleCell(callback, scope) {
      this.visibleCells.each(callback, scope);
      return this;
    };
  
    // For when you absolutely know this Set won't be modified during the iteration
    var IterateVisibleCell = function IterateVisibleCell(callback, scope) {
      this.visibleCells.iterate(callback, scope);
      return this;
    };
    var EachCell = function EachCell(callback, scope) {
      this.table.cells.slice().forEach(callback, scope);
      return this;
    };
    var IterateCell = function IterateCell(callback, scope) {
      this.table.cells.forEach(callback, scope);
      return this;
    };
  
    var SetCellsCount = function SetCellsCount(count) {
      var cellsCount = this.cellsCount;
      if (cellsCount === count) {
        return this;
      }
      if (cellsCount > count) {
        this.removeCells(count, cellsCount - count);
      } else {
        // cellsCount < count
        this.insertNewCells(cellsCount, count - cellsCount);
      }
      return this;
    };
  
    var Clamp$4 = Phaser.Math.Clamp;
    var InsertNewCells = function InsertNewCells(cellIdx, count) {
      if (_typeof(cellIdx) === 'object') {
        cellIdx = cellIdx.index;
      }
      if (count === undefined) {
        count = 1;
      }
      if (count <= 0) {
        return this;
      }
      cellIdx = Clamp$4(cellIdx, 0, this.cellsCount);
      this.table.insertNewCells(cellIdx, count);
      return this;
    };
  
    var RemoveCells = function RemoveCells(cellIdx, count) {
      if (_typeof(cellIdx) === 'object') {
        cellIdx = cellIdx.index;
      }
      if (count === undefined) {
        count = 1;
      }
      if (cellIdx < 0) {
        count += cellIdx;
        cellIdx = 0;
      }
      if (count <= 0) {
        return this;
      }
      // out-of-range
      if (cellIdx > this.cellsCount) {
        return this;
      }
      var cell;
      for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
        cell = this.getCell(i, false);
        if (cell) {
          if (this.visibleCells.contains(cell)) {
            HideCell.call(this, cell);
            this.visibleCells["delete"](cell);
          }
          this.preVisibleCells["delete"](cell);
        }
      }
      this.table.removeCells(cellIdx, count);
      return this;
    };
  
    var SetColumnCount = function SetColumnCount(count) {
      if (this.table.colCount === count) {
        return this;
      }
      this.table.setColumnCount(count);
      return this;
    };
  
    var SetGridSize = function SetGridSize(colCount, rowCount) {
      this.setCellsCount(colCount * rowCount);
      this.table.setColumnCount(colCount);
      return this;
    };
  
    var UpdateVisibleCell = function UpdateVisibleCell(cellIdx) {
      var cell = this.table.getCell(cellIdx, false);
      if (!cell || !cell.container) {
        return this;
      }
      ShowCell.call(this, cell);
      return this;
    };
  
    var methods$e = {
      setTableOY: SetTableOY,
      setTableOX: SetTableOX,
      showCells: ShowCells,
      showCell: ShowCell,
      getCellTLX: GetCellTLX,
      getCellTLY: GetCellTLY,
      hideCells: HideCells,
      hideCell: HideCell,
      updateTable: UpdateTable,
      isCellVisible: IsCellVisible,
      pointToCellIndex: PointToCellIndex,
      pointToCellContainer: PointToCellContainer,
      eachVisibleCell: EachVisibleCell,
      iterateVisibleCell: IterateVisibleCell,
      eachCell: EachCell,
      iterateCell: IterateCell,
      setCellsCount: SetCellsCount,
      insertNewCells: InsertNewCells,
      removeCells: RemoveCells,
      setColumnCount: SetColumnCount,
      setGridSize: SetGridSize,
      updateVisibleCell: UpdateVisibleCell
    };
    Object.assign(methods$e, ChildrenMaskMethods);
  
    var Group = Phaser.GameObjects.Group;
    var Set = Phaser.Structs.Set;
    var GetValue$14 = Phaser.Utils.Objects.GetValue;
    var GridTable$1 = /*#__PURE__*/function (_ContainerLite) {
      _inherits(GridTable, _ContainerLite);
      function GridTable(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, GridTable);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, GridTable, [scene, x, y, width, height]);
        _this.type = 'rexGridTable';
        _this._tableOX = 0;
        _this._tableOY = 0;
        _this.visibleCells = new Set();
        _this.preVisibleCells = new Set();
        _this.execeedTopState = false;
        _this.execeedBottomState = false;
        _this.execeedLeftState = false;
        _this.execeedRightState = false;
        var reuseCellContainer = GetValue$14(config, 'reuseCellContainer', false);
        if (reuseCellContainer) {
          _this.cellContainersPool = new Group(scene); // Don't add Group into update list, I will destroy it manually
        }
        var callback = GetValue$14(config, 'cellVisibleCallback', null);
        if (callback !== null) {
          var scope = GetValue$14(config, 'cellVisibleCallbackScope', undefined);
          _this.on('cellvisible', callback, scope);
        }
        callback = GetValue$14(config, 'cellInvisibleCallback', null);
        if (callback !== null) {
          var scope = GetValue$14(config, 'cellInvisibleCallbackScope', undefined);
          _this.on('cellinvisible', callback, scope);
        }
        if (GetValue$14(config, 'enableLayer', false)) {
          _this.enableLayer();
        }
        _this.setupChildrenMask(GetValue$14(config, 'mask', undefined));
        _this.setScrollMode(GetValue$14(config, 'scrollMode', 0));
        _this.setClampMode(GetValue$14(config, 'clamplTableOXY', true));
  
        // Pre-process cell size
        var cellWidth, cellHeight, columns;
        var scrollY = _this.scrollMode === 0;
        if (scrollY) {
          // scroll y
          cellWidth = config.cellWidth;
          cellHeight = config.cellHeight;
          columns = config.columns;
        } else {
          // scroll x
          cellWidth = config.cellHeight;
          cellHeight = config.cellWidth;
          columns = GetValue$14(config, 'rows', config.columns);
        }
        if (!columns) {
          columns = 1; // Default columns
        }
        _this.expandCellSize = cellWidth === undefined;
        if (_this.expandCellSize) {
          var width = scrollY ? _this.width : _this.height;
          cellWidth = width / columns;
        }
        config.cellWidth = cellWidth;
        config.cellHeight = cellHeight;
        config.columns = columns;
        _this.table = new Table(_assertThisInitialized(_this), config);
        _this.updateTable();
        return _this;
      }
      _createClass(GridTable, [{
        key: "destroy",
        value: function destroy(fromScene) {
          // preDestroy method does not have fromScene parameter
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.destroyChildrenMask();
          this.table.destroy(fromScene);
          this.table = undefined;
          if (this.cellContainersPool) {
            this.cellContainersPool.destroy(true);
            this.cellContainersPool = undefined;
          }
          _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setScrollMode",
        value: function setScrollMode(mode) {
          if (typeof mode === 'string') {
            mode = SCROLLMODE[mode.toLowerCase()];
          }
          this.scrollMode = mode;
          return this;
        }
      }, {
        key: "setClampMode",
        value: function setClampMode(mode) {
          if (mode === undefined) {
            mode = true;
          }
          this.clampTableOXY = mode;
          return this;
        }
      }, {
        key: "tableOY",
        get: function get() {
          return this._tableOY;
        },
        set: function set(oy) {
          this.setTableOY(oy).updateTable();
        }
      }, {
        key: "tableOX",
        get: function get() {
          return this._tableOX;
        },
        set: function set(ox) {
          this.setTableOX(ox).updateTable();
        }
      }, {
        key: "setTableOXY",
        value: function setTableOXY(ox, oy) {
          this.setTableOY(oy).setTableOX(ox);
          return this;
        }
      }, {
        key: "addTableOY",
        value: function addTableOY(dy) {
          this.setTableOY(this.tableOY + dy);
          return this;
        }
      }, {
        key: "addTableOX",
        value: function addTableOX(dx) {
          this.setTableOX(this.tableOX + dx);
          return this;
        }
      }, {
        key: "addTableOXY",
        value: function addTableOXY(dx, dy) {
          this.addTableOY(dy).addTableOX(dx);
          return this;
        }
      }, {
        key: "setTableOYByPercentage",
        value: function setTableOYByPercentage(percentage) {
          this.setTableOY(-this.tableVisibleHeight * percentage);
          return this;
        }
      }, {
        key: "getTableOYPercentage",
        value: function getTableOYPercentage() {
          var tableVisibleHeight = this.tableVisibleHeight;
          if (tableVisibleHeight === 0) {
            return 0;
          }
          return this.tableOY / -tableVisibleHeight;
        }
      }, {
        key: "setTableOXByPercentage",
        value: function setTableOXByPercentage(percentage) {
          this.setTableOX(-this.tableVisibleWidth * percentage);
          return this;
        }
      }, {
        key: "getTableOXPercentage",
        value: function getTableOXPercentage() {
          var tableVisibleWidth = this.tableVisibleWidth;
          if (tableVisibleWidth === 0) {
            return 0;
          }
          return this.tableOX / -tableVisibleWidth;
        }
      }, {
        key: "t",
        get: function get() {
          return this.getTableOYPercentage();
        },
        set: function set(value) {
          this.setTableOYByPercentage(value).updateTable();
        }
      }, {
        key: "s",
        get: function get() {
          return this.getTableOXPercentage();
        },
        set: function set(value) {
          this.setTableOXByPercentage(value).updateTable();
        }
      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          this.t = 1;
          // t will be 0 if table does not exceed visible area
          if (this.t === 0) {
            return this;
          }
  
          // Table height might be expanded while cells are visible        
          do {
            this.t = 1;
          } while (this.t !== 1);
          return this;
        }
      }, {
        key: "scrollToRow",
        value: function scrollToRow(rowIndex) {
          // To get all height of cells
          this.scrollToBottom();
          var height = this.table.rowIndexToHeight(0, rowIndex - 1);
          this.setTableOY(-height).updateTable();
          return this;
        }
      }, {
        key: "scrollToNextRow",
        value: function scrollToNextRow(rowCount) {
          if (rowCount === undefined) {
            rowCount = 1;
          }
          this.scrollToRow(this.startRowIndex + rowCount);
          return this;
        }
      }, {
        key: "getCell",
        value: function getCell(cellIdx) {
          return this.table.getCell(cellIdx, true);
        }
      }, {
        key: "getCellContainer",
        value: function getCellContainer(cellIdx) {
          var cell = this.table.getCell(cellIdx, false);
          var container;
          if (cell) {
            container = cell.getContainer();
          }
          return container;
        }
      }, {
        key: "cellsCount",
        get: function get() {
          return this.table.cellsCount;
        }
      }, {
        key: "columnCount",
        get: function get() {
          return this.table.colCount;
        }
      }, {
        key: "setCellHeight",
        value: function setCellHeight(cellIdx, height) {
          var cell;
          if (typeof cellIdx === 'number') {
            cell = this.table.getCell(cellIdx, true);
          } else {
            cell = cellIdx;
          }
          cell.height = height; // Only worked when scrollMode is 0
          return this;
        }
      }, {
        key: "setCellWidth",
        value: function setCellWidth(cellIdx, width) {
          var cell;
          if (typeof cellIdx === 'number') {
            cell = this.table.getCell(cellIdx, true);
          } else {
            cell = cellIdx;
          }
          cell.width = width; // Only worked when scrollMode is 1
          return this;
        }
      }, {
        key: "instHeight",
        get: function get() {
          return this.scrollMode === 0 ? this.height : this.width;
        }
      }, {
        key: "instWidth",
        get: function get() {
          return this.scrollMode === 0 ? this.width : this.height;
        }
      }, {
        key: "tableHeight",
        get: function get() {
          return this.table.totalRowsHeight;
        }
      }, {
        key: "tableWidth",
        get: function get() {
          return this.table.totalColumnWidth;
        }
      }, {
        key: "topTableOY",
        get: function get() {
          return 0;
        }
      }, {
        key: "bottomTableOY",
        get: function get() {
          return -this.tableVisibleHeight;
        }
      }, {
        key: "leftTableOX",
        get: function get() {
          return 0;
        }
      }, {
        key: "rightTableOX",
        get: function get() {
          return -this.tableVisibleWidth;
        }
      }, {
        key: "tableVisibleHeight",
        get: function get() {
          var h = this.tableHeight - this.instHeight;
          if (h < 0) {
            h = 0;
          }
          return h;
        }
      }, {
        key: "tableVisibleWidth",
        get: function get() {
          var w = this.tableWidth - this.instWidth;
          if (w < 0) {
            w = 0;
          }
          return w;
        }
      }, {
        key: "bottomLeftY",
        get: function get() {
          return -(this.displayHeight * this.originY) + this.displayHeight;
        }
      }, {
        key: "topRightX",
        get: function get() {
          return -(this.displayWidth * this.originX) + this.displayWidth;
        }
      }, {
        key: "topLeftX",
        get: function get() {
          return -(this.displayWidth * this.originX);
        }
      }, {
        key: "topLeftY",
        get: function get() {
          return -(this.displayHeight * this.originY);
        }
      }, {
        key: "bottomBound",
        get: function get() {
          if (this.scrollMode === 0) {
            return this.bottomLeftY;
          } else {
            return this.topRightX;
          }
        }
      }, {
        key: "rightBound",
        get: function get() {
          if (this.scrollMode === 0) {
            return this.topRightX;
          } else {
            return this.bottomLeftY;
          }
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          if (this.width === width && this.height === height) {
            return this;
          }
          _get(_getPrototypeOf(GridTable.prototype), "resize", this).call(this, width, height);
          if (this.expandCellSize) {
            this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
          }
          this.updateTable(true);
  
          // Layout children-mask
          this.layoutChildrenMask();
          // Re-mask children
          this.maskChildren();
          return this;
        }
      }]);
      return GridTable;
    }(ContainerLite);
  
    // mixin
    Object.assign(GridTable$1.prototype, methods$e);
    var SCROLLMODE = {
      v: 0,
      vertical: 0,
      h: 1,
      horizontal: 1
    };
  
    var InjectProperties$1 = function InjectProperties(table) {
      Object.defineProperty(table, 'childOY', {
        configurable: true,
        get: function get() {
          return table.tableOY;
        },
        set: function set(value) {
          table.tableOY = value;
        }
      });
      Object.defineProperty(table, 'childOX', {
        configurable: true,
        get: function get() {
          return table.tableOX;
        },
        set: function set(value) {
          table.tableOX = value;
        }
      });
      Object.defineProperty(table, 'topChildOY', {
        get: function get() {
          return table.topTableOY;
        }
      });
      Object.defineProperty(table, 'bottomChildOY', {
        get: function get() {
          return table.bottomTableOY;
        }
      });
      Object.defineProperty(table, 'leftChildOX', {
        get: function get() {
          return table.leftTableOX;
        }
      });
      Object.defineProperty(table, 'rightChildOX', {
        get: function get() {
          return table.rightTableOX;
        }
      });
      Object.defineProperty(table, 'childVisibleHeight', {
        get: function get() {
          return table.instHeight;
        }
      });
      Object.defineProperty(table, 'childHeight', {
        get: function get() {
          return table.tableHeight;
        }
      });
      Object.defineProperty(table, 'childVisibleWidth', {
        get: function get() {
          return table.instWidth;
        }
      });
      Object.defineProperty(table, 'childWidth', {
        get: function get() {
          return table.tableWidth;
        }
      });
    };
  
    var TableOnCellVisible = function TableOnCellVisible(table) {
      table.on('cellvisible', function (cell, cellContainer, table) {
        var callback = this.createCellContainerCallback;
        var scope = this.createCellContainerCallbackScope;
        cell.item = this.items[cell.index];
        cell.items = this.items;
        var cellContainer;
        if (scope) {
          cellContainer = callback.call(scope, cell, cellContainer, table);
        } else {
          cellContainer = callback(cell, cellContainer, table);
        }
        if (cellContainer) {
          if (cell.cellContainerAlign == null && cellContainer.setOrigin) {
            cellContainer.setOrigin(0);
          }
          if (cellContainer.isRexSizer) {
            cellContainer.layout(); // Use original size
          }
        }
        cell.item = undefined;
        cell.items = undefined;
        cell.setContainer(cellContainer);
      }, this);
    };
  
    var EmitCellEvent = function EmitCellEvent(eventEmitter, eventName, table, x, y, pointer, event) {
      var cellIndex;
      if (y === undefined) {
        cellIndex = x;
      } else {
        cellIndex = table.pointToCellIndex(x, y);
      }
      if (cellIndex === null || cellIndex === undefined) {
        return;
      }
      var cellContainer = table.getCellContainer(cellIndex);
      if (cellContainer) {
        eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
      }
    };
  
    var PointerUpDownCell = function PointerUpDownCell(table, tableConfig) {
      table.on('pointerdown', function (pointer, localX, localY, event) {
        EmitCellEvent(this.eventEmitter, 'cell.down', table, pointer.worldX, pointer.worldY, pointer, event);
      }, this).on('pointerup', function (pointer, localX, localY, event) {
        EmitCellEvent(this.eventEmitter, 'cell.up', table, pointer.worldX, pointer.worldY, pointer, event);
      }, this);
    };
  
    var OverCell = function OverCell(table, tableConfig) {
      table.on('pointermove', OnMove, this).on('pointerover', OnMove, this).on('pointerout', OnOut, this); // pointer-up is included too
    };
    var OnMove = function OnMove(pointer, localX, localY, event) {
      var table = this.childrenMap.child;
      var cellIndex = table.pointToCellIndex(pointer.worldX, pointer.worldY);
      if (cellIndex === table.input.lastOverCellIndex) {
        return;
      }
      var preCellIndex = table.input.lastOverCellIndex;
      table.input.lastOverCellIndex = cellIndex;
      EmitCellEvent(this.eventEmitter, 'cell.out', table, preCellIndex, undefined, pointer, event);
      EmitCellEvent(this.eventEmitter, 'cell.over', table, cellIndex, undefined, pointer, event);
    };
    var OnOut = function OnOut(pointer, event) {
      var table = this.childrenMap.child;
      var cellIndex = table.input.lastOverCellIndex;
      table.input.lastOverCellIndex = undefined;
      EmitCellEvent(this.eventEmitter, 'cell.out', table, cellIndex, undefined, pointer, event);
    };
  
    var GetValue$13 = Phaser.Utils.Objects.GetValue;
    var ClickCell = function ClickCell(table, tableConfig) {
      var buttonConfig = GetValue$13(tableConfig, 'click', undefined);
      if (buttonConfig === false) {
        return;
      } else if (buttonConfig === undefined) {
        buttonConfig = {};
      }
      buttonConfig.threshold = 10;
      table._click = new Button(table, buttonConfig);
      table._click.on('click', function (button, gameObject, pointer, event) {
        EmitCellEvent(this.eventEmitter, 'cell.click', gameObject, pointer.worldX, pointer.worldY, pointer, event);
      }, this);
    };
  
    var GetValue$12 = Phaser.Utils.Objects.GetValue;
    var TapCell = function TapCell(table, tableConfig) {
      var tapConfig = GetValue$12(tableConfig, 'tap', undefined);
      if (tapConfig === false) {
        return;
      }
      table._tap = new Tap(table, tapConfig);
      table._tap.on('tap', function (tap, gameObject, lastPointer) {
        var eventName = "cell.".concat(tap.tapsCount, "tap");
        EmitCellEvent(this.eventEmitter, eventName, tap.gameObject, tap.worldX, tap.worldY, lastPointer);
      }, this);
    };
  
    var GetValue$11 = Phaser.Utils.Objects.GetValue;
    var PressCell = function PressCell(table, tableConfig) {
      var pressConfig = GetValue$11(tableConfig, 'press', undefined);
      if (pressConfig === false) {
        return;
      }
      table._press = new Press(table, pressConfig);
      table._press.on('pressstart', function (press, gameObject, lastPointer) {
        EmitCellEvent(this.eventEmitter, 'cell.pressstart', table, press.worldX, press.worldY, lastPointer);
      }, this).on('pressend', function (press, gameObject, lastPointer) {
        EmitCellEvent(this.eventEmitter, 'cell.pressend', table, press.worldX, press.worldY, lastPointer);
      }, this);
    };
  
    var GetValue$10 = Phaser.Utils.Objects.GetValue;
    var SwipeCell = function SwipeCell(table, tableConfig) {
      var swipeConfig = GetValue$10(tableConfig, 'swipe', undefined);
      if (swipeConfig === false) {
        return;
      } else if (swipeConfig === undefined) {
        swipeConfig = {};
      }
      swipeConfig.dir = '4dir';
      table._swipe = new Swipe(table, swipeConfig);
      table._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
        var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
        EmitCellEvent(this.eventEmitter, "cell.swipe".concat(dirName), table, swipe.worldX, swipe.worldY, lastPointer);
      }, this);
    };
  
    var TableSetInteractive = function TableSetInteractive(table, tableConfig) {
      table.setInteractive();
      PointerUpDownCell.call(this, table, tableConfig);
      OverCell.call(this, table, tableConfig);
      ClickCell.call(this, table, tableConfig);
      TapCell.call(this, table, tableConfig);
      PressCell.call(this, table, tableConfig);
      SwipeCell.call(this, table, tableConfig);
    };
  
    var SetItems = function SetItems(items, updateTable) {
      if (items === undefined) {
        this.items = [];
      } else {
        this.items = items;
      }
      if (updateTable === undefined) {
        updateTable = true;
      }
      var table = this.childrenMap.child;
      table.setCellsCount(this.items.length);
      if (updateTable) {
        table.updateTable(true);
        this.resizeController();
      }
      return this;
    };
  
    var ScrollMethods$1 = {
      scrollToRow: function scrollToRow(rowIndex) {
        var table = this.childrenMap.child;
        table.scrollToRow(rowIndex);
        return this;
      },
      scrollToNextRow: function scrollToNextRow(rowCount) {
        var table = this.childrenMap.child;
        table.scrollToNextRow(rowCount);
        return this;
      }
    };
  
    var GetValue$$ = Phaser.Utils.Objects.GetValue;
    var GridTable = /*#__PURE__*/function (_Scrollable) {
      _inherits(GridTable, _Scrollable);
      function GridTable(scene, config) {
        var _this;
        _classCallCheck(this, GridTable);
        if (config === undefined) {
          config = {};
        }
  
        // Create grid table core
        var scrollMode = GetScrollMode(config);
        var tableConfig = GetValue$$(config, 'table', undefined);
        if (tableConfig === undefined) {
          tableConfig = {};
        }
        tableConfig.scrollMode = scrollMode === 2 ? 0 : scrollMode;
        tableConfig.clamplTableOXY = GetValue$$(config, 'clamplChildOY', false);
        var tableWidth = GetValue$$(tableConfig, 'width', undefined);
        var tableHeight = GetValue$$(tableConfig, 'height', undefined);
        var table = new GridTable$1(scene, 0, 0, tableWidth, tableHeight, tableConfig);
        scene.add.existing(table); // Important: Add to display list for touch detecting
        var expandWidth, expandHeight;
        if (tableConfig.scrollMode === 0) {
          expandWidth = tableWidth === undefined;
          expandHeight = tableHeight === undefined;
        } else {
          expandWidth = tableHeight === undefined;
          expandHeight = tableWidth === undefined;
        }
        // Inject properties for scrollable interface
        InjectProperties$1(table);
        // Set minWidth/minHeight to 0 if tableWidth/tableHeight is undefined
        table._minWidth = tableWidth === undefined ? 0 : undefined;
        table._minHeight = tableHeight === undefined ? 0 : undefined;
  
        // Fill config of scrollable
        config.type = 'rexGridTable';
        config.child = {
          gameObject: table,
          expandWidth: expandWidth,
          expandHeight: expandHeight
        };
        var spaceConfig = GetValue$$(config, 'space', undefined);
        if (spaceConfig) {
          spaceConfig.child = GetValue$$(spaceConfig, 'table', 0);
        }
        _this = _callSuper(this, GridTable, [scene, config]);
        _this.addChildrenMap('table', table);
        _this.addChildrenMap('tableLayer', table.maskLayer);
        _this.eventEmitter = GetValue$$(config, 'eventEmitter', _assertThisInitialized(_this));
        var callback = GetValue$$(config, 'createCellContainerCallback', NOOP);
        var scope = GetValue$$(config, 'createCellContainerCallbackScope', undefined);
        _this.setCreateCellContainerCallback(callback, scope);
        TableOnCellVisible.call(_assertThisInitialized(_this), table);
        _this.resizeControllerFlag = false;
        var eventName = scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
        table.on(eventName, function () {
          this.resizeControllerFlag = true;
        }, _assertThisInitialized(_this));
        if (GetValue$$(tableConfig, 'interactive', true)) {
          TableSetInteractive.call(_assertThisInitialized(_this), table, tableConfig);
        }
        _this.setItems(GetValue$$(config, 'items', []), false);
        scene.game.events.on('poststep', _this.onPostStep, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(GridTable, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.scene.game.events.off('poststep', this.onPostStep, this);
          _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setCreateCellContainerCallback",
        value: function setCreateCellContainerCallback(callback, scope) {
          this.createCellContainerCallback = callback;
          this.createCellContainerCallbackScope = scope;
          return this;
        }
      }, {
        key: "refresh",
        value: function refresh() {
          this.setItems(this.items);
          return this;
        }
      }, {
        key: "getCell",
        value: function getCell(cellIdx) {
          var table = this.childrenMap.child;
          return table.getCell(cellIdx);
        }
      }, {
        key: "getCellContainer",
        value: function getCellContainer(cellIdx) {
          var table = this.childrenMap.child;
          return table.getCellContainer(cellIdx);
        }
      }, {
        key: "updateVisibleCell",
        value: function updateVisibleCell(cellIdx) {
          var table = this.childrenMap.child;
          return table.updateVisibleCell(cellIdx);
        }
      }, {
        key: "onPostStep",
        value: function onPostStep() {
          if (this.resizeControllerFlag) {
            this.resizeController();
            this.resizeControllerFlag = false;
          }
        }
      }, {
        key: "startRowIndex",
        get: function get() {
          var table = this.childrenMap.child;
          return table.startRowIndex;
        }
      }]);
      return GridTable;
    }(Scrollable);
    var methods$d = {
      setItems: SetItems
    };
    Object.assign(GridTable.prototype, ScrollMethods$1, methods$d);
  
    ObjectFactory.register('gridTable', function (config) {
      var gameObject = new GridTable(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.GridTable', GridTable);
  
    var GetEaseConfig = function GetEaseConfig(easeConfig, menu) {
      if (easeConfig.sameOrientation) {
        easeConfig.orientation = menu.orientation;
      } else {
        easeConfig.orientation = menu.orientation === 0 ? 1 : 0;
      }
      return easeConfig;
    };
  
    var PopUp = function PopUp(menu, duration) {
      menu.popUp(GetEaseConfig(menu.root.easeIn, menu));
    };
    var ScaleDown$1 = function ScaleDown(menu, duration) {
      // Don't destroy here
      menu.scaleDown(GetEaseConfig(menu.root.easeOut, menu));
    };
    var SetTransitCallbackMethods = {
      setTransitInCallback: function setTransitInCallback(callback) {
        if (callback === undefined) {
          callback = PopUp;
        }
        this.transitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setTransitOutCallback: function setTransitOutCallback(callback) {
        if (callback === undefined) {
          callback = ScaleDown$1;
        }
        this.transitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      }
    };
  
    var PostUpdateDelayCall = function PostUpdateDelayCall(gameObject, delay, callback, scope, args) {
      // Invoke callback under scene's 'postupdate' event
      var scene = GetSceneObject(gameObject);
      var timer = scene.time.delayedCall(delay, function () {
        scene.sys.events.once('postupdate', function () {
          callback.call(scope, args);
        });
      });
      return timer;
    };
  
    var DelayCallMethods = {
      delayCall: function delayCall(delay, callback, scope) {
        // Invoke callback under scene's 'postupdate' event
        this.timer = PostUpdateDelayCall(this, delay, callback, scope);
        return this;
      },
      removeDelayCall: function removeDelayCall() {
        if (this.timer) {
          this.timer.remove(false);
          this.timer = undefined;
        }
        return this;
      }
    };
  
    var ExpandSubMenu = function ExpandSubMenu(parentButton, items) {
      var subMenu = this.childrenMap.subMenu;
      // Submenu already expand
      if (subMenu && subMenu.parentButton === parentButton) {
        return this;
      }
      this.collapseSubMenu();
      var orientation;
      if (this.root.toggleOrientation) {
        orientation = this.orientation === 0 ? 1 : 0;
      } else {
        orientation = this.orientation;
      }
      var subMenu = new this.constructor(this.scene, {
        items: items,
        orientation: orientation,
        space: this.space,
        createBackgroundCallback: this.root.createBackgroundCallback,
        createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
        createButtonCallback: this.root.createButtonCallback,
        createButtonCallbackScope: this.root.createButtonCallbackScope,
        easeIn: this.root.easeIn,
        easeOut: this.root.easeOut,
        _rootMenu: this.root,
        _parentMenu: this,
        _parentButton: parentButton
      });
      this.pin(subMenu);
      this.childrenMap.subMenu = subMenu;
      this.root.emit('expand', subMenu, parentButton, this);
      return this;
    };
  
    var Collapse = function Collapse() {
      var root = this.root;
      root.emit('collapse', this, this.parentButton, root);
      var duration = root.easeOut.duration;
      // Don't destroy under transitOutCallback
      root.transitOutCallback(this, duration);
      this.collapseSubMenu();
  
      // Destroy by delayCall
      this.delayCall(duration, this.destroy, this);
      return this;
    };
  
    var CollapseSubMenu = function CollapseSubMenu() {
      var subMenu = this.childrenMap.subMenu;
      if (subMenu === undefined) {
        return this;
      }
      this.childrenMap.subMenu = undefined;
      this.remove(subMenu);
      subMenu.collapse();
      return this;
    };
  
    var Methods$4 = {
      expandSubMenu: ExpandSubMenu,
      collapse: Collapse,
      collapseSubMenu: CollapseSubMenu
    };
    Object.assign(Methods$4, SetTransitCallbackMethods, DelayCallMethods);
  
    var CreateBackground$1 = function CreateBackground(scene, items, callback, scope) {
      var background;
      if (callback) {
        items.scene = scene;
        if (scope) {
          background = callback.call(scope, items);
        } else {
          background = callback(items);
        }
        items.scene = undefined;
      }
      return background;
    };
  
    var CreateButtons$3 = function CreateButtons(scene, items, callback, scope) {
      var item;
      var buttons = [],
        button;
      if (items && callback) {
        for (var i = 0, cnt = items.length; i < cnt; i++) {
          item = items[i];
          item.scene = scene;
          if (scope) {
            button = callback.call(scope, item, i, items);
          } else {
            button = callback(item, i, items);
          }
          item.scene = undefined;
          buttons.push(button);
        }
      }
      return buttons;
    };
  
    var MenuSetInteractive = function MenuSetInteractive(menu) {
      menu
      // Expand sub event
      .on(menu.root.expandEventName, function (button, index) {
        if (this._isPassedEvent) {
          return;
        }
        var childrenKey = this.root.childrenKey;
        var subItems = this.items[index][childrenKey];
        if (subItems) {
          this.expandSubMenu(button, subItems);
        }
      }, menu)
      // Click any button
      .on('button.click', function (button, index, pointer, event) {
        // Pass event to root menu object
        if (this !== this.root) {
          this.root._isPassedEvent = true;
          this.root.emit('button.click', button, index, pointer, event);
          this.root._isPassedEvent = false;
        }
      }, menu)
      //Pointer over any button
      .on('button.over', function (button, index, pointer, event) {
        // Pass event to root menu object
        if (this !== this.root) {
          this.root._isPassedEvent = true;
          this.root.emit('button.over', button, index, pointer, event);
          this.root._isPassedEvent = false;
        }
      }, menu)
      //Pointer out any button
      .on('button.out', function (button, index, pointer, event) {
        // Pass event to root menu object
        if (this !== this.root) {
          this.root._isPassedEvent = true;
          this.root.emit('button.out', button, index, pointer, event);
          this.root._isPassedEvent = false;
        }
      }, menu);
    };
  
    var ParseEaseConfig = function ParseEaseConfig(menu, easeConfig) {
      if (typeof easeConfig === 'number') {
        easeConfig = {
          duration: easeConfig
        };
      }
      if (easeConfig.hasOwnProperty('orientation') && easeConfig.orientation !== undefined) {
        easeConfig.sameOrientation = GetOrientationMode(easeConfig.orientation) === menu.orientation;
      } else {
        easeConfig.sameOrientation = true;
      }
      easeConfig.destroy = false;
      return easeConfig;
    };
  
    var Expand = function Expand() {
      var root = this.root;
      var duration = root.easeIn.duration;
      // Ease in menu
      root.transitInCallback(this, duration);
      if (this !== this.root) {
        this.delayCall(duration, function () {
          // Pass event to root menu object
          this.root.emit('popup.complete', this);
        }, this);
      }
    };
  
    var GetValue$_ = Phaser.Utils.Objects.GetValue;
    var Menu = /*#__PURE__*/function (_Buttons) {
      _inherits(Menu, _Buttons);
      function Menu(scene, config) {
        var _this;
        _classCallCheck(this, Menu);
        if (config === undefined) {
          config = {};
        }
  
        // Orientation
        if (!config.hasOwnProperty('orientation')) {
          config.orientation = 1; // y
        }
  
        // Parent
        var rootMenu = config._rootMenu;
        var parentMenu = config._parentMenu;
        var parentButton = config._parentButton;
        // Popup, root menu can be static, sub-menus are always popup.
        var popUp = GetValue$_(config, 'popup', true);
        // Items
        var items = GetValue$_(config, 'items', undefined);
        // Background
        var createBackgroundCallback = GetValue$_(config, 'createBackgroundCallback', undefined);
        var createBackgroundCallbackScope = GetValue$_(config, 'createBackgroundCallbackScope', undefined);
        config.background = CreateBackground$1(scene, items, createBackgroundCallback, createBackgroundCallbackScope);
        // Buttons
        var createButtonCallback = GetValue$_(config, 'createButtonCallback', undefined);
        var createButtonCallbackScope = GetValue$_(config, 'createButtonCallbackScope', undefined);
        config.buttons = CreateButtons$3(scene, items, createButtonCallback, createButtonCallbackScope);
        _this = _callSuper(this, Menu, [scene, config]);
        _this.type = 'rexMenu';
        _this.items = items;
        _this.root = rootMenu === undefined ? _assertThisInitialized(_this) : rootMenu;
        _this.isRoot = _this.root === _assertThisInitialized(_this);
        _this.parentMenu = parentMenu;
        _this.parentButton = parentButton;
        _this.timer = undefined;
  
        // Root menu
        if (_this.isRoot) {
          _this.isPopUpMode = popUp;
          // Bounds
          var bounds = config.bounds;
          if (bounds === undefined) {
            bounds = GetViewport(scene);
          }
          _this.bounds = bounds;
  
          // Side of submenu
          _this.subMenuSide = [_this.y < bounds.centerY ? SUBMENU_DOWN : SUBMENU_UP, _this.x < bounds.centerX ? SUBMENU_RIGHT : SUBMENU_LEFT];
          // Overwrite subMenuSide value if given
          var subMenuSide = GetValue$_(config, 'subMenuSide', undefined);
          if (subMenuSide !== undefined) {
            if (typeof subMenuSide === 'string') {
              subMenuSide = SubMenuSideMode[subMenuSide];
            }
            _this.subMenuSide[_this.orientation] = subMenuSide;
          }
          // ToggleOrientation mode
          _this.toggleOrientation = GetValue$_(config, 'toggleOrientation', false);
          // Expand mode
          _this.expandEventName = GetValue$_(config, 'expandEvent', 'button.click');
          // Transition
          _this.easeIn = ParseEaseConfig(_assertThisInitialized(_this), GetValue$_(config, 'easeIn', 0));
          _this.easeOut = ParseEaseConfig(_assertThisInitialized(_this), GetValue$_(config, 'easeOut', 0));
          _this.setTransitInCallback(GetValue$_(config, 'transitIn'));
          _this.setTransitOutCallback(GetValue$_(config, 'transitOut'));
          // Callbacks
          _this.createBackgroundCallback = createBackgroundCallback;
          _this.createBackgroundCallbackScope = createBackgroundCallbackScope;
          _this.createButtonCallback = createButtonCallback;
          _this.createButtonCallbackScope = createButtonCallbackScope;
          // Children key
          _this.childrenKey = GetValue$_(config, 'childrenKey', 'children');
          // Event flag
          _this._isPassedEvent = false;
  
          // pointerdown-outside-collapse
          _this.pointerDownOutsideCollapsing = GetValue$_(config, 'pointerDownOutsideCollapsing', true);
          if (_this.pointerDownOutsideCollapsing) {
            scene.input.on('pointerdown', _this.onPointerDownOutside, _assertThisInitialized(_this));
          }
        }
        var originX = 0,
          originY = 0;
        if (!_this.root.easeIn.sameOrientation) {
          var easeOrientation = GetEaseConfig(_this.root.easeIn, _assertThisInitialized(_this)).orientation;
          var menuOrientation = parentMenu ? parentMenu.orientation : _this.orientation;
          var subMenuSide = _this.root.subMenuSide[menuOrientation];
          if (easeOrientation === 0 && subMenuSide === SUBMENU_LEFT) {
            originX = 1;
          }
          if (easeOrientation === 1 && subMenuSide === SUBMENU_UP) {
            originY = 1;
          }
        }
        if (popUp) {
          _this.setOrigin(originX, originY).layout();
        }
  
        // Sub-menu: 
        // - scale to root's scale value
        // - align to parent button
        if (!_this.isRoot) {
          _this.setScale(_this.root.scaleX, _this.root.scaleY);
          var subMenuSide = _this.root.subMenuSide[parentMenu.orientation];
          switch (subMenuSide) {
            case SUBMENU_LEFT:
              //Put submene at left side
              _this.alignTop(parentButton.top).alignRight(parentButton.left);
              break;
            case SUBMENU_RIGHT:
              //Put submene at right side
              _this.alignTop(parentButton.top).alignLeft(parentButton.right);
              break;
            case SUBMENU_UP:
              //Put submene at up side
              _this.alignLeft(parentButton.left).alignBottom(parentButton.top);
              break;
            case SUBMENU_DOWN:
              //Put submene at down side
              _this.alignLeft(parentButton.left).alignTop(parentButton.bottom);
              break;
          }
        }
        MenuSetInteractive(_assertThisInitialized(_this));
        if (popUp) {
          _this.pushIntoBounds(_this.root.bounds);
  
          // Expand this menu
          Expand.call(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Menu, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (this.isRoot && this.pointerDownOutsideCollapsing) {
            this.scene.input.off('pointerdown', this.onPointerDownOutside, this);
          }
          _get(_getPrototypeOf(Menu.prototype), "destroy", this).call(this, fromScene);
          this.removeDelayCall();
        }
      }, {
        key: "isInTouching",
        value: function isInTouching(pointer) {
          if (_get(_getPrototypeOf(Menu.prototype), "isInTouching", this).call(this, pointer)) {
            return true;
          } else if (this.childrenMap.subMenu) {
            return this.childrenMap.subMenu.isInTouching(pointer);
          } else {
            return false;
          }
        }
      }, {
        key: "onPointerDownOutside",
        value: function onPointerDownOutside(pointer) {
          if (this.isInTouching(pointer)) {
            return;
          }
          if (this.isPopUpMode) {
            this.collapse();
          } else {
            this.collapseSubMenu();
          }
        }
      }]);
      return Menu;
    }(Buttons$1);
    var SUBMENU_LEFT = 2;
    var SUBMENU_RIGHT = 0;
    var SUBMENU_UP = 3;
    var SUBMENU_DOWN = 1;
    var SubMenuSideMode = {
      up: SUBMENU_UP,
      down: SUBMENU_DOWN,
      left: SUBMENU_LEFT,
      right: SUBMENU_RIGHT
    };
    Object.assign(Menu.prototype, Methods$4);
  
    ObjectFactory.register('menu', function (config) {
      var gameObject = new Menu(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Menu', Menu);
  
    var methods$c = {
      setWrapEnable: function setWrapEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.listWrapEnable = enable;
        return this;
      },
      setCreateButtonCallback: function setCreateButtonCallback(callback) {
        this.listCreateButtonCallback = callback;
        return this;
      },
      setCreateListBackgroundCallback: function setCreateListBackgroundCallback(callback) {
        this.listCreateBackgroundCallback = callback;
        return this;
      },
      setButtonClickCallback: function setButtonClickCallback(callback) {
        this.listOnButtonClick = callback;
        return this;
      },
      setButtonOverCallback: function setButtonOverCallback(callback) {
        this.listOnButtonOver = callback;
        return this;
      },
      setButtonOutCallback: function setButtonOutCallback(callback) {
        this.listOnButtonOut = callback;
        return this;
      },
      setListExpandDirection: function setListExpandDirection(direction) {
        if (typeof direction === 'string') {
          direction = ListExpandDirections[direction];
        }
        this.listExpandDirection = direction;
        return this;
      },
      setListEaseInDuration: function setListEaseInDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.listEaseInDuration = duration;
        return this;
      },
      setListEaseOutDuration: function setListEaseOutDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.listEaseOutDuration = duration;
        return this;
      },
      setListTransitInCallback: function setListTransitInCallback(callback) {
        this.listTransitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      settListTransitOutCallback: function settListTransitOutCallback(callback) {
        this.listTransitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setListBounds: function setListBounds(bounds) {
        this.listBounds = bounds;
        return this;
      },
      setListWidth: function setListWidth(width) {
        this.listWidth = width;
        return this;
      },
      setListHeight: function setListHeight(height) {
        this.listHeight = height;
        return this;
      },
      setListSize: function setListSize(width, height) {
        this.setListWidth(width).setListHeight(height);
        return this;
      },
      setListAlignmentMode: function setListAlignmentMode(mode) {
        this.listAlignMode = mode;
        return this;
      },
      setListAlignmentSide: function setListAlignmentSide(side) {
        if (side === undefined) {
          side = '';
        }
        this.listAlignSide = side;
        return this;
      },
      setListSpace: function setListSpace(space) {
        if (space === undefined) {
          space = {};
        }
        this.listSpace = space;
        return this;
      },
      setListDraggable: function setListDraggable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.listDraggable = enable;
        return this;
      }
    };
    var ListExpandDirections = {
      down: 0,
      up: 1
    };
  
    var CreateListPanel = function CreateListPanel() {
      var scene = this.scene;
      var background;
      var createBackgroundCallback = this.listCreateBackgroundCallback;
      if (createBackgroundCallback) {
        background = createBackgroundCallback.call(this, scene);
        scene.add.existing(background);
      }
      var buttons = [];
      var createButtonCallback = this.listCreateButtonCallback;
      if (createButtonCallback) {
        var options = this.options;
        for (var i = 0, cnt = options.length; i < cnt; i++) {
          var button = createButtonCallback.call(this, scene, options[i], i, options);
          if (!button) {
            continue;
          }
          scene.add.existing(button);
          buttons.push(button);
        }
      }
      var width = this.listWidth;
      if (width === undefined) {
        if (this.listAlignMode === 'text') {
          width = this.getElement('text').width;
        } else {
          width = this.width;
        }
      }
      var height = this.listHeight;
      var listPanel;
      if (!this.listWrapEnable) {
        listPanel = new Buttons$1(scene, {
          width: width,
          height: height,
          orientation: 'y',
          background: background,
          buttons: buttons,
          space: this.listSpace,
          draggable: this.listDraggable
        });
      } else {
        listPanel = new Buttons(scene, {
          width: width,
          height: height,
          background: background,
          buttons: buttons,
          space: this.listSpace,
          draggable: this.listDraggable
        });
      }
      scene.add.existing(listPanel);
      return listPanel;
    };
  
    var ScaleDown = function ScaleDown(gameObject, duration, orientation, ease, scale) {
      if (ease === undefined) {
        ease = 'Linear';
      }
      var config = {};
      config.mode = 0;
      switch (orientation) {
        case 0:
        case 'x':
          config.end = {
            x: 0
          };
          break;
        case 1:
        case 'y':
          config.end = {
            y: 0
          };
          break;
        default:
          config.end = 0;
          break;
      }
      config.duration = duration;
      config.ease = ease;
      if (scale === undefined) {
        scale = new Scale(gameObject, config);
      } else {
        scale.resetFromJSON(config);
      }
      scale.restart();
      return scale;
    };
  
    var GetValueFromAliasKeys = function GetValueFromAliasKeys(source, key0, key1, key2, defaultValue) {
      if (HasValue(source, key0)) {
        return GetValue$3G(source, key0);
      } else if (key1 && HasValue(source, key1)) {
        return GetValue$3G(source, key1);
      } else if (key2 && HasValue(source, key2)) {
        return GetValue$3G(source, key2);
      } else {
        return defaultValue;
      }
    };
  
    var GetValue$Z = Phaser.Utils.Objects.GetValue;
    var SetPosition = function SetPosition(gameObject, config) {
      var expandDirection = GetValue$Z(config, 'expandDirection', undefined);
      if (typeof expandDirection === 'string') {
        expandDirection = ExpandDirections[expandDirection];
      }
      var alignTargetX = GetValueFromAliasKeys(config, 'alignTarget', 'alignTargetX');
      var alignTargetY = GetValue$Z(config, 'alignTargetY', alignTargetX);
      var alignOffsetX = GetValue$Z(config, 'alignOffsetX', 0);
      var alignOffsetY = GetValue$Z(config, 'alignOffsetY', 0);
      var alignSide = GetValue$Z(config, 'alignSide', '');
      var alignRight = alignSide.includes('right');
      var positionBounds = GetValue$Z(config, 'bounds');
  
      // Expand direction
      var isExpandDown = expandDirection === 0;
      var isExpandUp = expandDirection === 1;
      var flexExpand = !isExpandDown && !isExpandUp;
      var originX = alignRight ? 1 : 0;
      var originY = isExpandDown || flexExpand ? 0 : 1;
      gameObject.setOrigin(originX, originY);
      var x, y;
      if (alignRight) {
        x = alignTargetX.getTopRight().x;
      } else {
        x = alignTargetX.getTopLeft().x;
      }
      y = alignTargetY.getBottomLeft().y;
      gameObject.setPosition(x + alignOffsetX, y + alignOffsetY);
      var bounds = positionBounds;
      if (!bounds) {
        bounds = GetViewport(gameObject.scene);
      }
      if (flexExpand && gameObject.getBottomLeft().y > bounds.bottom) {
        // Out of bounds, can't put list-panel below parent
        y = alignTargetY.getTopLeft().y;
        gameObject.setOrigin(0, 1).setPosition(x + alignOffsetX, y + alignOffsetY);
      }
    };
    var ExpandDirections = {
      down: 0,
      up: 1
    };
  
    var GetValue$Y = Phaser.Utils.Objects.GetValue;
    var DropDown = /*#__PURE__*/function (_OpenCloseTransition) {
      _inherits(DropDown, _OpenCloseTransition);
      function DropDown(gameObject, config) {
        var _this;
        _classCallCheck(this, DropDown);
        if (config === undefined) {
          config = {};
        }
        if (config.transitIn == null) {
          config.transitIn = function (gameObject, duration) {
            PopUp$1(gameObject, duration, 'y', 'Cubic');
          };
        }
        if (config.transitOut == null) {
          config.transitOut = function (gameObject, duration) {
            // Don't destroy here
            ScaleDown(gameObject, duration, 'y', 'Linear');
          };
        }
        config.manualClose = true;
        config.clickOutsideClose = true;
        config.destroy = true;
        _this = _callSuper(this, DropDown, [gameObject, config]);
        // this.parent = gameObject;
        // this.scene
  
        SetPosition(gameObject, config);
        if (gameObject.isRexSizer) {
          gameObject.layout();
        }
  
        // Close conditions:
        var touchOutsideClose = GetValue$Y(config, 'touchOutsideClose', false);
        var anyTouchClose = GetValue$Y(config, 'anyTouchClose', false);
        if (anyTouchClose) {
          touchOutsideClose = false;
        }
  
        // Registet touch-close event after opened
        if (anyTouchClose) {
          _this.once('open', _this.anyTouchClose, _assertThisInitialized(_this));
        } else if (touchOutsideClose) {
          _this.once('open', _this.touchOutsideClose, _assertThisInitialized(_this));
        }
        _this.requestOpen();
        return _this;
      }
      _createClass(DropDown, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // Registered in touchOutsideClose()
          this.scene.input.off('pointerup', this.touchCloseCallback, this);
          _get(_getPrototypeOf(DropDown.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "touchOutsideClose",
        value: function touchOutsideClose() {
          this.scene.input.on('pointerup', this.touchCloseCallback, this);
          this.clickOutsideTest = true;
          return this;
        }
      }, {
        key: "anyTouchClose",
        value: function anyTouchClose() {
          this.scene.input.once('pointerup', this.touchCloseCallback, this);
          return this;
        }
      }, {
        key: "touchCloseCallback",
        value: function touchCloseCallback(pointer) {
          if (this.clickOutsideTest && IsPointInBounds(this.parent, pointer.worldX, pointer.worldY)) {
            return;
          }
          this.requestClose();
        }
      }, {
        key: "onOpen",
        value: function onOpen() {
          this.emit('open', this.parent, this);
          _get(_getPrototypeOf(DropDown.prototype), "onOpen", this).call(this);
        }
      }, {
        key: "onClose",
        value: function onClose() {
          this.emit('close', this.parent, this);
          _get(_getPrototypeOf(DropDown.prototype), "onClose", this).call(this);
        }
      }]);
      return DropDown;
    }(OpenCloseTransition);
  
    var OpenListPanel = function OpenListPanel() {
      if (this.listPanel) {
        return this;
      }
      var listPanel = CreateListPanel.call(this);
  
      // Button over/out
      listPanel.on('button.over', function (button, index, pointer, event) {
        this.currentOverIndex = index;
        if (this.listOnButtonOver) {
          this.listOnButtonOver.call(this, button, index, pointer, event);
        }
        this.emit('button.over', this, listPanel, button, index, pointer, event);
      }, this).on('button.out', function (button, index, pointer, event) {
        if (this.currentOverIndex === index) {
          this.currentOverIndex = undefined;
        }
        if (this.listOnButtonOut) {
          this.listOnButtonOut.call(this, button, index, pointer, event);
        }
        this.emit('button.out', this, listPanel, button, index, pointer, event);
      }, this);
      var alignTargetX;
      if (!this.listAlignMode || this.listAlignMode === 'label') {
        alignTargetX = this;
      } else {
        alignTargetX = this.getElement(this.listAlignMode);
      }
      var dropDownBehavior = new DropDown(listPanel, {
        // Transition
        duration: {
          "in": this.listEaseInDuration,
          out: this.listEaseOutDuration
        },
        transitIn: this.listTransitInCallback,
        transitOut: this.listTransitOutCallback,
        // Position
        expandDirection: this.listExpandDirection,
        alignTargetX: alignTargetX,
        alignTargetY: this,
        alignSide: this.listAlignSide,
        bounds: this.listBounds,
        // Close condition
        anyTouchClose: true
      }).on('open', function () {
        // After popping up
        // Can click
        listPanel.on('button.click', function (button, index, pointer, event) {
          if (this.listOnButtonClick) {
            this.listOnButtonClick.call(this, button, index, pointer, event);
          }
          this.emit('button.click', this, listPanel, button, index, pointer, event);
        }, this);
        this.emit('list.open', this, listPanel);
      }, this).on('close', function () {
        this.listPanel = undefined;
        this.dropDownBehavior = undefined;
        this.emit('list.close', this);
      }, this);
      this.listPanel = listPanel;
      this.dropDownBehavior = dropDownBehavior;
      this.pin(listPanel);
      return this;
    };
  
    var CloseListPanel = function CloseListPanel() {
      if (!this.dropDownBehavior) {
        return this;
      }
      this.dropDownBehavior.requestClose();
      this.currentOverIndex = undefined;
      return this;
    };
  
    var ToggleListPanel = function ToggleListPanel() {
      if (!this.listPanel) {
        this.openListPanel();
      } else {
        this.closeListPanel();
      }
      return this;
    };
  
    var EmitListButtonClick = function EmitListButtonClick(index) {
      if (index === undefined) {
        index = this.currentOverIndex;
      }
      if (index === undefined) {
        return this;
      }
      var listPanel = this.listPanel;
  
      // Use option if listPanel is not created.
      var button = listPanel ? listPanel.getButton(index) : this.options[index];
      if (this.listOnButtonClick) {
        this.listOnButtonClick.call(this, button, index);
      }
      this.emit('button.click', this, listPanel, button, index);
      return this;
    };
  
    var EmitButtonOver = function EmitButtonOver(index) {
      var listPanel = this.listPanel;
      if (!listPanel) {
        return this;
      }
      listPanel.emitButtonOver(index);
      return this;
    };
  
    var FocusButtonMethods = {
      focusNextButton: function focusNextButton() {
        if (!this.isOpened) {
          return this;
        }
        var currentIndex = this.currentOverIndex;
        var nextIndex;
        if (currentIndex === undefined) {
          nextIndex = 0;
        } else {
          var total = this.listPanel.getButtons().length;
          nextIndex = (currentIndex + 1) % total;
        }
        this.emitButtonOver(nextIndex);
        return this;
      },
      focusPrevButton: function focusPrevButton() {
        if (!this.isOpened) {
          return this;
        }
        var currentIndex = this.currentOverIndex;
        var nextIndex;
        if (currentIndex === undefined) {
          nextIndex = 0;
        } else {
          var total = this.listPanel.getButtons().length;
          nextIndex = (currentIndex - 1 + total) % total;
        }
        this.emitButtonOver(nextIndex);
        return this;
      }
    };
  
    var Methods$3 = {
      openListPanel: OpenListPanel,
      closeListPanel: CloseListPanel,
      toggleListPanel: ToggleListPanel,
      emitButtonClick: EmitListButtonClick,
      emitButtonOver: EmitButtonOver
    };
    Object.assign(Methods$3, methods$c, FocusButtonMethods);
  
    var GetValue$X = Phaser.Utils.Objects.GetValue;
    var DropDownList = /*#__PURE__*/function (_Label) {
      _inherits(DropDownList, _Label);
      function DropDownList(scene, config) {
        var _this;
        _classCallCheck(this, DropDownList);
        _this = _callSuper(this, DropDownList, [scene, config]);
        _this.type = 'rexDropDownList';
        _this.timer = undefined;
        _this.listPanel = undefined;
        _this.currentOverIndex = undefined;
        _this.setOptions(GetValue$X(config, 'options'));
        var listConfig = GetValue$X(config, 'list');
        _this.setWrapEnable(GetValue$X(listConfig, 'wrap', false));
        _this.setCreateButtonCallback(GetValue$X(listConfig, 'createButtonCallback'));
        _this.setCreateListBackgroundCallback(GetValue$X(listConfig, 'createBackgroundCallback'));
        _this.setButtonClickCallback(GetValue$X(listConfig, 'onButtonClick'));
        _this.setButtonOverCallback(GetValue$X(listConfig, 'onButtonOver'));
        _this.setButtonOutCallback(GetValue$X(listConfig, 'onButtonOut'));
        _this.setListExpandDirection(GetValue$X(listConfig, 'expandDirection'));
        _this.setListEaseInDuration(GetValue$X(listConfig, 'easeIn', 500));
        _this.setListEaseOutDuration(GetValue$X(listConfig, 'easeOut', 100));
        _this.setListTransitInCallback(GetValue$X(listConfig, 'transitIn'));
        _this.settListTransitOutCallback(GetValue$X(listConfig, 'transitOut'));
        _this.setListSize(GetValue$X(listConfig, 'width'), GetValue$X(listConfig, 'height'));
        _this.setListAlignmentMode(GetValue$X(listConfig, 'alignParent', 'text'));
        _this.setListAlignmentSide(GetValue$X(listConfig, 'alignSide', ''));
        _this.setListBounds(GetValue$X(listConfig, 'bounds'));
        _this.setListSpace(GetValue$X(listConfig, 'space'));
        _this.setListDraggable(GetValue$X(listConfig, 'draggable', false));
        _this.setValueChangeCallback(GetValue$X(config, 'setValueCallback'), GetValue$X(config, 'setValueCallbackScope'));
        _this.setValue(GetValue$X(config, 'value'));
        _this.onClick(_this.toggleListPanel, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(DropDownList, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          if (this.listPanel) {
            this.listPanel.destroy(fromScene);
            this.listPanel = undefined;
          }
          _get(_getPrototypeOf(DropDownList.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "isOpened",
        get: function get() {
          return !!this.listPanel;
        }
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          if (options === undefined) {
            options = [];
          }
          this.options = options;
          return this;
        }
      }, {
        key: "setValueChangeCallback",
        value: function setValueChangeCallback(callback, scope) {
          this.valueChangeCallback = callback;
          this.valueChangeCallbackScope = scope;
          return this;
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (this._value === value) {
            return;
          }
          var previousValue = this._value;
          this._value = value;
          var callback = this.valueChangeCallback,
            scope = this.valueChangeCallbackScope;
          if (callback) {
            if (scope) {
              callback.call(scope, this, value, previousValue);
            } else {
              callback(this, value, previousValue);
            }
          }
          this.emit('valuechange', this, value, previousValue);
        }
      }]);
      return DropDownList;
    }(Label);
    Object.assign(DropDownList.prototype, Methods$3);
  
    ObjectFactory.register('dropDownList', function (config) {
      var gameObject = new DropDownList(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.DropDownList', DropDownList);
  
    var BuildListConfig = function BuildListConfig(scene, config, creators) {
      config = config ? DeepClone(config) : {};
      if (creators === undefined) {
        creators = {};
      }
      var labelConfig = config.label || config.button;
      var listButtonConfig = config.button || config.label;
      delete config.label;
      delete config.button;
      var labelCreator = creators.label || creators.button || creators;
      var listButtonCreator = creators.button || creators.label || creators;
      var listConfig = BuildLabelConfig(scene, labelConfig, labelCreator);
      listConfig.list = config.list || {};
      listConfig.list.createButtonCallback = function (scene, option) {
        var gameObject = CreateLabel(scene, listButtonConfig, listButtonCreator).resetDisplayContent(option);
        if (option.hasOwnProperty('value')) {
          gameObject.value = option.value;
        }
        return gameObject;
      };
      listConfig.list.onButtonOver = function (button, index, pointer, event) {
        if (button.setHoverState) {
          button.setHoverState(true);
        }
      };
      listConfig.list.onButtonOut = function (button, index, pointer, event) {
        if (button.setHoverState) {
          button.setHoverState(false);
        }
      };
      return listConfig;
    };
  
    var SimpleDropDownList = /*#__PURE__*/function (_DropDownList) {
      _inherits(SimpleDropDownList, _DropDownList);
      function SimpleDropDownList(scene, config, creators) {
        var _this;
        _classCallCheck(this, SimpleDropDownList);
        config = BuildListConfig(scene, config, creators);
        _this = _callSuper(this, SimpleDropDownList, [scene, config]);
        _this.type = 'rexSimpleDropDownList';
        return _this;
      }
      _createClass(SimpleDropDownList, [{
        key: "setOptions",
        value: function setOptions(options) {
          if (options === undefined) {
            options = [];
          }
          for (var i = 0, cnt = options.length; i < cnt; i++) {
            var option = options[i];
            if (typeof option === 'string') {
              options[i] = {
                text: option,
                value: option
              };
            }
          }
          _get(_getPrototypeOf(SimpleDropDownList.prototype), "setOptions", this).call(this, options);
          return this;
        }
      }]);
      return SimpleDropDownList;
    }(DropDownList);
  
    ObjectFactory.register('simpleDropDownList', function (config, creators) {
      var gameObject = new SimpleDropDownList(this.scene, config, creators);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.SimpleDropDownList', SimpleDropDownList);
  
    var TextHeightToLinesCount = function TextHeightToLinesCount(textObject) {
      var textObjectType = GetTextObjectType(textObject);
      var height, lineSpacing, lineHeight;
      switch (textObjectType) {
        case TextType:
        case TagTextType:
          height = textObject.height - textObject.padding.top - textObject.padding.bottom;
          lineSpacing = textObject.lineSpacing;
          lineHeight = textObject.style.metrics.fontSize + textObject.style.strokeThickness;
          break;
        case BitmapTextType:
          height = textObject.height;
          lineSpacing = 0;
          var scale = textObject.fontSize / textObject.fontData.size;
          lineHeight = textObject.fontData.lineHeight * scale;
          break;
      }
  
      // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
      return (height - lineSpacing) / (lineHeight + lineSpacing);
    };
  
    var GetLines = function GetLines(startLineIndex, endLineIdx) {
      if (startLineIndex === undefined) {
        startLineIndex = this.startLineIndex;
      }
      if (endLineIdx === undefined) {
        var pageLinesCount = this.pageLinesCount;
        if (pageLinesCount > 0) {
          endLineIdx = startLineIndex + pageLinesCount;
        } else {
          endLineIdx = this.totalLinesCount;
        }
      }
      if (endLineIdx > this.totalLinesCount) {
        endLineIdx = this.totalLinesCount;
      }
      var text;
      switch (this.textObjectType) {
        case TextType:
        case BitmapTextType:
          text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
          break;
        case TagTextType:
          var startIdx = this.lines.getLineStartIndex(startLineIndex);
          var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
          text = this.lines.getSliceTagText(startIdx, endIdx, true);
  
          // Check line count
          var newLineCharCount = (text.match(/\n/g) || []).length;
          if (newLineCharCount > endLineIdx - startLineIndex - 1) {
            // Remove last '\n'
            text = text.substring(0, text.length - 1);
          }
          break;
      }
      return text;
    };
  
    var GetString = function GetString(text) {
      if (Array.isArray(text)) {
        text = text.join('\n');
      } else if (typeof text === 'number') {
        text = text.toString();
      }
      return text;
    };
    var SetContentMethods = {
      clearText: function clearText() {
        this.sections.length = 0;
        this.pageStartIndexes.length = 0;
        this.lines.length = 0;
        return this;
      },
      appendPage: function appendPage(text) {
        var pageStartIndex = this.totalLinesCount;
        this.sections.push(GetString(text));
        var text = this.sections.join('\n');
        this.lines = TextToLines(this.parent, text, this.lines);
        var newLinesCount = this.totalLinesCount - pageStartIndex;
        var pageLinesCount = this.pageLinesCount;
        var pageCount;
        if (pageLinesCount > 0) {
          pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
        } else {
          // Height of Text object might be 0
          pageCount = 1;
        }
        for (var i = 0; i < pageCount; i++) {
          this.pageStartIndexes.push(pageStartIndex + i * this.pageLinesCount);
        }
        return this;
      },
      setText: function setText(text, resetIndex) {
        if (resetIndex === undefined) {
          resetIndex = true;
        }
        if (resetIndex) {
          this.resetIndex();
        }
        this.clearText();
        var sections = GetString(text).split(this.pageBreak);
        // if (sections[sections.length - 1] === '') { // Last section is an empty string
        //     sections.length -= 1;
        // }
  
        for (var i = 0, cnt = sections.length; i < cnt; i++) {
          this.appendPage(sections[i]);
        }
        return this;
      },
      appendText: function appendText(text) {
        var content = this.content + GetString(text);
        this.setText(content, false);
        return this;
      }
    };
  
    var Clamp$3 = Phaser.Math.Clamp;
    var GetPageMethods = {
      resetIndex: function resetIndex() {
        this.pageIndex = -1;
        this.startLineIndex = -1;
        this.endLineIndex = undefined;
        return this;
      },
      setPageIndex: function setPageIndex(idx) {
        idx = Clamp$3(idx, 0, this.lastPageIndex);
        this.pageIndex = idx;
        this.startLineIndex = this.pageStartIndexes[idx];
        this.endLineIndex = this.pageStartIndexes[idx + 1];
        return this;
      },
      getPage: function getPage(idx) {
        if (idx === undefined) {
          idx = this.pageIndex;
        }
        return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
      },
      getNextPage: function getNextPage() {
        return this.getPage(this.pageIndex + 1);
      },
      getPreviousPage: function getPreviousPage() {
        return this.getPage(this.pageIndex - 1);
      },
      getFirstPage: function getFirstPage() {
        return this.getPage(0);
      },
      getLastPage: function getLastPage() {
        return this.getPage(this.lastPageIndex);
      },
      setStartLineIndex: function setStartLineIndex(idx) {
        var lastStartLineIndex = Math.max(this.totalLinesCount - this.pageLinesCount, 0);
        idx = Clamp$3(idx, 0, lastStartLineIndex);
        this.startLineIndex = idx;
        this.endLineIndex = idx + this.pageLinesCount;
        return this;
      },
      getPageByLineIndex: function getPageByLineIndex(idx) {
        return this.setStartLineIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
      },
      getPageOfNextLine: function getPageOfNextLine() {
        return this.getPageByLineIndex(this.startLineIndex + 1);
      },
      getPageOfPreviousLine: function getPageOfPreviousLine() {
        return this.getPageByLineIndex(this.startLineIndex - 1);
      },
      getPageOfFirstLine: function getPageOfFirstLine() {
        return this.getPageByLineIndex(0);
      },
      getPageOfLastLine: function getPageOfLastLine() {
        return this.getPageByLineIndex(this.totalLinesCount);
      }
    };
  
    var ShowMethods = {
      showPage: function showPage(idx) {
        this.displayText(this.getPage(idx));
        return this;
      },
      showNextPage: function showNextPage() {
        this.displayText(this.getNextPage());
        return this;
      },
      showPreviousPage: function showPreviousPage() {
        this.displayText(this.getPreviousPage());
        return this;
      },
      showFirstPage: function showFirstPage() {
        this.displayText(this.getFirstPage());
        return this;
      },
      showLastPage: function showLastPage() {
        this.displayText(this.getLastPage());
        return this;
      },
      show: function show() {
        this.displayText(this.getLines());
        return this;
      },
      showPageByLineIndex: function showPageByLineIndex(lineIndex) {
        this.displayText(this.getPageByLineIndex(lineIndex));
        return this;
      },
      showNextLine: function showNextLine() {
        this.displayText(this.getPageOfNextLine());
        return this;
      },
      showPreviousLine: function showPreviousLine() {
        this.displayText(this.getPageOfPreviousLine());
        return this;
      },
      showFirstLine: function showFirstLine() {
        this.displayText(this.getPageOfFirstLine());
        return this;
      },
      showLastLine: function showLastLine() {
        this.displayText(this.getPageOfLastLine());
        return this;
      },
      displayText: function displayText(text) {
        SetNoWrapText(this.parent, text);
      }
    };
  
    var Methods$2 = {
      getLines: GetLines
    };
    Object.assign(Methods$2, SetContentMethods, GetPageMethods, ShowMethods);
  
    var GetValue$W = Phaser.Utils.Objects.GetValue;
    Phaser.Math.Clamp;
    var TextPage = /*#__PURE__*/function (_ComponentBase) {
      _inherits(TextPage, _ComponentBase);
      function TextPage(gameObject, config) {
        var _this;
        _classCallCheck(this, TextPage);
        _this = _callSuper(this, TextPage, [gameObject, {
          eventEmitter: false
        }]);
        // No event emitter
        // this.parent = gameObject;
  
        _this.textObjectType = GetTextObjectType(_this.parent);
        _this.pageStartIndexes = [];
  
        // Text object : array of string
        // Tag text object : pens-manager
        // Bitmap text object : array of string
        _this.lines = TextToLines(_this.parent, '');
        _this.sections = [];
        _this.resetFromJSON(config);
        return _this;
      }
      _createClass(TextPage, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setMaxLines(GetValue$W(o, 'maxLines', undefined));
          this.setPageBreak(GetValue$W(o, 'pageBreak', '\f\n'));
          this.setText(GetValue$W(o, 'text', ''));
          this.startLineIndex = GetValue$W(o, 'start', -1);
          this.endLineIndex = GetValue$W(o, 'end', undefined);
          var pageIndex = GetValue$W(o, 'page');
          if (pageIndex === undefined) {
            this.resetIndex();
          } else {
            this.setPageIndex(pageIndex);
          }
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            maxLines: this.maxLines,
            text: this.content,
            start: this.startLineIndex,
            end: this.endLineIndex,
            page: this.pageIndex,
            pageBreak: this.pageBreak
          };
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          switch (this.textObjectType) {
            case TextType:
              this.lines.length = 0;
              break;
            case TagTextType:
              this.lines.destroy();
              break;
            case BitmapTextType:
              this.lines.length = 0;
              break;
          }
          this.pageStartIndexes.length = 0;
          this.sections.length = 0;
          this.lines = undefined;
          this.pageStartIndexes = undefined;
          this.sections = undefined;
          _get(_getPrototypeOf(TextPage.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "setMaxLines",
        value: function setMaxLines(maxLines) {
          this.maxLines = maxLines;
          return this;
        }
      }, {
        key: "setPageBreak",
        value: function setPageBreak(pageBreak) {
          this.pageBreak = pageBreak;
          return this;
        }
      }, {
        key: "pageCount",
        get: function get() {
          return this.pageStartIndexes.length;
        }
      }, {
        key: "lastPageIndex",
        get: function get() {
          return this.pageCount - 1;
        }
      }, {
        key: "isFirstPage",
        get: function get() {
          return this.pageIndex <= 0;
        }
      }, {
        key: "isLastPage",
        get: function get() {
          return this.pageIndex >= this.pageCount - 1;
        }
      }, {
        key: "totalLinesCount",
        get: function get() {
          return this.lines ? this.lines.length : 0;
        }
      }, {
        key: "pageLinesCount",
        get: function get() {
          if (this.maxLines !== undefined) {
            return this.maxLines;
          } else {
            var count;
            switch (this.textObjectType) {
              case TextType:
              case TagTextType:
                var maxLines = this.parent.style.maxLines;
                if (maxLines > 0) {
                  count = maxLines;
                } else {
                  count = Math.floor(TextHeightToLinesCount(this.parent));
                }
                break;
              case BitmapTextType:
                count = this.totalLinesCount;
                break;
            }
            return count;
          }
        }
      }, {
        key: "isFirstLine",
        get: function get() {
          return this.startLineIndex <= 0;
        }
      }, {
        key: "isLastLine",
        get: function get() {
          return this.endLineIndex === this.totalLinesCount;
        }
      }, {
        key: "content",
        get: function get() {
          return this.sections.join(this.pageBreak);
        }
      }]);
      return TextPage;
    }(ComponentBase);
    Object.assign(TextPage.prototype, Methods$2);
  
    var StartTyping = function StartTyping(text, speed, startIndex, timerStartAt) {
      if (text !== undefined) {
        this.setTypingContent(text);
      }
      if (speed !== undefined) {
        this.speed = speed;
      }
      if (startIndex === undefined) {
        startIndex = 0;
      }
      this.typingIndex = startIndex + 1;
      if (this.speed === 0) {
        this.stop(true);
      } else {
        this.setText('');
        this.startTimer(timerStartAt);
      }
      return this;
    };
  
    var GetPlainText = function GetPlainText(textObject, text) {
      if (textObject.getPlainText) {
        text = textObject.getPlainText(text);
      }
      return text;
    };
  
    var StartTypingFromLine = function StartTypingFromLine(text, lineIndex, speed, offsetIndex, timerStartAt) {
      var startIdx;
      if (lineIndex > 0) {
        if (offsetIndex === undefined) {
          offsetIndex = 0;
        }
        var plainText = GetPlainText(this.parent, text);
        startIdx = GetNewLineIndex(plainText, lineIndex) + offsetIndex;
      }
      return this.start(text, speed, startIdx, timerStartAt);
    };
    var GetNewLineIndex = function GetNewLineIndex(s, n) {
      var index = undefined;
      for (var i = 0; i < n; i++) {
        index = s.indexOf('\n', index + 1);
        if (index === -1) {
          break;
        }
      }
      return index;
    };
  
    var GetSubString = function GetSubString(textObject, text, startIdx, endIdx) {
      var result;
      if (textObject.getSubString) {
        result = textObject.getSubString(text, startIdx, endIdx);
      } else {
        result = text.slice(startIdx, endIdx);
      }
      return result;
    };
  
    var GetTypingString = function GetTypingString(text, typeIdx, textLength, typeMode) {
      var textObject = this.parent;
      var result;
      if (typeMode === 0) {
        //left-to-right
        var startIdx = 0;
        var endIdx = typeIdx;
        this.insertIndex = endIdx;
        result = GetSubString(textObject, text, startIdx, endIdx);
      } else if (typeMode === 1) {
        //right-to-left
        var endIdx = textLength;
        var startIdx = endIdx - typeIdx;
        this.insertIndex = 0;
        result = GetSubString(textObject, text, startIdx, endIdx);
      } else if (typeMode === 2) {
        //middle-to-sides
        var midIdx = textLength / 2;
        var startIdx = Math.floor(midIdx - typeIdx / 2);
        var endIdx = startIdx + typeIdx;
        this.insertIndex = typeIdx % 2 ? typeIdx : 0;
        result = GetSubString(textObject, text, startIdx, endIdx);
      } else if (typeMode === 3) {
        //sides-to-middle
        var lowerLen = Math.floor(typeIdx / 2);
        var lowerResult;
        if (lowerLen > 0) {
          var endIdx = textLength;
          var startIdx = endIdx - lowerLen;
          lowerResult = GetSubString(textObject, text, startIdx, endIdx);
        } else {
          lowerResult = "";
        }
        var upperLen = typeIdx - lowerLen;
        var upperResult;
        if (upperLen > 0) {
          var startIdx = 0;
          var endIdx = startIdx + upperLen;
          this.insertIndex = endIdx;
          upperResult = GetSubString(textObject, text, startIdx, endIdx);
        } else {
          upperResult = "";
          this.insertIndex = 0;
        }
        result = upperResult + lowerResult;
      }
      this.insertChar = result.charAt(this.insertIndex - 1);
      return result;
    };
  
    var StopTyping = function StopTyping(showAllText) {
      var timer = this.getTimer();
      if (timer) {
        this.freeTimer();
      }
      if (showAllText) {
        // Fire 'type' event for remainder characters until lastChar
        while (!this.isLastChar) {
          GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
          this.emit('typechar', this.insertChar);
          this.typingIndex++;
        }
        // Display all characters on text game object
        this.setText(this.text);
        this.emit('type');
        this.emit('complete', this, this.parent);
      }
      return this;
    };
  
    var PauseTyping = function PauseTyping() {
      var timer = this.getTimer();
      if (timer) {
        timer.paused = true;
      }
      return this;
    };
  
    var ResumeTyping = function ResumeTyping() {
      var timer = this.getTimer();
      if (timer) {
        timer.paused = false;
      }
      return this;
    };
  
    var AppendText = function AppendText(text) {
      var newText = this.text.concat(TransferText(text));
      if (this.isTyping) {
        this.setTypingContent(newText);
      } else {
        this.start(newText, undefined, this.textLength);
      }
      return this;
    };
  
    var methods$b = {
      start: StartTyping,
      startFromLine: StartTypingFromLine,
      stop: StopTyping,
      pause: PauseTyping,
      resumeTyping: ResumeTyping,
      appendText: AppendText
    };
  
    var GetWrapText = function GetWrapText(textObject, text) {
      var textObjectType = GetTextObjectType(textObject);
      switch (textObjectType) {
        case TextType:
          textObject.style.syncFont(textObject.canvas, textObject.context);
          text = textObject.runWordWrap(text);
          break;
        case TagTextType:
          text = textObject.getText(text, undefined, undefined, true);
          break;
        case BitmapTextType:
          text = textObject.setText(text).getTextBounds().wrappedText;
          break;
      }
      return text;
    };
  
    var GetFastValue = Phaser.Utils.Objects.GetFastValue;
    var GetValue$V = Phaser.Utils.Objects.GetValue;
    var TextTyping = /*#__PURE__*/function (_ComponentBase) {
      _inherits(TextTyping, _ComponentBase);
      function TextTyping(gameObject, config) {
        var _this;
        _classCallCheck(this, TextTyping);
        _this = _callSuper(this, TextTyping, [gameObject, config]);
        // this.parent = gameObject;
  
        _this.timer = null;
        _this.resetFromJSON(config);
        return _this;
      }
      _createClass(TextTyping, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.setTextWrapEnable(GetValue$V(o, 'wrap', false));
          this.setTypeMode(GetValue$V(o, 'typeMode', 0));
          this.setTypingSpeed(GetValue$V(o, 'speed', 333));
          this.setTextCallback = GetFastValue(o, 'setTextCallback', null);
          this.setTextCallbackScope = GetFastValue(o, 'setTextCallbackScope', null);
          this.setTypingContent(GetFastValue(o, 'text', ''));
          this.typingIndex = GetFastValue(o, 'typingIndex', 0);
          this.insertIndex = null;
          this.insertChar = null;
          var elapsed = GetFastValue(o, 'elapsed', null);
          if (elapsed !== null) {
            this.start(undefined, undefined, this.typingIndex, elapsed);
          }
          return this;
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.freeTimer();
          _get(_getPrototypeOf(TextTyping.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "setTypeMode",
        value: function setTypeMode(m) {
          if (typeof m === 'string') {
            m = TYPEMODE[m];
          }
          this.typeMode = m;
          return this;
        }
      }, {
        key: "setTypeSpeed",
        value: function setTypeSpeed(speed) {
          this.speed = speed;
          return this;
        }
      }, {
        key: "setTypingSpeed",
        value: function setTypingSpeed(speed) {
          this.speed = speed;
          return this;
        }
      }, {
        key: "setTextWrapEnable",
        value: function setTextWrapEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.textWrapEnable = enable;
          return this;
        }
      }, {
        key: "text",
        get: function get() {
          return this._text;
        },
        set: function set(value) {
          var text = TransferText$1(value);
          if (this.textWrapEnable) {
            text = GetWrapText(this.parent, text);
          }
          this._text = text;
        }
      }, {
        key: "isTyping",
        get: function get() {
          return this.getTimer() !== null;
        }
      }, {
        key: "isLastChar",
        get: function get() {
          return this.typingIndex === this.textLength;
        }
      }, {
        key: "setTypingContent",
        value: function setTypingContent(text) {
          this.text = text;
          this.textLength = GetPlainText(this.parent, this.text).length;
          return this;
        }
      }, {
        key: "onTyping",
        value: function onTyping() {
          var newText = GetTypingString.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
          this.setText(newText);
          this.emit('typechar', this.insertChar);
          this.emit('type');
          if (this.isLastChar) {
            this.freeTimer();
            // Fire 'complete' next tick, to render last character on screen
            this.scene.sys.events.once('preupdate', function () {
              this.emit('complete', this, this.parent);
            }, this);
          } else {
            this.timer.delay = this.speed; // delay of next typing            
            this.typingIndex++;
          }
        }
      }, {
        key: "startTimer",
        value: function startTimer(timerStartAt) {
          if (this.timer) {
            this.freeTimer();
          }
          var startAt;
          if (timerStartAt === undefined) {
            startAt = 0;
          } else {
            this.speed;
            startAt = timerStartAt;
          }
          this.timer = this.scene.time.addEvent({
            delay: 0.0001,
            startAt: startAt,
            loop: true,
            callback: this.onTyping,
            callbackScope: this
          });
          // Note: Throw error message if delay is 0 with repeat/loop
  
          return this;
        }
      }, {
        key: "getTimer",
        value: function getTimer() {
          return this.timer;
        }
      }, {
        key: "freeTimer",
        value: function freeTimer() {
          if (this.timer) {
            this.timer.remove();
            this.timer = null;
          }
          return this;
        }
      }, {
        key: "setText",
        value: function setText(text) {
          if (this.setTextCallback) {
            if (this.setTextCallbackScope) {
              text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
            } else {
              text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
            }
          }
          if (this.textWrapEnable) {
            SetNoWrapText(this.parent, text);
          } else {
            this.parent.setText(text);
          }
        }
      }]);
      return TextTyping;
    }(ComponentBase);
    var TransferText$1 = function TransferText(text) {
      if (Array.isArray(text)) {
        text = text.join('\n');
      } else if (typeof text === 'number') {
        text = text.toString();
      }
      return text;
    };
    var TYPEMODE = {
      'left-to-right': 0,
      'right-to-left': 1,
      'middle-to-sides': 2,
      'sides-to-middle': 3
    };
    Object.assign(TextTyping.prototype, methods$b);
  
    var GetValue$U = Phaser.Utils.Objects.GetValue;
    var TextBoxBase = function TextBoxBase(GOClass, type) {
      if (type === undefined) {
        type = 'rexTextBox';
      }
      var TextBox = /*#__PURE__*/function (_GOClass) {
        _inherits(TextBox, _GOClass);
        function TextBox(scene, config) {
          var _this;
          _classCallCheck(this, TextBox);
          _this = _callSuper(this, TextBox, [scene, config]);
          _this.type = type;
          _this.isRunning = false;
  
          // childrenMap must have 'text' element
          var text = _this.childrenMap.text;
  
          // Expand text size
          var expandTextWidth = GetValue$U(config, 'expandTextWidth', false);
          var expandTextHeight = GetValue$U(config, 'expandTextHeight', false);
          if (expandTextWidth || expandTextHeight) {
            var textObjectType = GetTextObjectType(text);
            switch (textObjectType) {
              case TextType:
              case TagTextType:
                // Don't overwrite resize method if text has it already
                text.resize = function (width, height) {
                  var fixedWidth = expandTextWidth ? width : 0;
                  var fixedHeight = expandTextHeight ? height : 0;
                  text.setFixedSize(fixedWidth, fixedHeight);
                  if (fixedWidth > 0) {
                    text.setWordWrapWidth(fixedWidth);
                  }
                };
                if (textObjectType === TagTextType) {
                  var style = text.style;
                  if (style.wrapMode === 0) {
                    // Turn no-wrap to word-wrap
                    style.wrapMode = 1;
                  }
                }
                break;
            }
            if (expandTextWidth) {
              text._minWidth = 0;
            }
            if (expandTextHeight) {
              text._minHeight = 0;
            }
          }
  
          // Build typing and page behaviors
          _this.setTypingMode(GetValue$U(config, 'typingMode', 'page'));
          _this.page = new TextPage(text, GetValue$U(config, 'page', undefined));
          _this.typing = new TextTyping(text, GetValue$U(config, 'typing', config.type));
          _this.typing.on('complete', _this.onTypingComplete, _assertThisInitialized(_this)).on('type', _this.onType, _assertThisInitialized(_this)).on('typechar', _this.onTypeChar, _assertThisInitialized(_this));
  
          // Run layout again when size of text game object has changed
          _this.textWidthSave = text.width;
          _this.textHeightSave = text.height;
          return _this;
        }
        _createClass(TextBox, [{
          key: "setTypingMode",
          value: function setTypingMode(mode) {
            if (typeof mode === 'string') {
              mode = TypingMode[mode];
            }
            this.typingMode = mode;
            return this;
          }
        }, {
          key: "start",
          value: function start(text, speed) {
            if (speed !== undefined) {
              this.setTypingSpeed(speed);
            }
  
            // Start typing task
            this.isRunning = true;
            this.page.setText(text);
            this.emit('start');
            if (this.typingMode === 0) {
              // Typing page by page
              this.typeNextPage();
            } else {
              // Typing line by line
              this.typeNextLine();
            }
            return this;
          }
        }, {
          key: "more",
          value: function more(text, speed) {
            if (speed !== undefined) {
              this.setTypingSpeed(speed);
            }
            if (this.isRunning) {
              this.page.appendText(text);
              this.typing.appendText(text);
            } else {
              this.isRunning = true;
              this.page.appendText(text);
              this.emit('start');
              if (this.typingMode === 0) {
                var txt = this.page.getPage();
                var startIndex = this.typing.textLength;
                this.typing.start(txt, undefined, startIndex);
              }
              return this;
            }
          }
        }, {
          key: "typeNextPage",
          value: function typeNextPage() {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            if (!this.isLastPage) {
              var txt = this.page.getNextPage();
              this.typing.start(txt);
            } else {
              this.emit('complete');
            }
            return this;
          }
        }, {
          key: "typeNextLine",
          value: function typeNextLine() {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            if (!this.isLastLine) {
              var txt = this.page.getPageOfNextLine();
              var startLineIndex;
              if (this.isFirstLine) {
                // Typing from 1st line
                startLineIndex = 0;
              } else {
                // Typing last line
                startLineIndex = this.page.pageLinesCount - 1;
              }
              this.typing.startFromLine(txt, startLineIndex);
            } else {
              // Stop typing tasl if typing complete at last line
  
              this.isRunning = false;
              this.emit('pageend');
              this.emit('complete');
            }
          }
        }, {
          key: "pause",
          value: function pause() {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            if (this.isTyping) {
              this.typing.pause();
              this.emit('pause');
            }
            return this;
          }
        }, {
          key: "resume",
          value: function resume() {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            if (!this.isTyping) {
              this.emit('resume');
              this.typing.resume();
            }
            return this;
          }
        }, {
          key: "stop",
          value: function stop(showAllText) {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            this.typing.stop(showAllText);
            return this;
          }
        }, {
          key: "showLastPage",
          value: function showLastPage() {
            // Do nothing if typing task does not start
            if (!this.isRunning) {
              return this;
            }
            this.typing.stop();
            if (this.typingMode === 0) {
              this.page.showLastPage();
            } else {
              this.page.showLastLine();
            }
            this.emit('type');
            this.onTypingComplete();
            return this;
          }
        }, {
          key: "setTypeSpeed",
          value: function setTypeSpeed(speed) {
            this.typing.setTypingSpeed(speed);
            return this;
          }
        }, {
          key: "setTypingSpeed",
          value: function setTypingSpeed(speed) {
            this.typing.setTypingSpeed(speed);
            return this;
          }
        }, {
          key: "isTyping",
          get: function get() {
            return this.typing.isTyping;
          }
        }, {
          key: "isLastPage",
          get: function get() {
            return this.page.isLastPage;
          }
        }, {
          key: "isFirstPage",
          get: function get() {
            return this.page.isFirstPage;
          }
        }, {
          key: "pageCount",
          get: function get() {
            return this.page.pageCount;
          }
        }, {
          key: "pageIndex",
          get: function get() {
            return this.page.pageIndex;
          }
        }, {
          key: "isLastLine",
          get: function get() {
            return this.page.isLastLine;
          }
        }, {
          key: "isFirstLine",
          get: function get() {
            return this.page.isFirstLine;
          }
        }, {
          key: "lineCound",
          get: function get() {
            return this.page.totalLinesCount;
          }
        }, {
          key: "startLineIndex",
          get: function get() {
            return this.page.startLineIndex;
          }
        }, {
          key: "endLineIndex",
          get: function get() {
            return this.page.endLineIndex;
          }
        }, {
          key: "typingSpeed",
          get: function get() {
            return this.typing.speed;
          }
        }, {
          key: "onType",
          value: function onType() {
            var text = this.childrenMap.text;
            if (this.textWidthSave !== text.width || this.textHeightSave !== text.height) {
              this.textWidthSave = text.width;
              this.textHeightSave = text.height;
              this.getTopmostSizer().layout();
            }
            this.emit('type');
          }
        }, {
          key: "onTypeChar",
          value: function onTypeChar(_char) {
            this.emit('typechar', _char);
          }
        }, {
          key: "onTypingComplete",
          value: function onTypingComplete() {
            if (this.typingMode === 0) {
              var isLastPage = this.isLastPage;
  
              // Stop typing tasl if typing complete at last page
              this.isRunning = !isLastPage;
              this.emit('pageend');
              /*
              Might enter this method immediately, if invoking typeNextPage() in this 'pageend' event.
              */
  
              if (isLastPage) {
                this.emit('complete');
              }
            } else {
              // Typing next line continually
              this.typeNextLine();
            }
          }
        }]);
        return TextBox;
      }(GOClass);
      return TextBox;
    };
    var TypingMode = {
      page: 0,
      line: 1
    };
  
    var TextBox = /*#__PURE__*/function (_TextBoxBase) {
      _inherits(TextBox, _TextBoxBase);
      function TextBox(scene, config) {
        _classCallCheck(this, TextBox);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('layoutMode')) {
          config.layoutMode = 1;
        }
        return _callSuper(this, TextBox, [scene, config]);
      }
      return _createClass(TextBox);
    }(TextBoxBase(TitleLabel));
  
    ObjectFactory.register('textBox', function (config) {
      var gameObject = new TextBox(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TextBox', TextBox);
  
    var SimpleTextBox = /*#__PURE__*/function (_TextBox) {
      _inherits(SimpleTextBox, _TextBox);
      function SimpleTextBox(scene, config, creators) {
        _classCallCheck(this, SimpleTextBox);
        config = BuildTitleLabelConfig(scene, config, creators);
        return _callSuper(this, SimpleTextBox, [scene, config]);
      }
      return _createClass(SimpleTextBox);
    }(TextBox);
  
    ObjectFactory.register('simpleTextBox', function (config) {
      var gameObject = new SimpleTextBox(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.SimpleTextBox', SimpleTextBox);
  
    var GetValue$T = Phaser.Utils.Objects.GetValue;
    var NumberBar = /*#__PURE__*/function (_Sizer) {
      _inherits(NumberBar, _Sizer);
      function NumberBar(scene, config) {
        var _this;
        _classCallCheck(this, NumberBar);
        // Create sizer
        _this = _callSuper(this, NumberBar, [scene, config]);
        _this.type = 'rexNumberBar';
  
        // Add elements
        var background = GetValue$T(config, 'background', undefined);
        var icon = GetValue$T(config, 'icon', undefined);
        var iconMask = GetValue$T(config, 'iconMask', undefined);
        var sliderConfig = GetValue$T(config, 'slider', undefined);
        var text = GetValue$T(config, 'text', undefined);
  
        // Space
        var iconSpace = GetValue$T(config, 'space.icon', 0);
        var sliderSpace = GetValue$T(config, 'space.slider', 0);
        if (background) {
          _this.addBackground(background);
        }
        if (icon) {
          var padding;
          if (_this.orientation === 0) {
            if (sliderConfig || text) {
              padding = {
                right: iconSpace
              };
            }
          } else {
            if (sliderConfig || text) {
              padding = {
                bottom: iconSpace
              };
            }
          }
          _this.add(icon, {
            proportion: 0,
            align: 'center',
            padding: padding
          });
          if (iconMask) {
            iconMask = AddChildMask.call(_assertThisInitialized(_this), icon, icon, 1); // Circle mask
          }
        }
        var slider;
        if (sliderConfig) {
          sliderConfig.orientation = _this.orientation;
          sliderConfig.eventEmitter = _assertThisInitialized(_this);
          sliderConfig.value = null;
          if (!sliderConfig.hasOwnProperty('input')) {
            sliderConfig.input = -1;
          }
          slider = new Slider(scene, sliderConfig);
          scene.add.existing(slider);
          var padding;
          if (_this.orientation === 0) {
            if (text) {
              padding = {
                right: sliderSpace
              };
            }
          } else {
            if (text) {
              padding = {
                bottom: sliderSpace
              };
            }
          }
          var proportion;
          if (_this.orientation === 0) {
            var sliderWidth = GetValue$T(sliderConfig, 'width', undefined);
            proportion = sliderWidth === undefined ? 1 : 0;
          } else {
            var sliderHeight = GetValue$T(sliderConfig, 'height', undefined);
            proportion = sliderHeight === undefined ? 1 : 0;
          }
          _this.add(slider, {
            proportion: proportion,
            align: 'center',
            padding: padding
          });
        }
        if (text) {
          _this.add(text);
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('icon', icon);
        _this.addChildrenMap('iconMask', iconMask);
        _this.addChildrenMap('slider', slider);
        _this.addChildrenMap('text', text);
        var callback = GetValue$T(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$T(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        _this.setEnable(GetValue$T(config, 'enable', undefined));
        _this.setValue(GetValue$T(config, 'value', 0));
        return _this;
      }
      _createClass(NumberBar, [{
        key: "enable",
        get: function get() {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.enable;
          } else {
            return false;
          }
        },
        set: function set(value) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEnable(value);
          }
        }
      }, {
        key: "setEnable",
        value: function setEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.enable = enable;
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.value;
          } else {
            return 0;
          }
        },
        set: function set(value) {
          if (!this.childrenMap.slider) {
            return;
          }
          this.childrenMap.slider.value = value;
        }
      }, {
        key: "setValue",
        value: function setValue(value, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setValue(value, min, max);
          }
          return this;
        }
      }, {
        key: "addValue",
        value: function addValue(inc, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.addValue(inc, min, max);
          }
          return this;
        }
      }, {
        key: "getValue",
        value: function getValue(min, max) {
          if (this.childrenMap.slider) {
            return this.childrenMap.slider.getValue(min, max);
          } else {
            return 0;
          }
        }
      }, {
        key: "easeValueTo",
        value: function easeValueTo(value, min, max) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.easeValueTo(value, min, max);
          }
          return this;
        }
      }, {
        key: "stopEaseValue",
        value: function stopEaseValue() {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.stopEaseValue();
          }
          return this;
        }
      }, {
        key: "setEaseValueDuration",
        value: function setEaseValueDuration(duration) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueDuration(duration);
          }
          return this;
        }
      }, {
        key: "setEaseValueFunction",
        value: function setEaseValueFunction(ease) {
          if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueFunction(ease);
          }
          return this;
        }
      }, {
        key: "text",
        get: function get() {
          var textObject = this.childrenMap.text;
          if (textObject === undefined) {
            return '';
          }
          var value;
          if (textObject.text) {
            value = textObject.text;
          } else {
            value = textObject.getData('text');
          }
          return value;
        },
        set: function set(value) {
          var textObject = this.childrenMap.text;
          if (textObject === undefined) {
            return;
          }
          if (textObject.setText) {
            textObject.setText(value);
          } else {
            textObject.setData('text', value);
          }
        }
      }, {
        key: "setText",
        value: function setText(value) {
          this.text = value;
          return this;
        }
      }]);
      return NumberBar;
    }(Sizer);
  
    ObjectFactory.register('numberBar', function (config) {
      var gameObject = new NumberBar(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.NumberBar', NumberBar);
  
    ObjectFactory.register('scrollBar', function (config) {
      var gameObject = new ScrollBar(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ScrollBar', ScrollBar);
  
    var GetValue$S = Phaser.Utils.Objects.GetValue;
    var BadgeKeys = {
      leftTop: 'left-top',
      centerTop: 'center-top',
      rightTop: 'right-top',
      leftCenter: 'left-center',
      center: 'center',
      rightCenter: 'right-center',
      leftBottom: 'left-bottom',
      centerBottom: 'center-bottom',
      rightBottom: 'right-bottom'
    };
    var Badge = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(Badge, _OverlapSizer);
      function Badge(scene, config) {
        var _this;
        _classCallCheck(this, Badge);
        // Create sizer  
        _this = _callSuper(this, Badge, [scene, config]);
        _this.type = 'rexBadge';
  
        // Add elements
        var background = GetValue$S(config, 'background', undefined);
        if (background) {
          _this.addBackground(background);
        }
        _this.addChildrenMap('background', background);
  
        // Base item
        var main = GetValue$S(config, 'main', undefined);
        if (main) {
          _this.add(main, {
            key: 'main',
            align: 'center',
            expand: false
          });
        }
        _this.addChildrenMap('main', main);
  
        // Badges
        for (var key in BadgeKeys) {
          var badge = GetValue$S(config, key, undefined);
          if (badge) {
            _this.add(badge, {
              key: key,
              align: BadgeKeys[key],
              expand: false
            });
            _this.addChildrenMap(key, badge);
          }
        }
        return _this;
      }
      return _createClass(Badge);
    }(OverlapSizer);
  
    ObjectFactory.register('badgeLabel', function (config) {
      var gameObject = new Badge(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.BadgeLabel', Badge);
  
    var OverlapSizerAdd = OverlapSizer.prototype.add;
    var Add = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
      gameObject.setVisible(false); // Default is invisible
      OverlapSizerAdd.call(this, gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY);
      return this;
    };
    var AddChildMethods = {
      add: Add,
      addPage: Add
    };
  
    var GetPage$1 = function GetPage(key) {
      if (key === undefined) {
        return null;
      } else if (!this.sizerChildren.hasOwnProperty(key)) {
        return null;
      } else {
        return this.sizerChildren[key];
      }
    };
  
    var ContainerSetChildVisible$1 = ContainerLite.prototype.setChildVisible;
    var SwapPage$1 = function SwapPage(key, fadeInDuration) {
      this._previousKey = this._currentKey;
      var prevoiusPage = this.previousPage;
      if (prevoiusPage) {
        if (this.swapMode === 0) {
          // Invisible
          ContainerSetChildVisible$1.call(this, prevoiusPage, false);
          this.emit('pageinvisible', prevoiusPage, this._previousKey, this);
        } else {
          // Destroy
          prevoiusPage.destroy();
        }
      }
      if (key && !this.sizerChildren.hasOwnProperty(key)) {
        this.emit('createpage', key, this);
      }
      this._currentKey = key;
      var currentPage = this.currentPage;
      if (currentPage) {
        ContainerSetChildVisible$1.call(this, currentPage, true);
        this.emit('pagevisible', currentPage, this._currentKey, this);
        if (fadeInDuration === undefined) {
          fadeInDuration = this.fadeInDuration;
        }
        if (fadeInDuration > 0) {
          currentPage.setAlpha(0).fadeIn(fadeInDuration, 1);
        }
      }
      return this;
    };
  
    var HasPage = function HasPage(key) {
      return this.sizerChildren.hasOwnProperty(key);
    };
  
    var methods$a = {
      getPage: GetPage$1,
      swapPage: SwapPage$1,
      hasPage: HasPage
    };
    Object.assign(methods$a, AddChildMethods);
  
    var GetValue$R = Phaser.Utils.Objects.GetValue;
    var Pages = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(Pages, _OverlapSizer);
      function Pages(scene, config) {
        var _this;
        _classCallCheck(this, Pages);
        _this = _callSuper(this, Pages, [scene, config]);
        _this.type = 'rexPages';
        _this.childrenMap = _this.sizerChildren;
        _this._previousKey = undefined;
        _this._currentKey = undefined;
        _this.setSwapMode(GetValue$R(config, 'swapMode', 0));
        _this.setFadeInDuration(GetValue$R(config, 'fadeIn', 0));
        return _this;
      }
      _createClass(Pages, [{
        key: "setSwapMode",
        value: function setSwapMode(mode) {
          if (typeof mode === 'string') {
            mode = SWAPMODE[mode];
          }
          this.swapMode = mode;
          return this;
        }
      }, {
        key: "setFadeInDuration",
        value: function setFadeInDuration(duration) {
          this.fadeInDuration = duration;
          return this;
        }
      }, {
        key: "previousKey",
        get: function get() {
          return this._previousKey;
        }
      }, {
        key: "currentKey",
        get: function get() {
          return this._currentKey;
        },
        set: function set(key) {
          this.swapPage(key);
        }
      }, {
        key: "currentPage",
        get: function get() {
          return this.getPage(this.currentKey);
        }
      }, {
        key: "previousPage",
        get: function get() {
          return this.getPage(this.previousKey);
        }
      }, {
        key: "keys",
        get: function get() {
          return Object.keys(this.sizerChildren);
        }
      }]);
      return Pages;
    }(OverlapSizer);
    Object.assign(Pages.prototype, methods$a);
    var SWAPMODE = {
      invisible: 0,
      destroy: 1
    };
  
    ObjectFactory.register('pages', function (config) {
      var gameObject = new Pages(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Pages', Pages);
  
    var Mesh = Phaser.GameObjects.Mesh;
    var MeshBase = /*#__PURE__*/function (_Mesh) {
      _inherits(MeshBase, _Mesh);
      function MeshBase() {
        _classCallCheck(this, MeshBase);
        return _callSuper(this, MeshBase, arguments);
      }
      _createClass(MeshBase, [{
        key: "tint",
        get: function get() {
          if (this.vertices.length === 0) {
            return 0xffffff;
          } else {
            return this.vertices[0].color;
          }
        }
      }, {
        key: "forceUpdate",
        value: function forceUpdate() {
          this.dirtyCache[10] = 1;
          return this;
        }
      }]);
      return MeshBase;
    }(Mesh);
  
    var Vector3 = Phaser.Math.Vector3;
    var Matrix4 = Phaser.Math.Matrix4;
    var tempPosition = new Vector3();
    var tempRotation = new Vector3();
    var tempMatrix = new Matrix4();
    var TransformVerts = function TransformVerts(mesh, x, y, z, rotateX, rotateY, rotateZ) {
      if (x === undefined) {
        x = 0;
      }
      if (y === undefined) {
        y = 0;
      }
      if (z === undefined) {
        z = 0;
      }
      if (rotateX === undefined) {
        rotateX = 0;
      }
      if (rotateY === undefined) {
        rotateY = 0;
      }
      if (rotateZ === undefined) {
        rotateZ = 0;
      }
      tempPosition.set(x, y, z);
      tempRotation.set(rotateX, rotateY, rotateZ);
      tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, true);
      for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
        mesh.vertices[i].transformMat4(tempMatrix);
      }
    };
  
    var IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$Q = Phaser.Utils.Objects.GetValue;
    var GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
    var RadToDeg$2 = Phaser.Math.RadToDeg;
    var DegToRad$3 = Phaser.Math.DegToRad;
    var FOV = 45;
    var PanZ = 1 + 1 / Math.sin(DegToRad$3(FOV));
    var Image$2 = /*#__PURE__*/function (_MeshBase) {
      _inherits(Image, _MeshBase);
      function Image(scene, x, y, key, frame, config) {
        var _this;
        _classCallCheck(this, Image);
        if (IsPlainObject$a(x)) {
          config = x;
          x = GetValue$Q(config, 'x', 0);
          y = GetValue$Q(config, 'y', 0);
          key = GetValue$Q(config, 'key', null);
          frame = GetValue$Q(config, 'frame', null);
        }
        _this = _callSuper(this, Image, [scene, x, y, key, frame]);
        _this.type = 'rexPerspectiveImage';
        _this.setSizeToFrame();
        _this.resetPerspective();
        _this.panZ(PanZ);
        _this.hideCCW = GetValue$Q(config, 'hideCCW', true);
        var gridWidth = GetValue$Q(config, 'gridWidth', 0);
        var gridHeight = GetValue$Q(config, 'gridHeight', gridWidth);
        _this.resetVerts(gridWidth, gridHeight);
        _this.prevFrame = _this.frame;
        return _this;
      }
      _createClass(Image, [{
        key: "preUpdate",
        value: function preUpdate(time, delta) {
          // Reset size and vertex if frame is changed
          if (this.prevFrame !== this.frame) {
            this.prevFrame = this.frame;
            this.syncSize();
          }
          _get(_getPrototypeOf(Image.prototype), "preUpdate", this).call(this, time, delta);
        }
      }, {
        key: "originX",
        get: function get() {
          return 0.5;
        }
      }, {
        key: "originY",
        get: function get() {
          return 0.5;
        }
      }, {
        key: "resetPerspective",
        value: function resetPerspective() {
          this.setPerspective(this.width, this.height, FOV);
          return this;
        }
      }, {
        key: "resetVerts",
        value: function resetVerts(gridWidth, gridHeight) {
          if (gridWidth !== undefined) {
            this.gridWidth = gridWidth;
          }
          if (gridHeight !== undefined) {
            this.gridHeight = gridHeight;
          }
  
          // Clear faces and vertices
          this.clear();
          this.dirtyCache[9] = -1;
          if (this.width === 0 || this.height === 0) {
            return this;
          }
  
          // Generate faces and vertices
          var frameWidth = this.frame.cutWidth,
            frameHeight = this.frame.cutHeight;
          var gridWidth, gridHeight;
          if (this.gridWidth === 0) {
            gridWidth = Math.max(frameWidth / 8, 32);
          } else {
            gridHeight = this.gridWidth;
          }
          if (this.gridHeight === 0) {
            gridHeight = Math.max(frameHeight / 8, 32);
          } else {
            gridHeight = this.gridHeight;
          }
          GenerateGridVerts({
            mesh: this,
            width: frameWidth / this.height,
            height: frameHeight / this.height,
            widthSegments: Math.ceil(frameWidth / gridWidth),
            heightSegments: Math.ceil(frameHeight / gridHeight)
          });
  
          // Recover vertices transform
          var transformInfo = this.transformInfo;
          if (transformInfo) {
            this.transformVerts(transformInfo.x, transformInfo.y, transformInfo.z, transformInfo.rotateX, transformInfo.rotateY, transformInfo.rotateZ);
          }
          return this;
        }
      }, {
        key: "syncSize",
        value: function syncSize() {
          this.setSizeToFrame(); // Reset size
          this.resetPerspective(); // Reset perspective
          this.resetVerts(); // Reset verts
          return this;
        }
      }, {
        key: "rotationX",
        get: function get() {
          return this.modelRotation.x;
        },
        set: function set(value) {
          this.modelRotation.x = value;
        }
      }, {
        key: "angleX",
        get: function get() {
          return RadToDeg$2(this.rotationX);
        },
        set: function set(value) {
          this.rotationX = DegToRad$3(value);
        }
      }, {
        key: "rotationY",
        get: function get() {
          return this.modelRotation.y;
        },
        set: function set(value) {
          this.modelRotation.y = value;
        }
      }, {
        key: "angleY",
        get: function get() {
          return RadToDeg$2(this.rotationY);
        },
        set: function set(value) {
          this.rotationY = DegToRad$3(value);
        }
      }, {
        key: "rotationZ",
        get: function get() {
          return this.modelRotation.z;
        },
        set: function set(value) {
          this.modelRotation.z = value;
        }
      }, {
        key: "angleZ",
        get: function get() {
          return RadToDeg$2(this.rotationZ);
        },
        set: function set(value) {
          this.rotationZ = DegToRad$3(value);
        }
      }, {
        key: "transformVerts",
        value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
          if (x === undefined) {
            x = 0;
          }
          if (y === undefined) {
            y = 0;
          }
          if (z === undefined) {
            z = 0;
          }
          if (rotateX === undefined) {
            rotateX = 0;
          }
          if (rotateY === undefined) {
            rotateY = 0;
          }
          if (rotateZ === undefined) {
            rotateZ = 0;
          }
          if (!this.transformInfo) {
            this.transformInfo = {};
          }
          this.transformInfo.x = x;
          this.transformInfo.y = y;
          this.transformInfo.rotateX = rotateX;
          this.transformInfo.rotateY = rotateY;
          this.transformInfo.rotateZ = rotateZ;
          TransformVerts(this, x, y, z, rotateX, rotateY, rotateZ);
          return this;
        }
      }]);
      return Image;
    }(MeshBase);
  
    var DynamicTexture = Phaser.Textures.DynamicTexture;
    var CreateDynamicTexture = function CreateDynamicTexture(scene, width, height) {
      if (width === undefined) {
        width = 2;
      }
      if (height === undefined) {
        height = 2;
      }
      var dt = new DynamicTexture(scene.sys.textures, null, width, height);
      return dt;
    };
  
    var IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$P = Phaser.Utils.Objects.GetValue;
    var RenderTexture = /*#__PURE__*/function (_Image) {
      _inherits(RenderTexture, _Image);
      function RenderTexture(scene, x, y, width, height, config) {
        var _this;
        _classCallCheck(this, RenderTexture);
        if (IsPlainObject$9(x)) {
          config = x;
          x = GetValue$P(config, 'x', 0);
          y = GetValue$P(config, 'y', 0);
          width = GetValue$P(config, 'width', 32);
          height = GetValue$P(config, 'height', 32);
        }
  
        // dynamic-texture -> quad-image
        var texture = CreateDynamicTexture(scene, width, height);
        _this = _callSuper(this, RenderTexture, [scene, x, y, texture, null, config]);
        _this.type = 'rexPerspectiveRenderTexture';
        _this.rt = _this.texture;
        return _this;
      }
      _createClass(RenderTexture, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this, fromScene);
          this.rt.destroy();
          this.rt = null;
        }
      }, {
        key: "snapshot",
        value: function snapshot(gameObjects, config) {
          if (config === undefined) {
            config = {};
          }
          config.gameObjects = gameObjects;
          config.renderTexture = this.rt;
          Snapshot(config);
          if (this.width !== this.frame.realWidth || this.height !== this.frame.realHeight) {
            this.syncSize();
          }
          return this;
        }
      }]);
      return RenderTexture;
    }(Image$2);
  
    Phaser.Animations.AnimationState;
    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
  
    var ForEachFace = function ForEachFace(faces, callback, scope, ignoreInvalid) {
      if (Array.isArray(faces)) {
        var isBreak = false;
        for (var i = 0, cnt = faces.length; i < cnt; i++) {
          var face = faces[i];
          if (ignoreInvalid && !face) {
            continue;
          }
          if (scope) {
            isBreak = callback.call(scope, face, i, faces);
          } else {
            isBreak = callback(face, i, faces);
          }
          if (isBreak) {
            return;
          }
        }
      } else {
        var isBreak = false;
        for (var name in faces) {
          var face = faces[name];
          if (ignoreInvalid && !face) {
            continue;
          }
          if (scope) {
            isBreak = callback.call(scope, face, name, faces);
          } else {
            isBreak = callback(face, name, faces);
          }
          if (isBreak) {
            return;
          }
        }
      }
    };
  
    var RadToDeg$1 = Phaser.Math.RadToDeg;
    var DegToRad$2 = Phaser.Math.DegToRad;
    var FaceContainer = /*#__PURE__*/function (_Container) {
      _inherits(FaceContainer, _Container);
      function FaceContainer(scene, x, y, width, height, faces) {
        var _this;
        _classCallCheck(this, FaceContainer);
        _this = _callSuper(this, FaceContainer, [scene, x, y, width, height]);
        _this.faces = faces; // Face Dictionary, or array
  
        ForEachFace(faces, function (face) {
          face.setPosition(x, y);
          this.add(face);
        }, _assertThisInitialized(_this), true);
        return _this;
      }
  
      // Override
      _createClass(FaceContainer, [{
        key: "rotationX",
        get: function get() {
          return 0;
        }
  
        // Override
        ,
        set: function set(value) {
          // rad
        }
      }, {
        key: "angleX",
        get: function get() {
          return RadToDeg$1(this.rotationX);
        },
        set: function set(value) {
          this.rotationX = DegToRad$2(value);
        }
      }, {
        key: "rotateX",
        get: function get() {
          return RadToDeg$1(this.rotationX);
        },
        set: function set(value) {
          this.rotationX = DegToRad$2(value);
        }
  
        // Override
      }, {
        key: "rotationY",
        get: function get() {
          return 0;
        }
  
        // Override
        ,
        set: function set(value) {
          // rad
        }
      }, {
        key: "angleY",
        get: function get() {
          return RadToDeg$1(this.rotationY);
        },
        set: function set(value) {
          this.rotationY = DegToRad$2(value);
        }
      }, {
        key: "rotateY",
        get: function get() {
          return RadToDeg$1(this.rotationY);
        },
        set: function set(value) {
          this.rotationY = DegToRad$2(value);
        }
  
        // Override
      }, {
        key: "rotationZ",
        get: function get() {
          return 0;
        }
  
        // Override
        ,
        set: function set(value) {
          // rad
        }
      }, {
        key: "angleZ",
        get: function get() {
          return RadToDeg$1(this.rotationZ);
        },
        set: function set(value) {
          this.rotationZ = DegToRad$2(value);
        }
      }, {
        key: "rotateZ",
        get: function get() {
          return RadToDeg$1(this.rotationZ);
        },
        set: function set(value) {
          this.rotationZ = DegToRad$2(value);
        }
      }, {
        key: "setDebug",
        value: function setDebug(graphic, callback) {
          ForEachFace(this.faces, function (face) {
            face.setDebug(graphic, callback);
          }, null, true);
          return this;
        }
      }, {
        key: "panX",
        value: function panX(v) {
          ForEachFace(this.faces, function (face) {
            face.panX(v);
          }, null, true);
          return this;
        }
      }, {
        key: "panY",
        value: function panY(v) {
          ForEachFace(this.faces, function (face) {
            face.panY(v);
          }, null, true);
          return this;
        }
      }, {
        key: "panZ",
        value: function panZ(v) {
          ForEachFace(this.faces, function (face) {
            face.panZ(v);
          }, null, true);
          return this;
        }
      }, {
        key: "transformVerts",
        value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
          ForEachFace(this.faces, function (face) {
            face.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
          }, null, true);
          return this;
        }
      }, {
        key: "forEachFace",
        value: function forEachFace(callback, scope, ignoreInvalid) {
          ForEachFace(this.faces, callback, scope, ignoreInvalid);
          return this;
        }
      }]);
      return FaceContainer;
    }(ContainerLite);
  
    var IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;
    var DefaultImageConfig = {
      key: '__WHITE'
    };
    var ClassMap = {
      image: Image$2,
      rendertexture: RenderTexture
    };
    var CreatePerspectiveObject = function CreatePerspectiveObject(scene, config) {
      if (config === undefined) {
        config = DefaultImageConfig;
      }
      var perspectiveObject;
      if (IsPlainObject$8(config)) {
        if (!config.hasOwnProperty('type')) {
          if (config.hasOwnProperty('key')) {
            config.type = 'image';
          } else if (config.hasOwnProperty('width')) {
            config.type = 'rendertexture';
          }
        }
        perspectiveObject = new ClassMap[config.type](scene, config);
        scene.add.existing(perspectiveObject);
      } else {
        perspectiveObject = config;
      }
      return perspectiveObject;
    };
  
    var CreateFaces = function CreateFaces(scene, config, faceNames) {
      var faces;
      if (faceNames === undefined) {
        // Return an array of faces
        faces = [];
        var face, faceConfig;
        for (var i = 0, cnt = config.length; i < cnt; i++) {
          faceConfig = config[i];
          if (faceConfig) {
            face = CreatePerspectiveObject(scene, faceConfig);
          } else {
            face = null;
          }
          faces.push(face);
        }
      } else {
        // Return a face map
        faces = {};
        var face, name;
        for (var i = 0, cnt = faceNames.length; i < cnt; i++) {
          name = faceNames[i];
          if (config.hasOwnProperty(name)) {
            face = CreatePerspectiveObject(scene, config[name]);
          } else {
            face = null;
          }
          faces[name] = face;
        }
      }
      return faces;
    };
  
    var DegToRad$1 = Phaser.Math.DegToRad;
    var RAD180 = DegToRad$1(180);
    var LayoutFaces = function LayoutFaces(parent, faces) {
      var backFace = faces.back;
      if (backFace) {
        if (parent.orientation === 0) {
          // Flip around Y
          backFace.transformVerts(0, 0, 0, 0, RAD180, 0);
        } else {
          // Flip around X
          backFace.transformVerts(0, 0, 0, RAD180, 0, 0);
        }
      }
    };
  
    var GetValue$O = Phaser.Utils.Objects.GetValue;
    var Linear$2 = Phaser.Math.Linear;
    var Flip$1 = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(Flip, _EaseValueTaskBase);
      function Flip(gameObject, config) {
        var _this;
        _classCallCheck(this, Flip);
        _this = _callSuper(this, Flip, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Flip, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Flip.prototype), "resetFromJSON", this).call(this, o);
          this.setEase(GetValue$O(o, 'ease', 'Cubic'));
          this.setFrontToBackDirection(GetValue$O(o, 'frontToBack', 0));
          this.setBackToFrontDirection(GetValue$O(o, 'backToFront', 1));
          return this;
        }
      }, {
        key: "setFrontToBackDirection",
        value: function setFrontToBackDirection(direction) {
          if (typeof direction === 'string') {
            direction = DIRMODE[direction];
          }
          this.endAngleFB = direction === 0 ? 180 : -180;
          return this;
        }
      }, {
        key: "setBackToFrontDirection",
        value: function setBackToFrontDirection(direction) {
          if (typeof direction === 'string') {
            direction = DIRMODE[direction];
          }
          this.endAngleBF = direction === 0 ? -180 : 180;
          return this;
        }
      }, {
        key: "start",
        value: function start(duration, repeat) {
          if (this.timer.isRunning) {
            return this;
          }
          this.timer.setDelay(this.delay).setDuration(duration);
          var loop = repeat + 1;
          var gameObject = this.parent;
          if (gameObject.face === 0) {
            // isFrontToBack
            this.startAngle = 0;
            this.endAngle = this.endAngleFB * loop;
          } else {
            this.startAngle = this.endAngleBF;
            this.endAngle = this.startAngle - this.endAngleBF * loop;
          }
          _get(_getPrototypeOf(Flip.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "flip",
        value: function flip(duration, repeat) {
          if (this.isRunning) {
            return this;
          }
          if (duration === undefined) {
            duration = this.duration;
          }
          if (repeat === undefined) {
            repeat = 0;
          }
          this.start(duration, repeat);
          this.emit('start', this.parent, this);
  
          // Set face index
          this.parent.currentFaceIndex = (this.parent.currentFaceIndex + repeat + 1) % 2;
          return this;
        }
      }, {
        key: "flipRight",
        value: function flipRight(duration, repeat) {
          if (this.parent.currentFaceIndex === 0) {
            // Front to back
            this.setFrontToBackDirection(0);
          } else {
            // Back to front
            this.setBackToFrontDirection(0);
          }
          this.flip(duration, repeat);
          return this;
        }
      }, {
        key: "flipLeft",
        value: function flipLeft(duration, repeat) {
          if (this.parent.currentFaceIndex === 0) {
            // Front to back
            this.setFrontToBackDirection(1);
          } else {
            // Back to front
            this.setBackToFrontDirection(1);
          }
          this.flip(duration, repeat);
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(gameObject, timer) {
          var t = this.easeFn(timer.t);
          var value = Linear$2(this.startAngle, this.endAngle, t);
          if (gameObject.orientation === 0) {
            gameObject.angleY = value;
          } else {
            gameObject.angleX = value;
          }
        }
      }]);
      return Flip;
    }(EaseValueTaskBase);
    var DIRMODE = {
      'right': 0,
      'left-to-right': 0,
      'left': 1,
      'right-to-left': 1
    };
  
    var IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$N = Phaser.Utils.Objects.GetValue;
    var FaceNames = ['back', 'front'];
    var Card = /*#__PURE__*/function (_FaceContainer) {
      _inherits(Card, _FaceContainer);
      function Card(scene, x, y, config) {
        var _this;
        _classCallCheck(this, Card);
        if (IsPlainObject$7(x)) {
          config = x;
          x = GetValue$N(config, 'x', 0);
          y = GetValue$N(config, 'y', 0);
        }
        var faces = CreateFaces(scene, config, FaceNames);
        var backFace = faces.back;
        var frontFace = faces.front;
        var width = GetValue$N(config, 'width');
        var height = GetValue$N(config, 'height');
        if (width === undefined || height === undefined) {
          if (width === undefined) {
            var frontFaceWidth = frontFace ? frontFace.width : 0;
            var backFaceWidth = backFace ? backFace.width : 0;
            width = Math.max(frontFaceWidth, backFaceWidth);
          }
          if (height === undefined) {
            var frontFaceHeight = frontFace ? frontFace.height : 0;
            var backFaceHeight = backFace ? backFace.height : 0;
            height = Math.max(frontFaceHeight, backFaceHeight);
          }
        }
        _this = _callSuper(this, Card, [scene, x, y, width, height, faces]);
        _this.type = 'rexPerspectiveCard';
        _this.frontFaceRotationX = 0;
        _this.frontFaceRotationY = 0;
        _this.frontFaceRotationZ = 0;
        ForEachFace(faces, function (face, name) {
          this["".concat(name, "Face")] = face;
        }, _assertThisInitialized(_this));
        var flipConfig = GetValue$N(config, 'flip', undefined);
        if (flipConfig !== false) {
          _this.flip = new Flip$1(_assertThisInitialized(_this), flipConfig);
        }
        _this.setOrientation(GetValue$N(config, 'orientation', 0));
        LayoutFaces(_assertThisInitialized(_this), faces);
        _this.setFace(GetValue$N(config, 'face', 0));
        return _this;
      }
      _createClass(Card, [{
        key: "rotationX",
        get: function get() {
          return this.frontFaceRotationX;
        },
        set: function set(value) {
          if (this.frontFaceRotationX === value) {
            return;
          }
          this.frontFaceRotationX = value;
          ForEachFace(this.faces, function (face) {
            face.rotationX = value;
          }, null, true);
        }
      }, {
        key: "rotationY",
        get: function get() {
          return this.frontFaceRotationY;
        },
        set: function set(value) {
          if (this.frontFaceRotationY === value) {
            return;
          }
          this.frontFaceRotationY = value;
          ForEachFace(this.faces, function (face) {
            face.rotationY = value;
          }, null, true);
        }
      }, {
        key: "rotationZ",
        get: function get() {
          return this.frontFaceRotationZ;
        },
        set: function set(value) {
          if (this.frontFaceRotationZ === value) {
            return;
          }
          this.frontFaceRotationZ = value;
          ForEachFace(this.faces, function (face) {
            face.rotationZ = value;
          }, null, true);
        }
      }, {
        key: "setOrientation",
        value: function setOrientation(orientation) {
          if (typeof orientation === 'string') {
            orientation = ORIENTATIONMODE$1[orientation];
          }
          this.orientation = orientation;
          return this;
        }
      }, {
        key: "face",
        get: function get() {
          return this.currentFaceIndex;
        },
        set: function set(index) {
          if (typeof index === 'string') {
            index = FACEMODE$1[index];
          }
          this.currentFaceIndex = index;
          var isBackFace = index === 1;
          var angle = isBackFace ? 180 : 0;
          if (this.orientation === 0) {
            // Flip around Y
            this.angleY = angle;
          } else {
            // Flip around X
            this.angleX = angle;
          }
        }
      }, {
        key: "setFace",
        value: function setFace(face) {
          this.face = face;
          return this;
        }
      }, {
        key: "toggleFace",
        value: function toggleFace() {
          var newFace = this.face === 0 ? 1 : 0;
          this.setFace(newFace);
          return this;
        }
      }]);
      return Card;
    }(FaceContainer);
    var ORIENTATIONMODE$1 = {
      x: 0,
      horizontal: 0,
      h: 0,
      y: 1,
      vertical: 1,
      v: 1
    };
    var FACEMODE$1 = {
      front: 0,
      back: 1
    };
  
    Phaser.Utils.Objects.GetValue;
    Phaser.Math.RadToDeg;
    Phaser.Math.DegToRad;
    Phaser.Math.Angle.WrapDegrees;
    Phaser.Math.Angle.ShortestBetween;
    Phaser.Math.Wrap;
    Phaser.Math.Linear;
  
    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
    Phaser.Math.DegToRad;
    Phaser.Math.RadToDeg;
    Phaser.Math.Angle.WrapDegrees;
    Phaser.Math.Linear;
    Phaser.Math.Wrap;
  
    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
    Phaser.Math.Wrap;
  
    var GetValue$M = Phaser.Utils.Objects.GetValue;
    var Init = function Init(parentContainer, rtOwner, config) {
      rtOwner.visibleSibling = [];
      rtOwner.isRunning = false;
      rtOwner.useParentBounds = GetValue$M(config, 'useParentBounds', false);
      rtOwner.setPosition(parentContainer.x, parentContainer.y).setVisible(false);
      parentContainer.pin(rtOwner);
    };
  
    var Exit = function Exit(parentContainer, rtOwner) {
      if (!parentContainer) {
        return false;
      }
      var visibleSibling = rtOwner.visibleSibling;
      // Set all visible children back
      for (var i = 0, cnt = visibleSibling.length; i < cnt; i++) {
        parentContainer.setChildVisible(visibleSibling[i], true);
      }
      visibleSibling.length = 0;
  
      // Set rtOwner to be invisible
      parentContainer.setChildVisible(rtOwner, false);
      rtOwner.isRunning = false;
      return true;
    };
  
    var Enter = function Enter(parentContainer, rtOwner) {
      if (!parentContainer) {
        return false;
      }
      Exit(parentContainer, rtOwner);
  
      // Get and paste all visible children, which dose not include this render texture
      var useParentBounds = rtOwner.useParentBounds;
      Snapshot({
        gameObjects: parentContainer.getAllVisibleChildren(),
        renderTexture: rtOwner.rt,
        x: rtOwner.x,
        y: rtOwner.y,
        width: useParentBounds ? parentContainer.displayWidth : undefined,
        height: useParentBounds ? parentContainer.displayHeighth : undefined,
        originX: useParentBounds ? parentContainer.originX : undefined,
        originY: useParentBounds ? parentContainer.originY : undefined
      });
  
      // Set rtOwner to be visible
      parentContainer.setChildVisible(rtOwner, true);
  
      // Set visible sibling to be invisible
      var visibleSibling = rtOwner.visibleSibling;
      var children = parentContainer.children;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (child.visible && child !== rtOwner) {
          parentContainer.setChildVisible(child, false);
          visibleSibling.push(child);
        }
      }
      rtOwner.isRunning = true;
      return true;
    };
  
    var MeshRenderTextureBase = function MeshRenderTextureBase(RenderTextureOwnerClass) {
      return /*#__PURE__*/function (_RenderTextureOwnerCl) {
        _inherits(Base, _RenderTextureOwnerCl);
        function Base(parentContainer, config) {
          var _this;
          _classCallCheck(this, Base);
          var scene = parentContainer.scene;
          _this = _callSuper(this, Base, [scene, 0, 0, 1, 1, config]);
          scene.add.existing(_assertThisInitialized(_this));
          Init(parentContainer, _assertThisInitialized(_this), config);
          return _this;
        }
        _createClass(Base, [{
          key: "destroy",
          value: function destroy(fromScene) {
            if (!this.scene || this.ignoreDestroy) {
              return;
            }
            this.exit();
            _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
          }
        }, {
          key: "enter",
          value: function enter() {
            var result = Enter(this.rexContainer.parent, this);
            if (result) {
              this.syncSize();
            }
            return this;
          }
        }, {
          key: "exit",
          value: function exit() {
            Exit(this.rexContainer.parent, this);
            return this;
          }
        }]);
        return Base;
      }(RenderTextureOwnerClass);
    };
  
    var ContainerPerspective = /*#__PURE__*/function (_MeshRenderTextureBas) {
      _inherits(ContainerPerspective, _MeshRenderTextureBas);
      function ContainerPerspective() {
        _classCallCheck(this, ContainerPerspective);
        return _callSuper(this, ContainerPerspective, arguments);
      }
      _createClass(ContainerPerspective, [{
        key: "perspectiveState",
        get: function get() {
          return this.isRunning;
        }
      }]);
      return ContainerPerspective;
    }(MeshRenderTextureBase(RenderTexture));
  
    var GetValue$L = Phaser.Utils.Objects.GetValue;
    var CreatePerspectiveCardMesh = function CreatePerspectiveCardMesh(config) {
      var scene = this.scene;
      this.setSnapshotPadding(GetValue$L(config, 'snapshotPadding', 0));
      config = Clone$2(config);
      // Remove size config
      delete config.width;
      delete config.height;
      // Initial size of render-texture is 1x1
      config.front = {
        width: 1,
        height: 1
      };
      config.back = {
        width: 1,
        height: 1
      };
      // Create PerspectiveCard as card-behavior
      var card = new Card(scene, config);
      scene.add.existing(card);
      var flip = card.flip;
      if (flip) {
        var parent = this;
        flip.on('start', function () {
          // Before flipping
          parent.enterPerspectiveMode();
        }).on('complete', function () {
          // After flipping
          parent.exitPerspectiveMode();
        });
      }
      return card;
    };
  
    var FaceIndexMap = ['front', 'back'];
    var PerspectiveMethods = {
      enterPerspectiveMode: function enterPerspectiveMode() {
        if (this.isInPerspectiveMode) {
          return this;
        }
  
        // Set card's visible to true
        this.setChildVisible(this.perspectiveCard, true);
        // Snapshot front and back children to card's faces
        this.snapshotFace(0);
        this.snapshotFace(1);
        // Set front and back children's visible to false
        this.setChildVisible(this.childrenMap.front, false);
        this.setChildVisible(this.childrenMap.back, false);
        // Reset size of card
        this.perspectiveCard.setSize(this.width, this.height);
        return this;
      },
      exitPerspectiveMode: function exitPerspectiveMode() {
        if (!this.isInPerspectiveMode) {
          return this;
        }
  
        // Set card's visible to false
        this.setChildVisible(this.perspectiveCard, false);
        // Set front or back children's visible to true, according to card's face
        var isFrontFace = this.perspectiveCard.face === 0;
        this.setChildVisible(this.childrenMap.front, isFrontFace);
        this.setChildVisible(this.childrenMap.back, !isFrontFace);
        return this;
      },
      setSnapshotPadding: function setSnapshotPadding(padding) {
        this.snapshotPadding = padding;
        return this;
      },
      snapshotFace: function snapshotFace(face) {
        if (typeof face === 'number') {
          face = FaceIndexMap[face];
        }
        var cardFace = this.perspectiveCard.faces[face];
        var faceChild = this.childrenMap[face];
        cardFace.rt.clear();
        var faceChildVisibleSave = faceChild.visible;
        faceChild.visible = true;
        var gameObjects = faceChild.isRexContainerLite ? faceChild.getAllVisibleChildren() : faceChild;
        cardFace.snapshot(gameObjects, {
          padding: this.snapshotPadding
        });
        faceChild.visible = faceChildVisibleSave;
        return this;
      }
    };
  
    var GetValue$K = Phaser.Utils.Objects.GetValue;
    var PerspectiveCard = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(PerspectiveCard, _OverlapSizer);
      function PerspectiveCard(scene, config) {
        var _this;
        _classCallCheck(this, PerspectiveCard);
        _this = _callSuper(this, PerspectiveCard, [scene, config]);
        _this.type = 'rexPerspectiveCard';
  
        // Layout faces
        var backFace = config.back;
        var backFaceExpand = GetValue$K(config, 'expand.back', true);
        _this.add(backFace, {
          key: 'back',
          expand: backFaceExpand
        });
        var frontFace = config.front;
        var frontFaceExpand = GetValue$K(config, 'expand.front', true);
        _this.add(frontFace, {
          key: 'front',
          expand: frontFaceExpand
        });
  
        // Add PerspectiveCardMesh
        _this.perspectiveCard = CreatePerspectiveCardMesh.call(_assertThisInitialized(_this), config);
        _this.pin(_this.perspectiveCard);
        _this.exitPerspectiveMode(false);
        return _this;
      }
      _createClass(PerspectiveCard, [{
        key: "flip",
        get: function get() {
          return this.perspectiveCard.flip;
        }
      }, {
        key: "face",
        get: function get() {
          return this.perspectiveCard.face;
        },
        set: function set(index) {
          // Can't set face during flipping
          if (this.flip && this.flip.isRunning) {
            return;
          }
          this.perspectiveCard.face = index;
          var isFrontFace = index === 0;
          var frontFace = this.childrenMap.front;
          var backFace = this.childrenMap.back;
          this.setChildVisible(frontFace, isFrontFace);
          this.setChildVisible(backFace, !isFrontFace);
        }
      }, {
        key: "setFace",
        value: function setFace(face) {
          this.face = face;
          return this;
        }
      }, {
        key: "toggleFace",
        value: function toggleFace() {
          var newFace = this.face === 0 ? 1 : 0;
          this.setFace(newFace);
          return this;
        }
      }, {
        key: "isInPerspectiveMode",
        get: function get() {
          return this.perspectiveCard.visible;
        }
      }, {
        key: "rotationX",
        get: function get() {
          return this.perspectiveCard.rotationX;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.rotationX = value;
        }
      }, {
        key: "angleX",
        get: function get() {
          return this.perspectiveCard.angleX;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.angleX = value;
        }
      }, {
        key: "rotationY",
        get: function get() {
          return this.perspectiveCard.rotationY;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.rotationY = value;
        }
      }, {
        key: "angleY",
        get: function get() {
          return this.perspectiveCard.angleY;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.angleY = value;
        }
      }, {
        key: "rotationZ",
        get: function get() {
          return this.perspectiveCard.rotationZ;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.rotationZ = value;
        }
      }, {
        key: "angleZ",
        get: function get() {
          return this.perspectiveCard.angleZ;
        },
        set: function set(value) {
          this.enterPerspectiveMode();
          this.perspectiveCard.angleZ = value;
        }
      }, {
        key: "panX",
        value: function panX(v) {
          this.enterPerspectiveMode();
          this.perspectiveCard.panX(v);
          return this;
        }
      }, {
        key: "panY",
        value: function panY(v) {
          this.enterPerspectiveMode();
          this.perspectiveCard.panY(v);
          return this;
        }
      }, {
        key: "panZ",
        value: function panZ(v) {
          this.enterPerspectiveMode();
          this.perspectiveCard.panZ(v);
          return this;
        }
      }, {
        key: "transformVerts",
        value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
          this.enterPerspectiveMode();
          this.perspectiveCard.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
          return this;
        }
      }, {
        key: "forEachFace",
        value: function forEachFace(callback, scope, ignoreInvalid) {
          this.enterPerspectiveMode();
          this.perspectiveCard.forEachFace(callback, scope, ignoreInvalid);
          return this;
        }
      }]);
      return PerspectiveCard;
    }(OverlapSizer);
    Object.assign(PerspectiveCard.prototype, PerspectiveMethods);
  
    ObjectFactory.register('perspectiveCard', function (config) {
      var gameObject = new PerspectiveCard(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.PerspectiveCard', PerspectiveCard);
  
    var GetPageKeyByIndex = function GetPageKeyByIndex(index) {
      var buttons = this.getElement('tabs.buttons');
      if (index >= buttons.length) {
        return undefined;
      }
      return buttons[index].name;
    };
  
    var GetPageIndexByKey = function GetPageIndexByKey(key) {
      var buttons = this.getElement('tabs.buttons');
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        if (buttons[i].name === key) {
          return i;
        }
      }
      return undefined;
    };
  
    var IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$J = Phaser.Utils.Objects.GetValue;
    var UUID$2 = Phaser.Utils.String.UUID;
    var AddPage = function AddPage(key, tabGameObject, pageGameObject) {
      if (IsPlainObject$6(key)) {
        var config = key;
        key = GetValue$J(config, 'key');
        tabGameObject = GetValue$J(config, 'tab');
        pageGameObject = GetValue$J(config, 'page');
      }
      if (!key) {
        key = UUID$2();
      }
      tabGameObject.name = key; // For ratio buttons
  
      this.childrenMap.tabs.addButton(tabGameObject);
      this.childrenMap.pages.addPage(pageGameObject, {
        key: key
      });
      return this;
    };
  
    var SwapPage = function SwapPage(key, fadeInDuration) {
      var index;
      if (typeof key === 'number') {
        index = key;
      } else {
        index = this.getPageIndex(key);
      }
      if (index != null) {
        // Override fadeInDuration
        var fadeInDurationSave;
        if (fadeInDuration !== undefined) {
          fadeInDurationSave = this.childrenMap.pages.fadeInDuration;
          this.childrenMap.pages.fadeInDuration = fadeInDuration;
        }
        this.childrenMap.tabs.emitButtonClick(index);
  
        // Restore fadeInDuration
        if (fadeInDurationSave !== undefined) {
          this.childrenMap.pages.fadeInDuration = fadeInDurationSave;
        }
      }
      return this;
    };
    var SwapFirstPage = function SwapFirstPage(fadeInDuration) {
      this.swapPage(0, fadeInDuration);
      return this;
    };
    var SwapLastPage = function SwapLastPage(fadeInDuration) {
      var index = this.getElement('tabs.buttons').length - 1;
      this.swapPage(index, fadeInDuration);
      return this;
    };
    var SwapPageMethods = {
      swapPage: SwapPage,
      swapFirstPage: SwapFirstPage,
      swapLastPage: SwapLastPage
    };
  
    var RemovePageMethods = {
      removePage: function removePage(key, destroyChild) {
        if (typeof key === 'number') {
          key = this.getPageKey(key);
        }
        var tabs = this.childrenMap.tabs;
        var tabGameObject = tabs.getByName(key);
        var pages = this.childrenMap.pages;
        var pageGameObject = pages.getElement(key);
        if (!tabGameObject || !pageGameObject) {
          return this;
        }
        pages.removeChildrenMap(key);
        tabs.removeButton(tabGameObject, destroyChild);
        pages.remove(pageGameObject, destroyChild);
        return this;
      },
      removeAllPages: function removeAllPages(destroyChild) {
        var buttons = this.getElement('tabs.buttons');
        for (var i = buttons.length - 1; i >= 0; i--) {
          this.removePage(buttons[i].name, destroyChild);
        }
        return this;
      }
    };
  
    var GetPage = function GetPage(key) {
      if (typeof key === 'number') {
        key = this.getPageKey(key);
      }
      return this.childrenMap.pages.getPage(key);
    };
  
    var GetTab = function GetTab(key) {
      var index;
      if (typeof key === 'number') {
        index = key;
      } else {
        index = this.getPageIndex(key);
      }
      return this.getElement('tabs.buttons')[index];
    };
  
    var TabsPositionToIndex = {
      top: 1,
      left: 3,
      right: 5,
      bottom: 7
    };
    var TabsPositionToTabsPaddingKey = {
      top: 'bottom',
      left: 'right',
      right: 'left',
      bottom: 'top'
    };
    var SetTabPosition = function SetTabPosition(tabsPosition) {
      var newIndex = TabsPositionToIndex[tabsPosition];
      if (newIndex === undefined) {
        return this;
      }
      var tabs = this.childrenMap.tabs;
      var currentIndex = this.sizerChildren.indexOf(tabs);
      if (currentIndex === newIndex) {
        return this;
      }
      this.sizerChildren[currentIndex] = null;
      this.sizerChildren[newIndex] = tabs;
      var tabPadding = this.getSizerConfig(tabs).padding;
      var currentPaddingKey = TabsPositionToTabsPaddingKey[this.tabsPosition];
      var newPaddingKey = TabsPositionToTabsPaddingKey[tabsPosition];
      tabPadding[newPaddingKey] = tabPadding[currentPaddingKey];
      tabPadding[currentPaddingKey] = 0;
      this.tabsPosition = tabsPosition;
      return this;
    };
  
    var methods$9 = {
      getPageKey: GetPageKeyByIndex,
      getPageIndex: GetPageIndexByKey,
      addPage: AddPage,
      getPage: GetPage,
      getTab: GetTab,
      setTabPosition: SetTabPosition
    };
    Object.assign(methods$9, SwapPageMethods, RemovePageMethods);
  
    var GetValue$I = Phaser.Utils.Objects.GetValue;
    var SizerAdd = GridSizer.prototype.add;
    var TabPages$1 = /*#__PURE__*/function (_GridSizer) {
      _inherits(TabPages, _GridSizer);
      function TabPages(scene, config) {
        var _this;
        _classCallCheck(this, TabPages);
        if (config === undefined) {
          config = {};
        }
        // Create sizer
        config.column = 3;
        config.row = 3;
        config.columnProportions = [0, 0, 0];
        config.rowProportions = [0, 0, 0];
        var expandPages = GetValue$I(config, 'expand.pages', true);
        if (expandPages) {
          config.columnProportions[1] = 1;
          config.rowProportions[1] = 1;
        }
        _this = _callSuper(this, TabPages, [scene, config]);
        _this.type = 'rexTabPages';
  
        // Add elements
        var background = GetValue$I(config, 'background', undefined);
        if (background) {
          _this.addBackground(background);
        }
        var pagesConfig = GetValue$I(config, 'pages');
        var pages = new Pages(scene, pagesConfig);
        scene.add.existing(pages);
        var tabsPosition = GetValue$I(config, 'tabsPosition', undefined);
        if (tabsPosition === undefined) {
          tabsPosition = GetValue$I(config, 'tabPosition', 'top');
        }
        var wrapTabs = GetValue$I(config, 'wrapTabs', false);
        var ButtonsClass = wrapTabs ? Buttons : Buttons$1;
        var tabsConfig = GetValue$I(config, 'tabs', undefined);
        if (tabsConfig === undefined) {
          tabsConfig = {};
        }
        tabsConfig.orientation = tabsPosition === 'top' || tabsPosition === 'bottom' ? 'x' : 'y';
        tabsConfig.buttonsType = 'radio';
        if (!wrapTabs && !tabsConfig.hasOwnProperty('expand')) {
          tabsConfig.expand = GetValue$I(config, 'expand.tabs', false);
        }
        var tabs = new ButtonsClass(scene, tabsConfig);
        scene.add.existing(tabs);
  
        // Add to sizer
        SizerAdd.call(_assertThisInitialized(_this), pages, {
          column: 1,
          row: 1,
          expand: expandPages
        });
        var tabColumnIndex, tabRowIndex;
        var tabPadding = GetValue$I(config, 'space.item', 0); // Backward compatible
        switch (tabsPosition) {
          case 'top':
            tabColumnIndex = 1;
            tabRowIndex = 0;
            tabPadding = {
              bottom: tabPadding
            };
            break;
          case 'bottom':
            tabColumnIndex = 1;
            tabRowIndex = 2;
            tabPadding = {
              top: tabPadding
            };
            break;
          case 'left':
            tabColumnIndex = 0;
            tabRowIndex = 1;
            tabPadding = {
              right: tabPadding
            };
            break;
          case 'right':
            tabColumnIndex = 2;
            tabRowIndex = 1;
            tabPadding = {
              left: tabPadding
            };
            break;
        }
        SizerAdd.call(_assertThisInitialized(_this), tabs, {
          column: tabColumnIndex,
          row: tabRowIndex,
          padding: tabPadding,
          expand: wrapTabs ? true : GetValue$I(config, 'expand.tabs', false),
          align: GetValue$I(config, 'align.tabs', 'left')
        });
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('tabs', tabs);
        _this.addChildrenMap('pages', pages);
        _this.tabsPosition = tabsPosition;
  
        // Register events
        tabs.on('button.click', function (tab) {
          var key = tab.name;
          if (pages.hasPage(key)) {
            pages.swapPage(key);
          }
        });
        tabs.on('button.statechange', function (tab, index, value, previousValue) {
          var eventName = value ? 'tab.focus' : 'tab.blur';
          this.emit(eventName, tab, tab.name);
        }, _assertThisInitialized(_this));
        pages.on('pagevisible', function (pageObject, key, pages) {
          this.emit('page.focus', pageObject, key);
        });
        pages.on('pageinvisible', function (pageObject, key, pages) {
          this.emit('page.blur', pageObject, key);
        });
        return _this;
      }
      _createClass(TabPages, [{
        key: "currentKey",
        get: function get() {
          return this.getElement('pages').currentKey;
        },
        set: function set(key) {
          this.showPage(key);
        }
      }, {
        key: "keys",
        get: function get() {
          return this.getElement('pages').keys;
        }
      }, {
        key: "currentPage",
        get: function get() {
          return this.getElement('pages').currentPage;
        }
      }, {
        key: "previousPage",
        get: function get() {
          return this.getElement('pages').previousPage;
        }
      }]);
      return TabPages;
    }(GridSizer);
    Object.assign(TabPages$1.prototype, methods$9);
  
    ObjectFactory.register('tabPages', function (config) {
      var gameObject = new TabPages$1(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TabPages', TabPages$1);
  
    var Transition = /*#__PURE__*/function (_OpenCloseTransition) {
      _inherits(Transition, _OpenCloseTransition);
      function Transition(gameObject, config) {
        _classCallCheck(this, Transition);
        if (config === undefined) {
          config = {};
        }
        config.destroy = false;
        return _callSuper(this, Transition, [gameObject, config]);
      }
      _createClass(Transition, [{
        key: "onOpen",
        value: function onOpen() {
          this.emit('open', this.parent, this);
          _get(_getPrototypeOf(Transition.prototype), "onOpen", this).call(this);
        }
      }, {
        key: "onClose",
        value: function onClose() {
          this.emit('close', this.parent, this);
          _get(_getPrototypeOf(Transition.prototype), "onClose", this).call(this);
        }
      }]);
      return Transition;
    }(OpenCloseTransition);
  
    var ExpandMethods = {
      expand: function expand(duration) {
        if (this.expanded === true) {
          return this;
        }
        if (duration === undefined) {
          duration = this.transitionDuration;
        }
        this.expanded = true;
        var title = this.childrenMap.title;
        var child = this.childrenMap.child;
        this.show(child);
        if (this.reLayoutEnable) {
          var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
          layoutTarget.layout();
        }
        title.emit('folder.expand', duration, this);
        child.emit('folder.expand', duration, this);
        this.emit('expand.start', this);
        this.childTransition.once('open', function () {
          this.emit('expand.complete', this);
        }, this).requestOpen(null, duration);
        return this;
      },
      collapse: function collapse(duration) {
        if (this.expanded === false) {
          return this;
        }
        if (duration === undefined) {
          duration = this.transitionDuration;
        }
        this.expanded = false;
        var title = this.childrenMap.title;
        var child = this.childrenMap.child;
        title.emit('folder.collapse', duration, this);
        child.emit('folder.collapse', duration, this);
        this.emit('collapse.start', this);
        this.childTransition.once('close', function () {
          this.setChildScale(child, 1, 1).hide(child);
          if (this.reLayoutEnable) {
            var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
            layoutTarget.layout();
          }
          this.emit('collapse.complete', this);
        }, this).requestClose(null, duration);
        return this;
      },
      toggle: function toggle(duration) {
        if (this.expanded) {
          this.collapse(duration);
        } else {
          this.expand(duration);
        }
        return this;
      },
      setExpandedState: function setExpandedState(expanded) {
        this.reLayoutEnable = false;
        if (expanded === undefined) {
          this.expanded = undefined;
        } else if (expanded) {
          this.expand(0);
        } else {
          this.collapse(0);
        }
        this.reLayoutEnable = true;
        return this;
      }
    };
  
    var DefaultExpandCallback = function DefaultExpandCallback(gameObject, duration) {
      methods$y.popUp.call(gameObject, duration, this.expandDirection);
    };
    var DefaultCollapseCallback = function DefaultCollapseCallback(gameObject, duration) {
      methods$y.scaleDown.call(gameObject, duration, this.expandDirection);
    };
    var ConfigurationMethods$2 = {
      setTransitionDuration: function setTransitionDuration(duration) {
        this.transitionDuration = duration;
        this.childTransition.setTransitInTime(duration).setTransitOutTime(duration);
        return this;
      },
      setExpandCallback: function setExpandCallback(callback) {
        if (callback === undefined) {
          callback = DefaultExpandCallback.bind(this);
        }
        this.childTransition.setTransitInCallback(callback);
        return this;
      },
      setCollapseCallback: function setCollapseCallback(callback) {
        if (callback === undefined) {
          callback = DefaultCollapseCallback.bind(this);
        }
        this.childTransition.setTransitOutCallback(callback);
        return this;
      }
    };
  
    var GetValue$H = Phaser.Utils.Objects.GetValue;
    var Folder$1 = /*#__PURE__*/function (_Sizer) {
      _inherits(Folder, _Sizer);
      function Folder(scene, config) {
        var _this;
        _classCallCheck(this, Folder);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('orientation')) {
          config.orientation = 1;
        }
        _this = _callSuper(this, Folder, [scene, config]);
        _this.type = 'rexFolder';
        _this.reLayoutEnable = true;
        _this.expanded = undefined;
        _this.expandDirection = _this.orientation === 1 ? 'y' : 'x';
        var background = config.background;
        var title = config.title;
        var child = config.child;
  
        // background
        if (background) {
          _this.addBackground(background);
        }
        var spaceConfig = GetValue$H(config, 'space');
  
        // title
        var defaultAlign = _this.orientation === 1 ? 'left' : 'top';
        var align = GetValue$H(config, 'align.title', defaultAlign);
        var expand = GetValue$H(config, 'expand.title', true);
        _this.add(title, {
          proportion: 0,
          align: align,
          expand: expand,
          padding: {
            left: GetValue$H(spaceConfig, 'titleLeft', 0),
            right: GetValue$H(spaceConfig, 'titleRight', 0),
            top: GetValue$H(spaceConfig, 'titleTop', 0),
            bottom: GetValue$H(spaceConfig, 'titleBottom', 0)
          }
        });
        var toggleByTarget = GetValue$H(config, 'toggleByTarget', undefined);
        var toggleClickConfig = GetValue$H(config, 'toggleClickConfig');
        if (toggleByTarget === undefined) {
          toggleByTarget = title;
        }
        if (toggleByTarget) {
          ClickMethods.onClick.call(toggleByTarget, function () {
            this.toggle();
          }, _assertThisInitialized(_this), toggleClickConfig);
        }
  
        // child
        _this.childTransition = new Transition(child);
        var customOrigin = GetValue$H(config, 'customChildOrigin', false);
        if (!customOrigin) {
          var origin = !_this.rtl ? 0 : 1;
          child.setOrigin(origin);
        }
        var align = GetValue$H(config, 'align.child', 'left');
        var expand = GetValue$H(config, 'expand.child', true);
        var proportion = expand ? 1 : 0;
        _this.add(child, {
          proportion: proportion,
          align: align,
          expand: expand,
          padding: {
            left: GetValue$H(spaceConfig, 'childLeft', 0),
            right: GetValue$H(spaceConfig, 'childRight', 0),
            top: GetValue$H(spaceConfig, 'childTop', 0),
            bottom: GetValue$H(spaceConfig, 'childBottom', 0)
          }
        });
        _this.addChildrenMap('title', title);
        _this.addChildrenMap('child', child);
        _this.addChildrenMap('background', background);
        var transitionConfig = config.transition;
        _this.setTransitionDuration(GetValue$H(transitionConfig, 'duration', 200));
        _this.setExpandCallback(GetValue$H(transitionConfig, 'expandCallback', undefined));
        _this.setCollapseCallback(GetValue$H(transitionConfig, 'collapseCallback', undefined));
        _this.reLayoutTarget = GetValue$H(config, 'reLayoutTarget', undefined);
        var onExpandStart = config.onExpandStart;
        if (onExpandStart) {
          _this.on('expand.start', onExpandStart);
        }
        var onExpandComplete = config.onExpandComplete;
        if (onExpandComplete) {
          _this.on('expand.complete', onExpandComplete);
        }
        var onCollapseStart = config.onCollapseStart;
        if (onCollapseStart) {
          _this.on('collapse.start', onCollapseStart);
        }
        var onCollapseComplete = config.onCollapseComplete;
        if (onCollapseComplete) {
          _this.on('collapse.complete', onCollapseComplete);
        }
        var expanded = GetValue$H(config, 'expanded', undefined);
        if (expanded !== undefined) {
          _this.setExpandedState(expanded);
        }
        return _this;
      }
      return _createClass(Folder);
    }(Sizer);
    Object.assign(Folder$1.prototype, ExpandMethods, ConfigurationMethods$2);
  
    ObjectFactory.register('folder', function (config) {
      var gameObject = new Folder$1(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Folder', Folder$1);
  
    var ExtendNodeClass = function ExtendNodeClass(GOClass) {
      return /*#__PURE__*/function (_GOClass) {
        _inherits(Base, _GOClass);
        function Base() {
          _classCallCheck(this, Base);
          return _callSuper(this, Base, arguments);
        }
        _createClass(Base, [{
          key: "setText",
          value:
          // Wrap text/setText() from nodeBody
          function setText(text) {
            this.text = text;
            return this;
          }
        }, {
          key: "text",
          get: function get() {
            var textObject = this.childrenMap.nodeBody;
            return textObject.text;
          },
          set: function set(value) {
            var textObject = this.childrenMap.nodeBody;
            if (textObject.setText) {
              textObject.setText(value);
            }
          }
  
          // Wrap setTexture() from nodeBody
        }, {
          key: "setTexture",
          value: function setTexture(key, frame) {
            var imageObject = this.childrenMap.nodeBody;
            if (imageObject.setTexture) {
              imageObject.setTexture(key, frame);
            }
            return this;
          }
        }, {
          key: "texture",
          get: function get() {
            var imageObject = this.childrenMap.nodeBody;
            if (!imageObject) {
              return undefined;
            }
            return imageObject.texture;
          }
        }, {
          key: "frame",
          get: function get() {
            var imageObject = this.childrenMap.nodeBody;
            if (!imageObject) {
              return undefined;
            }
            return imageObject.frame;
          }
        }]);
        return Base;
      }(GOClass);
    };
  
    var ParentMethods = {
      getTreePatent: function getTreePatent(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        if (!gameObject.rexSizer) {
          return undefined;
        }
        return gameObject.rexSizer.treeParent;
      },
      getTreeRoot: function getTreeRoot(gameObject) {
        if (gameObject === undefined) {
          gameObject = this;
        }
        var treeParent;
        while (1) {
          if (!gameObject.rexSizer) {
            return undefined;
          }
          treeParent = gameObject.rexSizer.treeParent;
          if (treeParent === null) {
            return gameObject;
          }
          gameObject = treeParent;
        }
        return undefined;
      },
      isGrandsonNode: function isGrandsonNode(gameObject) {
        if (gameObject === undefined || !gameObject.rexSizer) {
          return false;
        }
        var treeParent;
        while (1) {
          if (!gameObject.rexSizer) {
            return false;
          }
          treeParent = gameObject.rexSizer.treeParent;
          if (treeParent === this) {
            return true;
          } else if (treeParent === null) {
            return false;
          }
          gameObject = treeParent;
        }
        return false;
      }
    };
  
    var GetValue$G = Phaser.Utils.Objects.GetValue;
    var GetGameObjectFromConfig = function GetGameObjectFromConfig(scene, config, key, createCallbackData, defaultCreateGameObjectCallback) {
      var creatorConfig = GetValue$G(config, key);
      var gameObject;
      if (IsGameObject(creatorConfig)) {
        gameObject = creatorConfig;
        delete config[key]; // Remove reference of game object
      } else if (IsFunction(creatorConfig)) {
        gameObject = creatorConfig(scene, createCallbackData);
        scene.add.existing(gameObject);
      } else if (defaultCreateGameObjectCallback) {
        gameObject = defaultCreateGameObjectCallback(scene, creatorConfig, createCallbackData);
        scene.add.existing(gameObject);
      }
      return gameObject;
    };
  
    var GetValue$F = Phaser.Utils.Objects.GetValue;
    var Node = /*#__PURE__*/function (_ExtendNodeClass) {
      _inherits(Node, _ExtendNodeClass);
      function Node(scene, config, createCallbackData) {
        var _this;
        _classCallCheck(this, Node);
        var spaceConfig = config.space;
        _this = _callSuper(this, Node, [scene, {
          orientation: 'x',
          space: {
            left: GetValue$F(spaceConfig, 'nodeLeft', 0),
            right: GetValue$F(spaceConfig, 'nodeRight', 0),
            top: GetValue$F(spaceConfig, 'nodeTop', 0),
            bottom: GetValue$F(spaceConfig, 'nodeBottom', 0)
          }
        }]);
        _this.type = 'rexTreeNode';
  
        // Optional
        var nodeBackground = GetGameObjectFromConfig(scene, config, 'nodeBackground', createCallbackData);
  
        // Required
        var nodeBody = GetGameObjectFromConfig(scene, config, 'nodeBody', createCallbackData, DefaultCreateNodeBodyCallback);
        if (nodeBackground) {
          _this.addBackground(nodeBackground);
        }
        _this.add(nodeBody, {
          proportion: 1,
          key: 'nodeBody'
        });
        return _this;
      }
      _createClass(Node, [{
        key: "getTreePatent",
        value: function getTreePatent() {
          return this.rexSizer.treeParent;
        }
      }, {
        key: "getTreeRoot",
        value: function getTreeRoot() {
          var treeParent = this.rexSizer.treeParent;
          if (!treeParent) {
            return null;
          }
          return treeParent.getTreeRoot();
        }
      }]);
      return Node;
    }(ExtendNodeClass(Sizer));
    var DefaultCreateNodeBodyCallback = function DefaultCreateNodeBodyCallback(scene, config, createCallbackData) {
      var gameObject = new SimpleLabel(scene, config);
      gameObject.resetDisplayContent('');
      return gameObject;
    };
  
    var SyncDisplayList = function SyncDisplayList(sourceGameObject, targetGameObject) {
      var p3Container = sourceGameObject.parentContainer;
      if (p3Container) {
        if (targetGameObject.isRexContainerLite) {
          // Add containerLite and its children
          targetGameObject.addToContainer(p3Container);
        } else {
          // Add gameObject directly
          p3Container.add(targetGameObject);
        }
        return;
      }
      var layer = sourceGameObject.displayList;
      if (IsLayerGameObject(layer)) {
        if (targetGameObject.isRexContainerLite) {
          // Add containerLite and its children
          targetGameObject.addToLayer(layer);
        } else {
          // Add gameObject directly
          layer.add(targetGameObject);
        }
        return;
      }
      sourceGameObject.scene.add.existing(targetGameObject);
    };
  
    var UUID$1 = Phaser.Utils.String.UUID;
    var AddNodeMethods = {
      addTree: function addTree(config, nodeKey) {
        if (IsGameObject(config)) {
          var nodeBody = config;
          config = {
            nodeBody: nodeBody,
            nodeKey: nodeKey
          };
        }
        return this.insertTree(undefined, config);
      },
      insertTree: function insertTree(index, config) {
        var nodeKey;
        if (typeof config === 'string') {
          nodeKey = config;
          config = undefined;
        } else if (config) {
          nodeKey = config.nodeKey;
          delete config.nodeKey;
        }
        if (nodeKey === undefined) {
          nodeKey = UUID$1();
        }
        var tree = this.createTree(config);
        SyncDisplayList(this, tree);
        this.insertNode(index, tree, {
          expand: true
        });
        return tree;
      },
      addNode: function addNode(gameObject, config) {
        return this.insertNode(undefined, gameObject, config);
      },
      insertNode: function insertNode(index, gameObject, config) {
        var nodeKey;
        if (!IsGameObject(gameObject)) {
          config = gameObject;
          gameObject = new Node(this.scene, this.configSave, {
            isLeaf: true
          });
        }
        if (typeof config === 'string') {
          nodeKey = config;
          config = undefined;
        } else if (config) {
          nodeKey = config.nodeKey;
          delete config.nodeKey;
        }
        if (nodeKey === undefined) {
          nodeKey = UUID$1();
        }
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('expand')) {
          config.expand = true;
        }
        this.removeNode(gameObject, false);
        gameObject.rexSizer.treeParent = this;
        if (this.nodesMap.hasOwnProperty(nodeKey)) {
          console.error("[Trees] Duplicate nodeKey '".concat(nodeKey, "'"));
          this.removeNode(this.nodesMap[nodeKey], true);
        }
        gameObject.nodeKey = nodeKey;
        this.nodesMap[nodeKey] = gameObject;
        var childrenSizer = this.childrenMap.child;
        childrenSizer.insert(index, gameObject, config);
        return gameObject;
      }
    };
  
    var RemoveNodeMethods = {
      removeNode: function removeNode(gameObject, destroyChild) {
        if (!gameObject) {
          return this;
        }
        var treeParent = this.getTreePatent(gameObject);
        if (!treeParent) {
          return this;
        }
        delete treeParent.nodesMap[gameObject.nodeKey];
        gameObject.nodeKey = null;
        gameObject.rexSizer.treeParent = null;
        var childrenSizer = treeParent.childrenMap.child;
        childrenSizer.remove(gameObject, destroyChild);
        return this;
      },
      removeAllNodes: function removeAllNodes(destroyChild) {
        var nodesMap = this.nodesMap;
        for (var nodeKey in nodesMap) {
          this.removeNode(nodesMap[nodeKey], destroyChild);
        }
        return this;
      }
    };
  
    var GetNodeMethods = {
      getNode: function getNode(mapNameList) {
        if (typeof mapNameList === 'string') {
          mapNameList = mapNameList.split('.');
        }
        if (mapNameList.length === 0) {
          return undefined;
        }
        var name = mapNameList.shift();
        var element = this.nodesMap[name];
        if (mapNameList.length === 0) {
          return element;
        } else if (element && this.isTree(element)) {
          return element.getNode(mapNameList);
        } else {
          return null;
        }
      },
      getNodes: function getNodes(out) {
        var nodesMap = this.nodesMap;
        if (!out) {
          out = nodes; // Return internal children array
        } else {
          for (var nodeKey in nodesMap) {
            out.push(nodesMap[nodeKey]);
          }
          // Copy children
        }
        return out;
      },
      getAllNodes: function getAllNodes(out) {}
    };
  
    var methods$8 = {};
    Object.assign(methods$8, ParentMethods, AddNodeMethods, RemoveNodeMethods, GetNodeMethods);
  
    var GetValue$E = Phaser.Utils.Objects.GetValue;
    var CreateTitleSizer = function CreateTitleSizer(scene, config) {
      var nodeSizer = new Node(scene, config, {
        isLeaf: false
      });
      scene.add.existing(nodeSizer);
  
      // Required
      var toggleButton = GetGameObjectFromConfig(scene, config, 'toggleButton', {
        isLeaf: false
      }, DefaultCreateToggleButtonCallback);
      nodeSizer.insert(0, toggleButton, {
        padding: {
          right: GetValue$E(config, 'space.toggleButton', 0)
        },
        fitRatio: 1,
        key: 'toggleButton'
      });
      return nodeSizer;
    };
    var DefaultCreateToggleButtonCallback = function DefaultCreateToggleButtonCallback(scene, config, createCallbackData) {
      var gameObject = new Triangle(scene, config);
      gameObject.on('expand.start', function (gameObject) {
        gameObject.setDirection('down');
      }).on('collapse.complete', function (gameObject) {
        gameObject.setDirection('right');
      });
      return gameObject;
    };
  
    var GetValue$D = Phaser.Utils.Objects.GetValue;
    var CreateChildrenSizer = function CreateChildrenSizer(scene, config) {
      var childrenSizer = new Sizer(scene, {
        orientation: GetValue$D(config, 'childrenOrientation', 'y')
      });
      scene.add.existing(childrenSizer);
  
      // Optional
      var childrenBackground = GetGameObjectFromConfig(scene, config, 'childrenBackground', {
        isLeaf: false
      });
      if (childrenBackground) {
        childrenSizer.addBackground(childrenBackground);
      }
      return childrenSizer;
    };
  
    var Clone$1 = Phaser.Utils.Objects.Clone;
    var Merge$1 = function Merge(defaultConfig, overrideConfig) {
      var config = defaultConfig ? Clone$1(defaultConfig) : {};
      if (!overrideConfig) {
        return config;
      }
      for (var name in overrideConfig) {
        config[name] = overrideConfig[name];
      }
      return config;
    };
  
    var GetValue$C = Phaser.Utils.Objects.GetValue;
    var Tree = /*#__PURE__*/function (_ExtendNodeClass) {
      _inherits(Tree, _ExtendNodeClass);
      function Tree(scene, config) {
        var _this;
        _classCallCheck(this, Tree);
        if (config === undefined) {
          config = {};
        }
        var background = GetGameObjectFromConfig(scene, config, 'background', {
          isLeaf: false
        });
        var child = CreateChildrenSizer(scene, config);
        var childrenNodes = child.childrenMap.items;
        var title = CreateTitleSizer(scene, config);
        var toggleButton = title.childrenMap.toggleButton;
        var nodeBody = title.childrenMap.nodeBody;
        var orientation = GetOrientationMode(GetValue$C(config, 'orientation', 'y'));
        var spaceConfig = config.space;
        if (spaceConfig) {
          var indent = GetValue$C(spaceConfig, 'indent', 0);
          spaceConfig.childLeft = GetValue$C(spaceConfig, 'indentLeft', orientation === 1 ? indent : 0);
          spaceConfig.childRight = GetValue$C(spaceConfig, 'indentRight', 0);
          spaceConfig.childTop = GetValue$C(spaceConfig, 'indentTop', orientation === 0 ? indent : 0);
          spaceConfig.childBottom = GetValue$C(spaceConfig, 'indentBottom', 0);
        }
        var folderConfig = {
          background: background,
          title: title,
          child: child,
          toggleByTarget: toggleButton,
          transition: config.transition,
          orientation: orientation,
          space: spaceConfig,
          align: config.align,
          expand: config.expand
        };
        _this = _callSuper(this, Tree, [scene, folderConfig]);
        _this.type = 'rexTree';
        _this.rexSizer.treeParent = null;
        _this.nodesMap = {};
        _this.configSave = config;
        _this.addChildrenMap('toggleButton', toggleButton);
        _this.addChildrenMap('nodeBody', nodeBody);
        _this.addChildrenMap('childrenNodes', childrenNodes);
        _this.on('expand.start', function () {
          toggleButton.emit('expand.start', toggleButton);
        }).on('expand.complete', function () {
          toggleButton.emit('expand.complete', toggleButton);
        }).on('collapse.start', function () {
          toggleButton.emit('collapse.start', toggleButton);
        }).on('collapse.complete', function () {
          toggleButton.emit('collapse.complete', toggleButton);
        });
        var expanded = GetValue$C(config, 'expanded', true);
        if (expanded !== undefined) {
          _this.setExpandedState(expanded);
        }
        return _this;
      }
      _createClass(Tree, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.configSave = undefined;
          Clear(this.nodesMap);
          this.nodesMap = undefined;
          _get(_getPrototypeOf(Tree.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "createTree",
        value: function createTree(config) {
          return Tree.CreateTree(this.scene, this.configSave, config);
        }
      }, {
        key: "isTree",
        value: function isTree(gameObject) {
          return !!gameObject && gameObject instanceof TreeNode;
        }
      }]);
      return Tree;
    }(ExtendNodeClass(Folder$1)); // Static method
    Tree.CreateTree = function (scene, defaultConfig, overrideConfig) {
      return new Tree(scene, Merge$1(defaultConfig, overrideConfig));
    };
    Object.assign(Tree.prototype, methods$8);
  
    var UUID = Phaser.Utils.String.UUID;
    var AddTreeMethods = {
      addTree: function addTree(config) {
        if (IsGameObject(config)) {
          var nodeBody = config;
          config = {
            nodeBody: nodeBody,
            nodeKey: nodeKey
          };
        }
        return this.insertTree(undefined, config);
      },
      insertTree: function insertTree(index, config) {
        var nodeKey;
        if (typeof config === 'string') {
          nodeKey = config;
          config = undefined;
        } else if (config) {
          nodeKey = config.nodeKey;
          delete config.nodeKey;
        }
        if (nodeKey === undefined) {
          nodeKey = UUID();
        }
        var tree = Tree.CreateTree(this.scene, this.treeConfig, config);
        SyncDisplayList(this, tree);
        tree.nodeKey = nodeKey;
        this.treesMap[nodeKey] = tree;
        this.insert(index, tree, {
          expand: true
        });
        return tree;
      }
    };
  
    var RemoveTreeMethods = {
      removeTree: function removeTree(gameObject, destroyChild) {
        if (!gameObject) {
          return this;
        }
        delete this.treesMap[gameObject.nodeKey];
        gameObject.nodeKey = null;
        this.remove(gameObject, destroyChild);
        return this;
      },
      removeAllNodes: function removeAllNodes(destroyChild) {
        var treesMap = this.treesMap;
        for (var nodeKey in treesMap) {
          this.removeTree(treesMap[nodeKey], destroyChild);
        }
        return this;
      }
    };
  
    var GetTreeMethods = {
      getTree: function getTree(nodeKey) {
        return this.treesMap[nodeKey];
      },
      getNode: function getNode(nodeKey) {
        var dotIndex = nodeKey.indexOf('.');
        if (dotIndex === -1) {
          return this.getTree(nodeKey);
        }
        var tree = this.getTree(nodeKey.substring(0, dotIndex));
        if (!tree) {
          return undefined;
        }
        return tree.getNode(nodeKey.substring(dotIndex + 1));
      }
    };
  
    var methods$7 = {};
    Object.assign(methods$7, AddTreeMethods, RemoveTreeMethods, GetTreeMethods);
  
    var GetValue$B = Phaser.Utils.Objects.GetValue;
  
    // TODO extend from TreeNode
    var Trees = /*#__PURE__*/function (_Sizer) {
      _inherits(Trees, _Sizer);
      function Trees(scene, config) {
        var _this;
        _classCallCheck(this, Trees);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('orientation')) {
          config.orientation = 'y';
        }
        _this = _callSuper(this, Trees, [scene, config]);
        _this.type = 'rexTrees';
        _this.treesMap = {};
        _this.treeConfig = GetValue$B(config, 'tree');
        return _this;
      }
      _createClass(Trees, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.treeConfig = undefined;
          Clear(this.treesMap);
          this.treesMap = undefined;
          _get(_getPrototypeOf(Trees.prototype), "destroy", this).call(this, fromScene);
        }
      }]);
      return Trees;
    }(Sizer);
    Object.assign(Trees.prototype, methods$7);
  
    ObjectFactory.register('trees', function (config) {
      var gameObject = new Trees(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Trees', Trees);
  
    ObjectFactory.register('textArea', function (config) {
      var gameObject = new TextArea(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TextArea', TextArea);
  
    var InjectProperties = function InjectProperties(inputText) {
      Object.defineProperty(inputText, 'childOY', {
        configurable: true,
        get: function get() {
          return inputText.textOY;
        },
        set: function set(value) {
          inputText.textOY = value;
        }
      });
      Object.defineProperty(inputText, 'topChildOY', {
        get: function get() {
          return inputText.topTextOY;
        }
      });
      Object.defineProperty(inputText, 'bottomChildOY', {
        get: function get() {
          return inputText.bottomTextOY;
        }
      });
      Object.defineProperty(inputText, 'childVisibleHeight', {
        get: function get() {
          return inputText.textVisibleHeight;
        }
      });
      Object.defineProperty(inputText, 'childHeight', {
        get: function get() {
          return inputText.contentHeight;
        }
      });
    };
  
    var SetTextMethods = {
      setText: function setText(text) {
        var inputText = this.childrenMap.child;
        inputText.setText(text);
        return this;
      },
      appendText: function appendText(text) {
        this.setText(this.text + text);
        return this;
      }
    };
  
    var ScrollMethods = {
      scrollToLine: function scrollToLine(lineIndex) {
        this.setChildOY(-this.lineHeight * lineIndex);
        return this;
      },
      scrollToNextLine: function scrollToNextLine(lineCount) {
        if (lineCount === undefined) {
          lineCount = 1;
        }
        var lineIndex = this.lineIndex + lineCount;
        this.scrollToLine(lineIndex);
        return this;
      }
    };
  
    var GetValue$A = Phaser.Utils.Objects.GetValue;
    var TextAreaInput = /*#__PURE__*/function (_Scrollable) {
      _inherits(TextAreaInput, _Scrollable);
      function TextAreaInput(scene, config) {
        var _this;
        _classCallCheck(this, TextAreaInput);
        if (config === undefined) {
          config = {};
        }
  
        // Create inputText
        var inputTextConfig = GetValue$A(config, 'text');
        var inputText;
        if (IsGameObject(inputTextConfig)) {
          inputText = inputTextConfig;
        } else {
          if (inputTextConfig === undefined) {
            inputTextConfig = {};
          }
          inputTextConfig.textArea = true;
          inputText = new CanvasInput(scene, inputTextConfig);
          scene.add.existing(inputText); // Important: Add to display list for touch detecting
        }
  
        // Inject properties for scrollable interface
        InjectProperties(inputText);
  
        // Fill config of scrollable
        var expandInputTextWidth = inputTextConfig.width === undefined;
        var expandInputTextHeight = inputTextConfig.height === undefined;
        if (expandInputTextWidth) {
          inputText.minWidth = 0;
        }
        if (expandInputTextHeight) {
          inputText.minHeight = 0;
        }
        config.scrollMode = 0; // Vertical
        config.type = 'rexTextAreaInput';
        config.child = {
          gameObject: inputText,
          expandWidth: expandInputTextWidth,
          expandHeight: expandInputTextHeight
        };
        var spaceConfig = GetValue$A(config, 'space', undefined);
        if (spaceConfig) {
          spaceConfig.child = GetValue$A(spaceConfig, 'text', 0);
        }
        config.scroller = false; // No scroller supported
        _this = _callSuper(this, TextAreaInput, [scene, config]);
        _this.addChildrenMap('text', inputText);
  
        // More setting...
  
        // Rsize and move slider
        var prevTextOY, prevContentHeight;
        inputText.on('cursorin', function () {
          var textOY = inputText.textOY,
            contentHeight = inputText.contentHeight;
          var isTextOYChanged = prevTextOY !== textOY;
          var isContentHeightChanged = prevContentHeight !== contentHeight;
          prevTextOY = textOY;
          prevContentHeight = contentHeight;
          if (isContentHeightChanged) {
            this.resizeController();
          }
          if (isTextOYChanged || isContentHeightChanged) {
            this.t = inputText.t;
          }
        }, _assertThisInitialized(_this));
  
        // Route 'textchange', 'close' events
        inputText.on('textchange', function (text) {
          this.emit('textchange', text, this);
        }, _assertThisInitialized(_this)).on('close', function () {
          this.emit('close', this.text, this);
        }, _assertThisInitialized(_this));
  
        // Set initial text if given
        var content = GetValue$A(config, 'content', undefined);
        if (content) {
          _this.setText(content);
        }
        return _this;
      }
      _createClass(TextAreaInput, [{
        key: "text",
        get: function get() {
          return this.childrenMap.child.text;
        },
        set: function set(value) {
          if (value == null) {
            value = '';
          } else {
            value = value.toString();
          }
          if (this.childrenMap.child.text === value) {
            return;
          }
          this.setText(value);
        }
      }, {
        key: "lineHeight",
        get: function get() {
          var inputText = this.childrenMap.child;
          return inputText.lineHeight;
        }
      }, {
        key: "lineIndex",
        get: function get() {
          return Math.floor(-this.childOY / this.lineHeight);
        }
      }, {
        key: "linesCount",
        get: function get() {
          var inputText = this.childrenMap.child;
          return inputText.linesCount;
        }
      }, {
        key: "contentHeight",
        get: function get() {
          var inputText = this.childrenMap.child;
          return inputText.contentHeight;
        }
      }, {
        key: "readOnly",
        get: function get() {
          var inputText = this.childrenMap.child;
          return inputText.readOnly;
        },
        set: function set(value) {
          var inputText = this.childrenMap.child;
          inputText.readOnly = value;
        }
      }, {
        key: "setReadOnly",
        value: function setReadOnly(value) {
          var inputText = this.childrenMap.child;
          inputText.setReadOnly(value);
          return this;
        }
      }, {
        key: "value",
        get: function get() {
          return this.text;
        },
        set: function set(value) {
          this.text = value;
        }
      }]);
      return TextAreaInput;
    }(Scrollable);
    Object.assign(TextAreaInput.prototype, SetTextMethods, ScrollMethods);
  
    ObjectFactory.register('textAreaInput', function (config) {
      var gameObject = new TextAreaInput(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.TextAreaInput', TextAreaInput);
  
    var GetChildrenWidth = function GetChildrenWidth() {
      if (this.rexSizer.hidden) {
        return 0;
      }
      var childWidth;
      var child = this.child,
        childConfig = child.rexSizer;
      var hasUnknownChildWidth = false;
      if (childConfig.hidden) {
        childWidth = 0;
      } else {
        switch (this.scrollMode) {
          case 0:
            childWidth = this.getChildWidth(child);
            if (childWidth === undefined) {
              hasUnknownChildWidth = true;
            }
            break;
          case 1:
            childWidth = 0;
            break;
          default:
            childWidth = 0;
            break;
        }
      }
      if (hasUnknownChildWidth) {
        return undefined;
      }
      return childWidth;
    };
  
    var GetChildrenHeight = function GetChildrenHeight() {
      if (this.rexSizer.hidden) {
        return 0;
      }
      var childHeight;
      var child = this.child,
        childConfig = child.rexSizer;
      var hasUnknownChildHeight = false;
      if (childConfig.hidden) {
        childHeight = 0;
      } else {
        switch (this.scrollMode) {
          case 0:
            childHeight = 0;
            break;
          case 1:
            childHeight = this.getChildHeight(child);
            if (childHeight === undefined) {
              hasUnknownChildHeight = true;
            }
            break;
          default:
            childHeight = 0;
            break;
        }
      }
      if (hasUnknownChildHeight) {
        return undefined;
      }
      return childHeight;
    };
  
    var GetChildrenSizers = function GetChildrenSizers(out) {
      if (out === undefined) {
        out = [];
      }
      if (this.child && this.child.isRexSizer) {
        out.push(this.child);
      }
      return out;
    };
  
    var ResetChildPosition = function ResetChildPosition() {
      var x = this.left;
      var y = this.top;
      switch (this.scrollMode) {
        case 0:
          y += this.childOY;
          break;
        case 1:
          x += this.childOY;
          break;
        default:
          // xy
          y += this.childOY;
          x += this.childOX;
          break;
      }
      this.child.setPosition(x, y);
      this.resetChildPositionState(this.child);
      this.setMaskChildrenFlag();
    };
  
    var LayoutChildren = function LayoutChildren() {
      // LayoutChildren child
      var child = this.child;
      var childWidth, childHeight;
      if (!child.rexSizer.hidden) {
        // Set size
        switch (this.scrollMode) {
          case 0:
            childWidth = this.width;
            break;
          case 1:
            childHeight = this.height;
            break;
        }
        if (child.isRexSizer) {
          child.runLayout(this, childWidth, childHeight);
        } else {
          ResizeGameObject(child, childWidth, childHeight);
        }
  
        // Update local state
        this.resetChildPosition();
        // Layout children-mask
        this.layoutChildrenMask();
        // Re-mask children
        this.maskChildren();
      }
    };
  
    var RemoveChildCallback = function RemoveChildCallback(gameObject, destroyChild) {
      if (destroyChild) {
        return;
      }
      if (gameObject.clearMask) {
        gameObject.clearMask(false);
      }
    };
  
    var methods$6 = {
      getChildrenWidth: GetChildrenWidth,
      getChildrenHeight: GetChildrenHeight,
      getChildrenSizers: GetChildrenSizers,
      resetChildPosition: ResetChildPosition,
      layoutChildren: LayoutChildren,
      removeChildCallback: RemoveChildCallback
    };
    Object.assign(methods$6, ChildrenMaskMethods);
  
    var IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$z = Phaser.Utils.Objects.GetValue;
    var ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;
    var ScrollableBlock = /*#__PURE__*/function (_BaseSizer) {
      _inherits(ScrollableBlock, _BaseSizer);
      function ScrollableBlock(scene, x, y, minWidth, minHeight, config) {
        var _this;
        _classCallCheck(this, ScrollableBlock);
        if (IsPlainObject$5(x)) {
          config = x;
          x = GetValue$z(config, 'x', 0);
          y = GetValue$z(config, 'y', 0);
          minWidth = GetValue$z(config, 'width', undefined);
          minHeight = GetValue$z(config, 'height', undefined);
        } else if (IsPlainObject$5(minWidth)) {
          config = minWidth;
          minWidth = GetValue$z(config, 'width', undefined);
          minHeight = GetValue$z(config, 'height', undefined);
        }
        _this = _callSuper(this, ScrollableBlock, [scene, x, y, minWidth, minHeight, config]);
        _this.type = 'rexScrollableBlock';
        _this.child = undefined;
        _this.childrenMask = undefined;
        _this._childOY = 0;
        _this._childOX = 0;
        _this.execeedTopState = false;
        _this.execeedBottomState = false;
        _this.execeedLeftState = false;
        _this.execeedRightState = false;
        _this.setScrollMode(GetValue$z(config, 'scrollMode', 0));
        var clampChildOY = GetValue$z(config, 'clamplChildOY', true);
        var clampChildOX = GetValue$z(config, 'clamplChildOX', clampChildOY);
        _this.setClampMode(clampChildOY, clampChildOX);
  
        // Add elements
        // No background object, and child does not have padding
        var child = GetValue$z(config, 'child', undefined);
        var expand = GetValue$z(config, 'expand', true);
        if (child.setOrigin) {
          child.setOrigin(0);
        }
        _this.add(child);
        _this.sizerChildren = [child];
        var sizerConfig = _this.getSizerConfig(child);
        sizerConfig.align = ALIGN_LEFTTOP;
        sizerConfig.expand = expand;
        _this.child = child;
  
        // Create mask of child object
        _this.setupChildrenMask(GetValue$z(config, 'mask', undefined));
        if (_this.childrenMask) {
          _this.maskGameObject = MaskToGameObject(_this.childrenMask);
        }
        return _this;
      }
      _createClass(ScrollableBlock, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.destroyChildrenMask();
          this.child = undefined;
          _get(_getPrototypeOf(ScrollableBlock.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setScrollMode",
        value: function setScrollMode(mode) {
          if (typeof mode === 'string') {
            mode = SCROLLMODE$1[mode.toLowerCase()];
          }
          this.scrollMode = mode;
          return this;
        }
      }, {
        key: "setClampMode",
        value: function setClampMode(clampChildOY, clampChildOX) {
          this.clampChildOY = clampChildOY;
          this.clampChildOX = clampChildOX;
          return this;
        }
      }, {
        key: "instHeight",
        get: function get() {
          if (this.scrollMode === 0 || this.scrollMode === 2) {
            return this.height;
          } else {
            // scrollMode === 1
            return this.width;
          }
        }
      }, {
        key: "instWidth",
        get: function get() {
          if (this.scrollMode === 0 || this.scrollMode === 2) {
            return this.width;
          } else {
            // scrollMode === 1
            return this.height;
          }
        }
      }, {
        key: "childHeight",
        get: function get() {
          if (this.scrollMode === 0 || this.scrollMode === 2) {
            return GetDisplayHeight(this.child);
          } else {
            // scrollMode === 1
            return GetDisplayWidth(this.child);
          }
        }
      }, {
        key: "childWidth",
        get: function get() {
          if (this.scrollMode === 0 || this.scrollMode === 2) {
            return GetDisplayWidth(this.child);
          } else {
            // scrollMode === 1
            return GetDisplayHeight(this.child);
          }
        }
      }, {
        key: "topChildOY",
        get: function get() {
          return 0;
        }
      }, {
        key: "bottomChildOY",
        get: function get() {
          return -this.visibleHeight;
        }
      }, {
        key: "leftChildOX",
        get: function get() {
          return 0;
        }
      }, {
        key: "rightChildOX",
        get: function get() {
          return -this.visibleWidth;
        }
      }, {
        key: "childVisibleHeight",
        get: function get() {
          return this.instHeight;
        }
      }, {
        key: "childVisibleWidth",
        get: function get() {
          return this.instWidth;
        }
      }, {
        key: "visibleHeight",
        get: function get() {
          var h = this.childHeight - this.childVisibleHeight;
          if (h < 0) {
            h = 0;
          }
          return h;
        }
      }, {
        key: "visibleWidth",
        get: function get() {
          var w = this.childWidth - this.childVisibleWidth;
          if (w < 0) {
            w = 0;
          }
          return w;
        }
      }, {
        key: "childOYExceedTop",
        value: function childOYExceedTop(oy) {
          if (oy === undefined) {
            oy = this.childOY;
          }
          return oy > this.topChildOY;
        }
      }, {
        key: "childOYExeceedBottom",
        value: function childOYExeceedBottom(oy) {
          if (oy === undefined) {
            oy = this.childOY;
          }
          return oy < this.bottomChildOY;
        }
      }, {
        key: "childOXExceedLeft",
        value: function childOXExceedLeft(ox) {
          if (ox === undefined) {
            ox = this.childOX;
          }
          return ox > this.leftChildOX;
        }
      }, {
        key: "childOXExeceedRight",
        value: function childOXExeceedRight(ox) {
          if (ox === undefined) {
            ox = this.childOX;
          }
          return ox < this.rightChildOX;
        }
      }, {
        key: "childOY",
        get: function get() {
          return this._childOY;
        },
        set: function set(oy) {
          var topChildOY = this.topChildOY;
          var bottomChildOY = this.bottomChildOY;
          var childOYExceedTop = this.childOYExceedTop(oy);
          var childOYExeceedBottom = this.childOYExeceedBottom(oy);
          if (this.clampChildOY) {
            if (this.childVisibleHeight > this.childHeight) {
              oy = 0;
            } else if (childOYExceedTop) {
              oy = topChildOY;
            } else if (childOYExeceedBottom) {
              oy = bottomChildOY;
            }
          }
          if (this._childOY !== oy) {
            this._childOY = oy;
            this.resetChildPosition();
          }
          if (childOYExceedTop) {
            if (!this.execeedTopState) {
              this.emit('execeedtop', this, oy, topChildOY);
            }
          }
          this.execeedTopState = childOYExceedTop;
          if (childOYExeceedBottom) {
            if (!this.execeedBottomState) {
              this.emit('execeedbottom', this, oy, bottomChildOY);
            }
          }
          this.execeedBottomState = childOYExeceedBottom;
        }
      }, {
        key: "childOX",
        get: function get() {
          return this._childOX;
        },
        set: function set(ox) {
          var leftChildOX = this.leftChildOX;
          var rightChildOX = this.rightChildOX;
          var childOXExceedLeft = this.childOXExceedLeft(ox);
          var childOXExeceedRight = this.childOXExeceedRight(ox);
          if (this.clampChildOX) {
            if (this.childVisibleWidth > this.childWidth) {
              ox = 0;
            } else if (childOXExceedLeft) {
              ox = leftChildOX;
            } else if (childOXExeceedRight) {
              ox = rightChildOX;
            }
          }
          if (this._childOX !== ox) {
            this._childOX = ox;
            this.resetChildPosition();
          }
          if (childOXExceedLeft) {
            if (!this.execeedLeftState) {
              this.emit('execeedleft', this, ox, leftChildOX);
            }
          }
          this.execeedLeftState = childOXExceedLeft;
          if (childOXExeceedRight) {
            if (!this.execeedRightState) {
              this.emit('execeedright', this, ox, rightChildOX);
            }
          }
          this.execeedRightState = childOXExeceedRight;
        }
      }, {
        key: "setChildOY",
        value: function setChildOY(oy) {
          this.childOY = oy;
          return this;
        }
      }, {
        key: "setChildOX",
        value: function setChildOX(ox) {
          this.childOX = ox;
          return this;
        }
      }, {
        key: "t",
        get: function get() {
          var visibleHeight = this.visibleHeight;
          if (visibleHeight === 0) {
            return 0;
          }
          return this.childOY / -visibleHeight;
        },
        set: function set(value) {
          this.childOY = -this.visibleHeight * value;
        }
      }, {
        key: "s",
        get: function get() {
          var visibleWidth = this.visibleWidth;
          if (visibleWidth === 0) {
            return 0;
          }
          return this.childOX / -visibleWidth;
        },
        set: function set(value) {
          this.childOX = -this.visibleWidth * value;
        }
      }, {
        key: "setChildOYByPercentage",
        value: function setChildOYByPercentage(percentage) {
          this.t = percentage;
          return this;
        }
      }, {
        key: "setChildOXByPercentage",
        value: function setChildOXByPercentage(percentage) {
          this.s = percentage;
          return this;
        }
      }]);
      return ScrollableBlock;
    }(Base);
    Object.assign(ScrollableBlock.prototype, methods$6);
  
    var ScrollToChild = function ScrollToChild(child, align) {
      if (!this.hasChild(child)) {
        return this;
      }
      switch (this.scrollMode) {
        case 0:
          AlignChild.call(this, child, 'y', align);
          break;
        case 1:
          AlignChild.call(this, child, 'x', align);
          break;
        default:
          AlignChild.call(this, child, 'y', align);
          AlignChild.call(this, child, 'x', align);
          break;
      }
      return this;
    };
    var AlignYModes = ['top', 'bottom', 'centerY', 'center'];
    var AlignXModes = ['left', 'right', 'centerX', 'center'];
    var AlignChild = function AlignChild(child, axis, align) {
      axis = axis.toUpperCase();
      var isAxisY = axis === 'Y';
      var scrollableBlock = this.childrenMap.child;
      var delta;
      if (isAxisY) {
        if (align) {
          for (var i = 0, cnt = AlignYModes.length; i < cnt; i++) {
            var modeName = AlignYModes[i];
            if (align.indexOf(modeName) !== -1) {
              align = modeName;
              break;
            }
          }
        }
        switch (align) {
          case 'top':
            delta = scrollableBlock.top - GetTopLeft(child).y;
            break;
          case 'bottom':
            delta = scrollableBlock.bottom - GetBottomLeft(child).y;
            break;
          case 'centerY':
          case 'center':
            delta = scrollableBlock.centerY - GetCenter(child).y;
            break;
          default:
            var dTop = scrollableBlock.top - GetTopLeft(child).y;
            var dBottom = scrollableBlock.bottom - GetBottomLeft(child).y;
            if (dTop <= 0 && dBottom >= 0) {
              delta = 0;
            } else {
              delta = Math.abs(dTop) <= Math.abs(dBottom) ? dTop : dBottom;
            }
            break;
        }
      } else {
        if (align) {
          for (var i = 0, cnt = AlignXModes.length; i < cnt; i++) {
            var modeName = AlignXModes[i];
            if (align.indexOf(modeName) !== -1) {
              align = modeName;
              break;
            }
          }
        }
        switch (align) {
          case 'left':
            delta = scrollableBlock.left - GetTopLeft(child).x;
            break;
          case 'right':
            delta = scrollableBlock.right - GetTopRight(child).x;
            break;
          case 'centerX':
          case 'center':
            delta = scrollableBlock.centerX - GetCenter(child).x;
            break;
          default:
            var dLeft = scrollableBlock.left - GetTopLeft(child).x;
            var dRight = scrollableBlock.right - GetTopRight(child).x;
            if (dLeft <= 0 && dRight >= 0) {
              delta = 0;
            } else {
              delta = Math.abs(dLeft) <= Math.abs(dRight) ? dLeft : dRight;
            }
            break;
        }
      }
      switch (this.scrollMode) {
        case 0:
        case 1:
          this.childOY += delta;
          break;
        default:
          this["childO".concat(axis)] += delta;
          break;
      }
    };
  
    var GetValue$y = Phaser.Utils.Objects.GetValue;
    var ScrollablePanel = /*#__PURE__*/function (_Scrollable) {
      _inherits(ScrollablePanel, _Scrollable);
      function ScrollablePanel(scene, config) {
        var _this;
        _classCallCheck(this, ScrollablePanel);
        if (config === undefined) {
          config = {};
        }
  
        // Create scrollable-block
        var scrollMode = GetScrollMode(config);
        var panelConfig = GetValue$y(config, 'panel', undefined);
        if (panelConfig === undefined) {
          panelConfig = {};
        }
        panelConfig.scrollMode = scrollMode;
        panelConfig.clamplChildOY = GetValue$y(config, 'clamplChildOY', false);
        panelConfig.clamplChildOX = GetValue$y(config, 'clamplChildOX', false);
        var scrollableBlock = new ScrollableBlock(scene, panelConfig);
        scene.add.existing(scrollableBlock); // Important: Add to display list for touch detecting
  
        var expandPanelWidth, expandPanelHeight;
        switch (scrollMode) {
          case 0:
            expandPanelWidth = GetValue$y(config, 'expand.panel', true);
            expandPanelHeight = true;
            break;
          case 1:
            expandPanelWidth = true;
            expandPanelHeight = GetValue$y(config, 'expand.panel', true);
            break;
          default:
            // 2
            expandPanelWidth = true;
            expandPanelHeight = true;
        }
  
        // Fill config of scrollable
        config.type = 'rexScrollablePanel';
        config.child = {
          gameObject: scrollableBlock,
          expandWidth: expandPanelWidth,
          expandHeight: expandPanelHeight,
          align: GetValue$y(config, 'align.panel', 'center')
        };
        var spaceConfig = GetValue$y(config, 'space', undefined);
        if (spaceConfig) {
          spaceConfig.child = GetValue$y(spaceConfig, 'panel', 0);
        }
        _this = _callSuper(this, ScrollablePanel, [scene, config]);
        _this.addChildrenMap('panel', scrollableBlock.child);
        _this.addChildrenMap('panelLayer', scrollableBlock.maskLayer);
        _this.addChildrenMap('mask', scrollableBlock.maskGameObject);
        _this.addChildrenMap('scrollableBlock', scrollableBlock);
        return _this;
      }
      _createClass(ScrollablePanel, [{
        key: "setChildrenInteractive",
        value: function setChildrenInteractive(config) {
          if (config === undefined) {
            config = {};
          }
          if (!config.hasOwnProperty('eventEmitter')) {
            config.eventEmitter = this;
          }
          if (!config.hasOwnProperty('targets')) {
            config.targets = [this.childrenMap.panel];
          }
          SetChildrenInteractive(this.childrenMap.child, config);
          return this;
        }
      }]);
      return ScrollablePanel;
    }(Scrollable);
    var methods$5 = {
      scrollToChild: ScrollToChild
    };
    Object.assign(ScrollablePanel.prototype, methods$5);
  
    ObjectFactory.register('scrollablePanel', function (config) {
      var gameObject = new ScrollablePanel(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ScrollablePanel', ScrollablePanel);
  
    var DefaultTransitionCallbacks$1 = {
      popUp: function popUp(gameObject, duration) {
        gameObject.popUp(duration);
      },
      scaleDown: function scaleDown(gameObject, duration) {
        gameObject.scaleDown(duration);
      },
      fadeIn: function fadeIn(gameObject, duration) {
        gameObject.fadeIn(duration);
      },
      fadeOut: function fadeOut(gameObject, duration) {
        gameObject.fadeOut(duration);
      }
    };
  
    var TransitionMode = {
      popUp: 0,
      fadeIn: 1,
      scaleDown: 0,
      fadeOut: 1
    };
  
    var ConfigurationMethods$1 = {
      setDisplayTime: function setDisplayTime(time) {
        this.displayTime = time;
        return this;
      },
      setTransitOutTime: function setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
      },
      setTransitInTime: function setTransitInTime(time) {
        this.transitInTime = time;
        return this;
      },
      setTransitInCallback: function setTransitInCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode[callback];
        }
        switch (callback) {
          case TransitionMode.popUp:
            callback = DefaultTransitionCallbacks$1.popUp;
            break;
          case TransitionMode.fadeIn:
            callback = DefaultTransitionCallbacks$1.fadeIn;
            break;
        }
        if (!callback) {
          callback = NOOP;
        }
        this.transitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setTransitOutCallback: function setTransitOutCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode[callback];
        }
        switch (callback) {
          case TransitionMode.scaleDown:
            callback = DefaultTransitionCallbacks$1.scaleDown;
            break;
          case TransitionMode.fadeOut:
            callback = DefaultTransitionCallbacks$1.fadeOut;
            break;
        }
        if (!callback) {
          callback = NOOP;
        }
        this.transitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      }
    };
  
    var MessageMethods$1 = {
      showMessage: function showMessage(message) {
        // Remember first scaleX, scaleY as initial scale
        if (this.scaleX0 === undefined) {
          this.scaleX0 = this.scaleX;
        }
        if (this.scaleY0 === undefined) {
          this.scaleY0 = this.scaleY;
        }
        if (message === undefined) {
          // Try pop up a pendding message
          if (this.messages.length === 0) {
            return this;
          }
          message = this.messages.shift();
        }
        if (this.player.isPlaying) {
          // Pend message
          this.messages.push(message);
          return this;
        }
  
        // Recover to initial state
        this.setScale(this.scaleX0, this.scaleY0).setVisible(true);
        if (typeof message === 'string') {
          this.setText(message);
        } else {
          message(this);
        }
        this.layout();
        var commands = [[
        // Transit-in
        0,
        // time
        [this.transitInCallback, this, this.transitInTime] // [callback, param, ...]
        ], [
        // Transit-in event
        0,
        // time
        [this.emit, 'transitin', this, this.transitInTime] // [callback, param, ...]
        ], [
        // Hold
        this.transitInTime, [NOOP]], [
        // Transit-out
        this.displayTime, [this.transitOutCallback, this, this.transitOutTime]],
        // Transit-out event
        [0,
        // time
        [this.emit, 'transitout', this, this.transitOutTime] // [callback, param, ...]
        ], [
        // End
        this.transitOutTime, [this.setVisible, false]], [
        // Complete - show next message
        30,
        // Add a small delay before complete
        [NOOP]]];
        this.player.load(commands, this).once('complete', function () {
          this.showMessage();
        }, this).start();
        return this;
      },
      removeAllMessages: function removeAllMessages() {
        this.messages.length = 0;
        return this;
      }
    };
  
    var GetValue$x = Phaser.Utils.Objects.GetValue;
    var Toast = /*#__PURE__*/function (_Label) {
      _inherits(Toast, _Label);
      function Toast(scene, config) {
        var _this;
        _classCallCheck(this, Toast);
        if (config === undefined) {
          config = {
            text: createDefaultTextObject(scene)
          };
        }
        _this = _callSuper(this, Toast, [scene, config]);
        _this.type = 'rexToast';
        _this.setTransitInTime(GetValue$x(config, 'duration.in', 200));
        _this.setDisplayTime(GetValue$x(config, 'duration.hold', 1200));
        _this.setTransitOutTime(GetValue$x(config, 'duration.out', 200));
        _this.setTransitInCallback(GetValue$x(config, 'transitIn', TransitionMode.popUp));
        _this.setTransitOutCallback(GetValue$x(config, 'transitOut', TransitionMode.scaleDown));
        _this.player = new Player(_assertThisInitialized(_this), {
          dtMode: 1
        });
        _this.messages = [];
        _this.scaleX0 = undefined;
        _this.scaleY0 = undefined;
        _this.setVisible(false);
        return _this;
      }
      _createClass(Toast, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.player.destroy();
          this.player = undefined;
          this.messages = undefined;
          _get(_getPrototypeOf(Toast.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setScale",
        value: function setScale(scaleX, scaleY) {
          if (scaleY === undefined) {
            scaleY = scaleX;
          }
          // Can override initial scale
          this.scaleX0 = scaleX;
          this.scaleY0 = scaleY;
          _get(_getPrototypeOf(Toast.prototype), "setScale", this).call(this, scaleX, scaleY);
          return this;
        }
      }]);
      return Toast;
    }(Label);
    Object.assign(Toast.prototype, ConfigurationMethods$1, MessageMethods$1);
  
    ObjectFactory.register('toast', function (config) {
      var gameObject = new Toast(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Toast', Toast);
  
    var QueueDirectionMap = {
      'bottom-to-top': 1,
      'top-to-bottom': 0,
      'right-to-left': 1,
      'left-to-right': 0
    };
    var ConfigurationMethods = {
      setQueueDirection: function setQueueDirection(direction) {
        if (typeof direction === 'string') {
          direction = QueueDirectionMap[direction];
        }
        this.rtl = direction === 0;
        if (this.orientation === 1) {
          if (direction) {
            // bottom-to-top
            this.queueDirection = 0;
          } else {
            // top-to-bottom
            this.queueDirection = 1;
          }
        } else {
          if (direction) {
            // right-to-left
            this.queueDirection = 2;
          } else {
            // left-to-right
            this.queueDirection = 3;
          }
        }
        return this;
      },
      setCreateMessageLabelCallback: function setCreateMessageLabelCallback(callback) {
        this.createMessageLabelCallback = callback;
        return this;
      },
      setDisplayTime: function setDisplayTime(time) {
        this.displayTime = time;
        return this;
      },
      setTransitOutTime: function setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
      },
      setTransitInTime: function setTransitInTime(time) {
        this.transitInTime = time;
        return this;
      },
      setTransitInCallback: function setTransitInCallback(callback) {
        if (!callback) {
          callback = NOOP;
        }
        this.transitInCallback = callback;
        // callback = function(gameObject, duration, toastQueue) {}
        return this;
      },
      setTransitOutCallback: function setTransitOutCallback(callback) {
        if (!callback) {
          callback = NOOP;
        }
        this.transitOutCallback = callback;
        // callback = function(gameObject, duration, toastQueue) {}
        return this;
      }
    };
  
    var OnClick = ClickMethods.onClick;
    var DelayCall = DelayCallMethods$2.delayCall;
    var MoveTo = methods$w.moveTo;
    var CreateChild = function CreateChild(parent, callback, message) {
      var child = callback(parent.scene, message, parent);
  
      // Destroy this child when
      // Click
      OnClick.call(child, function () {
        parent.removeMessage(child);
      });
  
      // Timeout 
      if (parent.displayTime) {
        var delay = parent.transitInTime + parent.displayTime + 10;
        DelayCall.call(child, delay, function () {
          parent.removeMessage(child);
        });
      }
      return child;
    };
    var GetChildrenPosition = function GetChildrenPosition(parent) {
      var children = parent.childrenMap.items,
        child;
      var positionList = [];
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        positionList.push({
          x: child.x,
          y: child.y
        });
      }
      return positionList;
    };
    var RunLayout = function RunLayout(parent) {
      var children = parent.childrenMap.items,
        child;
  
      // Store current scale, reset scale to 1
      var scaleList = [];
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        scaleList.push({
          x: child.scaleX,
          y: child.scaleY
        });
        child.setScale(1);
      }
  
      // Run layout, with scale1
      parent.layout();
      var newPositionList = GetChildrenPosition(parent);
  
      // Restore scale
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var scaleData = scaleList[i];
        children[i].setScale(scaleData.x, scaleData.y);
      }
      return newPositionList;
    };
    var EaseChildren = function EaseChildren(parent, prevPositionList, newPositionList, duration) {
      var children = parent.childrenMap.items;
      var listLength = Math.min(prevPositionList.length, newPositionList.length, children.length);
      var child, prevPositionData, newPostionData;
      var queueDirection = parent.queueDirection;
      for (var i = 0; i < listLength; i++) {
        child = children[i];
        prevPositionData = prevPositionList[i];
        newPostionData = newPositionList[i];
        child.setPosition(prevPositionData.x, prevPositionData.y);
        switch (queueDirection) {
          case 0:
            // bottom-to-top
            if (prevPositionData.y <= newPostionData.y) {
              continue;
            }
            break;
          case 1:
            // top-to-bottom
            if (prevPositionData.y >= newPostionData.y) {
              continue;
            }
            break;
          case 2:
            // right-to-left
            if (prevPositionData.x <= newPostionData.x) {
              continue;
            }
            break;
          case 3:
            // left-to-right
            if (prevPositionData.x >= newPostionData.x) {
              continue;
            }
            break;
        }
        MoveTo.call(child, duration, newPostionData.x, newPostionData.y);
      }
    };
    var PushChild = function PushChild(parent, child, duration) {
      var prevPositionList = GetChildrenPosition(parent);
      parent.add(child);
      var newPositionList = RunLayout(parent);
      EaseChildren(parent, prevPositionList, newPositionList, duration);
      parent.transitInCallback(child, duration, parent);
    };
    var MessageMethods = {
      showMessage: function showMessage(message) {
        var child = CreateChild(this, this.createMessageLabelCallback, message);
        PushChild(this, child, this.transitInTime);
        return this;
      },
      removeMessage: function removeMessage(messageLabel) {
        if (this.getParentSizer(messageLabel) !== this) {
          return this;
        }
        if (messageLabel.__isDestroying) {
          return;
        }
        messageLabel.__isDestroying = true;
        var duration = this.transitOutTime;
        this.transitOutCallback(messageLabel, duration, this);
        DelayCall.call(messageLabel, duration + 10, function () {
          delete messageLabel.__isDestroying;
          messageLabel.destroy();
        });
        return this;
      },
      removeAllMessages: function removeAllMessages() {
        var children = this.childrenMap.items;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          this.removeMessage(children[i]);
        }
        return this;
      }
    };
  
    var Methods$1 = {};
    Object.assign(Methods$1, ConfigurationMethods, MessageMethods);
  
    var DefaultTransitionCallbacks = {
      transitIn: function transitIn(gameObject, duration, parent) {
        switch (parent.queueDirection) {
          case 0:
            // bottom-to-top
            gameObject.setOrigin(0.5, 1);
            methods$y.popUp.call(gameObject, duration, 'y');
            break;
          case 1:
            // top-to-bottom
            gameObject.setOrigin(0.5, 0);
            methods$y.popUp.call(gameObject, duration, 'y');
            break;
          case 2:
            // right-to-left
            gameObject.setOrigin(1, 0.5);
            methods$y.popUp.call(gameObject, duration, 'x');
            break;
          case 3:
            // left-to-right
            gameObject.setOrigin(0, 0.5);
            methods$y.popUp.call(gameObject, duration, 'x');
            break;
        }
        methods$x.fadeIn.call(gameObject, duration);
      },
      transitOut: function transitOut(gameObject, duration, parent) {
        methods$x.fadeOut.call(gameObject, duration);
      }
    };
  
    var GetValue$w = Phaser.Utils.Objects.GetValue;
    var ToastQueue = /*#__PURE__*/function (_Sizer) {
      _inherits(ToastQueue, _Sizer);
      function ToastQueue(scene, config) {
        var _this;
        _classCallCheck(this, ToastQueue);
        if (config === undefined) {
          config = {};
        }
        if (!config.hasOwnProperty('orientation')) {
          config.orientation = 1;
        }
        _this = _callSuper(this, ToastQueue, [scene, config]);
        _this.type = 'rexToastQueue';
        _this.setCreateMessageLabelCallback(GetValue$w(config, 'createMessageLabelCallback'));
        _this.setQueueDirection(GetValue$w(config, 'queueDirection', 1));
        _this.setTransitInTime(GetValue$w(config, 'duration.in', 200));
        _this.setDisplayTime(GetValue$w(config, 'duration.hold', 2000));
        _this.setTransitOutTime(GetValue$w(config, 'duration.out', 200));
        _this.setTransitInCallback(GetValue$w(config, 'transitIn', DefaultTransitionCallbacks.transitIn));
        _this.setTransitOutCallback(GetValue$w(config, 'transitOut', DefaultTransitionCallbacks.transitOut));
        return _this;
      }
      return _createClass(ToastQueue);
    }(Sizer);
    Object.assign(ToastQueue.prototype, Methods$1);
  
    ObjectFactory.register('toastQueue', function (config) {
      var gameObject = new ToastQueue(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ToastQueue', ToastQueue);
  
    var CreateSwatch = function CreateSwatch(scene, config) {
      if (config === false) {
        return null;
      } else if (IsGameObject(config)) {
        return config;
      }
      var swatch = new RoundRectangle$2(scene, config);
      scene.add.existing(swatch);
      return swatch;
    };
  
    var CreateInputText$1 = function CreateInputText(scene, config, deepCloneConfig) {
      if (deepCloneConfig === undefined) {
        deepCloneConfig = true;
      }
      if (deepCloneConfig) {
        config = config ? DeepClone(config) : {};
      } else if (!config) {
        config = {};
      }
      var inputText = new CanvasInput(scene, config);
      scene.add.existing(inputText);
      return inputText;
    };
  
    var ColorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];
    var ColorValues = [0xf0f8ff, 0xfaebd7, 0x00ffff, 0x7fffd4, 0xf0ffff, 0xf5f5dc, 0xffe4c4, 0x000000, 0xffebcd, 0x0000ff, 0x8a2be2, 0xa52a2a, 0xdeb887, 0x5f9ea0, 0x7fff00, 0xd2691e, 0xff7f50, 0x6495ed, 0xfff8dc, 0xdc143c, 0x00ffff, 0x00008b, 0x008b8b, 0xb8860b, 0xa9a9a9, 0xa9a9a9, 0x006400, 0xbdb76b, 0x8b008b, 0x556b2f, 0xff8c00, 0x9932cc, 0x8b0000, 0xe9967a, 0x8fbc8f, 0x483d8b, 0x2f4f4f, 0x2f4f4f, 0x00ced1, 0x9400d3, 0xff1493, 0x00bfff, 0x696969, 0x696969, 0x1e90ff, 0xb22222, 0xfffaf0, 0x228b22, 0xff00ff, 0xdcdcdc, 0xf8f8ff, 0xffd700, 0xdaa520, 0x808080, 0x808080, 0x008000, 0xadff2f, 0xf0fff0, 0xff69b4, 0xcd5c5c, 0x4b0082, 0xfffff0, 0xf0e68c, 0xe6e6fa, 0xfff0f5, 0x7cfc00, 0xfffacd, 0xadd8e6, 0xf08080, 0xe0ffff, 0xfafad2, 0xd3d3d3, 0xd3d3d3, 0x90ee90, 0xffb6c1, 0xffa07a, 0x20b2aa, 0x87cefa, 0x778899, 0x778899, 0xb0c4de, 0xffffe0, 0x00ff00, 0x32cd32, 0xfaf0e6, 0xff00ff, 0x800000, 0x66cdaa, 0x0000cd, 0xba55d3, 0x9370db, 0x3cb371, 0x7b68ee, 0x00fa9a, 0x48d1cc, 0xc71585, 0x191970, 0xf5fffa, 0xffe4e1, 0xffe4b5, 0xffdead, 0x000080, 0xfdf5e6, 0x808000, 0x6b8e23, 0xffa500, 0xff4500, 0xda70d6, 0xeee8aa, 0x98fb98, 0xafeeee, 0xdb7093, 0xffefd5, 0xffdab9, 0xcd853f, 0xffc0cb, 0xdda0dd, 0xb0e0e6, 0x800080, 0x663399, 0xff0000, 0xbc8f8f, 0x4169e1, 0x8b4513, 0xfa8072, 0xf4a460, 0x2e8b57, 0xfff5ee, 0xa0522d, 0xc0c0c0, 0x87ceeb, 0x6a5acd, 0x708090, 0x708090, 0xfffafa, 0x00ff7f, 0x4682b4, 0xd2b48c, 0x008080, 0xd8bfd8, 0xff6347, 0x40e0d0, 0xee82ee, 0xf5deb3, 0xffffff, 0xf5f5f5, 0xffff00, 0x9acd32];
    var ColorNameToIntegerDict = {},
      name;
    for (var i = 0, cnt = ColorNames.length; i < cnt; i++) {
      name = ColorNames[i].toLowerCase();
      ColorNameToIntegerDict[name] = ColorValues[i];
    }
    var ColorNameToInteger = function ColorNameToInteger(colorName) {
      colorName = colorName.toLowerCase();
      if (ColorNameToIntegerDict.hasOwnProperty(colorName)) {
        return ColorNameToIntegerDict[colorName];
      } else {
        return null;
      }
    };
  
    var ColorStringToInteger = function ColorStringToInteger(value) {
      if (typeof value !== 'string') {
        return value;
      }
      if (value.startsWith('#')) {
        value = parseInt(value.substring(1), 16);
      } else if (value.startsWith('0x')) {
        value = parseInt(value.substring(2), 16);
      } else {
        value = ColorNameToInteger(value);
      }
      return value;
    };
  
    var Pad = Phaser.Utils.String.Pad;
    var GetHexColorString = function GetHexColorString(value, prefix) {
      if (prefix === undefined) {
        prefix = '0x';
      }
      var colorString = value.toString(16).toUpperCase();
      colorString = Pad(colorString, 6, 0, 1);
      colorString = prefix + colorString;
      return colorString;
    };
  
    var SetSwatchColor = function SetSwatchColor(swatch, color) {
      if (!swatch) {
        return;
      }
      if (swatch.setTint) {
        swatch.setTint(color);
      } else if (swatch.setFillStyle) {
        swatch.setFillStyle(color);
      }
    };
  
    var GetValue$v = Phaser.Utils.Objects.GetValue;
    var IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
    var Clamp$2 = Phaser.Math.Clamp;
    var ColorInput$1 = /*#__PURE__*/function (_Sizer) {
      _inherits(ColorInput, _Sizer);
      function ColorInput(scene, config) {
        var _this;
        _classCallCheck(this, ColorInput);
        if (config === undefined) {
          config = {};
        }
        config.orientation = 0;
        _this = _callSuper(this, ColorInput, [scene, config]);
        _this.type = 'rexColorInputLite';
  
        // Add elements
        var background = GetValue$v(config, 'background', undefined);
        var swatchConfig = GetValue$v(config, 'swatch');
        var swatchSize;
        if (IsPlainObject$4(swatchConfig)) {
          swatchSize = GetValue$v(swatchConfig, 'size');
        }
        var swatch = CreateSwatch(scene, GetValue$v(config, 'swatch'));
        var inputTextConfig = GetValue$v(config, 'inputText', {});
        var inputText;
        if (inputTextConfig) {
          inputText = CreateInputText$1(scene, inputTextConfig);
        }
        if (background) {
          _this.addBackground(background);
        }
        if (swatch) {
          swatchSize = GetValue$v(config, 'swatchSize', swatchSize);
          var squareExpandSwatch;
          if (swatchSize !== undefined) {
            ResizeGameObject(swatch, swatchSize, swatchSize);
            squareExpandSwatch = false;
          } else {
            squareExpandSwatch = GetValue$v(config, 'squareExpandSwatch', true);
          }
          var fitRatio = squareExpandSwatch ? 1 : 0;
          _this.add(swatch, {
            proportion: 0,
            expand: false,
            fitRatio: fitRatio
          });
        }
        if (inputText) {
          var proportion = GetValue$v(inputTextConfig, 'width') === undefined ? 1 : 0;
          var expand = GetValue$v(inputTextConfig, 'height') === undefined ? true : false;
          _this.add(inputText, {
            proportion: proportion,
            expand: expand
          });
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('swatch', swatch);
        _this.addChildrenMap('inputText', inputText);
        if (inputText) {
          inputText.on('close', function () {
            this.setValue(inputText.value);
          }, _assertThisInitialized(_this));
        }
        var callback = GetValue$v(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$v(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        _this.setValue(GetValue$v(config, 'value', 0x0));
        return _this;
      }
      _createClass(ColorInput, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (typeof value === 'string') {
            value = ColorStringToInteger(value);
            if (value == null) {
              var inputText = this.childrenMap.inputText;
              if (inputText) {
                inputText.setText(GetHexColorString(this._value));
              }
              return;
            }
          } else {
            value = Clamp$2(Math.floor(value), 0, 0xffffff);
          }
          if (this._value === value) {
            return;
          }
          this._value = value;
          var swatch = this.childrenMap.swatch;
          if (swatch) {
            SetSwatchColor(swatch, value);
          }
          var inputText = this.childrenMap.inputText;
          if (inputText) {
            inputText.setText(GetHexColorString(value));
          }
          this.emit('valuechange', this._value);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "color",
        get: function get() {
          return this._value;
        },
        set: function set(color) {
          this.value = color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = color;
          return this;
        }
      }]);
      return ColorInput;
    }(Sizer);
  
    var methods$4 = {
      // Color picker
      setCreateColorPickerBackgroundCallback: function setCreateColorPickerBackgroundCallback(callback) {
        this.colorPickerCreateBackgroundCallback = callback;
        return this;
      },
      setColorPickerHPalettePosition: function setColorPickerHPalettePosition(position) {
        this.colorPickerHPalettePosition = position;
        return this;
      },
      setColorPickerExpandDirection: function setColorPickerExpandDirection(direction) {
        if (typeof direction === 'string') {
          direction = ColorPickerExpandDirections[direction];
        }
        this.colorPickerExpandDirection = direction;
        return this;
      },
      setColorPickerEaseInDuration: function setColorPickerEaseInDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.colorPickerEaseInDuration = duration;
        return this;
      },
      setColorPickerEaseOutDuration: function setColorPickerEaseOutDuration(duration) {
        if (duration === undefined) {
          duration = 0;
        }
        this.colorPickerEaseOutDuration = duration;
        return this;
      },
      setColorPickerTransitInCallback: function setColorPickerTransitInCallback(callback) {
        this.colorPickerTransitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setColorPickerTransitOutCallback: function setColorPickerTransitOutCallback(callback) {
        this.colorPickerTransitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
      },
      setColorPickerBounds: function setColorPickerBounds(bounds) {
        this.colorPickerBounds = bounds;
        return this;
      },
      setColorPickerWidth: function setColorPickerWidth(width) {
        this.colorPickerWidth = width;
        return this;
      },
      setColorPickerHeight: function setColorPickerHeight(height) {
        this.colorPickerHeight = height;
        return this;
      },
      setColorPickerSize: function setColorPickerSize(width, height) {
        this.setColorPickerWidth(width).setColorPickerHeight(height);
        return this;
      },
      setColorPickerSpace: function setColorPickerSpace(space) {
        if (space === undefined) {
          space = {};
        }
        this.colorPickerSpace = space;
        return this;
      },
      // Color components
      setColorComponentsHeight: function setColorComponentsHeight(height) {
        this.colorComponentsHeight = height;
        return this;
      },
      setColorComponentsFormatLabelConfig: function setColorComponentsFormatLabelConfig(config) {
        this.colorComponentsFormatLabelConfig = config;
        return this;
      },
      setColorComponentsInputTextConfig: function setColorComponentsInputTextConfig(config) {
        this.colorComponentsInputTextConfig = config;
        return this;
      },
      setColorComponentsSpace: function setColorComponentsSpace(space) {
        if (space === undefined) {
          space = {};
        }
        this.colorComponentsSpace = space;
        return this;
      }
    };
    var ColorPickerExpandDirections = {
      down: 0,
      up: 1
    };
  
    var Color$3 = Phaser.Display.Color;
    var Percent$2 = Phaser.Math.Percent;
    var DrawHPalette = function DrawHPalette(canvas, context, verticalMode) {
      if (verticalMode === undefined) {
        verticalMode = false;
      }
      var width = canvas.width;
      var height = canvas.height;
      var color = new Color$3();
      if (verticalMode) {
        for (var iy = 0; iy < height; iy++) {
          var h = Percent$2(iy, 0, height);
          color.setFromHSV(h, 1, 1);
          context.fillStyle = color.rgba;
          context.fillRect(0, iy, width, 1);
        }
      } else {
        for (var ix = 0; ix < width; ix++) {
          var h = Percent$2(ix, 0, width);
          color.setFromHSV(h, 1, 1);
          context.fillStyle = color.rgba;
          context.fillRect(ix, 0, 1, height);
        }
      }
    };
    var DrawSVPalette = function DrawSVPalette(canvas, context, h) {
      var width = canvas.width;
      var height = canvas.height;
      var imgData = context.getImageData(0, 0, width, height);
      var data = imgData.data;
      var color = new Color$3();
      for (var iy = 0; iy < height; iy++) {
        for (var ix = 0; ix < width; ix++) {
          var s = Percent$2(ix, 0, width);
          var v = 1 - Percent$2(iy, 0, height);
          color.setFromHSV(h, s, v);
          var i = (iy * width + ix) * 4;
          data[i] = color.red;
          data[i + 1] = color.green;
          data[i + 2] = color.blue;
          data[i + 3] = 255;
        }
      }
      context.putImageData(imgData, 0, 0);
    };
  
    var Color$2 = Phaser.Display.Color;
    var Percent$1 = Phaser.Math.Percent;
    var ColorToRGBA$2 = Phaser.Display.Color.ColorToRGBA;
    var HSVToRGB$2 = Phaser.Display.Color.HSVToRGB;
    var HPaletteCanvas = /*#__PURE__*/function (_Canvas) {
      _inherits(HPaletteCanvas, _Canvas);
      function HPaletteCanvas(scene, x, y, width, height, orientation) {
        var _this;
        _classCallCheck(this, HPaletteCanvas);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 2;
        }
        if (height === undefined) {
          height = 2;
        }
        _this = _callSuper(this, HPaletteCanvas, [scene, x, y, width, height]);
        _this.type = 'rexColorPicker.HPaletteCanvas';
        _this.colorObject = new Color$2();
        _this.setOrientation(orientation);
        _this.setSize(width, height);
        return _this;
      }
      _createClass(HPaletteCanvas, [{
        key: "setOrientation",
        value: function setOrientation(orientation) {
          this.orientation = GetOrientationMode(orientation);
          return this;
        }
      }, {
        key: "updateTexture",
        value: function updateTexture() {
          DrawHPalette(this.canvas, this.context, this.orientation);
          _get(_getPrototypeOf(HPaletteCanvas.prototype), "updateTexture", this).call(this);
          return this;
        }
      }, {
        key: "color",
        get: function get() {
          return this.colorObject.color;
        }
      }, {
        key: "hue",
        get: function get() {
          return this._hue;
        },
        set: function set(value) {
          this._hue = value;
        }
      }, {
        key: "getHue",
        value: function getHue(localX, localY) {
          if (localX === undefined) {
            return this.hue;
          }
          if (this.orientation === 0) {
            this.hue = Percent$1(localX, 0, this.width);
          } else {
            this.hue = Percent$1(localY, 0, this.height);
          }
          return this.hue;
        }
      }, {
        key: "getColor",
        value: function getColor(localX, localY) {
          if (localX === undefined) {
            return this.color;
          }
          var h = this.getHue(localX, localY);
          this.colorObject.setFromRGB(HSVToRGB$2(h, 1, 1));
          return this.colorObject.color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          if (this.color === color) {
            return this;
          }
          return this;
        }
      }, {
        key: "colorToLocalPosition",
        value: function colorToLocalPosition(color, out) {
          if (out === undefined) {
            out = {};
          } else if (out === true) {
            if (LocalXY$1 === undefined) {
              LocalXY$1 = {};
            }
            out = LocalXY$1;
          }
          this.colorObject.setFromRGB(ColorToRGBA$2(color));
          if (this.orientation === 0) {
            out.x = this.width * this.colorObject.h;
            out.y = this.height / 2;
          } else {
            out.x = this.width / 2;
            out.y = this.height * this.colorObject.h;
          }
          return out;
        }
      }]);
      return HPaletteCanvas;
    }(Canvas);
    var LocalXY$1 = undefined;
  
    var RotateAround$1 = Phaser.Math.RotateAround;
    var LocalToWorld = function LocalToWorld(gameObject, localX, localY, out) {
      if (out === undefined) {
        out = {};
      } else if (out === true) {
        if (GlobOut === undefined) {
          GlobOut = {};
        }
        out = GlobOut;
      }
      localX -= gameObject.width * gameObject.originX;
      localY -= gameObject.height * gameObject.originY;
      var point = {
        x: localX * gameObject.scaleX,
        y: localY * gameObject.scaleY
      };
      RotateAround$1(point, 0, 0, -gameObject.rotation);
      out.x = gameObject.x + localX;
      out.y = gameObject.y + localY;
      return out;
    };
    var GlobOut;
  
    var HPalette = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(HPalette, _OverlapSizer);
      function HPalette(scene, config) {
        var _this;
        _classCallCheck(this, HPalette);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, HPalette, [scene, config]);
        var orientation = config.width != null ? 1 : 0;
        var paletteCanvas = new HPaletteCanvas(scene).setOrientation(orientation);
        scene.add.existing(paletteCanvas);
        _this.type = 'rexColorPicker.HPalette';
        paletteCanvas.setInteractive().on('pointerdown', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this)).on('pointermove', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this));
        var marker = new RoundRectangle$2(scene, {
          strokeColor: 0xffffff,
          strokeWidth: 2
        });
        scene.add.existing(marker);
        _this.add(paletteCanvas, {
          key: 'paletteCanvas',
          expand: true
        }).add(marker, {
          key: 'marker',
          expand: false
        });
        return _this;
      }
      _createClass(HPalette, [{
        key: "resize",
        value: function resize(width, height) {
          if (this.width === width && this.height === height) {
            return this;
          }
          _get(_getPrototypeOf(HPalette.prototype), "resize", this).call(this, width, height);
          var size = Math.min(width, height);
          this.childrenMap.marker.setSize(size, size);
          return this;
        }
      }, {
        key: "onPaletteCanvasPointerDown",
        value: function onPaletteCanvasPointerDown(pointer, localX, localY, event) {
          if (!pointer.isDown) {
            return;
          }
          var paletteCanvas = this.childrenMap.paletteCanvas;
          var color = paletteCanvas.getColor(localX, localY);
          this.setMarkerPosition(color);
          this.emit('input', color);
        }
      }, {
        key: "color",
        get: function get() {
          return this.childrenMap.paletteCanvas.color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          if (this.color === color) {
            return this;
          }
          var paletteCanvas = this.childrenMap.paletteCanvas;
          paletteCanvas.setColor(color);
          this.setMarkerPosition(color);
          return this;
        }
      }, {
        key: "setMarkerPosition",
        value: function setMarkerPosition(color) {
          var paletteCanvas = this.childrenMap.paletteCanvas;
          var marker = this.childrenMap.marker;
          var localXY = paletteCanvas.colorToLocalPosition(color, true);
          LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
          this.resetChildPositionState(marker);
          return this;
        }
      }, {
        key: "getHue",
        value: function getHue(localX, localY) {
          var paletteCanvas = this.childrenMap.paletteCanvas;
          return paletteCanvas.getHue(localX, localY);
        }
      }]);
      return HPalette;
    }(OverlapSizer);
  
    var Color$1 = Phaser.Display.Color;
    var Percent = Phaser.Math.Percent;
    var ColorToRGBA$1 = Phaser.Display.Color.ColorToRGBA;
    var HSVToRGB$1 = Phaser.Display.Color.HSVToRGB;
    var SVPaletteCanvas = /*#__PURE__*/function (_Canvas) {
      _inherits(SVPaletteCanvas, _Canvas);
      function SVPaletteCanvas(scene, x, y, width, height, hue) {
        var _this;
        _classCallCheck(this, SVPaletteCanvas);
        if (x === undefined) {
          x = 0;
        }
        if (y === undefined) {
          y = 0;
        }
        if (width === undefined) {
          width = 2;
        }
        if (height === undefined) {
          height = 2;
        }
        _this = _callSuper(this, SVPaletteCanvas, [scene, x, y, width, height]);
        _this.type = 'rexColorPicker.SVPaletteCanvas';
        if (hue === undefined) {
          hue = 1;
        }
        _this.colorObject = new Color$1();
        _this.setHue(hue);
        _this.setSize(width, height);
        return _this;
      }
      _createClass(SVPaletteCanvas, [{
        key: "color",
        get: function get() {
          return this.colorObject.color;
        }
      }, {
        key: "hue",
        get: function get() {
          return this._hue;
        },
        set: function set(hue) {
          if (this._hue === hue) {
            return;
          }
          this._hue = hue;
          this.colorObject.h = hue;
          this.dirty = true;
        }
      }, {
        key: "setHue",
        value: function setHue(hue) {
          this.hue = hue;
          return this;
        }
      }, {
        key: "updateTexture",
        value: function updateTexture() {
          DrawSVPalette(this.canvas, this.context, this.hue);
          _get(_getPrototypeOf(SVPaletteCanvas.prototype), "updateTexture", this).call(this);
          return this;
        }
      }, {
        key: "getColor",
        value: function getColor(localX, localY) {
          if (localX === undefined) {
            return this.colorObject.color;
          }
          var s = Percent(localX, 0, this.width);
          var v = 1 - Percent(localY, 0, this.height);
          this.colorObject.setFromRGB(HSVToRGB$1(this.hue, s, v));
          return this.colorObject.color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          if (this.color === color) {
            return this;
          }
          this.colorObject.setFromRGB(ColorToRGBA$1(color));
          this.setHue(this.colorObject.h);
          return this;
        }
      }, {
        key: "colorToLocalPosition",
        value: function colorToLocalPosition(color, out) {
          if (out === undefined) {
            out = {};
          } else if (out === true) {
            if (LocalXY === undefined) {
              LocalXY = {};
            }
            out = LocalXY;
          }
          this.colorObject.setFromRGB(ColorToRGBA$1(color));
          out.x = this.width * this.colorObject.s;
          out.y = this.height * (1 - this.colorObject.v);
          return out;
        }
      }]);
      return SVPaletteCanvas;
    }(Canvas);
    var LocalXY = undefined;
  
    var SVPalette = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(SVPalette, _OverlapSizer);
      function SVPalette(scene, config) {
        var _this;
        _classCallCheck(this, SVPalette);
        _this = _callSuper(this, SVPalette, [scene, config]);
        var paletteCanvas = new SVPaletteCanvas(scene);
        scene.add.existing(paletteCanvas);
        _this.type = 'rexColorPicker.SVPalette';
        paletteCanvas.setInteractive().on('pointerdown', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this)).on('pointermove', _this.onPaletteCanvasPointerDown, _assertThisInitialized(_this));
        var marker = new RoundRectangle$2(scene, {
          radius: 5,
          strokeColor: 0xffffff,
          strokeWidth: 2
        });
        scene.add.existing(marker);
        _this.add(paletteCanvas, {
          key: 'paletteCanvas',
          expand: true
        }).add(marker, {
          key: 'marker',
          expand: false
        });
        return _this;
      }
      _createClass(SVPalette, [{
        key: "onPaletteCanvasPointerDown",
        value: function onPaletteCanvasPointerDown(pointer, localX, localY, event) {
          if (!pointer.isDown) {
            return;
          }
          var paletteCanvas = this.childrenMap.paletteCanvas;
          var color = paletteCanvas.getColor(localX, localY);
          this.setMarkerPosition(color);
          this.emit('input', color);
        }
      }, {
        key: "color",
        get: function get() {
          return this.childrenMap.paletteCanvas.color;
        }
      }, {
        key: "setHue",
        value: function setHue(hue) {
          var paletteCanvas = this.childrenMap.paletteCanvas;
          paletteCanvas.setHue(hue); // Redraw paletteCanvas
          // Position of marker does not change
          return this;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          if (this.color === color) {
            return this;
          }
          var paletteCanvas = this.childrenMap.paletteCanvas;
          paletteCanvas.setColor(color); // Redraw paletteCanvas
          this.setMarkerPosition(color);
          return this;
        }
      }, {
        key: "setMarkerPosition",
        value: function setMarkerPosition(color) {
          var paletteCanvas = this.childrenMap.paletteCanvas;
          var marker = this.childrenMap.marker;
          var localXY = paletteCanvas.colorToLocalPosition(color, true);
          LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
          this.resetChildPositionState(marker);
          return this;
        }
      }]);
      return SVPalette;
    }(OverlapSizer);
  
    var GetValue$u = Phaser.Utils.Objects.GetValue;
    var ColorPicker = /*#__PURE__*/function (_Sizer) {
      _inherits(ColorPicker, _Sizer);
      function ColorPicker(scene, config) {
        var _this;
        _classCallCheck(this, ColorPicker);
        _this = _callSuper(this, ColorPicker, [scene, config]);
        _this.type = 'rexColorPicker';
        _this.freezePalettes = false;
  
        // orientation
        var hPalettePosition = GetValue$u(config, 'hPalette.position', 0);
        if (typeof hPalettePosition === 'string') {
          hPalettePosition = HPalettePositionNamesMap[hPalettePosition];
        }
        var orientation = hPalettePosition === 0 ||
        // bottom
        hPalettePosition === 2 // top
        ? 1 :
        // y
        0; // x
        _this.setOrientation(orientation);
  
        // Add elements
        var background = GetValue$u(config, 'background', undefined);
        var hPaletteWidth, hPaletteHeight;
        if (_this.orientation === 0) {
          var hPaletteWidth = GetValue$u(config, 'hPalette.width', undefined);
          if (hPaletteWidth === undefined) {
            hPaletteWidth = GetValue$u(config, 'hPalette.size', 10);
          }
        } else {
          hPaletteHeight = GetValue$u(config, 'hPalette.height', undefined);
          if (hPaletteHeight === undefined) {
            hPaletteHeight = GetValue$u(config, 'hPalette.size', 10);
          }
        }
        var hPalette = new HPalette(scene, {
          width: hPaletteWidth,
          height: hPaletteHeight
        });
        scene.add.existing(hPalette);
        var svPaletteWidth = GetValue$u(config, 'svPalette.width', undefined);
        var svPaletteHeight = GetValue$u(config, 'svPalette.height', undefined);
        var svPalette = new SVPalette(scene, {
          width: svPaletteWidth,
          height: svPaletteHeight
        });
        scene.add.existing(svPalette);
        if (background) {
          _this.addBackground(background);
        }
        var hPaletteAddConfig = {
          proportion: 0,
          expand: true
        };
        var svPaletteProportion, svPaletteExpand;
        if (_this.orientation === 0) {
          svPaletteProportion = svPaletteWidth === undefined ? 1 : 0;
          svPaletteExpand = svPaletteHeight === undefined ? true : false;
        } else {
          svPaletteProportion = svPaletteHeight === undefined ? 1 : 0;
          svPaletteExpand = svPaletteWidth === undefined ? true : false;
        }
        var svPaletteAddConfig = {
          proportion: svPaletteProportion,
          expand: svPaletteExpand
        };
        if (hPalettePosition === 0 || hPalettePosition === 3) {
          // bottom, right
          _this.add(svPalette, svPaletteAddConfig).add(hPalette, hPaletteAddConfig);
        } else {
          // left, top
          _this.add(hPalette, hPaletteAddConfig).add(svPalette, svPaletteAddConfig);
        }
        hPalette.on('input', function () {
          svPalette.setHue(hPalette.getHue());
          this.setValue(svPalette.color, true);
        }, _assertThisInitialized(_this));
        svPalette.on('input', function () {
          this.setValue(svPalette.color, true);
        }, _assertThisInitialized(_this));
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('hPalette', hPalette);
        _this.addChildrenMap('svPalette', svPalette);
        var callback = GetValue$u(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$u(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        _this.setValue(GetValue$u(config, 'value', 0xffffff));
        return _this;
      }
      _createClass(ColorPicker, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (this._value === value) {
            return;
          }
          var oldValue = this._value;
          this._value = value;
          if (!this.freezePalettes) {
            this.updatePalettes();
          }
          this.emit('valuechange', value, oldValue, this);
        }
      }, {
        key: "setValue",
        value: function setValue(value, freezePalettes) {
          this.freezePalettes = !!freezePalettes;
          this.value = value;
          this.freezePalettes = false;
          return this;
        }
      }, {
        key: "color",
        get: function get() {
          return this._value;
        },
        set: function set(color) {
          this.value = color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = color;
          return this;
        }
      }, {
        key: "updatePalettes",
        value: function updatePalettes() {
          this.childrenMap.hPalette.setColor(this.color);
          this.childrenMap.svPalette.setColor(this.color);
          return this;
        }
      }, {
        key: "postLayout",
        value: function postLayout(parent, newWidth, newHeight) {
          this.childrenMap.hPalette.setMarkerPosition(this.value);
          this.childrenMap.svPalette.setMarkerPosition(this.value);
          return this;
        }
      }]);
      return ColorPicker;
    }(Sizer);
    var HPalettePositionNamesMap = {
      bottom: 0,
      left: 1,
      top: 2,
      right: 3
    };
  
    var GetValue$t = Phaser.Utils.Objects.GetValue;
    var Color = Phaser.Display.Color;
    var ColorToRGBA = Phaser.Display.Color.ColorToRGBA;
    var HSVToRGB = Phaser.Display.Color.HSVToRGB;
    var Clamp$1 = Phaser.Math.Clamp;
    var ColorComponents = /*#__PURE__*/function (_Sizer) {
      _inherits(ColorComponents, _Sizer);
      function ColorComponents(scene, config) {
        var _this;
        _classCallCheck(this, ColorComponents);
        if (config === undefined) {
          config = {};
        }
        config.orientation = 0;
        _this = _callSuper(this, ColorComponents, [scene, config]);
        _this.type = 'rexColorComponents';
        _this.colorObject = new Color();
  
        // Add elements
        var background = GetValue$t(config, 'background', undefined);
        var formatLabel = GetValue$t(config, 'formatLabel', undefined);
        if (!IsGameObject(formatLabel)) {
          formatLabel = CreateLabel(scene, formatLabel).resetDisplayContent();
        }
        var components = [];
        if (config.inputText0 && config.inputText1 && config.inputText2) {
          components.push(config.inputText0);
          components.push(config.inputText1);
          components.push(config.inputText2);
        } else {
          var inputTextConfig = GetValue$t(config, 'inputText');
          for (var i = 0; i < 3; i++) {
            var inputText = CreateInputText$1(scene, inputTextConfig).setMaxLength(3).setNumberInput();
            components.push(inputText);
          }
        }
        if (background) {
          _this.addBackground(background);
        }
        var proportion = GetValue$t(config, 'proportion.formatLabel', 0);
        var defaultExpand = formatLabel.isRexContainerLite ? true : false;
        var expand = GetValue$t(config, 'expand.formatLabel', defaultExpand);
        _this.add(formatLabel, {
          proportion: proportion,
          expand: expand
        });
        var proportion = GetValue$t(inputTextConfig, 'width') === undefined ? 1 : 0;
        var expand = GetValue$t(inputTextConfig, 'height') === undefined ? true : false;
        for (var i = 0, cnt = components.length; i < cnt; i++) {
          _this.add(components[i], {
            proportion: proportion,
            expand: expand
          });
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('formatLabel', formatLabel);
        _this.addChildrenMap('components', components);
        _this.onClick(formatLabel, _this.toggleColorFormat, _assertThisInitialized(_this));
        for (var i = 0, cnt = components.length; i < cnt; i++) {
          components[i].on('close', function () {
            this.updateColorObject();
            this.setValue(this.colorObject.color);
          }, _assertThisInitialized(_this));
        }
        var callback = GetValue$t(config, 'valuechangeCallback', null);
        if (callback !== null) {
          var scope = GetValue$t(config, 'valuechangeCallbackScope', undefined);
          _this.on('valuechange', callback, scope);
        }
        formatLabel.setText('RGB');
        _this.setValue(GetValue$t(config, 'value', 0xffffff));
        return _this;
      }
      _createClass(ColorComponents, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          value = Clamp$1(Math.floor(value), 0, 0xffffff);
          if (this._value === value) {
            return;
          }
          this._value = value;
          this.colorObject.setFromRGB(ColorToRGBA(value));
          this.updateComponents();
          this.emit('valuechange', this._value);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }, {
        key: "color",
        get: function get() {
          return this._value;
        },
        set: function set(color) {
          this.value = color;
        }
      }, {
        key: "setColor",
        value: function setColor(color) {
          this.color = color;
          return this;
        }
      }, {
        key: "colorFormat",
        get: function get() {
          return this.childrenMap.formatLabel.text;
        },
        set: function set(value) {
          if (this.colorFormat === value) {
            return;
          }
          this.childrenMap.formatLabel.setText(value);
          this.updateComponents();
        }
      }, {
        key: "setColorFormat",
        value: function setColorFormat(colrType) {
          this.colorFormat = colrType;
          return this;
        }
      }, {
        key: "toggleColorFormat",
        value: function toggleColorFormat() {
          this.colorFormat = this.colorFormat === 'RGB' ? 'HSV' : 'RGB';
          return this;
        }
      }, {
        key: "updateComponents",
        value: function updateComponents() {
          var components = this.childrenMap.components;
          var value0, value1, value2;
          if (this.colorFormat === 'RGB') {
            value0 = this.colorObject.red;
            value1 = this.colorObject.green;
            value2 = this.colorObject.blue;
          } else {
            // colorFormat === 'HSV'
            value0 = Math.floor(this.colorObject.h * 360);
            value1 = Math.floor(this.colorObject.s * 100);
            value2 = Math.floor(this.colorObject.v * 100);
          }
          components[0].setValue(value0);
          components[1].setValue(value1);
          components[2].setValue(value2);
          return this;
        }
      }, {
        key: "updateColorObject",
        value: function updateColorObject() {
          var components = this.childrenMap.components;
          if (this.colorFormat === 'RGB') {
            var red = Clamp$1(components[0].value, 0, 255);
            var green = Clamp$1(components[1].value, 0, 255);
            var blue = Clamp$1(components[2].value, 0, 255);
            this.colorObject.setTo(red, green, blue);
          } else {
            var h = Clamp$1(components[0].value, 0, 359) / 360;
            var s = Clamp$1(components[1].value, 0, 100) / 100;
            var v = Clamp$1(components[2].value, 0, 100) / 100;
            this.colorObject.setFromRGB(HSVToRGB(h, s, v));
          }
          return this;
        }
      }]);
      return ColorComponents;
    }(Sizer);
  
    var GetValue$s = Phaser.Utils.Objects.GetValue;
    var ColorPickerPanel = /*#__PURE__*/function (_Sizer) {
      _inherits(ColorPickerPanel, _Sizer);
      function ColorPickerPanel(scene, config) {
        var _this;
        _classCallCheck(this, ColorPickerPanel);
        if (config === undefined) {
          config = {};
        }
        config.orientation = 1;
        _this = _callSuper(this, ColorPickerPanel, [scene, config]);
        _this.type = 'rexColorInput.ColorPickerPanel';
  
        // Add elements
        var background = GetValue$s(config, 'background', undefined);
        var colorPicker = new ColorPicker(scene, {
          hPalette: config.hPalette || {},
          svPalette: config.svPalette || {},
          space: {
            item: GetValue$s(config, 'space.hPalette', 8)
          }
        });
        scene.add.existing(colorPicker);
        var colorComponents;
        if (config.colorComponents) {
          colorComponents = new ColorComponents(scene, config.colorComponents);
          scene.add.existing(colorComponents);
        }
        if (background) {
          _this.addBackground(background);
          new TouchEventStop(background, {
            stopAllLevels: false
          });
        }
        _this.add(colorPicker, {
          proportion: 1,
          expand: true
        });
        if (colorComponents) {
          _this.add(colorComponents, {
            proportion: 0,
            expand: true
          });
        }
        _this.addChildrenMap('background', background);
        _this.addChildrenMap('colorPicker', colorPicker);
        _this.addChildrenMap('colorComponents', colorComponents);
        colorPicker.on('valuechange', function (value) {
          this.setValue(value);
        }, _assertThisInitialized(_this));
        if (colorComponents) {
          colorComponents.on('valuechange', function (value) {
            this.setValue(value);
          }, _assertThisInitialized(_this));
        }
        _this.setValue(GetValue$s(config, 'value', 0xffffff));
        return _this;
      }
      _createClass(ColorPickerPanel, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(value) {
          if (this._value === value) {
            return;
          }
          this._value = value;
          var colorPicker = this.childrenMap.colorPicker;
          colorPicker.setValue(value);
          var colorComponents = this.childrenMap.colorComponents;
          if (colorComponents) {
            colorComponents.setValue(value);
          }
          this.emit('valuechange', value);
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.value = value;
          return this;
        }
      }]);
      return ColorPickerPanel;
    }(Sizer);
  
    Phaser.Utils.Objects.GetValue;
    var CreateColorPicker = function CreateColorPicker(scene) {
      var scene = this.scene;
      var background;
      var createBackgroundCallback = this.colorPickerCreateBackgroundCallback;
      if (createBackgroundCallback) {
        background = createBackgroundCallback.call(this, scene);
        scene.add.existing(background);
      }
      var width = this.colorPickerWidth;
      if (width === undefined) {
        width = this.width;
      }
      var height = this.colorPickerHeight;
      if (height === undefined) {
        height = width;
      }
      var colorComponentsConfig;
      if (this.colorComponentsHeight > 0) {
        colorComponentsConfig = {
          height: this.colorComponentsHeight,
          formatLabel: this.colorComponentsFormatLabelConfig,
          inputText: this.colorComponentsInputTextConfig,
          space: this.colorComponentsSpace
        };
      } else {
        colorComponentsConfig = false;
      }
      var colorPicker = new ColorPickerPanel(scene, {
        width: width,
        height: height,
        background: background,
        space: this.colorPickerSpace,
        hPalette: {
          position: this.colorPickerHPalettePosition
        },
        colorComponents: colorComponentsConfig,
        value: this.value
      });
      scene.add.existing(colorPicker);
      return colorPicker;
    };
  
    var OpenColorPicker = function OpenColorPicker() {
      if (this.colorPicker) {
        return;
      }
  
      // Layout it to get full height
      var colorPicker = CreateColorPicker.call(this).layout();
      var dropDownBehavior = new DropDown(colorPicker, {
        // Transition
        duration: {
          "in": this.colorPickerEaseInDuration,
          out: this.colorPickerEaseOutDuration
        },
        transitIn: this.colorPickerTransitInCallback,
        transitOut: this.colorPickerTransitOutCallback,
        // Position
        expandDirection: this.colorPickerExpandDirection,
        alignTargetX: this,
        alignTargetY: this,
        bounds: this.colorPickerBounds,
        // Close condition
        touchOutsideClose: true
      }).on('open', function () {
        // After popping up
        // Can click
        colorPicker.on('valuechange', function (value) {
          this.setValue(value);
        }, this);
      }, this).on('close', function () {
        this.colorPicker = undefined;
        this.dropDownBehavior = undefined;
      }, this);
      this.colorPicker = colorPicker;
      this.dropDownBehavior = dropDownBehavior;
      this.pin(colorPicker);
      return this;
    };
  
    var methods$3 = {
      openColorPicker: OpenColorPicker
    };
    Object.assign(methods$3, methods$4);
  
    var GetValue$r = Phaser.Utils.Objects.GetValue;
    var ColorInput = /*#__PURE__*/function (_ColorInputBase) {
      _inherits(ColorInput, _ColorInputBase);
      function ColorInput(scene, config) {
        var _this;
        _classCallCheck(this, ColorInput);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, ColorInput, [scene, config]);
        _this.type = 'rexColorInput';
        if (!config.hasOwnProperty('colorPicker')) {
          config.colorPicker = {
            background: {
              color: 0x0
            }
          };
        }
        var colorPickerConfig = config.colorPicker;
        var hasColorPicker = colorPickerConfig !== false && colorPickerConfig !== null;
        if (hasColorPicker) {
          _this.setColorPickerSize(GetValue$r(colorPickerConfig, 'width', 160), GetValue$r(colorPickerConfig, 'height', 170));
          var createBackgroundCallback;
          var background = GetValue$r(colorPickerConfig, 'background');
          if (background) {
            createBackgroundCallback = function createBackgroundCallback(scene) {
              return CreateBackground$2(scene, background);
            };
          } else {
            createBackgroundCallback = GetValue$r(colorPickerConfig, 'createBackgroundCallback');
          }
          _this.setCreateColorPickerBackgroundCallback(createBackgroundCallback);
          _this.setColorPickerHPalettePosition(GetValue$r(colorPickerConfig, 'hPalettePosition', 0));
          _this.setColorPickerExpandDirection(GetValue$r(colorPickerConfig, 'expandDirection'));
          _this.setColorPickerEaseInDuration(GetValue$r(colorPickerConfig, 'easeIn', 200));
          _this.setColorPickerEaseOutDuration(GetValue$r(colorPickerConfig, 'easeOut', 200));
          _this.setColorPickerTransitInCallback(GetValue$r(colorPickerConfig, 'transitIn'));
          _this.setColorPickerTransitOutCallback(GetValue$r(colorPickerConfig, 'transitOut'));
          _this.setColorPickerBounds(GetValue$r(colorPickerConfig, 'bounds'));
          var colorPickerSpaceConfig = GetValue$r(colorPickerConfig, 'space');
          if (colorPickerSpaceConfig === undefined) {
            colorPickerSpaceConfig = {
              left: 10,
              right: 10,
              top: 10,
              bottom: 10,
              item: 8
            };
          }
          _this.setColorPickerSpace(colorPickerSpaceConfig);
        }
        var colorComponentsConfig = config.colorComponents;
        var hasColorComponents = colorComponentsConfig !== false && colorComponentsConfig !== null;
        if (hasColorPicker && hasColorComponents) {
          _this.setColorComponentsHeight(GetValue$r(colorComponentsConfig, 'height', 30));
          _this.setColorComponentsFormatLabelConfig(GetValue$r(colorComponentsConfig, 'formatLabel'));
          var colorComponentsInputTextConfig = GetValue$r(colorComponentsConfig, 'inputText');
          if (!colorComponentsInputTextConfig) {
            colorComponentsInputTextConfig = GetValue$r(config, 'inputText');
          }
          _this.setColorComponentsInputTextConfig(colorComponentsInputTextConfig);
          var colorComponentsSpace = GetValue$r(colorComponentsConfig, 'space');
          if (colorComponentsSpace === undefined) {
            colorComponentsSpace = {
              item: 8
            };
          }
          _this.setColorComponentsSpace(colorComponentsSpace);
        }
        var swatch = _this.childrenMap.swatch;
        if (swatch && hasColorPicker) {
          _this.onClick(swatch, _this.openColorPicker, _assertThisInitialized(_this));
        }
        return _this;
      }
      return _createClass(ColorInput);
    }(ColorInput$1);
    Object.assign(ColorInput.prototype, methods$3);
  
    ObjectFactory.register('colorInput', function (config) {
      var gameObject = new ColorInput(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ColorInput', ColorInput);
  
    ObjectFactory.register('colorInputLite', function (config) {
      var gameObject = new ColorInput$1(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ColorInputBase', ColorInput$1);
  
    ObjectFactory.register('colorPicker', function (config) {
      var gameObject = new ColorPicker(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ColorPicker', ColorPicker);
  
    ObjectFactory.register('colorComponents', function (config) {
      var gameObject = new ColorComponents(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.ColorComponents', ColorComponents);
  
    var RequestDrag = function RequestDrag(gameObject) {
      var inputPlugin = gameObject.scene.input;
      var inputManager = inputPlugin.manager;
      var pointersTotal = inputManager.pointersTotal;
      var pointers = inputManager.pointers,
        pointer;
      for (var i = 0; i < pointersTotal; i++) {
        pointer = pointers[i];
        if (!pointer.primaryDown || inputPlugin.getDragState(pointer) !== 0 || !IsPointerInHitArea(gameObject, pointer)) {
          continue;
        }
  
        // For 3.18.0
        inputPlugin.setDragState(pointer, 1);
        inputPlugin._drag[pointer.id] = [gameObject];
        if (inputPlugin.dragDistanceThreshold === 0 || inputPlugin.dragTimeThreshold === 0) {
          //  No drag criteria, so snap immediately to mode 3
          inputPlugin.setDragState(pointer, 3);
          inputPlugin.processDragStartList(pointer);
        } else {
          //  Check the distance / time on the next event
          inputPlugin.setDragState(pointer, 2);
        }
        // For 3.18.0
  
        return true;
      }
      return false;
    };
  
    var GetValue$q = Phaser.Utils.Objects.GetValue;
    var DistanceBetween = Phaser.Math.Distance.Between;
    var RotateAroundDistance = Phaser.Math.RotateAroundDistance;
    var Drag = /*#__PURE__*/function (_ComponentBase) {
      _inherits(Drag, _ComponentBase);
      function Drag(gameObject, config) {
        var _this;
        _classCallCheck(this, Drag);
        _this = _callSuper(this, Drag, [gameObject, {
          eventEmitter: false
        }]);
        // No event emitter
        // this.parent = gameObject;
  
        _this._enable = undefined;
        gameObject.setInteractive(GetValue$q(config, "inputConfig", undefined));
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Drag, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          this.pointer = undefined;
          this.setEnable(GetValue$q(o, "enable", true));
          this.setAxisMode(GetValue$q(o, "axis", 0));
          this.setAxisRotation(GetValue$q(o, "rotation", 0));
          return this;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            enable: this.enable,
            axis: this.axisMode,
            rotation: this.axisRotation
          };
        }
      }, {
        key: "boot",
        value: function boot() {
          var gameObject = this.parent;
          gameObject.on('dragstart', this.onDragStart, this);
          gameObject.on('drag', this.onDrag, this);
          gameObject.on('dragend', this.onDragEnd, this);
        }
      }, {
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
  
          // GameObject events will be removed when this gameObject destroyed 
          // this.parent.on('dragstart', this.onDragStart, this);
          // this.parent.on('drag', this.onDrag, this);
          // this.parent.on('dragend', this.onDragEnd, this);
          this.pointer = undefined;
          _get(_getPrototypeOf(Drag.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(e) {
          if (this._enable === e) {
            return;
          }
          if (!e) {
            this.dragend();
          }
          this._enable = e;
          this.scene.input.setDraggable(this.parent, e);
          return this;
        }
      }, {
        key: "setEnable",
        value: function setEnable(e) {
          if (e === undefined) {
            e = true;
          }
          this.enable = e;
          return this;
        }
      }, {
        key: "toggleEnable",
        value: function toggleEnable() {
          this.setEnable(!this.enable);
          return this;
        }
      }, {
        key: "setAxisMode",
        value: function setAxisMode(m) {
          if (typeof m === 'string') {
            m = DIRECTIONNODE[m];
          }
          this.axisMode = m;
          return this;
        }
      }, {
        key: "setAxisRotation",
        value: function setAxisRotation(a) {
          this.axisRotation = a;
          return this;
        }
      }, {
        key: "drag",
        value: function drag() {
          RequestDrag(this.parent);
          return this;
        }
      }, {
        key: "dragend",
        value: function dragend() {
          if (!this.isDragging) {
            return;
          }
          this.scene.input.setDragState(this.pointer, 5);
          return this;
        }
      }, {
        key: "onDragStart",
        value: function onDragStart(pointer, dragX, dragY) {
          if (this.isDragging) {
            return;
          }
          this.pointer = pointer;
        }
      }, {
        key: "onDrag",
        value: function onDrag(pointer, dragX, dragY) {
          if (this.pointer !== pointer) {
            return;
          }
          var gameObject = this.parent;
          if (this.axisMode === 0) {
            gameObject.x = dragX;
            gameObject.y = dragY;
          } else if (this.axisRotation === 0) {
            if (this.axisMode === 1) {
              gameObject.x = dragX;
            } else if (this.axisMode === 2) {
              gameObject.y = dragY;
            }
          } else {
            var dist;
            var p1 = {
              x: dragX,
              y: dragY
            };
            dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
            p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, -this.axisRotation, dist);
            if (this.axisMode === 1) {
              p1.y = gameObject.y;
            } else if (this.axisMode === 2) {
              p1.x = gameObject.x;
            }
            dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
            p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, this.axisRotation, dist);
            gameObject.x = p1.x;
            gameObject.y = p1.y;
          }
        }
      }, {
        key: "onDragEnd",
        value: function onDragEnd(pointer, dragX, dragY, dropped) {
          if (this.pointer !== pointer) {
            return;
          }
          this.pointer = undefined;
        }
      }, {
        key: "isDragging",
        get: function get() {
          return this.pointer !== undefined;
        }
      }]);
      return Drag;
    }(ComponentBase);
    var DIRECTIONNODE = {
      'both': 0,
      'h&v': 0,
      'x&y': 0,
      'horizontal': 1,
      'h': 1,
      'x': 1,
      'vertical': 2,
      'v': 2,
      'y': 2
    };
  
    var OnDragSplitter = function OnDragSplitter() {
      var firstChild = this.sizerChildren[0];
      var splitter = this.sizerChildren[1];
      var secondChild = this.sizerChildren[2];
      var firstChildSizerPadding = this.getSizerConfig(firstChild).padding,
        splitterSizerPadding = this.getSizerConfig(splitter).padding,
        secondChildSizerPadding = this.getSizerConfig(secondChild).padding;
      if (this.orientation === 0) {
        var firstChildInnerLeft = this.innerLeft + firstChildSizerPadding.left;
        var secondChildInnerRight = this.innerRight - secondChildSizerPadding.right;
        var splitterWidth = GetDisplayWidth(splitter);
        var splitterLeft = splitter.x + splitterWidth * (0 - splitter.originX);
        var splitterRight = splitter.x + splitterWidth * (1 - splitter.originX);
        var firstChildInnerRight = splitterLeft - splitterSizerPadding.left - this.space.item - firstChildSizerPadding.right;
        var secondChildInnerLeft = splitterRight + splitterSizerPadding.right + this.space.item + secondChildSizerPadding.left;
        var firstChildInnerWidth = firstChildInnerRight - firstChildInnerLeft;
        var secondChildInnerWidth = secondChildInnerRight - secondChildInnerLeft;
        var totalChildrenInnerWidth = firstChildInnerWidth + secondChildInnerWidth;
        if (this.minFirstChildSize > 0 && firstChildInnerWidth < this.minFirstChildSize) {
          firstChildInnerWidth = this.minFirstChildSize;
          secondChildInnerWidth = totalChildrenInnerWidth - firstChildInnerWidth;
        }
        if (this.minSecondChildSize > 0 && secondChildInnerWidth < this.minSecondChildSize) {
          secondChildInnerWidth = this.minSecondChildSize;
          firstChildInnerWidth = totalChildrenInnerWidth - secondChildInnerWidth;
        }
        this.setSplitRatio(firstChildInnerWidth / totalChildrenInnerWidth);
      } else {
        var firstChildInnerTop = this.innerTop + firstChildSizerPadding.top;
        var secondChildInnerBottom = this.innerBottom - secondChildSizerPadding.bottom;
        var splitterHeight = GetDisplayHeight(splitter);
        var splitterTop = splitter.y + splitterHeight * (0 - splitter.originY);
        var splitterBottom = splitter.y + splitterHeight * (1 - splitter.originY);
        var firstChildInnerBottom = splitterTop - splitterSizerPadding.top - this.space.item - firstChildSizerPadding.bottom;
        var secondChildInnerTop = splitterBottom + splitterSizerPadding.bottom + this.space.item + secondChildSizerPadding.top;
        var firstChildInnerHeight = firstChildInnerBottom - firstChildInnerTop;
        var secondChildInnerHeight = secondChildInnerBottom - secondChildInnerTop;
        var totalChildrenInnerHeight = firstChildInnerHeight + secondChildInnerHeight;
        if (this.minFirstChildSize > 0 && firstChildInnerHeight < this.minFirstChildSize) {
          firstChildInnerHeight = this.minFirstChildSize;
          secondChildInnerHeight = totalChildrenInnerHeight - firstChildInnerHeight;
        }
        if (this.minSecondChildSize > 0 && secondChildInnerHeight < this.minSecondChildSize) {
          secondChildInnerHeight = this.minSecondChildSize;
          firstChildInnerHeight = totalChildrenInnerHeight - secondChildInnerHeight;
        }
        this.setSplitRatio(firstChildInnerHeight / totalChildrenInnerHeight);
      }
      var minWidthSave = this.minWidth,
        minHeightSave = this.minHeight;
      this.setMinSize(this.width, this.height).layout().setMinSize(minWidthSave, minHeightSave);
    };
  
    var GetValue$p = Phaser.Utils.Objects.GetValue;
    var Clamp = Phaser.Math.Clamp;
    var SplitPanels = /*#__PURE__*/function (_Sizer) {
      _inherits(SplitPanels, _Sizer);
      function SplitPanels(scene, config) {
        var _this;
        _classCallCheck(this, SplitPanels);
        if (!config.hasOwnProperty('orientation')) {
          config.orientation = config.hasOwnProperty('leftPanel') ? 0 : 1;
        }
        _this = _callSuper(this, SplitPanels, [scene, config]);
        _this.type = 'rexSplit';
  
        // Add elements
        var background = GetValue$p(config, 'background', undefined);
        var firstChildKey, secondChildKey;
        var minFirstChildSizeKey, minSecondChildSizeKey;
        if (_this.orientation === 0) {
          firstChildKey = 'leftPanel';
          secondChildKey = 'rightPanel';
          minFirstChildSizeKey = 'minLeftPanelWidth';
          minSecondChildSizeKey = 'minRightPanelWidth';
        } else {
          firstChildKey = 'topPanel';
          secondChildKey = 'bottomPanel';
          minFirstChildSizeKey = 'minTopPanelHeight';
          minSecondChildSizeKey = 'minBottomPanelHeight';
        }
        var firstChild = GetValue$p(config, firstChildKey, undefined);
        var splitter = GetValue$p(config, 'splitter', undefined);
        var secondChild = GetValue$p(config, secondChildKey, undefined);
        if (background) {
          _this.addBackground(background);
        }
        var spaceConfig = GetValue$p(config, 'space', undefined);
        _this.add(firstChild, {
          proportion: 1,
          expand: true,
          padding: {
            left: GetValue$p(spaceConfig, "".concat(firstChildKey, "Left"), 0),
            right: GetValue$p(spaceConfig, "".concat(firstChildKey, "Right"), 0),
            top: GetValue$p(spaceConfig, "".concat(firstChildKey, "Top"), 0),
            bottom: GetValue$p(spaceConfig, "".concat(firstChildKey, "Bottom"), 0)
          }
        });
        _this.add(splitter, {
          proportion: 0,
          expand: true,
          padding: {
            left: GetValue$p(spaceConfig, 'splitterLeft', 0),
            right: GetValue$p(spaceConfig, 'splitterRight', 0),
            top: GetValue$p(spaceConfig, 'splitterTop', 0),
            bottom: GetValue$p(spaceConfig, 'splitterBottom', 0)
          }
        });
        _this.add(secondChild, {
          proportion: 1,
          expand: true,
          padding: {
            left: GetValue$p(spaceConfig, "".concat(secondChildKey, "Left"), 0),
            right: GetValue$p(spaceConfig, "".concat(secondChildKey, "Right"), 0),
            top: GetValue$p(spaceConfig, "".concat(secondChildKey, "Top"), 0),
            bottom: GetValue$p(spaceConfig, "".concat(secondChildKey, "Bottom"), 0)
          }
        });
        _this.addChildrenMap('background', background);
        _this.addChildrenMap(firstChildKey, firstChild);
        _this.addChildrenMap('splitter', splitter);
        _this.addChildrenMap(secondChildKey, secondChild);
        _this.minFirstChildSize = GetValue$p(config, minFirstChildSizeKey, 0);
        _this.minSecondChildSize = GetValue$p(config, minSecondChildSizeKey, 0);
        _this.setSplitRatio(GetValue$p(config, 'splitRatio', 0.5));
        _this.splitterDragBehavior = new Drag(splitter, {
          axis: _this.orientation === 0 ? 1 : 2
        });
        splitter.on('dragstart', function () {
          this.emit('splitter.dragstart', splitter, this.splitRatio);
        }, _assertThisInitialized(_this)).on('dragend', function () {
          this.emit('splitter.dragend', splitter, this.splitRatio);
        }, _assertThisInitialized(_this)).on('drag', function () {
          OnDragSplitter.call(this);
          this.emit('splitter.drag', splitter, this.splitRatio);
        }, _assertThisInitialized(_this)).on('pointerover', function () {
          this.emit('splitter.over', splitter, this.splitRatio);
        }, _assertThisInitialized(_this)).on('pointerout', function () {
          this.emit('splitter.out', splitter, this.splitRatio);
        }, _assertThisInitialized(_this));
        return _this;
      }
      _createClass(SplitPanels, [{
        key: "splitterEnable",
        get: function get() {
          return this.splitterDragBehavior.enable;
        },
        set: function set(value) {
          this.splitterDragBehavior.setEnable(value);
        }
      }, {
        key: "setSplitterEnable",
        value: function setSplitterEnable(enable) {
          if (enable === undefined) {
            enable = true;
          }
          this.splitterEnable = enable;
          return this;
        }
      }, {
        key: "minLeftPanelWidth",
        get: function get() {
          return this.minFirstChildSize;
        },
        set: function set(value) {
          this.minFirstChildSize = value;
        }
      }, {
        key: "minRightPanelWidth",
        get: function get() {
          return this.minSecondChildSize;
        },
        set: function set(value) {
          this.minSecondChildSize = value;
        }
      }, {
        key: "minTopPanelHeight",
        get: function get() {
          return this.minFirstChildSize;
        },
        set: function set(value) {
          this.minFirstChildSize = value;
        }
      }, {
        key: "minBottomPanelHeight",
        get: function get() {
          return this.minSecondChildSize;
        },
        set: function set(value) {
          this.minSecondChildSize = value;
        }
      }, {
        key: "setMinLeftPanelWidth",
        value: function setMinLeftPanelWidth(value) {
          this.minLeftPanelWidth = value;
          return this;
        }
      }, {
        key: "setMinRightPanelWidth",
        value: function setMinRightPanelWidth(value) {
          this.minRightPanelWidth = value;
          return this;
        }
      }, {
        key: "setMinTopPanelHeight",
        value: function setMinTopPanelHeight(value) {
          this.minTopPanelHeight = value;
          return this;
        }
      }, {
        key: "setMinBottomPanelHeight",
        value: function setMinBottomPanelHeight(value) {
          this.minBottomPanelHeight = value;
          return this;
        }
      }, {
        key: "splitRatio",
        get: function get() {
          return this._splitRatio;
        },
        set: function set(value) {
          value = Clamp(value, 0, 1);
          if (this._splitRatio === value) {
            return;
          }
          this._splitRatio = value;
          this.getSizerConfig(this.sizerChildren[0]).proportion = value;
          this.getSizerConfig(this.sizerChildren[2]).proportion = 1 - value;
        }
      }, {
        key: "setSplitRatio",
        value: function setSplitRatio(value) {
          this.splitRatio = value;
          return this;
        }
      }]);
      return SplitPanels;
    }(Sizer);
  
    ObjectFactory.register('splitPanels', function (config) {
      var gameObject = new SplitPanels(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.SplitPanels', SplitPanels);
  
    var GetShowCallback$1 = function GetShowCallback() {
      return function (child, key, sides, reset) {
        if (key !== 'panel') {
          sides.setChildVisible(child, true);
        }
      };
    };
    var GetHideCallback$1 = function GetHideCallback() {
      return function (child, key, sides, reset) {
        if (key !== 'panel') {
          sides.setChildVisible(child, false);
        }
      };
    };
    var VisibleCallbacks = {
      show: GetShowCallback$1,
      hide: GetHideCallback$1
    };
  
    var GetShowCallback = function GetShowCallback(duration, alpha) {
      if (alpha === undefined) {
        alpha = 1;
      }
      return function (child, key, sides, reset) {
        if (key !== 'panel') {
          sides.fadeChild(child, reset ? 0 : duration, alpha);
        }
      };
    };
    var GetHideCallback = function GetHideCallback(duration, alpha) {
      if (alpha === undefined) {
        alpha = 0;
      }
      return function (child, key, sides, reset) {
        if (key !== 'panel') {
          sides.fadeChild(child, reset ? 0 : duration, alpha);
        }
      };
    };
    var FadeCallbacks = {
      show: GetShowCallback,
      hide: GetHideCallback
    };
  
    var GetCallback$1 = function GetCallback(duration, ease) {
      return function (child, key, sides, reset) {
        if (key !== 'panel') {
          sides.moveChild(child, reset ? 0 : duration, ease);
        }
      };
    };
    var MoveCallbacks = {
      show: GetCallback$1,
      hide: GetCallback$1
    };
  
    var GetCallback = function GetCallback(duration, ease) {
      return function (child, key, sides, reset) {
        if (key === 'panel') {
          sides.moveChild(child, reset ? 0 : duration, ease);
        }
      };
    };
    var MovePanelCallbacks = {
      show: GetCallback,
      hide: GetCallback
    };
  
    var DefaultCallbacks = {
      visible: VisibleCallbacks,
      fade: FadeCallbacks,
      move: MoveCallbacks,
      'move-panel': MovePanelCallbacks
    };
    var GetDefaultCallbacks = function GetDefaultCallbacks(config) {
      var callbackType, callbackParams;
      var _ref = typeof config === 'string' ? [config] : config;
      var _ref2 = _toArray(_ref);
      callbackType = _ref2[0];
      callbackParams = _ref2.slice(1);
      var showCallback, hideCallback;
      if (DefaultCallbacks.hasOwnProperty(callbackType)) {
        showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
        hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
      } else {
        showCallback = NOOP;
        hideCallback = NOOP;
      }
      return {
        show: showCallback,
        hide: hideCallback
      };
    };
  
    var ShowChildMethods = {
      showChild: function showChild(key, reset) {
        var child = this.sizerChildren[key];
        if (child) {
          this.emit('showchild', child, key, this, reset);
          this.resetChildState(child);
        }
        return this;
      },
      hideChild: function hideChild(key, reset) {
        var child = this.sizerChildren[key];
        if (child) {
          this.emit('hidechild', child, key, this, reset);
          this.resetChildState(child);
        }
        return this;
      },
      swapChild: function swapChild(key, reset) {
        if (this.currentChildKey === key) ; else if (this.currentChildKey === 'panel' || key === 'panel') {
          this.previousChildKey = this.currentChildKey;
          this.currentChildKey = key;
          this.hideChild(this.previousChildKey, reset);
          this.showChild(this.currentChildKey, reset);
        } else {
          // Swap from current side to another side
          this.swapChild('panel', reset);
          this.swapChild(key, reset);
        }
        return this;
      },
      showPanel: function showPanel(reset) {
        this.swapChild('panel', reset);
        return this;
      },
      showLeftSide: function showLeftSide() {
        this.swapChild('leftSide');
        return this;
      },
      showRightSide: function showRightSide() {
        this.swapChild('rightSide');
        return this;
      },
      showTopSide: function showTopSide() {
        this.swapChild('topSide');
        return this;
      },
      showBottomSide: function showBottomSide() {
        this.swapChild('bottomSide');
        return this;
      },
      hideLeftSide: function hideLeftSide() {
        if (this.currentChildKey == 'leftSide') {
          this.showPanel();
        }
        return this;
      },
      hideRightSide: function hideRightSide() {
        if (this.currentChildKey == 'rightSide') {
          this.showPanel();
        }
        return this;
      },
      hideTopSide: function hideTopSide() {
        if (this.currentChildKey == 'topSide') {
          this.showPanel();
        }
        return this;
      },
      hideBottomSide: function hideBottomSide() {
        if (this.currentChildKey == 'bottomSide') {
          this.showPanel();
        }
        return this;
      },
      toggleLeftSide: function toggleLeftSide() {
        var key = this.currentChildKey !== 'panel' ? 'panel' : 'leftSide';
        this.swapChild(key);
        return this;
      },
      toggleRightSide: function toggleRightSide() {
        var key = this.currentChildKey !== 'panel' ? 'panel' : 'rightSide';
        this.swapChild(key);
        return this;
      },
      toggleTopSide: function toggleTopSide() {
        var key = this.currentChildKey !== 'panel' ? 'panel' : 'topSide';
        this.swapChild(key);
        return this;
      },
      toggleBottomSide: function toggleBottomSide() {
        var key = this.currentChildKey !== 'panel' ? 'panel' : 'bottomSide';
        this.swapChild(key);
        return this;
      }
    };
  
    var ContainerSetChildVisible = ContainerLite.prototype.setChildVisible;
    var Visible = {
      setChildVisible: function setChildVisible(child, visible) {
        var key;
        if (typeof child === 'string') {
          var key = child;
          child = this.sizerChildren[key];
        } else {
          key = IndexOf(this.sizerChildren, child);
        }
        if (visible === undefined) {
          visible = this.currentChildKey === key ? true : false;
        }
        ContainerSetChildVisible.call(this, child, visible);
        return this;
      }
    };
  
    var Fade = {
      fadeChild: function fadeChild(child, duration, alpha) {
        var key;
        if (typeof child === 'string') {
          key = child;
          child = this.sizerChildren[key];
        } else {
          key = IndexOf(this.sizerChildren, child);
        }
        if (duration === undefined) {
          duration = 500;
        }
        if (alpha === undefined) {
          alpha = this.currentChildKey === key ? 1 : 0;
        }
        child.fadeIn(duration, {
          start: child.alpha,
          end: alpha
        });
        return this;
      },
      fadeChildPromise: function fadeChildPromise(child, duration, alpha) {
        if (typeof child === 'string') {
          child = this.sizerChildren[key];
        }
        this.fadeChild(child, duration, alpha);
        if (child._fade) {
          return WaitComplete(child._fade);
        } else {
          return Promise.resolve();
        }
      }
    };
  
    var Move = {
      moveChild: function moveChild(child, duration, ease, distance) {
        var key;
        if (typeof child === 'string') {
          key = child;
          child = this.sizerChildren[key];
        } else {
          key = IndexOf(this.sizerChildren, child);
        }
        if (duration === undefined) {
          duration = 500;
        }
        var isShownChild = this.currentChildKey === key;
        if (distance === undefined) {
          switch (key) {
            case 'leftSide':
            case 'rightSide':
              distance = GetDisplayWidth(child);
              break;
            case 'topSide':
            case 'bottomSide':
              distance = GetDisplayHeight(child);
              break;
            default:
              // 'panel'
              if (isShownChild) {
                // Show panel
                switch (this.previousChildKey) {
                  case 'leftSide':
                  case 'rightSide':
                    distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                    break;
                  case 'topSide':
                  case 'bottomSide':
                    distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                    break;
                  default:
                    distance = 0;
                    break;
                }
              } else {
                // Hide panel
                switch (this.currentChildKey) {
                  case 'leftSide':
                  case 'rightSide':
                    distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                    break;
                  case 'topSide':
                  case 'bottomSide':
                    distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                    break;
                  default:
                    distance = 0;
                    break;
                }
              }
              break;
          }
        }
        var moveLeft, moveRight, moveUp, moveDown;
        if (isShownChild) {
          switch (key) {
            case 'panel':
              switch (this.previousChildKey) {
                case 'leftSide':
                  moveLeft = true;
                  break;
                case 'rightSide':
                  moveRight = true;
                  break;
                case 'topSide':
                  moveUp = true;
                  break;
                case 'bottomSide':
                  moveDown = true;
                  break;
              }
              break;
            case 'leftSide':
              moveRight = true;
              break;
            case 'rightSide':
              moveLeft = true;
              break;
            case 'topSide':
              moveDown = true;
              break;
            case 'bottomSide':
              moveUp = true;
              break;
          }
        } else {
          // Hide
          switch (key) {
            case 'panel':
              switch (this.currentChildKey) {
                case 'leftSide':
                  moveRight = true;
                  break;
                case 'rightSide':
                  moveLeft = true;
                  break;
                case 'topSide':
                  moveDown = true;
                  break;
                case 'bottomSide':
                  moveUp = true;
                  break;
              }
              break;
            case 'leftSide':
              moveLeft = true;
              break;
            case 'rightSide':
              moveRight = true;
              break;
            case 'topSide':
              moveUp = true;
              break;
            case 'bottomSide':
              moveDown = true;
              break;
          }
        }
        if (moveLeft) {
          child.moveTo(duration, "-=".concat(distance), undefined, ease);
        } else if (moveRight) {
          child.moveTo(duration, "+=".concat(distance), undefined, ease);
        } else if (moveUp) {
          child.moveTo(duration, undefined, "-=".concat(distance), ease);
        } else if (moveDown) {
          child.moveTo(duration, undefined, "+=".concat(distance), ease);
        } else {
          child.moveTo(0);
        }
        return this;
      },
      moveChildPromise: function moveChildPromise(child, duration, ease, distance) {
        if (typeof child === 'string') {
          child = this.sizerChildren[key];
        }
        this.moveChild(child, duration, ease, distance);
        if (child._easeMove) {
          return WaitComplete(child._easeMove);
        } else {
          return Promise.resolve();
        }
      }
    };
  
    var methods$2 = {};
    Object.assign(methods$2, Visible, Fade, Move);
  
    var GetValue$o = Phaser.Utils.Objects.GetValue;
    var Sides = /*#__PURE__*/function (_OverlapSizer) {
      _inherits(Sides, _OverlapSizer);
      function Sides(scene, config) {
        var _this;
        _classCallCheck(this, Sides);
        _this = _callSuper(this, Sides, [scene, config]);
        _this.type = 'rexSides';
        _this.childrenMap = _this.sizerChildren;
        _this.previousChildKey = undefined;
        _this.currentChildKey = undefined;
  
        // Callbacks
        var showChildCallback = GetValue$o(config, 'showChildCallback', undefined);
        if (showChildCallback) {
          // Has showChildCallback, and hideChildCallback
          if (IsFunction(showChildCallback)) {
            // Custom callbacks
            var showChildCallbackScope = GetValue$o(config, 'showChildCallbackScope', undefined);
            _this.on('showchild', showChildCallback, showChildCallbackScope);
            var hideChildCallback = GetValue$o(config, 'hideChildCallback', undefined);
            var hideChildCallbackScope = GetValue$o(config, 'hideChildCallbackScope', undefined);
            _this.on('hidechild', hideChildCallback, hideChildCallbackScope);
          } else {
            // Default callbacks
            var defaultCallbacks = GetDefaultCallbacks(showChildCallback);
            _this.on('showchild', defaultCallbacks.show);
            _this.on('hidechild', defaultCallbacks.hide);
          }
        }
  
        // Add elements
        var background = GetValue$o(config, 'background', undefined);
        var panel = GetValue$o(config, 'panel', undefined);
        var leftSide = GetValue$o(config, 'leftSide', undefined);
        var rightSide = GetValue$o(config, 'rightSide', undefined);
        var topSide = GetValue$o(config, 'topSide', undefined);
        var bottomSide = GetValue$o(config, 'bottomSide', undefined);
        if (background) {
          _this.addBackground(background);
        }
        if (panel) {
          _this.add(panel, 'panel', 'center', 0, true);
        }
        if (leftSide) {
          var expand = GetValue$o(config, 'expand.left', true);
          _this.add(leftSide, 'leftSide', 'left-top', 0, {
            height: expand
          });
        }
        if (rightSide) {
          var expand = GetValue$o(config, 'expand.right', true);
          _this.add(rightSide, 'rightSide', 'right-top', 0, {
            height: expand
          });
        }
        if (topSide) {
          var expand = GetValue$o(config, 'expand.top', true);
          _this.add(topSide, 'topSide', 'left-top', 0, {
            width: expand
          });
        }
        if (bottomSide) {
          var expand = GetValue$o(config, 'expand.bottom', true);
          _this.add(bottomSide, 'bottomSide', 'left-bottom', 0, {
            width: expand
          });
        }
        return _this;
      }
      _createClass(Sides, [{
        key: "reset",
        value: function reset() {
          this.previousChildKey = undefined;
          this.currentChildKey = 'panel';
          this.showChild('panel', true);
          this.hideChild('leftSide', true);
          this.hideChild('rightSide', true);
          this.hideChild('topSide', true);
          this.hideChild('bottomSide', true);
          return this;
        }
      }]);
      return Sides;
    }(OverlapSizer);
    Object.assign(Sides.prototype, ShowChildMethods, methods$2);
  
    ObjectFactory.register('sides', function (config) {
      var gameObject = new Sides(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Sides', Sides);
  
    var RegisterInputHandler = function RegisterInputHandler(config) {
      var isValidInputHandler = true;
      if (!config.hasOwnProperty('accept')) {
        isValidInputHandler = false;
        console.error("[Tweaker] Can't register inputHandler '".concat(config.name, "', missing 'accept' callback."));
      }
      if (!config.hasOwnProperty('build')) {
        isValidInputHandler = false;
        console.error("[Tweaker] Can't register inputHandler '".concat(config.name, "', missing 'build' callback."));
      }
      if (isValidInputHandler) {
        this.inputHandlers.unshift(config);
      }
      return this;
    };
  
    var GetFirst = Phaser.Utils.Array.GetFirst;
    var Remove = Phaser.Utils.Array.Remove;
    var RemoveInputHandler = function RemoveInputHandler(name) {
      var handler = GetFirst(this.inputHandlers, 'name', name);
      if (handler) {
        Remove(this.inputHandlers, handler);
      }
      return this;
    };
  
    var Title = /*#__PURE__*/function (_Label) {
      _inherits(Title, _Label);
      function Title(scene, config) {
        var _this;
        _classCallCheck(this, Title);
        config = BuildLabelConfig(scene, config);
        _this = _callSuper(this, Title, [scene, config]);
        _this.type = 'rexTweaker.Title';
        return _this;
      }
      _createClass(Title, [{
        key: "setTitle",
        value: function setTitle(config) {
          config = config ? DeepClone(config) : {};
          if (config.hasOwnProperty('text')) ; else if (config.hasOwnProperty('title')) {
            config.text = config.title;
          } else {
            config.text = '';
          }
          this.resetDisplayContent(config);
          return this;
        }
      }]);
      return Title;
    }(Label);
  
    var FolderTitle = /*#__PURE__*/function (_Title) {
      _inherits(FolderTitle, _Title);
      function FolderTitle(scene, config) {
        var _this;
        _classCallCheck(this, FolderTitle);
        if (config === undefined) {
          config = {};
        }
        _this = _callSuper(this, FolderTitle, [scene, config]);
        _this.type = 'rexTweaker.FolderTitle';
        var expandedIcon = new Triangle(scene, config.expandedIcon);
        scene.add.existing(expandedIcon);
        _this.addSpace().add(expandedIcon, {
          proportion: 0,
          expand: false,
          padding: 1,
          fitRatio: 1
        });
        _this.addChildrenMap('expandedIcon', expandedIcon);
        return _this;
      }
      _createClass(FolderTitle, [{
        key: "setExpandedState",
        value: function setExpandedState(expanded) {
          if (expanded === undefined) {
            expanded = true;
          }
          var direction = expanded ? 'down' : 'right';
          var expandedIcon = this.childrenMap.expandedIcon;
          expandedIcon.setDirection(direction);
          return this;
        }
      }]);
      return FolderTitle;
    }(Title);
  
    var CreateTweaker = function CreateTweaker(scene, config) {
      var tweaker = new TweakerShell(scene, config);
      scene.add.existing(tweaker);
      return tweaker;
    };
  
    var CreateBackground = function CreateBackground(scene, config, style) {
      // TODO: Might create nine-slice as background
      return CreateBackground$2(scene, style);
    };
  
    var BindingTargetMethods$2 = {
      setBindingTarget: function setBindingTarget(target) {
        var child = this.childrenMap.child; // tweaker
        child.setBindingTarget(target);
        return this;
      }
    };
  
    var InputRowTitleWidthMethods$1 = {
      getMaxInputRowTitleWidth: function getMaxInputRowTitleWidth() {
        var child = this.childrenMap.child; // tweaker
        var titleWidth = child.getMaxInputRowTitleWidth();
        return titleWidth + this.getInnerPadding('left');
      },
      setInputRowTitleWidth: function setInputRowTitleWidth(width) {
        width -= this.getInnerPadding('left');
        var child = this.childrenMap.child; // tweaker
        child.setInputRowTitleWidth(width);
        return this;
      }
    };
  
    var Folder = /*#__PURE__*/function (_FolderBase) {
      _inherits(Folder, _FolderBase);
      function Folder(scene, config) {
        var _this;
        _classCallCheck(this, Folder);
        _this = _callSuper(this, Folder, [scene, config]);
        _this.type = 'rexTweaker.Folder';
        return _this;
      }
      _createClass(Folder, [{
        key: "setTitle",
        value: function setTitle(config) {
          var title = this.childrenMap.title;
          title.setTitle(config);
          return this;
        }
      }]);
      return Folder;
    }(Folder$1);
    Object.assign(Folder.prototype, BindingTargetMethods$2, InputRowTitleWidthMethods$1);
  
    var GetValue$n = Phaser.Utils.Objects.GetValue;
    var CreateFolder = function CreateFolder(scene, config, style) {
      // Create Folder-title
      var titleStyle = GetValue$n(style, 'title') || {};
      var title = new FolderTitle(scene, titleStyle);
      scene.add.existing(title);
      title.on('folder.expand', function () {
        title.setExpandedState(true);
      }).on('folder.collapse', function () {
        title.setExpandedState(false);
      });
      var tweakerConfig = {
        root: GetValue$n(style, 'root'),
        styles: GetValue$n(style, 'tweaker'),
        space: GetValue$n(style, 'space') || {}
      };
      var child = CreateTweaker(scene, tweakerConfig);
      var backgroundStyle = GetValue$n(style, 'background');
      var background = CreateBackground(scene, config, backgroundStyle);
      var folder = new Folder(scene, {
        orientation: 1,
        title: title,
        child: child,
        background: background,
        transition: {
          duration: GetValue$n(style, 'transition.duration', 200)
        }
      });
      scene.add.existing(folder);
      return folder;
    };
  
    var GetValue$m = Phaser.Utils.Objects.GetValue;
    var AddFolder = function AddFolder(config) {
      var scene = this.scene;
  
      // Create folder
      var folderStyle = GetValue$m(this.styles, 'folder') || {};
      folderStyle.tweaker = this.styles;
      folderStyle.root = this.root;
      var folder = CreateFolder(scene, config, folderStyle);
      delete folderStyle.tweaker;
      delete folderStyle.root;
  
      // Add folder
      this.add(folder, {
        expand: true
      });
  
      // Set content
      folder.setTitle(config);
      var expanded = GetValue$m(config, 'expanded', true);
      if (expanded !== undefined) {
        folder.setExpandedState(expanded);
      }
      var childTweaker = folder.childrenMap.child;
      if (config.key) {
        this.root.addChildrenMap(config.key, childTweaker);
      }
      return childTweaker;
    };
  
    var BindingTargetMethods$1 = {
      setBindingTarget: function setBindingTarget(target) {
        var children = this.childrenMap.pages.children;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].setBindingTarget(target);
        }
        return this;
      }
    };
  
    var InputRowTitleWidthMethods = {
      getMaxInputRowTitleWidth: function getMaxInputRowTitleWidth() {
        var maxTitleWidth = 0;
        var children = this.childrenMap.pages.children; // tweaker array
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
        }
        return maxTitleWidth + this.getInnerPadding('left');
      },
      setInputRowTitleWidth: function setInputRowTitleWidth(width) {
        width -= this.getInnerPadding('left');
        var children = this.childrenMap.pages.children; // tweaker array
        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].setInputRowTitleWidth(width);
        }
        return this;
      }
    };
  
    var TabPages = /*#__PURE__*/function (_TabPagesBase) {
      _inherits(TabPages, _TabPagesBase);
      function TabPages(scene, config) {
        var _this;
        _classCallCheck(this, TabPages);
        _this = _callSuper(this, TabPages, [scene, config]);
        _this.type = 'rexTweaker.TabPages';
        return _this;
      }
      return _createClass(TabPages);
    }(TabPages$1);
    Object.assign(TabPages.prototype, BindingTargetMethods$1, InputRowTitleWidthMethods);
  
    var GetValue$l = Phaser.Utils.Objects.GetValue;
    var CreateTab = function CreateTab(scene, config, style) {
      var tabPages = new TabPages(scene, style);
      scene.add.existing(tabPages);
      var tabConfig = GetValue$l(style, 'tab');
      var tweakerConfig = {
        root: GetValue$l(style, 'root'),
        styles: GetValue$l(style, 'tweaker')
      };
      var pages = GetValue$l(config, 'pages') || [];
      for (var i = 0, cnt = pages.length; i < cnt; i++) {
        var page = pages[i];
        tabPages.addPage({
          key: page.title,
          tab: CreateLabel(scene, tabConfig).setActiveState(false).resetDisplayContent({
            text: page.title
          }),
          page: CreateTweaker(scene, tweakerConfig)
        });
      }
      tabPages.on('tab.focus', function (tab, key) {
        tab.setActiveState(true);
      }).on('tab.blur', function (tab, key) {
        tab.setActiveState(false);
      });
      return tabPages;
    };
  
    var GetValue$k = Phaser.Utils.Objects.GetValue;
    var AddTab = function AddTab(config) {
      var scene = this.scene;
  
      // Create tab
      var tabStyle = GetValue$k(this.styles, 'tab') || {};
      tabStyle.tweaker = this.styles;
      tabStyle.root = this.root;
      var tab = CreateTab(scene, config, tabStyle);
      delete tabStyle.tweaker;
      delete tabStyle.root;
  
      // Add tab
      this.add(tab, {
        expand: true
      });
      var pagesConfig = GetValue$k(config, 'pages') || [];
      var pages = [];
      var shownPageIndex = 0;
      for (var i = 0, cnt = pagesConfig.length; i < cnt; i++) {
        var childTweaker = tab.getPage(i);
        var isPageShown = pagesConfig[i].show;
        if (isPageShown) {
          shownPageIndex = i;
        }
        var key = pagesConfig[i].key;
        if (key) {
          this.root.addChildrenMap(key, childTweaker);
        }
        pages.push(childTweaker);
      }
      tab.swapPage(shownPageIndex, 0);
      return pages;
    };
  
    var GetValue$j = Phaser.Utils.Objects.GetValue;
    var BindingTargetMethods = {
      setupBinding: function setupBinding() {
        var inputField = this.childrenMap.inputField;
        inputField
        // Set text value to object when closing editor
        .on('valuechange', function (value) {
          if (!this.autoUpdateEnable) {
            return;
          }
          this.setTargetValue(value);
        }, this);
        return this;
      },
      setAutoUpdateEnable: function setAutoUpdateEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }
        this.autoUpdateEnable = enable;
        return this;
      },
      setBindingTarget: function setBindingTarget(target, key) {
        this.bindingTarget = target;
        if (key !== undefined) {
          this.setBindingTargetKey(key);
        }
        this.syncTargetValue();
        return this;
      },
      setBindingTargetKey: function setBindingTargetKey(key) {
        this.bindTargetKey = key;
        return this;
      },
      setValueCallbacks: function setValueCallbacks(config) {
        this.onGetValue = GetValue$j(config, 'onGetValue');
        this.onSetValue = GetValue$j(config, 'onSetValue');
        return this;
      },
      getTargetValue: function getTargetValue() {
        if (!this.bindingTarget) {
          return undefined;
        }
        if (this.bindTargetKey != null) {
          return this.bindingTarget[this.bindTargetKey];
        }
        if (this.onGetValue) {
          return this.onGetValue(this.bindingTarget);
        }
        return undefined;
      },
      setTargetValue: function setTargetValue(value) {
        if (!this.bindingTarget) {
          return this;
        }
        if (this.bindTargetKey != null) {
          this.bindingTarget[this.bindTargetKey] = value;
          return this;
        }
        if (this.onSetValue) {
          this.onSetValue(this.bindingTarget, value);
        }
        return this;
      },
      syncTargetValue: function syncTargetValue() {
        if (!this.bindingTarget) {
          return this;
        }
        var inputField = this.childrenMap.inputField;
        if (inputField.syncValue) {
          inputField.syncValue(this.getTargetValue());
        }
        return this;
      }
    };
  
    var MonitorTargetMethods = {
      startMonitorTarget: function startMonitorTarget() {
        if (this.isMonitoring) {
          return this;
        }
        this.isMonitoring = true;
        this.scene.events.on('postupdate', this.onMonitorTarget, this);
        return this;
      },
      stopMonitorTarget: function stopMonitorTarget() {
        if (!this.isMonitoring) {
          return this;
        }
        this.isMonitoring = false;
        this.scene.events.off('postupdate', this.onMonitorTarget, this);
        return this;
      },
      onMonitorTarget: function onMonitorTarget() {
        if (!this.bindingTarget) {
          return;
        }
        var newValue = this.getTargetValue();
        var inputField = this.childrenMap.inputField;
        if (inputField.value === newValue) {
          return;
        }
        // Sync new value
        inputField.syncValue(newValue);
      }
    };
  
    var MinTitleWidthMethods = {
      getMinTitleWidth: function getMinTitleWidth() {
        var title = this.childrenMap.title;
        if (!title || title.orientation !== 0) {
          // Don't count vertical input row
          return 0;
        }
        var padding = title.rexSizer.padding;
        var titleWidth = this.getChildWidth(this.childrenMap.title) + padding.left + padding.right;
        return titleWidth + this.getInnerPadding('left');
      },
      setMinTitleWidth: function setMinTitleWidth(width) {
        var title = this.childrenMap.title;
        if (!title || title.orientation !== 0) {
          // Don't set vertical input row
          return this;
        }
        var padding = title.rexSizer.padding;
        width -= padding.left + padding.right;
        title.minWidth = width;
        return this;
      }
    };
  
    var GetValue$i = Phaser.Utils.Objects.GetValue;
    var InputRow = /*#__PURE__*/function (_Sizer) {
      _inherits(InputRow, _Sizer);
      function InputRow(scene, config) {
        var _this;
        _classCallCheck(this, InputRow);
        _this = _callSuper(this, InputRow, [scene, config]);
        _this.type = 'rexTweaker.InputRow';
        _this.bindingTarget = undefined;
        _this.bindTargetKey = undefined;
        _this.autoUpdateEnable = true;
        var inputTitle = config.inputTitle;
        var inputField = config.inputField;
        var background = config.background;
        var proportion = GetValue$i(config, 'proportion.title', 0);
        var titleSpace = GetValue$i(config, 'space.title', 0);
        var padding;
        if (_this.orientation === 0) {
          padding = {
            right: titleSpace
          };
        } else {
          padding = {
            bottom: titleSpace
          };
        }
        _this.add(inputTitle, {
          proportion: proportion,
          expand: true,
          padding: padding
        });
        var defaultProportion = inputField.defaultProportion;
        if (defaultProportion === undefined) {
          defaultProportion = config.parentOrientation === 1 ? 1 : 0;
        }
        var proportion = GetValue$i(config, 'proportion.inputField', defaultProportion);
        _this.add(inputField, {
          proportion: proportion,
          expand: true
        });
        if (background) {
          _this.addBackground(background);
        }
        _this.addChildrenMap('title', inputTitle);
        _this.addChildrenMap('inputField', inputField);
        _this.addChildrenMap('background', background);
        _this.setupBinding();
        return _this;
      }
      _createClass(InputRow, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          this.stopMonitorTarget();
          _get(_getPrototypeOf(InputRow.prototype), "destroy", this).call(this, fromScene);
        }
      }, {
        key: "setTitle",
        value: function setTitle(config) {
          var title = this.childrenMap.title;
          title.setTitle(config);
          return this;
        }
      }, {
        key: "preLayout",
        value: function preLayout() {
          var title = this.childrenMap.title;
          if (title) {
            title.minWidth = 0;
          }
          _get(_getPrototypeOf(InputRow.prototype), "preLayout", this).call(this);
        }
      }]);
      return InputRow;
    }(Sizer);
    Object.assign(InputRow.prototype, BindingTargetMethods, MonitorTargetMethods, MinTitleWidthMethods);
  
    var CreateTitleLabel = function CreateTitleLabel(scene, config, style) {
      var gameObject = new Title(scene, style);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GenerateInputFieldClass = function GenerateInputFieldClass(BaseClass) {
      if (BaseClass === undefined) {
        BaseClass = Sizer;
      }
      var InputFiled = /*#__PURE__*/function (_BaseClass) {
        _inherits(InputFiled, _BaseClass);
        function InputFiled() {
          _classCallCheck(this, InputFiled);
          return _callSuper(this, InputFiled, arguments);
        }
        _createClass(InputFiled, [{
          key: "bindingTarget",
          get: function get() {
            var inputRow = this.getParentSizer();
            return inputRow.bindingTarget;
          }
        }, {
          key: "bindingKey",
          get: function get() {
            var inputRow = this.getParentSizer();
            return inputRow.bindTargetKey;
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(value) {
            if (this._value === value) {
              return;
            }
            if (!this.validate(value)) {
              value = this._value; // Back to previous value
            }
            if (this.filterValueCallback) {
              value = this.filterValueCallback(this, value);
            }
            if (this.displayValueCallback) {
              this.displayValueCallback(this, value);
            }
            if (this._value === value) {
              return;
            }
            var oldValue = this._value;
            this._value = value;
            if (!this.syncValueFlag) {
              var bindingTarget = this.bindingTarget;
              var bindingKey = this.bindingKey;
              this.emit('valuechange', value, oldValue, bindingTarget, bindingKey);
              this.root.emit('valuechange', value, oldValue, bindingTarget, bindingKey);
            }
          }
        }, {
          key: "root",
          get: function get() {
            var inputRow = this.getParentSizer();
            var tweaker = inputRow.getParentSizer();
            return tweaker.root;
          }
        }, {
          key: "validate",
          value: function validate(newValue) {
            if (this.syncValueFlag || !this.validateCallback) {
              return true;
            }
            return this.validateCallback(newValue, this._value, this.bindingTarget, this.bindingKey);
          }
        }, {
          key: "getFotmatText",
          value: function getFotmatText(value) {
            if (this.textFormatCallback) {
              value = this.textFormatCallback(value);
            } else {
              value = value.toString();
            }
            return value;
          }
        }, {
          key: "getValue",
          value: function getValue() {
            return this.value;
          }
        }, {
          key: "setValue",
          value: function setValue(value) {
            this.value = value;
            return this;
          }
  
          /* 
          Internal method invoked when 
          - inputRow.setBindingTarget(target), or 
          - inputRow.syncTargetValue()
          */
        }, {
          key: "syncValue",
          value: function syncValue(value) {
            this.syncValueFlag = true;
            this.value = value;
            this.syncValueFlag = false;
            return this;
          }
        }, {
          key: "setup",
          value: function setup(config, setDefaults) {
            if (setDefaults === undefined) {
              setDefaults = false;
            }
            if (setDefaults || config.hasOwnProperty('format')) {
              this.setTextFormatCallback(config.format);
            }
            if (setDefaults || config.hasOwnProperty('onValidate')) {
              this.setValidateCallback(config.onValidate);
            }
            if (this.setupCallback) {
              this.setupCallback(this, config, setDefaults);
            }
            return this;
          }
        }, {
          key: "setSetupCallback",
          value: function setSetupCallback(callback) {
            this.setupCallback = callback;
            return this;
          }
        }, {
          key: "setFilterValueCallback",
          value: function setFilterValueCallback(callback) {
            this.filterValueCallback = callback;
            return this;
          }
        }, {
          key: "setDisplayValueCallback",
          value: function setDisplayValueCallback(callback) {
            this.displayValueCallback = callback;
            return this;
          }
        }, {
          key: "setTextFormatCallback",
          value: function setTextFormatCallback(callback) {
            this.textFormatCallback = callback;
            return this;
          }
        }, {
          key: "setValidateCallback",
          value: function setValidateCallback(callback) {
            this.validateCallback = callback;
            return this;
          }
        }]);
        return InputFiled;
      }(BaseClass);
      return InputFiled;
    };
  
    var CreateInputField = function CreateInputField(scene, config, style) {
      var inputField;
      var inputHandlers = this.inputHandlers;
      for (var i = 0, cnt = inputHandlers.length; i < cnt; i++) {
        var handler = inputHandlers[i];
        if (handler.accept(config)) {
          var InputFieldClass = GenerateInputFieldClass(handler.baseClass);
          inputField = new InputFieldClass(scene);
          scene.add.existing(inputField);
          inputField.setSetupCallback(handler.setup).setFilterValueCallback(handler.filterValue).setDisplayValueCallback(handler.displayValue);
          handler.build(inputField, style);
          break;
        }
      }
      if (inputField) {
        // Setup by config
        inputField.setup(config, true);
      }
      return inputField;
    };
  
    var GetValue$h = Phaser.Utils.Objects.GetValue;
    var CreateInputRow = function CreateInputRow(scene, config, style) {
      // InputField
      var inputField = CreateInputField.call(this, scene, config, style);
      if (!inputField) {
        // Can't create inputField
        return null;
      }
  
      // Title
      var titleStyle = GetValue$h(style, 'title') || {};
      var inputTitle = CreateTitleLabel(scene, config, titleStyle);
  
      // Background
      var backgroundStyle = GetValue$h(style, 'background') || {};
      var background = CreateBackground$2(scene, backgroundStyle);
      var inputRow = new InputRow(scene, _objectSpread2(_objectSpread2(_objectSpread2({}, style), config), {}, {
        // config can overwrite style
  
        inputTitle: inputTitle,
        inputField: inputField,
        background: background
      }));
      scene.add.existing(inputRow);
      inputRow.setTitle(config);
      inputRow.setValueCallbacks(config);
      return inputRow;
    };
  
    var AddInput = function AddInput(object, key, config) {
      if (arguments.length === 1) {
        config = object;
        object = config.bindingTarget;
        key = config.bindingKey;
      } else {
        if (config === undefined) {
          config = {};
        }
        config.bindingTarget = object;
        config.bindingKey = key;
      }
      if (!config.title) {
        config.title = key;
      }
      if (config.bindingTarget && config.bindingKey) {
        config.value = config.bindingTarget[config.bindingKey];
      } else {
        config.value = undefined;
      }
  
      // Create InputRow
      var inputRowStyle = this.styles.inputRow || {};
      inputRowStyle.parentOrientation = this.styles.orientation;
      var inputSizer = CreateInputRow.call(this, this.scene, config, inputRowStyle);
      if (!inputSizer) {
        // Can't create inputField
        console.error("[Tweaker] Can't add Input\n    title: ".concat(config.title, "\n    view: ").concat(config.view, "\n"));
        return this;
      }
      var inputField = inputSizer.childrenMap.inputField;
      var proportion;
      if (this.orientation === 1) {
        // y
        proportion = 0;
      } else {
        // x
        proportion = this.itemWidth > 0 ? 0 : 1;
        inputSizer.setMinWidth(this.itemWidth);
      }
  
      // Add InputRow to Tweaker
      this.add(inputSizer, {
        proportion: proportion,
        expand: true
      });
      if (config.onValueChange) {
        inputField.on('valuechange', config.onValueChange);
      }
  
      // Bind target
      inputSizer.setAutoUpdateEnable(config.autoUpdate);
      inputSizer.setBindingTarget(object, key);
      if (config.monitor) {
        inputSizer.startMonitorTarget();
      }
      if (config.key) {
        this.root.addChildrenMap(config.key, inputSizer);
      }
      return this;
    };
  
    var CreateRoundRectangle = function CreateRoundRectangle(scene, config) {
      var gameObject = new RoundRectangle$2(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$g = Phaser.Utils.Objects.GetValue;
    var CreateButtons$2 = function CreateButtons(scene, config) {
      var wrap = GetValue$g(config, 'wrap', false);
      var ButtonClass = wrap ? Buttons : Buttons$1;
      var gameObject = new ButtonClass(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$f = Phaser.Utils.Objects.GetValue;
    var CreateButtons$1 = function CreateButtons(scene, config, style) {
      // Title
      var titleStyle = GetValue$f(style, 'title') || {};
      var title = CreateTitleLabel(scene, config, titleStyle);
  
      // Buttons
      var buttonsConfig = config.buttons;
      var buttonStyle = GetValue$f(style, 'button') || {};
      var buttons = [];
      for (var i = 0, cnt = buttonsConfig.length; i < cnt; i++) {
        var button = CreateLabel(scene, buttonStyle);
        buttons.push(button);
        var buttonConfig = buttonsConfig[i];
        button.resetDisplayContent(buttonConfig.label);
        button.callback = buttonConfig.callback;
      }
      var buttonsSizer = CreateButtons$2(scene, {
        buttons: buttons,
        expand: true,
        wrap: GetValue$f(config, 'wrap', false)
      });
      buttonsSizer.defaultProportion = 1;
  
      // Background
      var backgroundStyle = GetValue$f(style, 'background') || {};
      var background = CreateRoundRectangle(scene, backgroundStyle);
  
      // InputRow
      var inputRow = new InputRow(scene, _objectSpread2(_objectSpread2({}, style), {}, {
        inputTitle: title,
        inputField: buttonsSizer,
        background: background
      }));
      scene.add.existing(inputRow);
      inputRow.setTitle(config);
      buttonsSizer.on('button.click', function (button) {
        button.callback(inputRow.bindingTarget);
      });
      return inputRow;
    };
  
    var GetValue$e = Phaser.Utils.Objects.GetValue;
    var AddButtons = function AddButtons(config) {
      var scene = this.scene;
      if (config === undefined) {
        config = {};
      }
      var target = config.bindingTarget;
      delete config.bindingTarget;
  
      // Create buttons
      var buttonsStyle = GetValue$e(this.styles, 'inputRow') || {};
      var buttons = CreateButtons$1(scene, config, buttonsStyle);
  
      // Add buttons
      this.add(buttons, {
        expand: true
      });
  
      // Set binding target
      if (target) {
        buttons.setBindingTarget(target);
      }
      if (config.key) {
        this.root.addChildrenMap(config.key, buttons);
      }
      return this;
    };
  
    var AddButton = function AddButton(config) {
      if (config === undefined) {
        config = {};
      }
      config.buttons = [{
        label: config.label,
        callback: config.callback
      }];
      delete config.label;
      delete config.callback;
      this.addButtons(config);
      return this;
    };
  
    var GetValue$d = Phaser.Utils.Objects.GetValue;
    var AddSeparator = function AddSeparator(config) {
      var scene = this.scene;
  
      // Create separator
      var separatorStyle = GetValue$d(this.styles, 'separator');
      var separator = CreateBackground(scene, config, separatorStyle);
  
      // Add separator
      this.add(separator, {
        expand: true
      });
      return this;
    };
  
    var AddRows = function AddRows(properties, target, monitor) {
      if (typeof target === 'boolean') {
        monitor = target;
        target = undefined;
      }
      if (monitor === undefined) {
        monitor = true;
      }
      AddProperties(this, DeepClone(properties), target, monitor);
      return this;
    };
    var AddProperties = function AddProperties(tweaker, properties, target, monitor) {
      if (!properties) {
        return;
      }
      for (var i = 0, cnt = properties.length; i < cnt; i++) {
        var property = properties[i];
        if (property.hasOwnProperty('$target')) {
          target = property.$target;
          delete property.$target;
        }
        var type = property.$type;
        delete property.$type;
        switch (type) {
          case 'folder':
            var folder = tweaker.addFolder(property);
            AddProperties(folder, property.$properties, target, monitor);
            break;
          case 'tab':
            var pages = tweaker.addTab(property);
            for (var pIdx = 0, pcnt = pages.length; pIdx < pcnt; pIdx++) {
              AddProperties(pages[pIdx], property.pages[pIdx].$properties, target, monitor);
            }
            break;
          case 'separator':
            tweaker.addSeparator();
            break;
          case 'button':
            property.bindingTarget = target;
            tweaker.addButton(property);
            break;
          case 'buttons':
            property.bindingTarget = target;
            tweaker.addButtons(property);
            break;
          default:
            var key = property.$key;
            delete property.$key;
            if (key.indexOf('.') === -1) {
              property.bindingTarget = target;
              property.bindingKey = key;
            } else {
              var keys = key.split('.');
              property.bindingKey = keys.pop();
              var bindingTarget = target;
              for (var k = 0, kcnt = keys.length; k < kcnt; k++) {
                bindingTarget = bindingTarget[keys[k]];
                if (!target) {
                  console.warn("[Monitor] Key path '".concat(key, "' is invalid"));
                  continue;
                }
              }
              property.bindingTarget = bindingTarget;
            }
            if (!property.hasOwnProperty('monitor')) {
              property.monitor = monitor;
            }
            tweaker.addInput(property);
            break;
        }
      }
    };
  
    var SetBindingTarget = function SetBindingTarget(target) {
      var children = this.sizerChildren;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (!child.setBindingTarget) {
          continue;
        }
        child.setBindingTarget(target);
      }
      return this;
    };
  
    var GetMaxInputRowTitleWidth = function GetMaxInputRowTitleWidth() {
      var maxTitleWidth = 0;
      var children = this.sizerChildren;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (child.rexSizer.hidden) {
          continue;
        }
        if (child.getMinTitleWidth) {
          // InputRow
          maxTitleWidth = Math.max(maxTitleWidth, child.getMinTitleWidth());
        } else if (child.getMaxInputRowTitleWidth) {
          // Folder, TabPages
          maxTitleWidth = Math.max(maxTitleWidth, child.getMaxInputRowTitleWidth());
        }
      }
      return maxTitleWidth + this.getInnerPadding('left');
    };
  
    var SetInputRowTitleWidth = function SetInputRowTitleWidth(width) {
      width -= this.getInnerPadding('left');
      var children = this.sizerChildren;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (child.rexSizer.hidden) {
          continue;
        }
        if (child.setMinTitleWidth) {
          // InputRow
          child.setMinTitleWidth(width);
        } else if (child.setInputRowTitleWidth) {
          // Folder, TabPages
          child.setInputRowTitleWidth(width);
        }
      }
      return this;
    };
  
    var methods$1 = {
      registerInputHandler: RegisterInputHandler,
      removeInputHandler: RemoveInputHandler,
      addFolder: AddFolder,
      addTab: AddTab,
      addInput: AddInput,
      addButtons: AddButtons,
      addButton: AddButton,
      addSeparator: AddSeparator,
      addRows: AddRows,
      setBindingTarget: SetBindingTarget,
      getMaxInputRowTitleWidth: GetMaxInputRowTitleWidth,
      setInputRowTitleWidth: SetInputRowTitleWidth
    };
  
    var GetValue$c = Phaser.Utils.Objects.GetValue;
    var TweakerShell = /*#__PURE__*/function (_Sizer) {
      _inherits(TweakerShell, _Sizer);
      function TweakerShell(scene, config) {
        var _this;
        _classCallCheck(this, TweakerShell);
        if (config === undefined) {
          config = {};
        }
        if (config.orientation === undefined) {
          config.orientation = 1;
        }
  
        // Create sizer
        _this = _callSuper(this, TweakerShell, [scene, config]);
        _this.type = 'rexTweakerShell';
        _this.root = config.root || _assertThisInitialized(_this);
        _this.styles = GetValue$c(config, 'styles') || {};
        _this.styles.orientation = _this.orientation;
        _this.itemWidth = GetValue$c(_this.styles, 'itemWidth', 0);
        if (_this.root === _assertThisInitialized(_this) && _this.orientation === 1) {
          var alignTitle = GetValue$c(config, 'inputRow.alignTitle');
          if (alignTitle === undefined) {
            var titleProportion = GetValue$c(_this.styles, 'inputRow.proportion.title');
            alignTitle = !titleProportion;
          } else {
            if (alignTitle) {
              // Override title proportion to 0
              SetValue(_this.styles, 'inputRow.proportion.title', 0);
            }
          }
          _this.alignInputRowTitle = alignTitle;
        } else {
          _this.alignInputRowTitle = false;
          _this.inputHandlers = _this.root.inputHandlers;
        }
        var background = CreateBackground(scene, undefined, config.background);
        if (background) {
          _this.addBackground(background);
        }
        return _this;
      }
      _createClass(TweakerShell, [{
        key: "preLayout",
        value: function preLayout() {
          _get(_getPrototypeOf(TweakerShell.prototype), "preLayout", this).call(this);
          if (this.alignInputRowTitle) {
            this.setInputRowTitleWidth(this.getMaxInputRowTitleWidth());
          }
        }
      }]);
      return TweakerShell;
    }(Sizer);
    Object.assign(TweakerShell.prototype, methods$1);
  
    var SetInputTextReadOnly$4 = function SetInputTextReadOnly(gameObject, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var inputText = gameObject.childrenMap.inputText;
      inputText.setReadOnly(enable);
    };
    var TextInputHandler = {
      name: 'TextInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'string';
        }
        return typeof config.value === 'string';
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.TextInput';
        var inputTextConfig = style.inputText;
        var inputText = CreateInputText$1(scene, inputTextConfig);
        gameObject.add(inputText, {
          proportion: 1,
          expand: true,
          key: 'inputText'
        });
        inputText.on('close', function () {
          gameObject.setValue(inputText.value);
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
          SetInputTextReadOnly$4(gameObject, !!config.inputTextReadOnly);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var inputText = gameObject.childrenMap.inputText;
        inputText.setText(gameObject.getFotmatText(value));
      }
    };
  
    var CreateInputTextArea = function CreateInputTextArea(scene, config, deepCloneConfig) {
      if (deepCloneConfig === undefined) {
        deepCloneConfig = true;
      }
      if (deepCloneConfig) {
        config = config ? DeepClone(config) : {};
      } else if (!config) {
        config = {};
      }
      var inputText = new TextAreaInput(scene, config);
      scene.add.existing(inputText);
      return inputText;
    };
  
    var SetInputTextReadOnly$3 = function SetInputTextReadOnly(gameObject, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var inputText = gameObject.childrenMap.inputText;
      inputText.setReadOnly(enable);
    };
    var TextAreaInputHandler = {
      name: 'TextAreaInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'textarea';
        }
        return false;
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        this.type = 'rexTweaker.TextAreaInput';
        var inputTextAreaConfig = style.inputTextArea;
        if (inputTextAreaConfig === undefined) {
          inputTextAreaConfig = {};
        }
        if (!inputTextAreaConfig.hasOwnProperty('text')) {
          inputTextAreaConfig.text = style.inputText;
        }
        if (!inputTextAreaConfig.hasOwnProperty('slider')) {
          inputTextAreaConfig.slider = style.slider;
        }
        var inputText = CreateInputTextArea(scene, inputTextAreaConfig);
        gameObject.add(inputText, {
          proportion: 1,
          expand: true,
          key: 'inputText'
        });
        inputText.on('close', function () {
          gameObject.setValue(inputText.value);
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
          SetInputTextReadOnly$3(gameObject, !!config.inputTextReadOnly);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var inputText = gameObject.childrenMap.inputText;
        inputText.setText(gameObject.getFotmatText(value));
      }
    };
  
    var SetInputTextReadOnly$2 = function SetInputTextReadOnly(gameObject, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var inputText = gameObject.childrenMap.inputText;
      inputText.setReadOnly(enable);
    };
    var NumberInputHandler = {
      name: 'NumberInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'number';
        }
        return typeof config.value === 'number';
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.NumberInput';
        var inputTextConfig = style.inputNumber || style.inputText;
        var inputText = CreateInputText$1(scene, inputTextConfig).setNumberInput();
        gameObject.add(inputText, {
          proportion: 1,
          expand: true,
          key: 'inputText'
        });
        inputText.on('close', function () {
          gameObject.setValue(inputText.value);
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
          SetInputTextReadOnly$2(gameObject, !!config.inputTextReadOnly);
        }
        gameObject.isFloatType = !config["int"];
      },
      // Callback inside `setValue()`
      filterValue: function filterValue(gameObject, value) {
        if (gameObject.isFloatType) {
          return value;
        } else {
          return Math.floor(value);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var inputText = gameObject.childrenMap.inputText;
        inputText.setText(gameObject.getFotmatText(value));
      }
    };
  
    var CreateSlider = function CreateSlider(scene, config) {
      var gameObject = new Slider(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$b = Phaser.Utils.Objects.GetValue;
    var Linear$1 = Phaser.Math.Linear;
    var SnapFloor = Phaser.Math.Snap.Floor;
    var SetRange = function SetRange(gameObject, min, max, step) {
      gameObject.minValue = min;
      gameObject.maxValue = max;
      gameObject.step = step;
      var slider = gameObject.childrenMap.slider;
      slider.setGap(step, min, max);
    };
    var SetInputTextReadOnly$1 = function SetInputTextReadOnly(gameObject, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var inputText = gameObject.childrenMap.inputText;
      inputText.setReadOnly(enable);
    };
    var RangeInputHandler = {
      name: 'RangeInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'range';
        }
        return typeof config.value === 'number' && config.hasOwnProperty('min') && config.hasOwnProperty('max');
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.RangeInput';
        var sliderConfig = style.slider;
        var trackSizeKey = gameObject.orientation === 0 ? 'track.height' : 'track.width';
        var trackSize = GetValue$b(sliderConfig, trackSizeKey);
        var slider = CreateSlider(scene, sliderConfig);
        var defaultProportion = style.parentOrientation === 1 ? 2 : 0;
        var proportion = GetValue$b(style, 'proportion.range.slider', defaultProportion);
        var expand = trackSize === undefined;
        gameObject.add(slider, {
          proportion: proportion,
          expand: expand,
          key: 'slider'
        });
        var inputTextConfig = style.inputNumber || style.inputText;
        var inputText = CreateInputText$1(scene, inputTextConfig).setNumberInput();
        var defaultProportion = style.parentOrientation === 1 ? 1 : 0;
        var proportion = GetValue$b(style, 'proportion.range.inputText', defaultProportion);
        gameObject.add(inputText, {
          proportion: proportion,
          expand: true,
          key: 'inputText'
        });
        inputText.on('close', function () {
          gameObject.setValue(inputText.value);
        });
        slider.on('valuechange', function () {
          var value = Linear$1(gameObject.minValue, gameObject.maxValue, slider.value);
          if (gameObject.step) {
            value = SnapFloor(value, gameObject.step, gameObject.minValue);
          }
          gameObject.setValue(value);
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('max')) {
          SetRange(gameObject, config.min, config.max, config.step);
        }
        if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
          SetInputTextReadOnly$1(gameObject, !!config.inputTextReadOnly);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var slider = gameObject.childrenMap.slider;
        slider.setValue(value, gameObject.minValue, gameObject.maxValue);
        var inputText = gameObject.childrenMap.inputText;
        inputText.setText('').setText(gameObject.getFotmatText(value));
      }
    };
  
    var CreateButtons = function CreateButtons(scene, config) {
      var gameObject = new Buttons$1(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetValue$a = Phaser.Utils.Objects.GetValue;
    var SetInputTextReadOnly = function SetInputTextReadOnly(gameObject, enable) {
      if (enable === undefined) {
        enable = true;
      }
      var inputText = gameObject.childrenMap.inputText;
      inputText.setReadOnly(enable);
    };
    var IncDecInputHandler = {
      name: 'RangeInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'incdec';
        }
        return false;
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.IncDecInput';
  
        /*
        inputRow <-- buttons
        
        - incButton, inputText, decButton
        - inputText, incButton, decButton
        */
  
        var incDecConfig = GetValue$a(style, 'incDec') || {};
        var buttonConfigBase = {
          text: null,
          action: null
        };
  
        // buttons
        var buttons = CreateButtons(scene, {
          expand: false
        });
        var proportion = style.parentOrientation === 1 ? 1 : 0;
        gameObject.add(buttons, {
          proportion: proportion,
          expand: true
        });
  
        // inputText
        var inputTextConfig = style.inputNumber || style.inputText;
        var inputText = CreateInputText$1(scene, inputTextConfig).setNumberInput();
        inputText.on('close', function () {
          gameObject.setValue(inputText.value);
        });
  
        // incButton
        var incButtonConfig = Object.assign(DeepClone(buttonConfigBase), incDecConfig.incButton || {});
        var incButton = CreateLabel(scene, incButtonConfig);
  
        // decButton
        var decButtonConfig = Object.assign(DeepClone(buttonConfigBase), incDecConfig.decButton || {});
        var decButton = CreateLabel(scene, decButtonConfig);
  
        // inputTextIndex
        buttons.addButton(incButton);
        buttons.addButton(decButton);
        var inputTextIndex = incDecConfig.inputTextIndex || 0;
        buttons.insert(inputTextIndex, inputText, {
          proportion: 1,
          expand: true
        });
        gameObject.step = 1;
        gameObject.minValue = undefined;
        gameObject.maxValue = undefined;
        buttons.on('button.click', function (button, index, pointer, event) {
          var value = gameObject.value;
          if (index === 0) {
            // inc
            value += gameObject.step;
          } else {
            // dec
            value -= gameObject.step;
          }
          if (gameObject.maxValue !== undefined && value > gameObject.maxValue) {
            value = gameObject.maxValue;
          }
          if (gameObject.minValue !== undefined && value < gameObject.minValue) {
            value = gameObject.minValue;
          }
          gameObject.setValue(value);
        });
        gameObject.addChildrenMap('incButton', incButton);
        gameObject.addChildrenMap('decButton', decButton);
        gameObject.addChildrenMap('inputText', inputText);
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('inputTextReadOnly')) {
          SetInputTextReadOnly(gameObject, !!config.inputTextReadOnly);
        }
        if (setDefaults || config.hasOwnProperty('step')) {
          gameObject.step = config.hasOwnProperty('step') ? config.step : 1;
        }
        if (setDefaults || config.hasOwnProperty('min')) {
          gameObject.minValue = config.min;
        }
        if (setDefaults || config.hasOwnProperty('max')) {
          gameObject.maxValue = config.max;
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var inputText = gameObject.childrenMap.inputText;
        inputText.setText('').setText(gameObject.getFotmatText(value));
      }
    };
  
    var CreateColorInput = function CreateColorInput(scene, config, deepCloneConfig) {
      if (deepCloneConfig === undefined) {
        deepCloneConfig = true;
      }
      if (deepCloneConfig) {
        config = config ? DeepClone(config) : {};
      } else if (!config) {
        config = {};
      }
      var inputText = new ColorInput(scene, config);
      scene.add.existing(inputText);
      return inputText;
    };
  
    var ColorInputHandler = {
      name: 'ColorInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'color';
        }
        return false;
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.ColorInput';
        var colorInputConfig = style.colorInput;
        if (colorInputConfig === undefined) {
          colorInputConfig = {};
        }
        if (!colorInputConfig.hasOwnProperty('inputText')) {
          colorInputConfig.inputText = style.inputText;
        }
        var colorInput = CreateColorInput(scene, colorInputConfig);
        gameObject.add(colorInput, {
          proportion: 1,
          expand: true,
          key: 'colorInput'
        });
        colorInput.on('valuechange', function (value) {
          gameObject.setValue(value);
        });
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var colorInput = gameObject.childrenMap.colorInput;
        colorInput.setValue(value);
      }
    };
  
    var CreateCheckbox = function CreateCheckbox(scene, config) {
      var gameObject = new Checkbox(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var CheckboxInputHandler = {
      name: 'CheckboxInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'boolean';
        }
        return typeof config.value === 'boolean';
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.CheckboxInput';
        var checkboxConfig = style.checkbox;
        var checkbox = CreateCheckbox(scene, checkboxConfig);
        var size = checkboxConfig.size;
        if (size !== undefined) {
          checkbox.setSize(size, size);
        }
        var fitRatio = size !== undefined ? 0 : 1;
        gameObject.add(checkbox, {
          proportion: 0,
          expand: false,
          fitRatio: fitRatio,
          key: 'checkbox'
        });
        checkbox.on('valuechange', function (value) {
          gameObject.setValue(value);
        });
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var checkbox = gameObject.childrenMap.checkbox;
        checkbox.setValue(value);
      }
    };
  
    var CreateToggleSwitch = function CreateToggleSwitch(scene, config) {
      var gameObject = new ToggleSwitch(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var ToggleSwitchInputHandler = {
      name: 'ToggleSwitchInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'toggleSwitch';
        }
        return false;
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.ToggleSwitchInput';
        var toggleSwitchConfig = style.toggleSwitch;
        var toggleSwitch = CreateToggleSwitch(scene, toggleSwitchConfig);
        var size = toggleSwitchConfig.size;
        if (size !== undefined) {
          toggleSwitch.setSize(size, size);
        }
        var fitRatio = size !== undefined ? 0 : 1;
        gameObject.addSpace().add(toggleSwitch, {
          proportion: 0,
          expand: false,
          fitRatio: fitRatio,
          key: 'toggleSwitch'
        });
        toggleSwitch.on('valuechange', function (value) {
          gameObject.setValue(value);
        });
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var toggleSwitch = gameObject.childrenMap.toggleSwitch;
        toggleSwitch.setValue(value);
      }
    };
  
    var CreateDropDownList = function CreateDropDownList(scene, config) {
      config = BuildListConfig(scene, config);
      var gameObject = new DropDownList(scene, config);
      scene.add.existing(gameObject);
      return gameObject;
    };
  
    var GetOptionIndex = function GetOptionIndex(options, value) {
      for (var i = 0, cnt = options.length; i < cnt; i++) {
        var option = options[i];
        if (option.value === value) {
          return i;
        }
      }
      return undefined;
    };
    var GetOption = function GetOption(options, value) {
      var index = GetOptionIndex(options, value);
      if (index == null) {
        return undefined;
      }
      return options[index];
    };
  
    var SetOptions$1 = function SetOptions(gameObject, options) {
      var list = gameObject.childrenMap.list;
      list.setOptions(options);
    };
    var ListInputHandler = {
      name: 'ListInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'list';
        }
        return config.hasOwnProperty('options');
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.ListInput';
        var list = CreateDropDownList(scene, style.list);
        gameObject.add(list, {
          proportion: 1,
          expand: true,
          key: 'list'
        });
        list.on('button.click', function (dropDownList, listPanel, button, index, pointer, event) {
          gameObject.setValue(button.value);
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('options')) {
          SetOptions$1(gameObject, config.options);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var list = gameObject.childrenMap.list;
        var option = GetOption(list.options, value);
        list.resetDisplayContent(option).setMinSize(list.width, list.height).layout().setMinSize(0, 0);
      }
    };
  
    var SetButtonsActiveStateByIndex = function SetButtonsActiveStateByIndex(buttons, index) {
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        var button = buttons[i];
        if (!button) {
          continue;
        }
        button.setActiveState(i === index);
      }
    };
  
    var GetValue$9 = Phaser.Utils.Objects.GetValue;
    var SetOptions = function SetOptions(gameObject, options) {
      var list = gameObject.childrenMap.list;
      list.options = options;
      var scene = gameObject.scene;
      var buttonConfig = list.buttonConfig;
      list.clearButtons(true);
      for (var i = 0, cnt = options.length; i < cnt; i++) {
        var option = options[i];
        var button = CreateLabel(scene, buttonConfig).setActiveState(false).resetDisplayContent({
          text: option.text
        });
        list.addButton(button);
      }
    };
    var ButtonsInputHandler = {
      name: 'ButtonsInput',
      accept: function accept(config) {
        if (config.hasOwnProperty('view')) {
          return config.view === 'buttons';
        }
        return false;
      },
      // Callback after `constructor()`
      build: function build(gameObject, style) {
        var scene = gameObject.scene;
        gameObject.type = 'rexTweaker.ButtonsInput';
  
        // TODO : DeepClone?
        var buttonConfig = style.button ? DeepClone(style.button) : {};
        var buttonExpand = GetValue$9(buttonConfig, 'expand', true);
        if (buttonExpand) {
          buttonConfig.align = 'center';
        }
        delete buttonConfig.expand;
        var list = CreateButtons(scene, {
          expand: buttonExpand
        });
        list.buttonConfig = buttonConfig;
        gameObject.add(list, {
          proportion: 1,
          expand: true,
          key: 'list'
        });
        list.on('button.click', function (button, index, pointer, event) {
          var option = list.options[index];
          if (!option) {
            return; // ??
          }
          gameObject._selectedIndex = index;
          gameObject.setValue(option.value);
          gameObject._selectedIndex = undefined;
        });
      },
      // Callback inside `setup()`
      setup: function setup(gameObject, config, setDefaults) {
        if (setDefaults || config.hasOwnProperty('options')) {
          SetOptions(gameObject, config.options);
        }
      },
      // Callback inside `setValue()`
      displayValue: function displayValue(gameObject, value) {
        var list = gameObject.childrenMap.list;
        var index = gameObject._selectedIndex; // See list's 'button.click' event
        if (index === undefined) {
          index = GetOptionIndex(list.options, value);
        }
        SetButtonsActiveStateByIndex(list.childrenMap.buttons, index);
      }
    };
  
    // string
    var RegisterDefaultInputHandlers = function RegisterDefaultInputHandlers() {
      this
      // string
      .registerInputHandler(TextInputHandler).registerInputHandler(TextAreaInputHandler)
      // number
      .registerInputHandler(NumberInputHandler).registerInputHandler(RangeInputHandler).registerInputHandler(IncDecInputHandler).registerInputHandler(ColorInputHandler)
      // boolean
      .registerInputHandler(CheckboxInputHandler).registerInputHandler(ToggleSwitchInputHandler)
      // options
      .registerInputHandler(ListInputHandler).registerInputHandler(ButtonsInputHandler);
    };
  
    var Tweaker = /*#__PURE__*/function (_TweakerShell) {
      _inherits(Tweaker, _TweakerShell);
      function Tweaker(scene, config) {
        var _this;
        _classCallCheck(this, Tweaker);
        if (config === undefined) {
          config = {};
        }
        if (config.hasOwnProperty('style')) {
          config.styles = config.style;
        }
        if (config.styles === undefined) {
          config.styles = {}; // TODO: Default styles
        }
        config.background = config.styles.background || {};
        config.space = config.styles.space || {};
  
        // Create sizer
        _this = _callSuper(this, Tweaker, [scene, config]);
        _this.type = 'rexTweaker';
        _this.inputHandlers = [];
        RegisterDefaultInputHandlers.call(_assertThisInitialized(_this));
        return _this;
      }
      _createClass(Tweaker, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(Tweaker.prototype), "destroy", this).call(this, fromScene);
          this.inputHandlers = undefined;
        }
      }]);
      return Tweaker;
    }(TweakerShell);
  
    ObjectFactory.register('tweaker', function (config) {
      var gameObject = new Tweaker(this.scene, config);
      this.scene.add.existing(gameObject);
      return gameObject;
    });
    SetValue(window, 'RexPlugins.UI.Tweaker', Tweaker);
  
    ObjectFactory.register('click', function (gameObject, config) {
      return new Button(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Click', Button);
  
    ObjectFactory.register('clickOutside', function (gameObject, config) {
      return new ClickOutside(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.ClickOutside', ClickOutside);
  
    ObjectFactory.register('inTouching', function (gameObject, config) {
      return new InTouching(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.InTouching', InTouching);
  
    ObjectFactory.register('tap', function (gameObject, config) {
      if (!IsGameObject(gameObject)) {
        config = gameObject;
        gameObject = this.scene;
      }
      return new Tap(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Tap', Tap);
  
    ObjectFactory.register('press', function (gameObject, config) {
      if (!IsGameObject(gameObject)) {
        config = gameObject;
        gameObject = this.scene;
      }
      return new Press(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Press', Press);
  
    ObjectFactory.register('swipe', function (gameObject, config) {
      if (!IsGameObject(gameObject)) {
        config = gameObject;
        gameObject = this.scene;
      }
      return new Swipe(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Swipe', Swipe);
  
    ObjectFactory.register('pan', function (gameObject, config) {
      if (!IsGameObject(gameObject)) {
        config = gameObject;
        gameObject = this.scene;
      }
      return new Pan(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Pan', Pan);
  
    ObjectFactory.register('drag', function (gameObject, config) {
      return new Drag(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Drag', Drag);
  
    ObjectFactory.register('pinch', function (config) {
      return new Pinch(this.scene, config);
    });
    SetValue(window, 'RexPlugins.UI.Pinch', Pinch);
  
    ObjectFactory.register('rotate', function (config) {
      return new Rotate(this.scene, config);
    });
    SetValue(window, 'RexPlugins.UI.Rotate', Rotate);
  
    var IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$8 = Phaser.Utils.Objects.GetValue;
    var GetFrameUpdatingCallback = function GetFrameUpdatingCallback(key, frame, gameObject) {
      var callback;
      if (key === undefined) {
        key = gameObject.texture.key;
        frame = gameObject.frame.name;
      } else if (IsPlainObject$3(key)) {
        var config = key;
        key = GetValue$8(config, 'key', gameObject.texture.key);
        frame = GetValue$8(config, 'frame', gameObject.frame.name);
      } else if (typeof key === 'string') ; else {
        callback = key;
      }
      if (callback === undefined) {
        callback = function callback(gameObject) {
          gameObject.setTexture(key, frame);
        };
      }
      return callback;
    };
  
    var GetValue$7 = Phaser.Utils.Objects.GetValue;
    var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
    var Linear = Phaser.Math.Linear;
    var Flip = /*#__PURE__*/function (_EaseValueTaskBase) {
      _inherits(Flip, _EaseValueTaskBase);
      function Flip(gameObject, config) {
        var _this;
        _classCallCheck(this, Flip);
        _this = _callSuper(this, Flip, [gameObject, config]);
        // this.parent = gameObject;
        // this.timer
  
        _this.resetFromJSON(config);
        _this.boot();
        return _this;
      }
      _createClass(Flip, [{
        key: "resetFromJSON",
        value: function resetFromJSON(o) {
          _get(_getPrototypeOf(Flip.prototype), "resetFromJSON", this).call(this, o);
          this.setDuration(GetAdvancedValue(o, 'duration', 500));
          this.setEase(GetValue$7(o, 'ease', 'Sine'));
          this.setOrientation(GetValue$7(o, 'orientation', 0));
          this.setFrontFace(GetValue$7(o, 'front', undefined));
          this.setBackFace(GetValue$7(o, 'back', undefined));
          this.setFace(GetValue$7(o, 'face', 0));
          return this;
        }
      }, {
        key: "setOrientation",
        value: function setOrientation(orientation) {
          if (typeof orientation === 'string') {
            orientation = ORIENTATIONMODE[orientation];
          }
          this.orientation = orientation;
          return this;
        }
      }, {
        key: "face",
        get: function get() {
          return this._face;
        },
        set: function set(face) {
          if (typeof face === 'string') {
            face = FACEMODE[face];
          }
          this._face = face;
          if (face === 0 && this.frontFaceCallback) {
            this.frontFaceCallback(this.parent);
          } else if (face === 1 && this.backFaceCallback) {
            this.backFaceCallback(this.parent);
          }
        }
      }, {
        key: "setFace",
        value: function setFace(face) {
          this.face = face;
          return this;
        }
      }, {
        key: "toggleFace",
        value: function toggleFace() {
          var newFace = this.face === 0 ? 1 : 0;
          this.setFace(newFace);
          return this;
        }
      }, {
        key: "setFrontFace",
        value: function setFrontFace(key, frame) {
          this.frontFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
          return this;
        }
      }, {
        key: "setBackFace",
        value: function setBackFace(key, frame) {
          this.backFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
          return this;
        }
      }, {
        key: "start",
        value: function start() {
          if (this.timer.isRunning) {
            return this;
          }
          var gameObject = this.parent;
          if (this.orientation === 0) {
            this.scale0 = gameObject.scaleX;
          } else {
            this.scale0 = gameObject.scaleY;
          }
          this.timer.setDelay(this.delay).setDuration(this.duration / 2).setRepeat(1); // 2 times
  
          _get(_getPrototypeOf(Flip.prototype), "start", this).call(this);
          return this;
        }
      }, {
        key: "flip",
        value: function flip(duration) {
          if (this.isRunning) {
            return this;
          }
          if (duration !== undefined) {
            this.setDuration(duration);
          }
          this.start();
          return this;
        }
      }, {
        key: "updateGameObject",
        value: function updateGameObject(gameObject, timer) {
          if (timer.justRestart) {
            this.toggleFace();
          }
          var t = timer.t;
          if (timer.isOddIteration) {
            // Yoyo
            t = 1 - t;
          }
          t = this.easeFn(t);
          var value = Linear(this.scale0, 0, t);
          if (this.orientation === 0) {
            gameObject.scaleX = value;
          } else {
            gameObject.scaleY = value;
          }
        }
      }]);
      return Flip;
    }(EaseValueTaskBase);
    var ORIENTATIONMODE = {
      x: 0,
      horizontal: 0,
      y: 1,
      vertical: 1
    };
    var FACEMODE = {
      front: 0,
      back: 1
    };
  
    ObjectFactory.register('flip', function (gameObject, config) {
      return new Flip(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Flip', Flip);
  
    ObjectFactory.register('shake', function (gameObject, config) {
      return new ShakePosition(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Shake', ShakePosition);
  
    ObjectFactory.register('touchEventStop', function (gameObject, config) {
      return new TouchEventStop(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.TouchEventStop', TouchEventStop);
  
    ObjectFactory.register('perspective', function (gameObject, config) {
      return new ContainerPerspective(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Perspective', ContainerPerspective);
  
    var RotateAround = Phaser.Math.RotateAround;
    var LocalXYToWorldXY = function LocalXYToWorldXY(gameObject, localX, localY) {
      var ox = gameObject.width / 2;
      var oy = gameObject.height / 2;
      out.x = localX - ox;
      out.y = localY - oy;
      RotateAround(out, 0, 0, gameObject.rotation);
      out.x *= gameObject.scaleX;
      out.y *= gameObject.scaleY;
      out.x += gameObject.x;
      out.y += gameObject.y;
      return out;
    };
    var WorldXYToLocalXY = function WorldXYToLocalXY(gameObject, worldX, worldY) {
      var ox = gameObject.width / 2;
      var oy = gameObject.height / 2;
      out.x = worldX - gameObject.x;
      out.y = worldY - gameObject.y;
      out.x /= gameObject.scaleX;
      out.y /= gameObject.scaleY;
      RotateAround(out, 0, 0, -gameObject.rotation);
      out.x += ox;
      out.y += oy;
      return out;
    };
    var out = {
      x: 0,
      y: 0
    };
  
    var ControlPoint = /*#__PURE__*/function () {
      function ControlPoint(parent, vertex) {
        _classCallCheck(this, ControlPoint);
        this.parent = parent;
        this.vertex = vertex;
        this._localX = undefined;
        this._localY = undefined;
      }
      _createClass(ControlPoint, [{
        key: "destroy",
        value: function destroy() {
          this.parent = undefined;
          this.vertex = undefined;
        }
      }, {
        key: "updateVertexPosition",
        value: function updateVertexPosition(x, y) {
          var gameObject = this.parent;
          var srcHeight = gameObject.height;
          var vHalfWidth = gameObject.frame.cutWidth / srcHeight / 2;
          var vHalfHeight = gameObject.frame.cutHeight / srcHeight / 2;
          var vx = x / srcHeight - vHalfWidth;
          var vy = y / srcHeight - vHalfHeight;
          var vertex = this.vertex;
          vertex.x = vx;
          vertex.y = -vy;
          gameObject.forceUpdate();
          return this;
        }
      }, {
        key: "localX",
        get: function get() {
          return this._localX;
        },
        set: function set(x) {
          this.setLocalXY(x, this._localY);
        }
      }, {
        key: "localY",
        get: function get() {
          return this._localY;
        },
        set: function set(y) {
          this.setLocalXY(this._localX, y);
        }
      }, {
        key: "localXOrigin",
        get: function get() {
          return this._localXOrigin;
        }
      }, {
        key: "localYOrigin",
        get: function get() {
          return this._localYOrigin;
        }
      }, {
        key: "resetLocalXY",
        value: function resetLocalXY(x, y) {
          this._localXOrigin = x;
          this._localYOrigin = y;
          this._localX = x;
          this._localY = y;
          return this;
        }
      }, {
        key: "setLocalXY",
        value: function setLocalXY(x, y, ignoreUpdateVertex) {
          if (this._localX === x && this._localY === y) {
            return this;
          }
          this._localX = x;
          this._localY = y;
          if (!ignoreUpdateVertex) {
            this.updateVertexPosition(x, y);
          }
          return this;
        }
      }, {
        key: "setWorldXY",
        value: function setWorldXY(x, y) {
          if (this._worldX === x && this._worldY === y) {
            return this;
          }
          var localXY = WorldXYToLocalXY(this.parent, x, y);
          this.setLocalXY(localXY.x, localXY.y);
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x, y) {
          this.setWorldXY(x, y);
          return this;
        }
      }, {
        key: "getWorldXY",
        value: function getWorldXY() {
          return LocalXYToWorldXY(this.parent, this._localX, this._localY);
        }
      }, {
        key: "x",
        get: function get() {
          var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
          return worldXY.x;
        },
        set: function set(x) {
          this.setWorldXY(x, this.y);
        }
      }, {
        key: "y",
        get: function get() {
          var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
          return worldXY.y;
        },
        set: function set(y) {
          this.setWorldXY(this.x, y);
        }
      }]);
      return ControlPoint;
    }();
  
    var Vertex = Phaser.Geom.Mesh.Vertex;
    var Face = Phaser.Geom.Mesh.Face;
    var InitFaces = function InitFaces(quad) {
      var isNinePointMode = quad.isNinePointMode;
      var pointCount = isNinePointMode ? 9 : 4;
      var vertices = quad.vertices;
      var faces = quad.faces;
      var controlPoints = quad.controlPoints;
      for (var i = 0; i < pointCount; i++) {
        var vertex = new Vertex();
        vertices.push(vertex);
        controlPoints.push(new ControlPoint(quad, vertex));
      }
      var indices;
      if (isNinePointMode) {
        indices = NinePointsIndices;
      } else {
        if (!quad.fourPointsModeRTL) {
          indices = FourPointsIndices;
        } else {
          indices = FourPointsIndicesRTL;
        }
      }
      for (var i = 0, cnt = indices.length; i < cnt; i += 3) {
        var vert1 = vertices[indices[i + 0]];
        var vert2 = vertices[indices[i + 1]];
        var vert3 = vertices[indices[i + 2]];
        faces.push(new Face(vert1, vert2, vert3));
      }
      if (isNinePointMode) {
        quad.topLeft = controlPoints[0];
        quad.topCenter = controlPoints[1];
        quad.topRight = controlPoints[2];
        quad.centerLeft = controlPoints[3];
        quad.center = controlPoints[4];
        quad.centerRight = controlPoints[5];
        quad.bottomLeft = controlPoints[6];
        quad.bottomCenter = controlPoints[7];
        quad.bottomRight = controlPoints[8];
      } else {
        quad.topLeft = controlPoints[0];
        quad.topRight = controlPoints[1];
        quad.bottomLeft = controlPoints[2];
        quad.bottomRight = controlPoints[3];
      }
    };
  
    /*
    0, 1,
    2, 3,
    */
    var FourPointsIndices = [0, 2, 3, 0, 3, 1];
    var FourPointsIndicesRTL = [1, 3, 2, 1, 2, 0];
  
    /*
    0, 1, 2,
    3, 4, 5,
    6, 7, 8
    */
    var NinePointsIndices = [0, 3, 4, 0, 4, 1, 1, 4, 2, 4, 5, 2, 3, 6, 4, 6, 7, 4, 4, 7, 8, 4, 8, 5];
  
    var GetPointPosition = function GetPointPosition(quad) {
      var points;
      var top = 0,
        bottom = quad.height,
        left = 0,
        right = quad.width;
      if (quad.isNinePointMode) {
        var centerX = (left + right) / 2;
        var centerY = (top + bottom) / 2;
        points = [left, top,
        // top-left
        centerX, top,
        // top-center
        right, top,
        // top-right
        left, centerY,
        // center-left
        centerX, centerY,
        // center-center
        right, centerY,
        // top-right
        left, bottom,
        // center-left
        centerX, bottom,
        // bottom-center
        right, bottom // bottom-right
        ];
      } else {
        points = [left, top,
        // top-left
        right, top,
        // top-right
        left, bottom,
        // bottom-left
        right, bottom // bottom-right
        ];
      }
      return points;
    };
  
    var IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$6 = Phaser.Utils.Objects.GetValue;
    var Image$1 = /*#__PURE__*/function (_MeshBase) {
      _inherits(Image, _MeshBase);
      function Image(scene, x, y, key, frame, config) {
        var _this;
        _classCallCheck(this, Image);
        if (IsPlainObject$2(x)) {
          config = x;
          x = GetValue$6(config, 'x', 0);
          y = GetValue$6(config, 'y', 0);
          key = GetValue$6(config, 'key', null);
          frame = GetValue$6(config, 'frame', null);
        }
        _this = _callSuper(this, Image, [scene, x, y, key, frame]);
        _this.type = 'rexQuadImage';
        _this.isNinePointMode = GetValue$6(config, 'ninePointMode', false);
        _this.fourPointsModeRTL = GetValue$6(config, 'rtl', false);
        _this.controlPoints = [];
        InitFaces(_assertThisInitialized(_this));
        _this.hideCCW = false;
        _this.syncSize();
        return _this;
      }
      _createClass(Image, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(Image.prototype), "destroy", this).call(this, fromScene);
          for (var i = 0, cnt = this.controlPoints.length; i < cnt; i++) {
            this.controlPoints[i].destroy();
          }
          this.controlPoints = undefined;
        }
      }, {
        key: "resetVerts",
        value: function resetVerts() {
          // Clear faces and vertices        
          this.dirtyCache[9] = -1;
          var points = GetPointPosition(this);
  
          // Calculate vertex data
          var srcWidth = this.width;
          var srcHeight = this.height;
          var vHalfWidth = this.frame.cutWidth / srcHeight / 2;
          var vHalfHeight = this.frame.cutHeight / srcHeight / 2;
          var frameU0 = this.frame.u0;
          var frameU1 = this.frame.u1;
          var frameV0 = this.frame.v0;
          var frameV1 = this.frame.v1;
          var frameU = frameU1 - frameU0;
          var frameV = frameV1 - frameV0;
  
          // Update vertex
          var controlPoints = this.controlPoints;
          for (var i = 0, cnt = points.length; i < cnt; i += 2) {
            var px = points[i + 0];
            var py = points[i + 1];
            var vertexIndex = i / 2;
            var x = px / srcHeight - vHalfWidth;
            var y = py / srcHeight - vHalfHeight;
            var u = frameU0 + frameU * (px / srcWidth);
            var v = frameV0 + frameV * (py / srcHeight);
            this.vertices[vertexIndex].set(x, -y, 0).setUVs(u, v);
            controlPoints[vertexIndex].resetLocalXY(px, py);
          }
          return this;
        }
      }, {
        key: "syncSize",
        value: function syncSize() {
          this.setSizeToFrame(); // Reset size
          this.setOrtho(this.width / this.height, 1);
          this.resetVerts(); // Reset verts
          return this;
        }
      }]);
      return Image;
    }(MeshBase);
  
    Phaser.Utils.Objects.IsPlainObject;
    Phaser.Utils.Objects.GetValue;
  
    var Skew = function Skew(gameObject, skewX, skewY) {
      if (skewX === undefined) {
        skewX = 0;
      }
      if (skewY === undefined) {
        skewY = 0;
      }
      var width = gameObject.width,
        height = gameObject.height;
      var ox = width * 0.5;
      var oy = height * 0.5;
      var xOffset = Math.tan(skewX) * oy;
      var yOffset = Math.tan(skewY) * ox;
      var controlPoints = gameObject.controlPoints;
      for (var i = 0, cnt = controlPoints.length; i < cnt; i++) {
        var controlPoint = controlPoints[i];
        var x = controlPoint.localXOrigin;
        var y = controlPoint.localYOrigin;
        controlPoint.localX = x + (y > oy ? xOffset : -xOffset);
        controlPoint.localY = y + (x > ox ? yOffset : -yOffset);
      }
    };
  
    var IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$5 = Phaser.Utils.Objects.GetValue;
    var DegToRad = Phaser.Math.DegToRad;
    var RadToDeg = Phaser.Math.RadToDeg;
    var SkewImage = /*#__PURE__*/function (_Image) {
      _inherits(SkewImage, _Image);
      function SkewImage(scene, x, y, key, frame) {
        var _this;
        _classCallCheck(this, SkewImage);
        if (IsPlainObject$1(x)) {
          var config = x;
          x = GetValue$5(config, 'x', 0);
          y = GetValue$5(config, 'y', 0);
          key = GetValue$5(config, 'key', null);
          frame = GetValue$5(config, 'frame', null);
        }
        _this = _callSuper(this, SkewImage, [scene, x, y, key, frame]);
        _this.type = 'rexSkewmage';
        _this._skewX = 0;
        _this._skewY = 0;
        return _this;
      }
      _createClass(SkewImage, [{
        key: "skewX",
        get: function get() {
          return this._skewX;
        },
        set: function set(value) {
          this._skewX = value;
          Skew(this, this._skewX, this._skewY);
        }
      }, {
        key: "skewXDeg",
        get: function get() {
          return RadToDeg(this._skewX);
        },
        set: function set(value) {
          this.skewX = DegToRad(value);
        }
      }, {
        key: "skewY",
        get: function get() {
          return this._skewY;
        },
        set: function set(value) {
          this._skewY = value;
          Skew(this, this._skewX, this._skewY);
        }
      }, {
        key: "skewYDeg",
        get: function get() {
          return RadToDeg(this._skewY);
        },
        set: function set(value) {
          this.skewY = DegToRad(value);
        }
      }, {
        key: "setSkewX",
        value: function setSkewX(skewX) {
          this.skewX = skewX;
          return this;
        }
      }, {
        key: "setSkewY",
        value: function setSkewY(skewY) {
          this.skewY = skewY;
          return this;
        }
      }, {
        key: "setSkew",
        value: function setSkew(skewX, skewY) {
          if (skewY === undefined) {
            skewY = skewX;
          }
          this.skewX = skewX;
          this.skewY = skewY;
          return this;
        }
      }, {
        key: "setSkewXDeg",
        value: function setSkewXDeg(skewX) {
          this.skewXDeg = skewX;
          return this;
        }
      }, {
        key: "setSkewYDeg",
        value: function setSkewYDeg(skewY) {
          this.skewYDeg = skewY;
          return this;
        }
      }, {
        key: "setSkewDeg",
        value: function setSkewDeg(skewX, skewY) {
          if (skewY === undefined) {
            skewY = skewX;
          }
          this.skewXDeg = skewX;
          this.skewYDeg = skewY;
          return this;
        }
      }]);
      return SkewImage;
    }(Image$1);
  
    var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
    var GetValue$4 = Phaser.Utils.Objects.GetValue;
    var SkewRenderTexture = /*#__PURE__*/function (_SkewImage) {
      _inherits(SkewRenderTexture, _SkewImage);
      function SkewRenderTexture(scene, x, y, width, height) {
        var _this;
        _classCallCheck(this, SkewRenderTexture);
        if (IsPlainObject(x)) {
          var config = x;
          x = GetValue$4(config, 'x', 0);
          y = GetValue$4(config, 'y', 0);
          width = GetValue$4(config, 'width', 32);
          height = GetValue$4(config, 'height', 32);
        }
  
        // dynamic-texture -> quad-image
        var texture = CreateDynamicTexture(scene, width, height);
        _this = _callSuper(this, SkewRenderTexture, [scene, x, y, texture, null]);
        _this.type = 'rexSkewRenderTexture';
        _this.rt = _this.texture;
        return _this;
      }
      _createClass(SkewRenderTexture, [{
        key: "destroy",
        value: function destroy(fromScene) {
          //  This Game Object has already been destroyed
          if (!this.scene || this.ignoreDestroy) {
            return;
          }
          _get(_getPrototypeOf(SkewRenderTexture.prototype), "destroy", this).call(this, fromScene);
          this.rt.destroy();
          this.rt = null;
        }
      }]);
      return SkewRenderTexture;
    }(SkewImage);
  
    var ContainerSkew = /*#__PURE__*/function (_MeshRenderTextureBas) {
      _inherits(ContainerSkew, _MeshRenderTextureBas);
      function ContainerSkew() {
        _classCallCheck(this, ContainerSkew);
        return _callSuper(this, ContainerSkew, arguments);
      }
      _createClass(ContainerSkew, [{
        key: "skewState",
        get: function get() {
          return this.isRunning;
        }
      }]);
      return ContainerSkew;
    }(MeshRenderTextureBase(SkewRenderTexture));
  
    ObjectFactory.register('skew', function (gameObject, config) {
      return new ContainerSkew(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Skew', ContainerSkew);
  
    ObjectFactory.register('anchor', function (gameObject, config) {
      return new Anchor(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.Anchor', Anchor);
  
    ObjectFactory.register('textTyping', function (gameObject, config) {
      return new TextTyping(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.TextTyping', TextTyping);
  
    ObjectFactory.register('textPage', function (gameObject, config) {
      return new TextPage(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.TextPage', TextPage);
  
    var LastOpenedEditor = undefined;
    var SetLastOpenedEditor = function SetLastOpenedEditor(editor) {
      if (editor === LastOpenedEditor) {
        return;
      }
      if (LastOpenedEditor !== undefined) {
        LastOpenedEditor.close();
      }
      LastOpenedEditor = editor;
    };
    var CloseLastOpenEditor = function CloseLastOpenEditor(editor) {
      if (editor !== LastOpenedEditor) {
        return;
      }
  
      // Don't call `LastOpenedEditor.close()`
      LastOpenedEditor = undefined;
    };
  
    var GetValue$3 = Phaser.Utils.Objects.GetValue;
    var Clone = Phaser.Utils.Objects.Clone;
    var CreateInputText = function CreateInputText(text, config) {
      if (config === undefined) {
        config = {};
      }
      config = Clone(config);
      var scene = text.scene;
      var style = text.style;
      var backgroundColor = GetValue$3(config, 'backgroundColor', style.backgroundColor);
      if (backgroundColor === null) {
        backgroundColor = 'transparent';
      }
      config.text = GetValue$3(config, 'text', text.text);
      config.fontFamily = GetValue$3(config, 'fontFamily', style.fontFamily);
      config.fontSize = GetValue$3(config, 'fontSize', style.fontSize);
      config.color = GetValue$3(config, 'color', style.color);
      config.backgroundColor = backgroundColor;
      config.direction = GetValue$3(config, 'rtl', style.rtl) ? 'rtl' : 'ltr';
      config.align = GetValue$3(config, 'align', GetHAlign(style));
  
      // Built-in text game object with RTL only has 'right' align
      if (config.direction === 'rtl' && IsTextGameObject(text)) {
        config.align = 'right';
      }
      var padding = text.padding;
      if (padding.left > 0) {
        config.paddingLeft = "".concat(padding.left, "px");
      }
      if (padding.right > 0) {
        config.paddingRight = "".concat(padding.right, "px");
      }
      // config.paddingTop = 0;
      // config.paddingBottom = 0;
      // var valign = GetVAlign(style);
      // switch (valign) {
      //     case 'top':
      //         break;
      //     case 'bottom':
      //         break;
      // }
  
      if (style.backgroundCornerRadius) {
        config.borderRadius = GetValue$3(config, 'borderRadius', "".concat(style.backgroundCornerRadius, "px"));
      }
      var inputText = new InputText(scene, text.x, text.y, GetValue$3(config, 'width', text.width), GetValue$3(config, 'height', text.height), config);
      inputText
      // Sync scale
      .setScale(text.scaleX, text.scaleY)
      // Sync origin
      .setOrigin(text.originX, text.originY)
      // Sync scrollFactor
      .setScrollFactor(text.scrollFactorX, text.scrollFactorY);
      var textParentContainer = text.parentContainer;
      if (!textParentContainer) {
        scene.add.existing(inputText);
      } else {
        textParentContainer.add(inputText);
      }
      return inputText;
    };
    var GetHAlign = function GetHAlign(style) {
      if (style.hasOwnProperty('align')) {
        return style.align;
      } else if (style.hasOwnProperty('halign')) {
        return style.halign;
      } else {
        return 'left';
      }
    };
  
    var NextTick = function NextTick(scene, callback, scope) {
      return scene.time.delayedCall(0, callback, [], scope);
    };
  
    var GetValue$2 = Phaser.Utils.Objects.GetValue;
    var Merge = Phaser.Utils.Objects.Merge;
    var Open = function Open(config, onCloseCallback) {
      if (config === undefined) {
        config = {};
      }
      config = Merge(config, this.openConfig);
      SetLastOpenedEditor(this);
      if (IsFunction(config)) {
        onCloseCallback = config;
        config = undefined;
      }
      var textType = GetValue$2(config, 'inputType', undefined);
      if (textType === undefined) {
        textType = GetValue$2(config, 'type', 'text');
      }
      if (onCloseCallback === undefined) {
        onCloseCallback = GetValue$2(config, 'onClose', undefined);
      }
      var onOpenCallback = GetValue$2(config, 'onOpen', undefined);
      var customOnTextChanged = GetValue$2(config, 'onTextChanged', undefined);
      this.inputText = CreateInputText(this.parent, config).on('textchange', function (inputText) {
        var text = inputText.text;
        if (customOnTextChanged) {
          // Custom on-text-changed callback
          customOnTextChanged(this.parent, text);
        } else {
          // Default on-text-changed callback
          this.parent.text = text;
        }
      }, this).setFocus();
      this.parent.setVisible(false); // Set parent text invisible
  
      // Attach close event
      this.onClose = onCloseCallback;
      if (GetValue$2(config, 'enterClose', textType !== 'textarea')) {
        this.scene.input.keyboard.once('keydown-ENTER', this.close, this);
      }
      // Attach pointerdown (outside of input-text) event, at next tick
      this.delayCall = NextTick(this.scene, function () {
        this.scene.input.once('pointerdown', this.close, this);
  
        // Open editor completly, invoke onOpenCallback
        if (onOpenCallback) {
          onOpenCallback(this.parent);
        }
        this.emit('open', this.parent);
      }, this);
      return this;
    };
  
    var Close = function Close() {
      CloseLastOpenEditor(this);
      this.parent.setVisible(true); // Set parent text visible
  
      if (this.inputText) {
        this.inputText.destroy();
        this.inputText = undefined;
      }
      if (this.delayCall) {
        this.delayCall.remove();
        this.delayCall = undefined;
      }
  
      // Remove close event
      this.scene.input.keyboard.off('keydown-ENTER', this.close, this);
      this.scene.input.off('pointerdown', this.close, this);
      if (this.onClose) {
        this.onClose(this.parent);
      }
      this.emit('close', this.parent);
      return this;
    };
  
    var Methods = {
      open: Open,
      close: Close
    };
  
    var GetValue$1 = Phaser.Utils.Objects.GetValue;
    var TextEdit = /*#__PURE__*/function (_ComponentBase) {
      _inherits(TextEdit, _ComponentBase);
      function TextEdit(gameObject, config) {
        var _this;
        _classCallCheck(this, TextEdit);
        _this = _callSuper(this, TextEdit, [gameObject]);
        // this.parent = gameObject;
  
        _this.inputText = undefined;
        _this.onClose = undefined;
        _this.delayCall = undefined;
        _this.setOpenConfig(config);
        var clickEnable = GetValue$1(config, 'clickEnable', true);
        if (clickEnable) {
          gameObject.on('pointerdown', function () {
            this.open();
          }, _assertThisInitialized(_this)).setInteractive();
        }
        return _this;
      }
      _createClass(TextEdit, [{
        key: "shutdown",
        value: function shutdown(fromScene) {
          // Already shutdown
          if (this.isShutdown) {
            return;
          }
          this.close();
          _get(_getPrototypeOf(TextEdit.prototype), "shutdown", this).call(this, fromScene);
        }
      }, {
        key: "setOpenConfig",
        value: function setOpenConfig(config) {
          if (config === undefined) {
            config = {};
          }
          this.openConfig = config;
          return this;
        }
      }, {
        key: "isOpened",
        get: function get() {
          return this.inputText !== undefined;
        }
      }, {
        key: "text",
        get: function get() {
          return this.isOpened ? this.inputText.text : this.parent.text;
        }
      }]);
      return TextEdit;
    }(ComponentBase);
    Object.assign(TextEdit.prototype, Methods);
  
    var Edit = function Edit(gameObject, config, onCloseCallback) {
      if (!gameObject._edit) {
        gameObject._edit = new TextEdit(gameObject, {
          clickEnable: false
        });
      }
      gameObject._edit.open(config, onCloseCallback);
      return gameObject._edit;
    };
  
    ObjectFactory.register('textEdit', function (gameObject, config) {
      return new TextEdit(gameObject, config);
    });
    SetValue(window, 'RexPlugins.UI.TextEdit', TextEdit);
  
    ObjectFactory.register('layerManager', function (config) {
      return new LayerManager(this.scene, config);
    });
    SetValue(window, 'RexPlugins.UI.LayerManager', LayerManager);
  
    var MaxTestCount = 65535;
    var FontSizeFit = function FontSizeFit(textObject, width, height) {
      if (width == null) {
        // Do nothing if invalid width input
        return textObject;
      }
      if (width === 0) {
        SetTextWidth(textObject, 0, height);
        return textObject;
      }
      var textLength = textObject.text.length;
      if (textLength === 0) {
        SetTextWidth(textObject, width, height);
        return textObject;
      }
      var fontSize = Math.floor(width * 1.5 / textLength);
      if (height !== undefined) {
        if (fontSize > height) {
          fontSize = Math.floor(height);
        }
      }
      var sizeData = {};
      var testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
      for (var i = 0; i <= MaxTestCount; i++) {
        if (testResult === 0) {
          break;
        } else {
          fontSize += testResult;
          if (fontSize < 0) {
            fontSize = 0;
            break;
          }
        }
        testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
        // console.log(fontSize, testResult)
      }
      if (i === MaxTestCount) {
        console.warn("FontSizeFit: Test count exceeds ".concat(MaxTestCount));
      }
      textObject.setFontSize(fontSize);
      SetTextWidth(textObject, width, height);
      return textObject;
    };
    var GetTextSize = function GetTextSize(textObject, fontSize, sizeData) {
      if (sizeData[fontSize] === undefined) {
        textObject.setFontSize(fontSize);
        sizeData[fontSize] = {
          width: textObject.width,
          height: textObject.height
        };
      }
      return sizeData[fontSize];
    };
    var TestFontSize = function TestFontSize(textObject, fontSize, width, height, sizeData) {
      var textSize = GetTextSize(textObject, fontSize, sizeData);
      var textSize1 = GetTextSize(textObject, fontSize + 1, sizeData);
      var deltaHeight;
      if (height !== undefined) {
        // Clamp by height
        if (textSize.height <= height && textSize1.height > height) {
          deltaHeight = 0;
        } else if (textSize.height > height) {
          // Reduce font size
          return -1;
        } else {
          // Increase font size
          deltaHeight = Math.floor(height - textSize.height);
        }
      }
  
      // Clamp by width
      var deltaWidth;
      if (textSize.width <= width && textSize1.width > width) {
        return 0;
      } else if (textSize.width > width) {
        // Reduce font size
        return -1;
      } else {
        // Increase font size
        var deltaWidth = Math.floor(width - textSize.width);
        if (deltaHeight === undefined) {
          return deltaWidth;
        } else {
          return Math.min(deltaWidth, deltaHeight);
        }
      }
    };
    var SetTextWidth = function SetTextWidth(textObject, width, height) {
      var style = textObject.style;
      if (!style) {
        // BitmapText game object does not have style property
        return;
      }
      style.fixedWidth = width;
      style.parent.width = width;
      if (height !== undefined) {
        style.fixedHeight = height;
        style.parent.height = height;
      }
      style.update(false);
    };
  
    var GetValue = Phaser.Utils.Objects.GetValue;
    var FontSizeExpandText = function FontSizeExpandText(textObject, config) {
      if (typeof config === 'number') {
        config = {
          minWidth: config
        };
      }
      var minWidth = GetValue(config, 'minWidth', 0);
      var minHeight = GetValue(config, 'minHeight', 0);
      var fitHeight = GetValue(config, 'fitHeight', false);
      textObject._minWidth = minWidth;
      textObject._minHeight = minHeight;
      if (!fitHeight) {
        // Set font size to fit width only
        textObject.runWidthWrap = function (width) {
          if (textObject.setFixedSize) {
            textObject.setFixedSize(0, 0);
          }
          FontSizeFit(textObject, width, undefined);
          return textObject;
        };
        textObject.resize = function (width, height) {
          if (textObject.width === width && textObject.height === height) {
            return textObject;
          }
  
          // Font size is set under runWidthWrap/FontSizeFit
          textObject.setFixedSize(width, height);
          return textObject;
        };
      } else {
        // Set font size to fit width and height
        textObject.runWidthWrap = function (width) {
          // Minimun text size
          if (textObject.setFixedSize) {
            textObject.setFixedSize(0, 0);
          }
          textObject.setFontSize(1);
          return textObject;
        };
        textObject.resize = function (width, height) {
          FontSizeFit(textObject, width, height);
          return textObject;
        };
      }
      return textObject;
    };
  
    var UIPlugin = /*#__PURE__*/function (_Phaser$Plugins$Scene) {
      _inherits(UIPlugin, _Phaser$Plugins$Scene);
      function UIPlugin(scene, pluginManager) {
        var _this;
        _classCallCheck(this, UIPlugin);
        _this = _callSuper(this, UIPlugin, [scene, pluginManager]);
        _this.add = new ObjectFactory(scene);
        return _this;
      }
      _createClass(UIPlugin, [{
        key: "boot",
        value: function boot() {
          var eventEmitter = this.scene.events;
          eventEmitter.on('destroy', this.destroy, this);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.add.destroy();
          _get(_getPrototypeOf(UIPlugin.prototype), "destroy", this).call(this);
        }
      }, {
        key: "isInTouching",
        value: function isInTouching(gameObject, pointer, preTest, postTest) {
          if (!gameObject.visible) {
            return false;
          }
          return IsPointerInBounds(gameObject, pointer, preTest, postTest);
        }
      }, {
        key: "viewport",
        get: function get() {
          return GetViewport(this.scene, this.scene.cameras.main, true);
        }
      }]);
      return UIPlugin;
    }(Phaser.Plugins.ScenePlugin);
    var methods = {
      getParentSizer: GetParent$1,
      getTopmostSizer: GetTopmostParent$1,
      removeFromParent: RemoveFromParent,
      hide: Hide,
      show: Show,
      isShown: IsShown,
      confirmAction: ConfirmAction,
      edit: Edit,
      wrapExpandText: WrapExpandText,
      fontSizeExpandText: FontSizeExpandText,
      fontSizeResize: FontSizeFit,
      // Backward compatibility
      setFontSizeToFitWidth: FontSizeFit,
      waitEvent: WaitEvent,
      waitComplete: WaitComplete,
      delayPromise: Delay,
      setChildrenInteractive: SetChildrenInteractive,
      fadeIn: FadeIn,
      fadeOutDestroy: FadeOutDestroy,
      easeMoveTo: EaseMoveTo,
      easeMoveFrom: EaseMoveFrom,
      modal: Modal$1,
      modalPromise: ModalPromise,
      modalClose: ModalClose,
      requestDrag: RequestDrag,
      openFileChooser: Open$1
    };
    Object.assign(UIPlugin.prototype, methods);
  
    return UIPlugin;
  
  }));
  